
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AdvanceNotice
 * 
 */
export type AdvanceNotice = $Result.DefaultSelection<Prisma.$AdvanceNoticePayload>
/**
 * Model AutoWordReport
 * 
 */
export type AutoWordReport = $Result.DefaultSelection<Prisma.$AutoWordReportPayload>
/**
 * Model AutoWordReportSub
 * 
 */
export type AutoWordReportSub = $Result.DefaultSelection<Prisma.$AutoWordReportSubPayload>
/**
 * Model ChangeHistory
 * 
 */
export type ChangeHistory = $Result.DefaultSelection<Prisma.$ChangeHistoryPayload>
/**
 * Model CitysIncomeTaxDiscount
 * 
 */
export type CitysIncomeTaxDiscount = $Result.DefaultSelection<Prisma.$CitysIncomeTaxDiscountPayload>
/**
 * Model Companies
 * 
 */
export type Companies = $Result.DefaultSelection<Prisma.$CompaniesPayload>
/**
 * Model CompaniesProducts
 * 
 */
export type CompaniesProducts = $Result.DefaultSelection<Prisma.$CompaniesProductsPayload>
/**
 * Model CompaniesProductsExpireDates
 * 
 */
export type CompaniesProductsExpireDates = $Result.DefaultSelection<Prisma.$CompaniesProductsExpireDatesPayload>
/**
 * Model CompaniesType
 * 
 */
export type CompaniesType = $Result.DefaultSelection<Prisma.$CompaniesTypePayload>
/**
 * Model CompaniesUsers
 * 
 */
export type CompaniesUsers = $Result.DefaultSelection<Prisma.$CompaniesUsersPayload>
/**
 * Model CompaniesUsersProductsExpireDates
 * 
 */
export type CompaniesUsersProductsExpireDates = $Result.DefaultSelection<Prisma.$CompaniesUsersProductsExpireDatesPayload>
/**
 * Model Copyright
 * 
 */
export type Copyright = $Result.DefaultSelection<Prisma.$CopyrightPayload>
/**
 * Model Countries
 * 
 */
export type Countries = $Result.DefaultSelection<Prisma.$CountriesPayload>
/**
 * Model CreditShift
 * 
 */
export type CreditShift = $Result.DefaultSelection<Prisma.$CreditShiftPayload>
/**
 * Model DaysInMonth
 * 
 */
export type DaysInMonth = $Result.DefaultSelection<Prisma.$DaysInMonthPayload>
/**
 * Model DaysInMonth_NewYear
 * 
 */
export type DaysInMonth_NewYear = $Result.DefaultSelection<Prisma.$DaysInMonth_NewYearPayload>
/**
 * Model DayType
 * 
 */
export type DayType = $Result.DefaultSelection<Prisma.$DayTypePayload>
/**
 * Model DisplayType
 * 
 */
export type DisplayType = $Result.DefaultSelection<Prisma.$DisplayTypePayload>
/**
 * Model HashIndexGeneral
 * 
 */
export type HashIndexGeneral = $Result.DefaultSelection<Prisma.$HashIndexGeneralPayload>
/**
 * Model HashSecurity
 * 
 */
export type HashSecurity = $Result.DefaultSelection<Prisma.$HashSecurityPayload>
/**
 * Model Jobs
 * 
 */
export type Jobs = $Result.DefaultSelection<Prisma.$JobsPayload>
/**
 * Model KupaGemel
 * 
 */
export type KupaGemel = $Result.DefaultSelection<Prisma.$KupaGemelPayload>
/**
 * Model LandPages
 * 
 */
export type LandPages = $Result.DefaultSelection<Prisma.$LandPagesPayload>
/**
 * Model LanguageDefinition
 * 
 */
export type LanguageDefinition = $Result.DefaultSelection<Prisma.$LanguageDefinitionPayload>
/**
 * Model Lkup_Area
 * 
 */
export type Lkup_Area = $Result.DefaultSelection<Prisma.$Lkup_AreaPayload>
/**
 * Model Lkup_Banks
 * 
 */
export type Lkup_Banks = $Result.DefaultSelection<Prisma.$Lkup_BanksPayload>
/**
 * Model Lkup_BanksVerBranch
 * 
 */
export type Lkup_BanksVerBranch = $Result.DefaultSelection<Prisma.$Lkup_BanksVerBranchPayload>
/**
 * Model Lkup_City
 * 
 */
export type Lkup_City = $Result.DefaultSelection<Prisma.$Lkup_CityPayload>
/**
 * Model Lkup_Corporation
 * 
 */
export type Lkup_Corporation = $Result.DefaultSelection<Prisma.$Lkup_CorporationPayload>
/**
 * Model Lkup_Country
 * 
 */
export type Lkup_Country = $Result.DefaultSelection<Prisma.$Lkup_CountryPayload>
/**
 * Model Lkup_CreaditCard
 * 
 */
export type Lkup_CreaditCard = $Result.DefaultSelection<Prisma.$Lkup_CreaditCardPayload>
/**
 * Model Lkup_EmployeesType
 * 
 */
export type Lkup_EmployeesType = $Result.DefaultSelection<Prisma.$Lkup_EmployeesTypePayload>
/**
 * Model Lkup_Language
 * 
 */
export type Lkup_Language = $Result.DefaultSelection<Prisma.$Lkup_LanguagePayload>
/**
 * Model Lkup_PaySlip
 * 
 */
export type Lkup_PaySlip = $Result.DefaultSelection<Prisma.$Lkup_PaySlipPayload>
/**
 * Model Lkup_Sector
 * 
 */
export type Lkup_Sector = $Result.DefaultSelection<Prisma.$Lkup_SectorPayload>
/**
 * Model Lkup_SocialSecuritySector
 * 
 */
export type Lkup_SocialSecuritySector = $Result.DefaultSelection<Prisma.$Lkup_SocialSecuritySectorPayload>
/**
 * Model Lkup_street
 * 
 */
export type Lkup_street = $Result.DefaultSelection<Prisma.$Lkup_streetPayload>
/**
 * Model PensionDetail
 * 
 */
export type PensionDetail = $Result.DefaultSelection<Prisma.$PensionDetailPayload>
/**
 * Model Products
 * 
 */
export type Products = $Result.DefaultSelection<Prisma.$ProductsPayload>
/**
 * Model Rank
 * 
 */
export type Rank = $Result.DefaultSelection<Prisma.$RankPayload>
/**
 * Model RecoveryDefinition
 * 
 */
export type RecoveryDefinition = $Result.DefaultSelection<Prisma.$RecoveryDefinitionPayload>
/**
 * Model RecoveryDefinitionDetails
 * 
 */
export type RecoveryDefinitionDetails = $Result.DefaultSelection<Prisma.$RecoveryDefinitionDetailsPayload>
/**
 * Model RecoveryDefinitionRateDetails
 * 
 */
export type RecoveryDefinitionRateDetails = $Result.DefaultSelection<Prisma.$RecoveryDefinitionRateDetailsPayload>
/**
 * Model ReportDefinitions
 * 
 */
export type ReportDefinitions = $Result.DefaultSelection<Prisma.$ReportDefinitionsPayload>
/**
 * Model RewardRecoveryRate
 * 
 */
export type RewardRecoveryRate = $Result.DefaultSelection<Prisma.$RewardRecoveryRatePayload>
/**
 * Model RewardRecoveryVector
 * 
 */
export type RewardRecoveryVector = $Result.DefaultSelection<Prisma.$RewardRecoveryVectorPayload>
/**
 * Model RewardSickVector
 * 
 */
export type RewardSickVector = $Result.DefaultSelection<Prisma.$RewardSickVectorPayload>
/**
 * Model RewardVacationVector
 * 
 */
export type RewardVacationVector = $Result.DefaultSelection<Prisma.$RewardVacationVectorPayload>
/**
 * Model SickDefinition
 * 
 */
export type SickDefinition = $Result.DefaultSelection<Prisma.$SickDefinitionPayload>
/**
 * Model SickDefinitionDetail
 * 
 */
export type SickDefinitionDetail = $Result.DefaultSelection<Prisma.$SickDefinitionDetailPayload>
/**
 * Model SocialSecurity
 * 
 */
export type SocialSecurity = $Result.DefaultSelection<Prisma.$SocialSecurityPayload>
/**
 * Model SocialSecurityDetile
 * 
 */
export type SocialSecurityDetile = $Result.DefaultSelection<Prisma.$SocialSecurityDetilePayload>
/**
 * Model sysdiagrams
 * 
 */
export type sysdiagrams = $Result.DefaultSelection<Prisma.$sysdiagramsPayload>
/**
 * Model SystemDefinition
 * 
 */
export type SystemDefinition = $Result.DefaultSelection<Prisma.$SystemDefinitionPayload>
/**
 * Model SystemMaintenanc
 * 
 */
export type SystemMaintenanc = $Result.DefaultSelection<Prisma.$SystemMaintenancPayload>
/**
 * Model TaxStepDetile
 * 
 */
export type TaxStepDetile = $Result.DefaultSelection<Prisma.$TaxStepDetilePayload>
/**
 * Model TaxSteps
 * 
 */
export type TaxSteps = $Result.DefaultSelection<Prisma.$TaxStepsPayload>
/**
 * Model UnionFee
 * 
 */
export type UnionFee = $Result.DefaultSelection<Prisma.$UnionFeePayload>
/**
 * Model UnionFeeDetile
 * 
 */
export type UnionFeeDetile = $Result.DefaultSelection<Prisma.$UnionFeeDetilePayload>
/**
 * Model VacationDefinitionDetails
 * 
 */
export type VacationDefinitionDetails = $Result.DefaultSelection<Prisma.$VacationDefinitionDetailsPayload>
/**
 * Model VacationlDefinition
 * 
 */
export type VacationlDefinition = $Result.DefaultSelection<Prisma.$VacationlDefinitionPayload>
/**
 * Model ValueOfVehicleUse
 * 
 */
export type ValueOfVehicleUse = $Result.DefaultSelection<Prisma.$ValueOfVehicleUsePayload>
/**
 * Model ValueOfVehicleUseByDetile
 * 
 */
export type ValueOfVehicleUseByDetile = $Result.DefaultSelection<Prisma.$ValueOfVehicleUseByDetilePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AdvanceNotices
 * const advanceNotices = await prisma.advanceNotice.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AdvanceNotices
   * const advanceNotices = await prisma.advanceNotice.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.advanceNotice`: Exposes CRUD operations for the **AdvanceNotice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdvanceNotices
    * const advanceNotices = await prisma.advanceNotice.findMany()
    * ```
    */
  get advanceNotice(): Prisma.AdvanceNoticeDelegate<ExtArgs>;

  /**
   * `prisma.autoWordReport`: Exposes CRUD operations for the **AutoWordReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoWordReports
    * const autoWordReports = await prisma.autoWordReport.findMany()
    * ```
    */
  get autoWordReport(): Prisma.AutoWordReportDelegate<ExtArgs>;

  /**
   * `prisma.autoWordReportSub`: Exposes CRUD operations for the **AutoWordReportSub** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoWordReportSubs
    * const autoWordReportSubs = await prisma.autoWordReportSub.findMany()
    * ```
    */
  get autoWordReportSub(): Prisma.AutoWordReportSubDelegate<ExtArgs>;

  /**
   * `prisma.changeHistory`: Exposes CRUD operations for the **ChangeHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangeHistories
    * const changeHistories = await prisma.changeHistory.findMany()
    * ```
    */
  get changeHistory(): Prisma.ChangeHistoryDelegate<ExtArgs>;

  /**
   * `prisma.citysIncomeTaxDiscount`: Exposes CRUD operations for the **CitysIncomeTaxDiscount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CitysIncomeTaxDiscounts
    * const citysIncomeTaxDiscounts = await prisma.citysIncomeTaxDiscount.findMany()
    * ```
    */
  get citysIncomeTaxDiscount(): Prisma.CitysIncomeTaxDiscountDelegate<ExtArgs>;

  /**
   * `prisma.companies`: Exposes CRUD operations for the **Companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.companies.findMany()
    * ```
    */
  get companies(): Prisma.CompaniesDelegate<ExtArgs>;

  /**
   * `prisma.companiesProducts`: Exposes CRUD operations for the **CompaniesProducts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompaniesProducts
    * const companiesProducts = await prisma.companiesProducts.findMany()
    * ```
    */
  get companiesProducts(): Prisma.CompaniesProductsDelegate<ExtArgs>;

  /**
   * `prisma.companiesProductsExpireDates`: Exposes CRUD operations for the **CompaniesProductsExpireDates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompaniesProductsExpireDates
    * const companiesProductsExpireDates = await prisma.companiesProductsExpireDates.findMany()
    * ```
    */
  get companiesProductsExpireDates(): Prisma.CompaniesProductsExpireDatesDelegate<ExtArgs>;

  /**
   * `prisma.companiesType`: Exposes CRUD operations for the **CompaniesType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompaniesTypes
    * const companiesTypes = await prisma.companiesType.findMany()
    * ```
    */
  get companiesType(): Prisma.CompaniesTypeDelegate<ExtArgs>;

  /**
   * `prisma.companiesUsers`: Exposes CRUD operations for the **CompaniesUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompaniesUsers
    * const companiesUsers = await prisma.companiesUsers.findMany()
    * ```
    */
  get companiesUsers(): Prisma.CompaniesUsersDelegate<ExtArgs>;

  /**
   * `prisma.companiesUsersProductsExpireDates`: Exposes CRUD operations for the **CompaniesUsersProductsExpireDates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompaniesUsersProductsExpireDates
    * const companiesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.findMany()
    * ```
    */
  get companiesUsersProductsExpireDates(): Prisma.CompaniesUsersProductsExpireDatesDelegate<ExtArgs>;

  /**
   * `prisma.copyright`: Exposes CRUD operations for the **Copyright** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Copyrights
    * const copyrights = await prisma.copyright.findMany()
    * ```
    */
  get copyright(): Prisma.CopyrightDelegate<ExtArgs>;

  /**
   * `prisma.countries`: Exposes CRUD operations for the **Countries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.countries.findMany()
    * ```
    */
  get countries(): Prisma.CountriesDelegate<ExtArgs>;

  /**
   * `prisma.creditShift`: Exposes CRUD operations for the **CreditShift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditShifts
    * const creditShifts = await prisma.creditShift.findMany()
    * ```
    */
  get creditShift(): Prisma.CreditShiftDelegate<ExtArgs>;

  /**
   * `prisma.daysInMonth`: Exposes CRUD operations for the **DaysInMonth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DaysInMonths
    * const daysInMonths = await prisma.daysInMonth.findMany()
    * ```
    */
  get daysInMonth(): Prisma.DaysInMonthDelegate<ExtArgs>;

  /**
   * `prisma.daysInMonth_NewYear`: Exposes CRUD operations for the **DaysInMonth_NewYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DaysInMonth_NewYears
    * const daysInMonth_NewYears = await prisma.daysInMonth_NewYear.findMany()
    * ```
    */
  get daysInMonth_NewYear(): Prisma.DaysInMonth_NewYearDelegate<ExtArgs>;

  /**
   * `prisma.dayType`: Exposes CRUD operations for the **DayType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DayTypes
    * const dayTypes = await prisma.dayType.findMany()
    * ```
    */
  get dayType(): Prisma.DayTypeDelegate<ExtArgs>;

  /**
   * `prisma.displayType`: Exposes CRUD operations for the **DisplayType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisplayTypes
    * const displayTypes = await prisma.displayType.findMany()
    * ```
    */
  get displayType(): Prisma.DisplayTypeDelegate<ExtArgs>;

  /**
   * `prisma.hashIndexGeneral`: Exposes CRUD operations for the **HashIndexGeneral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HashIndexGenerals
    * const hashIndexGenerals = await prisma.hashIndexGeneral.findMany()
    * ```
    */
  get hashIndexGeneral(): Prisma.HashIndexGeneralDelegate<ExtArgs>;

  /**
   * `prisma.hashSecurity`: Exposes CRUD operations for the **HashSecurity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HashSecurities
    * const hashSecurities = await prisma.hashSecurity.findMany()
    * ```
    */
  get hashSecurity(): Prisma.HashSecurityDelegate<ExtArgs>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **Jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.jobs.findMany()
    * ```
    */
  get jobs(): Prisma.JobsDelegate<ExtArgs>;

  /**
   * `prisma.kupaGemel`: Exposes CRUD operations for the **KupaGemel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KupaGemels
    * const kupaGemels = await prisma.kupaGemel.findMany()
    * ```
    */
  get kupaGemel(): Prisma.KupaGemelDelegate<ExtArgs>;

  /**
   * `prisma.landPages`: Exposes CRUD operations for the **LandPages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LandPages
    * const landPages = await prisma.landPages.findMany()
    * ```
    */
  get landPages(): Prisma.LandPagesDelegate<ExtArgs>;

  /**
   * `prisma.languageDefinition`: Exposes CRUD operations for the **LanguageDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LanguageDefinitions
    * const languageDefinitions = await prisma.languageDefinition.findMany()
    * ```
    */
  get languageDefinition(): Prisma.LanguageDefinitionDelegate<ExtArgs>;

  /**
   * `prisma.lkup_Area`: Exposes CRUD operations for the **Lkup_Area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_Areas
    * const lkup_Areas = await prisma.lkup_Area.findMany()
    * ```
    */
  get lkup_Area(): Prisma.Lkup_AreaDelegate<ExtArgs>;

  /**
   * `prisma.lkup_Banks`: Exposes CRUD operations for the **Lkup_Banks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_Banks
    * const lkup_Banks = await prisma.lkup_Banks.findMany()
    * ```
    */
  get lkup_Banks(): Prisma.Lkup_BanksDelegate<ExtArgs>;

  /**
   * `prisma.lkup_BanksVerBranch`: Exposes CRUD operations for the **Lkup_BanksVerBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_BanksVerBranches
    * const lkup_BanksVerBranches = await prisma.lkup_BanksVerBranch.findMany()
    * ```
    */
  get lkup_BanksVerBranch(): Prisma.Lkup_BanksVerBranchDelegate<ExtArgs>;

  /**
   * `prisma.lkup_City`: Exposes CRUD operations for the **Lkup_City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_Cities
    * const lkup_Cities = await prisma.lkup_City.findMany()
    * ```
    */
  get lkup_City(): Prisma.Lkup_CityDelegate<ExtArgs>;

  /**
   * `prisma.lkup_Corporation`: Exposes CRUD operations for the **Lkup_Corporation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_Corporations
    * const lkup_Corporations = await prisma.lkup_Corporation.findMany()
    * ```
    */
  get lkup_Corporation(): Prisma.Lkup_CorporationDelegate<ExtArgs>;

  /**
   * `prisma.lkup_Country`: Exposes CRUD operations for the **Lkup_Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_Countries
    * const lkup_Countries = await prisma.lkup_Country.findMany()
    * ```
    */
  get lkup_Country(): Prisma.Lkup_CountryDelegate<ExtArgs>;

  /**
   * `prisma.lkup_CreaditCard`: Exposes CRUD operations for the **Lkup_CreaditCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_CreaditCards
    * const lkup_CreaditCards = await prisma.lkup_CreaditCard.findMany()
    * ```
    */
  get lkup_CreaditCard(): Prisma.Lkup_CreaditCardDelegate<ExtArgs>;

  /**
   * `prisma.lkup_EmployeesType`: Exposes CRUD operations for the **Lkup_EmployeesType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_EmployeesTypes
    * const lkup_EmployeesTypes = await prisma.lkup_EmployeesType.findMany()
    * ```
    */
  get lkup_EmployeesType(): Prisma.Lkup_EmployeesTypeDelegate<ExtArgs>;

  /**
   * `prisma.lkup_Language`: Exposes CRUD operations for the **Lkup_Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_Languages
    * const lkup_Languages = await prisma.lkup_Language.findMany()
    * ```
    */
  get lkup_Language(): Prisma.Lkup_LanguageDelegate<ExtArgs>;

  /**
   * `prisma.lkup_PaySlip`: Exposes CRUD operations for the **Lkup_PaySlip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_PaySlips
    * const lkup_PaySlips = await prisma.lkup_PaySlip.findMany()
    * ```
    */
  get lkup_PaySlip(): Prisma.Lkup_PaySlipDelegate<ExtArgs>;

  /**
   * `prisma.lkup_Sector`: Exposes CRUD operations for the **Lkup_Sector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_Sectors
    * const lkup_Sectors = await prisma.lkup_Sector.findMany()
    * ```
    */
  get lkup_Sector(): Prisma.Lkup_SectorDelegate<ExtArgs>;

  /**
   * `prisma.lkup_SocialSecuritySector`: Exposes CRUD operations for the **Lkup_SocialSecuritySector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_SocialSecuritySectors
    * const lkup_SocialSecuritySectors = await prisma.lkup_SocialSecuritySector.findMany()
    * ```
    */
  get lkup_SocialSecuritySector(): Prisma.Lkup_SocialSecuritySectorDelegate<ExtArgs>;

  /**
   * `prisma.lkup_street`: Exposes CRUD operations for the **Lkup_street** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_streets
    * const lkup_streets = await prisma.lkup_street.findMany()
    * ```
    */
  get lkup_street(): Prisma.Lkup_streetDelegate<ExtArgs>;

  /**
   * `prisma.pensionDetail`: Exposes CRUD operations for the **PensionDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PensionDetails
    * const pensionDetails = await prisma.pensionDetail.findMany()
    * ```
    */
  get pensionDetail(): Prisma.PensionDetailDelegate<ExtArgs>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **Products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.ProductsDelegate<ExtArgs>;

  /**
   * `prisma.rank`: Exposes CRUD operations for the **Rank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ranks
    * const ranks = await prisma.rank.findMany()
    * ```
    */
  get rank(): Prisma.RankDelegate<ExtArgs>;

  /**
   * `prisma.recoveryDefinition`: Exposes CRUD operations for the **RecoveryDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecoveryDefinitions
    * const recoveryDefinitions = await prisma.recoveryDefinition.findMany()
    * ```
    */
  get recoveryDefinition(): Prisma.RecoveryDefinitionDelegate<ExtArgs>;

  /**
   * `prisma.recoveryDefinitionDetails`: Exposes CRUD operations for the **RecoveryDefinitionDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecoveryDefinitionDetails
    * const recoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.findMany()
    * ```
    */
  get recoveryDefinitionDetails(): Prisma.RecoveryDefinitionDetailsDelegate<ExtArgs>;

  /**
   * `prisma.recoveryDefinitionRateDetails`: Exposes CRUD operations for the **RecoveryDefinitionRateDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecoveryDefinitionRateDetails
    * const recoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.findMany()
    * ```
    */
  get recoveryDefinitionRateDetails(): Prisma.RecoveryDefinitionRateDetailsDelegate<ExtArgs>;

  /**
   * `prisma.reportDefinitions`: Exposes CRUD operations for the **ReportDefinitions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportDefinitions
    * const reportDefinitions = await prisma.reportDefinitions.findMany()
    * ```
    */
  get reportDefinitions(): Prisma.ReportDefinitionsDelegate<ExtArgs>;

  /**
   * `prisma.rewardRecoveryRate`: Exposes CRUD operations for the **RewardRecoveryRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardRecoveryRates
    * const rewardRecoveryRates = await prisma.rewardRecoveryRate.findMany()
    * ```
    */
  get rewardRecoveryRate(): Prisma.RewardRecoveryRateDelegate<ExtArgs>;

  /**
   * `prisma.rewardRecoveryVector`: Exposes CRUD operations for the **RewardRecoveryVector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardRecoveryVectors
    * const rewardRecoveryVectors = await prisma.rewardRecoveryVector.findMany()
    * ```
    */
  get rewardRecoveryVector(): Prisma.RewardRecoveryVectorDelegate<ExtArgs>;

  /**
   * `prisma.rewardSickVector`: Exposes CRUD operations for the **RewardSickVector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardSickVectors
    * const rewardSickVectors = await prisma.rewardSickVector.findMany()
    * ```
    */
  get rewardSickVector(): Prisma.RewardSickVectorDelegate<ExtArgs>;

  /**
   * `prisma.rewardVacationVector`: Exposes CRUD operations for the **RewardVacationVector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardVacationVectors
    * const rewardVacationVectors = await prisma.rewardVacationVector.findMany()
    * ```
    */
  get rewardVacationVector(): Prisma.RewardVacationVectorDelegate<ExtArgs>;

  /**
   * `prisma.sickDefinition`: Exposes CRUD operations for the **SickDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SickDefinitions
    * const sickDefinitions = await prisma.sickDefinition.findMany()
    * ```
    */
  get sickDefinition(): Prisma.SickDefinitionDelegate<ExtArgs>;

  /**
   * `prisma.sickDefinitionDetail`: Exposes CRUD operations for the **SickDefinitionDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SickDefinitionDetails
    * const sickDefinitionDetails = await prisma.sickDefinitionDetail.findMany()
    * ```
    */
  get sickDefinitionDetail(): Prisma.SickDefinitionDetailDelegate<ExtArgs>;

  /**
   * `prisma.socialSecurity`: Exposes CRUD operations for the **SocialSecurity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialSecurities
    * const socialSecurities = await prisma.socialSecurity.findMany()
    * ```
    */
  get socialSecurity(): Prisma.SocialSecurityDelegate<ExtArgs>;

  /**
   * `prisma.socialSecurityDetile`: Exposes CRUD operations for the **SocialSecurityDetile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialSecurityDetiles
    * const socialSecurityDetiles = await prisma.socialSecurityDetile.findMany()
    * ```
    */
  get socialSecurityDetile(): Prisma.SocialSecurityDetileDelegate<ExtArgs>;

  /**
   * `prisma.sysdiagrams`: Exposes CRUD operations for the **sysdiagrams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sysdiagrams
    * const sysdiagrams = await prisma.sysdiagrams.findMany()
    * ```
    */
  get sysdiagrams(): Prisma.sysdiagramsDelegate<ExtArgs>;

  /**
   * `prisma.systemDefinition`: Exposes CRUD operations for the **SystemDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemDefinitions
    * const systemDefinitions = await prisma.systemDefinition.findMany()
    * ```
    */
  get systemDefinition(): Prisma.SystemDefinitionDelegate<ExtArgs>;

  /**
   * `prisma.systemMaintenanc`: Exposes CRUD operations for the **SystemMaintenanc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemMaintenancs
    * const systemMaintenancs = await prisma.systemMaintenanc.findMany()
    * ```
    */
  get systemMaintenanc(): Prisma.SystemMaintenancDelegate<ExtArgs>;

  /**
   * `prisma.taxStepDetile`: Exposes CRUD operations for the **TaxStepDetile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxStepDetiles
    * const taxStepDetiles = await prisma.taxStepDetile.findMany()
    * ```
    */
  get taxStepDetile(): Prisma.TaxStepDetileDelegate<ExtArgs>;

  /**
   * `prisma.taxSteps`: Exposes CRUD operations for the **TaxSteps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxSteps
    * const taxSteps = await prisma.taxSteps.findMany()
    * ```
    */
  get taxSteps(): Prisma.TaxStepsDelegate<ExtArgs>;

  /**
   * `prisma.unionFee`: Exposes CRUD operations for the **UnionFee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnionFees
    * const unionFees = await prisma.unionFee.findMany()
    * ```
    */
  get unionFee(): Prisma.UnionFeeDelegate<ExtArgs>;

  /**
   * `prisma.unionFeeDetile`: Exposes CRUD operations for the **UnionFeeDetile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnionFeeDetiles
    * const unionFeeDetiles = await prisma.unionFeeDetile.findMany()
    * ```
    */
  get unionFeeDetile(): Prisma.UnionFeeDetileDelegate<ExtArgs>;

  /**
   * `prisma.vacationDefinitionDetails`: Exposes CRUD operations for the **VacationDefinitionDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VacationDefinitionDetails
    * const vacationDefinitionDetails = await prisma.vacationDefinitionDetails.findMany()
    * ```
    */
  get vacationDefinitionDetails(): Prisma.VacationDefinitionDetailsDelegate<ExtArgs>;

  /**
   * `prisma.vacationlDefinition`: Exposes CRUD operations for the **VacationlDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VacationlDefinitions
    * const vacationlDefinitions = await prisma.vacationlDefinition.findMany()
    * ```
    */
  get vacationlDefinition(): Prisma.VacationlDefinitionDelegate<ExtArgs>;

  /**
   * `prisma.valueOfVehicleUse`: Exposes CRUD operations for the **ValueOfVehicleUse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ValueOfVehicleUses
    * const valueOfVehicleUses = await prisma.valueOfVehicleUse.findMany()
    * ```
    */
  get valueOfVehicleUse(): Prisma.ValueOfVehicleUseDelegate<ExtArgs>;

  /**
   * `prisma.valueOfVehicleUseByDetile`: Exposes CRUD operations for the **ValueOfVehicleUseByDetile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ValueOfVehicleUseByDetiles
    * const valueOfVehicleUseByDetiles = await prisma.valueOfVehicleUseByDetile.findMany()
    * ```
    */
  get valueOfVehicleUseByDetile(): Prisma.ValueOfVehicleUseByDetileDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.0.1
   * Query Engine version: 5dbef10bdbfb579e07d35cc85fb1518d357cb99e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AdvanceNotice: 'AdvanceNotice',
    AutoWordReport: 'AutoWordReport',
    AutoWordReportSub: 'AutoWordReportSub',
    ChangeHistory: 'ChangeHistory',
    CitysIncomeTaxDiscount: 'CitysIncomeTaxDiscount',
    Companies: 'Companies',
    CompaniesProducts: 'CompaniesProducts',
    CompaniesProductsExpireDates: 'CompaniesProductsExpireDates',
    CompaniesType: 'CompaniesType',
    CompaniesUsers: 'CompaniesUsers',
    CompaniesUsersProductsExpireDates: 'CompaniesUsersProductsExpireDates',
    Copyright: 'Copyright',
    Countries: 'Countries',
    CreditShift: 'CreditShift',
    DaysInMonth: 'DaysInMonth',
    DaysInMonth_NewYear: 'DaysInMonth_NewYear',
    DayType: 'DayType',
    DisplayType: 'DisplayType',
    HashIndexGeneral: 'HashIndexGeneral',
    HashSecurity: 'HashSecurity',
    Jobs: 'Jobs',
    KupaGemel: 'KupaGemel',
    LandPages: 'LandPages',
    LanguageDefinition: 'LanguageDefinition',
    Lkup_Area: 'Lkup_Area',
    Lkup_Banks: 'Lkup_Banks',
    Lkup_BanksVerBranch: 'Lkup_BanksVerBranch',
    Lkup_City: 'Lkup_City',
    Lkup_Corporation: 'Lkup_Corporation',
    Lkup_Country: 'Lkup_Country',
    Lkup_CreaditCard: 'Lkup_CreaditCard',
    Lkup_EmployeesType: 'Lkup_EmployeesType',
    Lkup_Language: 'Lkup_Language',
    Lkup_PaySlip: 'Lkup_PaySlip',
    Lkup_Sector: 'Lkup_Sector',
    Lkup_SocialSecuritySector: 'Lkup_SocialSecuritySector',
    Lkup_street: 'Lkup_street',
    PensionDetail: 'PensionDetail',
    Products: 'Products',
    Rank: 'Rank',
    RecoveryDefinition: 'RecoveryDefinition',
    RecoveryDefinitionDetails: 'RecoveryDefinitionDetails',
    RecoveryDefinitionRateDetails: 'RecoveryDefinitionRateDetails',
    ReportDefinitions: 'ReportDefinitions',
    RewardRecoveryRate: 'RewardRecoveryRate',
    RewardRecoveryVector: 'RewardRecoveryVector',
    RewardSickVector: 'RewardSickVector',
    RewardVacationVector: 'RewardVacationVector',
    SickDefinition: 'SickDefinition',
    SickDefinitionDetail: 'SickDefinitionDetail',
    SocialSecurity: 'SocialSecurity',
    SocialSecurityDetile: 'SocialSecurityDetile',
    sysdiagrams: 'sysdiagrams',
    SystemDefinition: 'SystemDefinition',
    SystemMaintenanc: 'SystemMaintenanc',
    TaxStepDetile: 'TaxStepDetile',
    TaxSteps: 'TaxSteps',
    UnionFee: 'UnionFee',
    UnionFeeDetile: 'UnionFeeDetile',
    VacationDefinitionDetails: 'VacationDefinitionDetails',
    VacationlDefinition: 'VacationlDefinition',
    ValueOfVehicleUse: 'ValueOfVehicleUse',
    ValueOfVehicleUseByDetile: 'ValueOfVehicleUseByDetile'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "advanceNotice" | "autoWordReport" | "autoWordReportSub" | "changeHistory" | "citysIncomeTaxDiscount" | "companies" | "companiesProducts" | "companiesProductsExpireDates" | "companiesType" | "companiesUsers" | "companiesUsersProductsExpireDates" | "copyright" | "countries" | "creditShift" | "daysInMonth" | "daysInMonth_NewYear" | "dayType" | "displayType" | "hashIndexGeneral" | "hashSecurity" | "jobs" | "kupaGemel" | "landPages" | "languageDefinition" | "lkup_Area" | "lkup_Banks" | "lkup_BanksVerBranch" | "lkup_City" | "lkup_Corporation" | "lkup_Country" | "lkup_CreaditCard" | "lkup_EmployeesType" | "lkup_Language" | "lkup_PaySlip" | "lkup_Sector" | "lkup_SocialSecuritySector" | "lkup_street" | "pensionDetail" | "products" | "rank" | "recoveryDefinition" | "recoveryDefinitionDetails" | "recoveryDefinitionRateDetails" | "reportDefinitions" | "rewardRecoveryRate" | "rewardRecoveryVector" | "rewardSickVector" | "rewardVacationVector" | "sickDefinition" | "sickDefinitionDetail" | "socialSecurity" | "socialSecurityDetile" | "sysdiagrams" | "systemDefinition" | "systemMaintenanc" | "taxStepDetile" | "taxSteps" | "unionFee" | "unionFeeDetile" | "vacationDefinitionDetails" | "vacationlDefinition" | "valueOfVehicleUse" | "valueOfVehicleUseByDetile"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AdvanceNotice: {
        payload: Prisma.$AdvanceNoticePayload<ExtArgs>
        fields: Prisma.AdvanceNoticeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvanceNoticeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceNoticePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvanceNoticeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceNoticePayload>
          }
          findFirst: {
            args: Prisma.AdvanceNoticeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceNoticePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvanceNoticeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceNoticePayload>
          }
          findMany: {
            args: Prisma.AdvanceNoticeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceNoticePayload>[]
          }
          create: {
            args: Prisma.AdvanceNoticeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceNoticePayload>
          }
          createMany: {
            args: Prisma.AdvanceNoticeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdvanceNoticeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceNoticePayload>
          }
          update: {
            args: Prisma.AdvanceNoticeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceNoticePayload>
          }
          deleteMany: {
            args: Prisma.AdvanceNoticeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdvanceNoticeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdvanceNoticeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvanceNoticePayload>
          }
          aggregate: {
            args: Prisma.AdvanceNoticeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvanceNotice>
          }
          groupBy: {
            args: Prisma.AdvanceNoticeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvanceNoticeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvanceNoticeCountArgs<ExtArgs>
            result: $Utils.Optional<AdvanceNoticeCountAggregateOutputType> | number
          }
        }
      }
      AutoWordReport: {
        payload: Prisma.$AutoWordReportPayload<ExtArgs>
        fields: Prisma.AutoWordReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoWordReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoWordReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportPayload>
          }
          findFirst: {
            args: Prisma.AutoWordReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoWordReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportPayload>
          }
          findMany: {
            args: Prisma.AutoWordReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportPayload>[]
          }
          create: {
            args: Prisma.AutoWordReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportPayload>
          }
          createMany: {
            args: Prisma.AutoWordReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AutoWordReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportPayload>
          }
          update: {
            args: Prisma.AutoWordReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportPayload>
          }
          deleteMany: {
            args: Prisma.AutoWordReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoWordReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutoWordReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportPayload>
          }
          aggregate: {
            args: Prisma.AutoWordReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoWordReport>
          }
          groupBy: {
            args: Prisma.AutoWordReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoWordReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutoWordReportCountArgs<ExtArgs>
            result: $Utils.Optional<AutoWordReportCountAggregateOutputType> | number
          }
        }
      }
      AutoWordReportSub: {
        payload: Prisma.$AutoWordReportSubPayload<ExtArgs>
        fields: Prisma.AutoWordReportSubFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoWordReportSubFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportSubPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoWordReportSubFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportSubPayload>
          }
          findFirst: {
            args: Prisma.AutoWordReportSubFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportSubPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoWordReportSubFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportSubPayload>
          }
          findMany: {
            args: Prisma.AutoWordReportSubFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportSubPayload>[]
          }
          create: {
            args: Prisma.AutoWordReportSubCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportSubPayload>
          }
          createMany: {
            args: Prisma.AutoWordReportSubCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AutoWordReportSubDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportSubPayload>
          }
          update: {
            args: Prisma.AutoWordReportSubUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportSubPayload>
          }
          deleteMany: {
            args: Prisma.AutoWordReportSubDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoWordReportSubUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutoWordReportSubUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoWordReportSubPayload>
          }
          aggregate: {
            args: Prisma.AutoWordReportSubAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoWordReportSub>
          }
          groupBy: {
            args: Prisma.AutoWordReportSubGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoWordReportSubGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutoWordReportSubCountArgs<ExtArgs>
            result: $Utils.Optional<AutoWordReportSubCountAggregateOutputType> | number
          }
        }
      }
      ChangeHistory: {
        payload: Prisma.$ChangeHistoryPayload<ExtArgs>
        fields: Prisma.ChangeHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangeHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangeHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeHistoryPayload>
          }
          findFirst: {
            args: Prisma.ChangeHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangeHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeHistoryPayload>
          }
          findMany: {
            args: Prisma.ChangeHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeHistoryPayload>[]
          }
          create: {
            args: Prisma.ChangeHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeHistoryPayload>
          }
          createMany: {
            args: Prisma.ChangeHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChangeHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeHistoryPayload>
          }
          update: {
            args: Prisma.ChangeHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ChangeHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChangeHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChangeHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeHistoryPayload>
          }
          aggregate: {
            args: Prisma.ChangeHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChangeHistory>
          }
          groupBy: {
            args: Prisma.ChangeHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChangeHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangeHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ChangeHistoryCountAggregateOutputType> | number
          }
        }
      }
      CitysIncomeTaxDiscount: {
        payload: Prisma.$CitysIncomeTaxDiscountPayload<ExtArgs>
        fields: Prisma.CitysIncomeTaxDiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CitysIncomeTaxDiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitysIncomeTaxDiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CitysIncomeTaxDiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitysIncomeTaxDiscountPayload>
          }
          findFirst: {
            args: Prisma.CitysIncomeTaxDiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitysIncomeTaxDiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CitysIncomeTaxDiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitysIncomeTaxDiscountPayload>
          }
          findMany: {
            args: Prisma.CitysIncomeTaxDiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitysIncomeTaxDiscountPayload>[]
          }
          create: {
            args: Prisma.CitysIncomeTaxDiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitysIncomeTaxDiscountPayload>
          }
          createMany: {
            args: Prisma.CitysIncomeTaxDiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CitysIncomeTaxDiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitysIncomeTaxDiscountPayload>
          }
          update: {
            args: Prisma.CitysIncomeTaxDiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitysIncomeTaxDiscountPayload>
          }
          deleteMany: {
            args: Prisma.CitysIncomeTaxDiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CitysIncomeTaxDiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CitysIncomeTaxDiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitysIncomeTaxDiscountPayload>
          }
          aggregate: {
            args: Prisma.CitysIncomeTaxDiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCitysIncomeTaxDiscount>
          }
          groupBy: {
            args: Prisma.CitysIncomeTaxDiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<CitysIncomeTaxDiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.CitysIncomeTaxDiscountCountArgs<ExtArgs>
            result: $Utils.Optional<CitysIncomeTaxDiscountCountAggregateOutputType> | number
          }
        }
      }
      Companies: {
        payload: Prisma.$CompaniesPayload<ExtArgs>
        fields: Prisma.CompaniesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompaniesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompaniesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesPayload>
          }
          findFirst: {
            args: Prisma.CompaniesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompaniesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesPayload>
          }
          findMany: {
            args: Prisma.CompaniesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesPayload>[]
          }
          create: {
            args: Prisma.CompaniesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesPayload>
          }
          createMany: {
            args: Prisma.CompaniesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompaniesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesPayload>
          }
          update: {
            args: Prisma.CompaniesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesPayload>
          }
          deleteMany: {
            args: Prisma.CompaniesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompaniesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompaniesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanies>
          }
          groupBy: {
            args: Prisma.CompaniesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompaniesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesCountAggregateOutputType> | number
          }
        }
      }
      CompaniesProducts: {
        payload: Prisma.$CompaniesProductsPayload<ExtArgs>
        fields: Prisma.CompaniesProductsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompaniesProductsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompaniesProductsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsPayload>
          }
          findFirst: {
            args: Prisma.CompaniesProductsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompaniesProductsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsPayload>
          }
          findMany: {
            args: Prisma.CompaniesProductsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsPayload>[]
          }
          create: {
            args: Prisma.CompaniesProductsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsPayload>
          }
          createMany: {
            args: Prisma.CompaniesProductsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompaniesProductsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsPayload>
          }
          update: {
            args: Prisma.CompaniesProductsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsPayload>
          }
          deleteMany: {
            args: Prisma.CompaniesProductsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompaniesProductsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompaniesProductsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsPayload>
          }
          aggregate: {
            args: Prisma.CompaniesProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompaniesProducts>
          }
          groupBy: {
            args: Prisma.CompaniesProductsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompaniesProductsCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesProductsCountAggregateOutputType> | number
          }
        }
      }
      CompaniesProductsExpireDates: {
        payload: Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>
        fields: Prisma.CompaniesProductsExpireDatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompaniesProductsExpireDatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsExpireDatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompaniesProductsExpireDatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsExpireDatesPayload>
          }
          findFirst: {
            args: Prisma.CompaniesProductsExpireDatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsExpireDatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompaniesProductsExpireDatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsExpireDatesPayload>
          }
          findMany: {
            args: Prisma.CompaniesProductsExpireDatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsExpireDatesPayload>[]
          }
          create: {
            args: Prisma.CompaniesProductsExpireDatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsExpireDatesPayload>
          }
          createMany: {
            args: Prisma.CompaniesProductsExpireDatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompaniesProductsExpireDatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsExpireDatesPayload>
          }
          update: {
            args: Prisma.CompaniesProductsExpireDatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsExpireDatesPayload>
          }
          deleteMany: {
            args: Prisma.CompaniesProductsExpireDatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompaniesProductsExpireDatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompaniesProductsExpireDatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesProductsExpireDatesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesProductsExpireDatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompaniesProductsExpireDates>
          }
          groupBy: {
            args: Prisma.CompaniesProductsExpireDatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesProductsExpireDatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompaniesProductsExpireDatesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesProductsExpireDatesCountAggregateOutputType> | number
          }
        }
      }
      CompaniesType: {
        payload: Prisma.$CompaniesTypePayload<ExtArgs>
        fields: Prisma.CompaniesTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompaniesTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompaniesTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesTypePayload>
          }
          findFirst: {
            args: Prisma.CompaniesTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompaniesTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesTypePayload>
          }
          findMany: {
            args: Prisma.CompaniesTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesTypePayload>[]
          }
          create: {
            args: Prisma.CompaniesTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesTypePayload>
          }
          createMany: {
            args: Prisma.CompaniesTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompaniesTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesTypePayload>
          }
          update: {
            args: Prisma.CompaniesTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesTypePayload>
          }
          deleteMany: {
            args: Prisma.CompaniesTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompaniesTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompaniesTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesTypePayload>
          }
          aggregate: {
            args: Prisma.CompaniesTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompaniesType>
          }
          groupBy: {
            args: Prisma.CompaniesTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompaniesTypeCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesTypeCountAggregateOutputType> | number
          }
        }
      }
      CompaniesUsers: {
        payload: Prisma.$CompaniesUsersPayload<ExtArgs>
        fields: Prisma.CompaniesUsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompaniesUsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompaniesUsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersPayload>
          }
          findFirst: {
            args: Prisma.CompaniesUsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompaniesUsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersPayload>
          }
          findMany: {
            args: Prisma.CompaniesUsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersPayload>[]
          }
          create: {
            args: Prisma.CompaniesUsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersPayload>
          }
          createMany: {
            args: Prisma.CompaniesUsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompaniesUsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersPayload>
          }
          update: {
            args: Prisma.CompaniesUsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersPayload>
          }
          deleteMany: {
            args: Prisma.CompaniesUsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompaniesUsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompaniesUsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersPayload>
          }
          aggregate: {
            args: Prisma.CompaniesUsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompaniesUsers>
          }
          groupBy: {
            args: Prisma.CompaniesUsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesUsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompaniesUsersCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesUsersCountAggregateOutputType> | number
          }
        }
      }
      CompaniesUsersProductsExpireDates: {
        payload: Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>
        fields: Prisma.CompaniesUsersProductsExpireDatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompaniesUsersProductsExpireDatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersProductsExpireDatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompaniesUsersProductsExpireDatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersProductsExpireDatesPayload>
          }
          findFirst: {
            args: Prisma.CompaniesUsersProductsExpireDatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersProductsExpireDatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompaniesUsersProductsExpireDatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersProductsExpireDatesPayload>
          }
          findMany: {
            args: Prisma.CompaniesUsersProductsExpireDatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersProductsExpireDatesPayload>[]
          }
          create: {
            args: Prisma.CompaniesUsersProductsExpireDatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersProductsExpireDatesPayload>
          }
          createMany: {
            args: Prisma.CompaniesUsersProductsExpireDatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompaniesUsersProductsExpireDatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersProductsExpireDatesPayload>
          }
          update: {
            args: Prisma.CompaniesUsersProductsExpireDatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersProductsExpireDatesPayload>
          }
          deleteMany: {
            args: Prisma.CompaniesUsersProductsExpireDatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompaniesUsersProductsExpireDatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompaniesUsersProductsExpireDatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUsersProductsExpireDatesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesUsersProductsExpireDatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompaniesUsersProductsExpireDates>
          }
          groupBy: {
            args: Prisma.CompaniesUsersProductsExpireDatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesUsersProductsExpireDatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompaniesUsersProductsExpireDatesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesUsersProductsExpireDatesCountAggregateOutputType> | number
          }
        }
      }
      Copyright: {
        payload: Prisma.$CopyrightPayload<ExtArgs>
        fields: Prisma.CopyrightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CopyrightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CopyrightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CopyrightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CopyrightPayload>
          }
          findFirst: {
            args: Prisma.CopyrightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CopyrightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CopyrightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CopyrightPayload>
          }
          findMany: {
            args: Prisma.CopyrightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CopyrightPayload>[]
          }
          create: {
            args: Prisma.CopyrightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CopyrightPayload>
          }
          createMany: {
            args: Prisma.CopyrightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CopyrightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CopyrightPayload>
          }
          update: {
            args: Prisma.CopyrightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CopyrightPayload>
          }
          deleteMany: {
            args: Prisma.CopyrightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CopyrightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CopyrightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CopyrightPayload>
          }
          aggregate: {
            args: Prisma.CopyrightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCopyright>
          }
          groupBy: {
            args: Prisma.CopyrightGroupByArgs<ExtArgs>
            result: $Utils.Optional<CopyrightGroupByOutputType>[]
          }
          count: {
            args: Prisma.CopyrightCountArgs<ExtArgs>
            result: $Utils.Optional<CopyrightCountAggregateOutputType> | number
          }
        }
      }
      Countries: {
        payload: Prisma.$CountriesPayload<ExtArgs>
        fields: Prisma.CountriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>
          }
          findFirst: {
            args: Prisma.CountriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>
          }
          findMany: {
            args: Prisma.CountriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>[]
          }
          create: {
            args: Prisma.CountriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>
          }
          createMany: {
            args: Prisma.CountriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CountriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>
          }
          update: {
            args: Prisma.CountriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>
          }
          deleteMany: {
            args: Prisma.CountriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CountriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>
          }
          aggregate: {
            args: Prisma.CountriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountries>
          }
          groupBy: {
            args: Prisma.CountriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountriesCountArgs<ExtArgs>
            result: $Utils.Optional<CountriesCountAggregateOutputType> | number
          }
        }
      }
      CreditShift: {
        payload: Prisma.$CreditShiftPayload<ExtArgs>
        fields: Prisma.CreditShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditShiftPayload>
          }
          findFirst: {
            args: Prisma.CreditShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditShiftPayload>
          }
          findMany: {
            args: Prisma.CreditShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditShiftPayload>[]
          }
          create: {
            args: Prisma.CreditShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditShiftPayload>
          }
          createMany: {
            args: Prisma.CreditShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CreditShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditShiftPayload>
          }
          update: {
            args: Prisma.CreditShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditShiftPayload>
          }
          deleteMany: {
            args: Prisma.CreditShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreditShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditShiftPayload>
          }
          aggregate: {
            args: Prisma.CreditShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditShift>
          }
          groupBy: {
            args: Prisma.CreditShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditShiftCountArgs<ExtArgs>
            result: $Utils.Optional<CreditShiftCountAggregateOutputType> | number
          }
        }
      }
      DaysInMonth: {
        payload: Prisma.$DaysInMonthPayload<ExtArgs>
        fields: Prisma.DaysInMonthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DaysInMonthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DaysInMonthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonthPayload>
          }
          findFirst: {
            args: Prisma.DaysInMonthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DaysInMonthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonthPayload>
          }
          findMany: {
            args: Prisma.DaysInMonthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonthPayload>[]
          }
          create: {
            args: Prisma.DaysInMonthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonthPayload>
          }
          createMany: {
            args: Prisma.DaysInMonthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DaysInMonthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonthPayload>
          }
          update: {
            args: Prisma.DaysInMonthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonthPayload>
          }
          deleteMany: {
            args: Prisma.DaysInMonthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DaysInMonthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DaysInMonthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonthPayload>
          }
          aggregate: {
            args: Prisma.DaysInMonthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDaysInMonth>
          }
          groupBy: {
            args: Prisma.DaysInMonthGroupByArgs<ExtArgs>
            result: $Utils.Optional<DaysInMonthGroupByOutputType>[]
          }
          count: {
            args: Prisma.DaysInMonthCountArgs<ExtArgs>
            result: $Utils.Optional<DaysInMonthCountAggregateOutputType> | number
          }
        }
      }
      DaysInMonth_NewYear: {
        payload: Prisma.$DaysInMonth_NewYearPayload<ExtArgs>
        fields: Prisma.DaysInMonth_NewYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DaysInMonth_NewYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonth_NewYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DaysInMonth_NewYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonth_NewYearPayload>
          }
          findFirst: {
            args: Prisma.DaysInMonth_NewYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonth_NewYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DaysInMonth_NewYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonth_NewYearPayload>
          }
          findMany: {
            args: Prisma.DaysInMonth_NewYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonth_NewYearPayload>[]
          }
          create: {
            args: Prisma.DaysInMonth_NewYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonth_NewYearPayload>
          }
          createMany: {
            args: Prisma.DaysInMonth_NewYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DaysInMonth_NewYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonth_NewYearPayload>
          }
          update: {
            args: Prisma.DaysInMonth_NewYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonth_NewYearPayload>
          }
          deleteMany: {
            args: Prisma.DaysInMonth_NewYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DaysInMonth_NewYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DaysInMonth_NewYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DaysInMonth_NewYearPayload>
          }
          aggregate: {
            args: Prisma.DaysInMonth_NewYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDaysInMonth_NewYear>
          }
          groupBy: {
            args: Prisma.DaysInMonth_NewYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<DaysInMonth_NewYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.DaysInMonth_NewYearCountArgs<ExtArgs>
            result: $Utils.Optional<DaysInMonth_NewYearCountAggregateOutputType> | number
          }
        }
      }
      DayType: {
        payload: Prisma.$DayTypePayload<ExtArgs>
        fields: Prisma.DayTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DayTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DayTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayTypePayload>
          }
          findFirst: {
            args: Prisma.DayTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DayTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayTypePayload>
          }
          findMany: {
            args: Prisma.DayTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayTypePayload>[]
          }
          create: {
            args: Prisma.DayTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayTypePayload>
          }
          createMany: {
            args: Prisma.DayTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DayTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayTypePayload>
          }
          update: {
            args: Prisma.DayTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayTypePayload>
          }
          deleteMany: {
            args: Prisma.DayTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DayTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DayTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayTypePayload>
          }
          aggregate: {
            args: Prisma.DayTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDayType>
          }
          groupBy: {
            args: Prisma.DayTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DayTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DayTypeCountArgs<ExtArgs>
            result: $Utils.Optional<DayTypeCountAggregateOutputType> | number
          }
        }
      }
      DisplayType: {
        payload: Prisma.$DisplayTypePayload<ExtArgs>
        fields: Prisma.DisplayTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisplayTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisplayTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisplayTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisplayTypePayload>
          }
          findFirst: {
            args: Prisma.DisplayTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisplayTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisplayTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisplayTypePayload>
          }
          findMany: {
            args: Prisma.DisplayTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisplayTypePayload>[]
          }
          create: {
            args: Prisma.DisplayTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisplayTypePayload>
          }
          createMany: {
            args: Prisma.DisplayTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DisplayTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisplayTypePayload>
          }
          update: {
            args: Prisma.DisplayTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisplayTypePayload>
          }
          deleteMany: {
            args: Prisma.DisplayTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisplayTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DisplayTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisplayTypePayload>
          }
          aggregate: {
            args: Prisma.DisplayTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisplayType>
          }
          groupBy: {
            args: Prisma.DisplayTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisplayTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisplayTypeCountArgs<ExtArgs>
            result: $Utils.Optional<DisplayTypeCountAggregateOutputType> | number
          }
        }
      }
      HashIndexGeneral: {
        payload: Prisma.$HashIndexGeneralPayload<ExtArgs>
        fields: Prisma.HashIndexGeneralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HashIndexGeneralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashIndexGeneralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HashIndexGeneralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashIndexGeneralPayload>
          }
          findFirst: {
            args: Prisma.HashIndexGeneralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashIndexGeneralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HashIndexGeneralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashIndexGeneralPayload>
          }
          findMany: {
            args: Prisma.HashIndexGeneralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashIndexGeneralPayload>[]
          }
          create: {
            args: Prisma.HashIndexGeneralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashIndexGeneralPayload>
          }
          createMany: {
            args: Prisma.HashIndexGeneralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HashIndexGeneralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashIndexGeneralPayload>
          }
          update: {
            args: Prisma.HashIndexGeneralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashIndexGeneralPayload>
          }
          deleteMany: {
            args: Prisma.HashIndexGeneralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HashIndexGeneralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HashIndexGeneralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashIndexGeneralPayload>
          }
          aggregate: {
            args: Prisma.HashIndexGeneralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHashIndexGeneral>
          }
          groupBy: {
            args: Prisma.HashIndexGeneralGroupByArgs<ExtArgs>
            result: $Utils.Optional<HashIndexGeneralGroupByOutputType>[]
          }
          count: {
            args: Prisma.HashIndexGeneralCountArgs<ExtArgs>
            result: $Utils.Optional<HashIndexGeneralCountAggregateOutputType> | number
          }
        }
      }
      HashSecurity: {
        payload: Prisma.$HashSecurityPayload<ExtArgs>
        fields: Prisma.HashSecurityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HashSecurityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashSecurityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HashSecurityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashSecurityPayload>
          }
          findFirst: {
            args: Prisma.HashSecurityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashSecurityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HashSecurityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashSecurityPayload>
          }
          findMany: {
            args: Prisma.HashSecurityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashSecurityPayload>[]
          }
          create: {
            args: Prisma.HashSecurityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashSecurityPayload>
          }
          createMany: {
            args: Prisma.HashSecurityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HashSecurityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashSecurityPayload>
          }
          update: {
            args: Prisma.HashSecurityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashSecurityPayload>
          }
          deleteMany: {
            args: Prisma.HashSecurityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HashSecurityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HashSecurityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashSecurityPayload>
          }
          aggregate: {
            args: Prisma.HashSecurityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHashSecurity>
          }
          groupBy: {
            args: Prisma.HashSecurityGroupByArgs<ExtArgs>
            result: $Utils.Optional<HashSecurityGroupByOutputType>[]
          }
          count: {
            args: Prisma.HashSecurityCountArgs<ExtArgs>
            result: $Utils.Optional<HashSecurityCountAggregateOutputType> | number
          }
        }
      }
      Jobs: {
        payload: Prisma.$JobsPayload<ExtArgs>
        fields: Prisma.JobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          findFirst: {
            args: Prisma.JobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          findMany: {
            args: Prisma.JobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>[]
          }
          create: {
            args: Prisma.JobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          createMany: {
            args: Prisma.JobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          update: {
            args: Prisma.JobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          deleteMany: {
            args: Prisma.JobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          aggregate: {
            args: Prisma.JobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobs>
          }
          groupBy: {
            args: Prisma.JobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobsCountArgs<ExtArgs>
            result: $Utils.Optional<JobsCountAggregateOutputType> | number
          }
        }
      }
      KupaGemel: {
        payload: Prisma.$KupaGemelPayload<ExtArgs>
        fields: Prisma.KupaGemelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KupaGemelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KupaGemelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KupaGemelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KupaGemelPayload>
          }
          findFirst: {
            args: Prisma.KupaGemelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KupaGemelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KupaGemelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KupaGemelPayload>
          }
          findMany: {
            args: Prisma.KupaGemelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KupaGemelPayload>[]
          }
          create: {
            args: Prisma.KupaGemelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KupaGemelPayload>
          }
          createMany: {
            args: Prisma.KupaGemelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KupaGemelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KupaGemelPayload>
          }
          update: {
            args: Prisma.KupaGemelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KupaGemelPayload>
          }
          deleteMany: {
            args: Prisma.KupaGemelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KupaGemelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KupaGemelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KupaGemelPayload>
          }
          aggregate: {
            args: Prisma.KupaGemelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKupaGemel>
          }
          groupBy: {
            args: Prisma.KupaGemelGroupByArgs<ExtArgs>
            result: $Utils.Optional<KupaGemelGroupByOutputType>[]
          }
          count: {
            args: Prisma.KupaGemelCountArgs<ExtArgs>
            result: $Utils.Optional<KupaGemelCountAggregateOutputType> | number
          }
        }
      }
      LandPages: {
        payload: Prisma.$LandPagesPayload<ExtArgs>
        fields: Prisma.LandPagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LandPagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LandPagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPagesPayload>
          }
          findFirst: {
            args: Prisma.LandPagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LandPagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPagesPayload>
          }
          findMany: {
            args: Prisma.LandPagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPagesPayload>[]
          }
          create: {
            args: Prisma.LandPagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPagesPayload>
          }
          createMany: {
            args: Prisma.LandPagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LandPagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPagesPayload>
          }
          update: {
            args: Prisma.LandPagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPagesPayload>
          }
          deleteMany: {
            args: Prisma.LandPagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LandPagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LandPagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandPagesPayload>
          }
          aggregate: {
            args: Prisma.LandPagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLandPages>
          }
          groupBy: {
            args: Prisma.LandPagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandPagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.LandPagesCountArgs<ExtArgs>
            result: $Utils.Optional<LandPagesCountAggregateOutputType> | number
          }
        }
      }
      LanguageDefinition: {
        payload: Prisma.$LanguageDefinitionPayload<ExtArgs>
        fields: Prisma.LanguageDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageDefinitionPayload>
          }
          findFirst: {
            args: Prisma.LanguageDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageDefinitionPayload>
          }
          findMany: {
            args: Prisma.LanguageDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageDefinitionPayload>[]
          }
          create: {
            args: Prisma.LanguageDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageDefinitionPayload>
          }
          createMany: {
            args: Prisma.LanguageDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LanguageDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageDefinitionPayload>
          }
          update: {
            args: Prisma.LanguageDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.LanguageDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LanguageDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageDefinitionPayload>
          }
          aggregate: {
            args: Prisma.LanguageDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguageDefinition>
          }
          groupBy: {
            args: Prisma.LanguageDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageDefinitionCountAggregateOutputType> | number
          }
        }
      }
      Lkup_Area: {
        payload: Prisma.$Lkup_AreaPayload<ExtArgs>
        fields: Prisma.Lkup_AreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_AreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_AreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_AreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_AreaPayload>
          }
          findFirst: {
            args: Prisma.Lkup_AreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_AreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_AreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_AreaPayload>
          }
          findMany: {
            args: Prisma.Lkup_AreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_AreaPayload>[]
          }
          create: {
            args: Prisma.Lkup_AreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_AreaPayload>
          }
          createMany: {
            args: Prisma.Lkup_AreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_AreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_AreaPayload>
          }
          update: {
            args: Prisma.Lkup_AreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_AreaPayload>
          }
          deleteMany: {
            args: Prisma.Lkup_AreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_AreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_AreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_AreaPayload>
          }
          aggregate: {
            args: Prisma.Lkup_AreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_Area>
          }
          groupBy: {
            args: Prisma.Lkup_AreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_AreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_AreaCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_AreaCountAggregateOutputType> | number
          }
        }
      }
      Lkup_Banks: {
        payload: Prisma.$Lkup_BanksPayload<ExtArgs>
        fields: Prisma.Lkup_BanksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_BanksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_BanksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksPayload>
          }
          findFirst: {
            args: Prisma.Lkup_BanksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_BanksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksPayload>
          }
          findMany: {
            args: Prisma.Lkup_BanksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksPayload>[]
          }
          create: {
            args: Prisma.Lkup_BanksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksPayload>
          }
          createMany: {
            args: Prisma.Lkup_BanksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_BanksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksPayload>
          }
          update: {
            args: Prisma.Lkup_BanksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksPayload>
          }
          deleteMany: {
            args: Prisma.Lkup_BanksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_BanksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_BanksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksPayload>
          }
          aggregate: {
            args: Prisma.Lkup_BanksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_Banks>
          }
          groupBy: {
            args: Prisma.Lkup_BanksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_BanksGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_BanksCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_BanksCountAggregateOutputType> | number
          }
        }
      }
      Lkup_BanksVerBranch: {
        payload: Prisma.$Lkup_BanksVerBranchPayload<ExtArgs>
        fields: Prisma.Lkup_BanksVerBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_BanksVerBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksVerBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_BanksVerBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksVerBranchPayload>
          }
          findFirst: {
            args: Prisma.Lkup_BanksVerBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksVerBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_BanksVerBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksVerBranchPayload>
          }
          findMany: {
            args: Prisma.Lkup_BanksVerBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksVerBranchPayload>[]
          }
          create: {
            args: Prisma.Lkup_BanksVerBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksVerBranchPayload>
          }
          createMany: {
            args: Prisma.Lkup_BanksVerBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_BanksVerBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksVerBranchPayload>
          }
          update: {
            args: Prisma.Lkup_BanksVerBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksVerBranchPayload>
          }
          deleteMany: {
            args: Prisma.Lkup_BanksVerBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_BanksVerBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_BanksVerBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_BanksVerBranchPayload>
          }
          aggregate: {
            args: Prisma.Lkup_BanksVerBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_BanksVerBranch>
          }
          groupBy: {
            args: Prisma.Lkup_BanksVerBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_BanksVerBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_BanksVerBranchCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_BanksVerBranchCountAggregateOutputType> | number
          }
        }
      }
      Lkup_City: {
        payload: Prisma.$Lkup_CityPayload<ExtArgs>
        fields: Prisma.Lkup_CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CityPayload>
          }
          findFirst: {
            args: Prisma.Lkup_CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CityPayload>
          }
          findMany: {
            args: Prisma.Lkup_CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CityPayload>[]
          }
          create: {
            args: Prisma.Lkup_CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CityPayload>
          }
          createMany: {
            args: Prisma.Lkup_CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CityPayload>
          }
          update: {
            args: Prisma.Lkup_CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CityPayload>
          }
          deleteMany: {
            args: Prisma.Lkup_CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CityPayload>
          }
          aggregate: {
            args: Prisma.Lkup_CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_City>
          }
          groupBy: {
            args: Prisma.Lkup_CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_CityCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_CityCountAggregateOutputType> | number
          }
        }
      }
      Lkup_Corporation: {
        payload: Prisma.$Lkup_CorporationPayload<ExtArgs>
        fields: Prisma.Lkup_CorporationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_CorporationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CorporationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_CorporationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CorporationPayload>
          }
          findFirst: {
            args: Prisma.Lkup_CorporationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CorporationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_CorporationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CorporationPayload>
          }
          findMany: {
            args: Prisma.Lkup_CorporationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CorporationPayload>[]
          }
          create: {
            args: Prisma.Lkup_CorporationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CorporationPayload>
          }
          createMany: {
            args: Prisma.Lkup_CorporationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_CorporationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CorporationPayload>
          }
          update: {
            args: Prisma.Lkup_CorporationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CorporationPayload>
          }
          deleteMany: {
            args: Prisma.Lkup_CorporationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_CorporationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_CorporationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CorporationPayload>
          }
          aggregate: {
            args: Prisma.Lkup_CorporationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_Corporation>
          }
          groupBy: {
            args: Prisma.Lkup_CorporationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_CorporationGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_CorporationCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_CorporationCountAggregateOutputType> | number
          }
        }
      }
      Lkup_Country: {
        payload: Prisma.$Lkup_CountryPayload<ExtArgs>
        fields: Prisma.Lkup_CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CountryPayload>
          }
          findFirst: {
            args: Prisma.Lkup_CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CountryPayload>
          }
          findMany: {
            args: Prisma.Lkup_CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CountryPayload>[]
          }
          create: {
            args: Prisma.Lkup_CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CountryPayload>
          }
          createMany: {
            args: Prisma.Lkup_CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CountryPayload>
          }
          update: {
            args: Prisma.Lkup_CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CountryPayload>
          }
          deleteMany: {
            args: Prisma.Lkup_CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CountryPayload>
          }
          aggregate: {
            args: Prisma.Lkup_CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_Country>
          }
          groupBy: {
            args: Prisma.Lkup_CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_CountryCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_CountryCountAggregateOutputType> | number
          }
        }
      }
      Lkup_CreaditCard: {
        payload: Prisma.$Lkup_CreaditCardPayload<ExtArgs>
        fields: Prisma.Lkup_CreaditCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_CreaditCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CreaditCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_CreaditCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CreaditCardPayload>
          }
          findFirst: {
            args: Prisma.Lkup_CreaditCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CreaditCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_CreaditCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CreaditCardPayload>
          }
          findMany: {
            args: Prisma.Lkup_CreaditCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CreaditCardPayload>[]
          }
          create: {
            args: Prisma.Lkup_CreaditCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CreaditCardPayload>
          }
          createMany: {
            args: Prisma.Lkup_CreaditCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_CreaditCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CreaditCardPayload>
          }
          update: {
            args: Prisma.Lkup_CreaditCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CreaditCardPayload>
          }
          deleteMany: {
            args: Prisma.Lkup_CreaditCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_CreaditCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_CreaditCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_CreaditCardPayload>
          }
          aggregate: {
            args: Prisma.Lkup_CreaditCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_CreaditCard>
          }
          groupBy: {
            args: Prisma.Lkup_CreaditCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_CreaditCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_CreaditCardCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_CreaditCardCountAggregateOutputType> | number
          }
        }
      }
      Lkup_EmployeesType: {
        payload: Prisma.$Lkup_EmployeesTypePayload<ExtArgs>
        fields: Prisma.Lkup_EmployeesTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_EmployeesTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_EmployeesTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_EmployeesTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_EmployeesTypePayload>
          }
          findFirst: {
            args: Prisma.Lkup_EmployeesTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_EmployeesTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_EmployeesTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_EmployeesTypePayload>
          }
          findMany: {
            args: Prisma.Lkup_EmployeesTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_EmployeesTypePayload>[]
          }
          create: {
            args: Prisma.Lkup_EmployeesTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_EmployeesTypePayload>
          }
          createMany: {
            args: Prisma.Lkup_EmployeesTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_EmployeesTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_EmployeesTypePayload>
          }
          update: {
            args: Prisma.Lkup_EmployeesTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_EmployeesTypePayload>
          }
          deleteMany: {
            args: Prisma.Lkup_EmployeesTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_EmployeesTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_EmployeesTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_EmployeesTypePayload>
          }
          aggregate: {
            args: Prisma.Lkup_EmployeesTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_EmployeesType>
          }
          groupBy: {
            args: Prisma.Lkup_EmployeesTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_EmployeesTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_EmployeesTypeCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_EmployeesTypeCountAggregateOutputType> | number
          }
        }
      }
      Lkup_Language: {
        payload: Prisma.$Lkup_LanguagePayload<ExtArgs>
        fields: Prisma.Lkup_LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_LanguagePayload>
          }
          findFirst: {
            args: Prisma.Lkup_LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_LanguagePayload>
          }
          findMany: {
            args: Prisma.Lkup_LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_LanguagePayload>[]
          }
          create: {
            args: Prisma.Lkup_LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_LanguagePayload>
          }
          createMany: {
            args: Prisma.Lkup_LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_LanguagePayload>
          }
          update: {
            args: Prisma.Lkup_LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_LanguagePayload>
          }
          deleteMany: {
            args: Prisma.Lkup_LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_LanguagePayload>
          }
          aggregate: {
            args: Prisma.Lkup_LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_Language>
          }
          groupBy: {
            args: Prisma.Lkup_LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_LanguageCountAggregateOutputType> | number
          }
        }
      }
      Lkup_PaySlip: {
        payload: Prisma.$Lkup_PaySlipPayload<ExtArgs>
        fields: Prisma.Lkup_PaySlipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_PaySlipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_PaySlipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_PaySlipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_PaySlipPayload>
          }
          findFirst: {
            args: Prisma.Lkup_PaySlipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_PaySlipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_PaySlipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_PaySlipPayload>
          }
          findMany: {
            args: Prisma.Lkup_PaySlipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_PaySlipPayload>[]
          }
          create: {
            args: Prisma.Lkup_PaySlipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_PaySlipPayload>
          }
          createMany: {
            args: Prisma.Lkup_PaySlipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_PaySlipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_PaySlipPayload>
          }
          update: {
            args: Prisma.Lkup_PaySlipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_PaySlipPayload>
          }
          deleteMany: {
            args: Prisma.Lkup_PaySlipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_PaySlipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_PaySlipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_PaySlipPayload>
          }
          aggregate: {
            args: Prisma.Lkup_PaySlipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_PaySlip>
          }
          groupBy: {
            args: Prisma.Lkup_PaySlipGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_PaySlipGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_PaySlipCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_PaySlipCountAggregateOutputType> | number
          }
        }
      }
      Lkup_Sector: {
        payload: Prisma.$Lkup_SectorPayload<ExtArgs>
        fields: Prisma.Lkup_SectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_SectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_SectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SectorPayload>
          }
          findFirst: {
            args: Prisma.Lkup_SectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_SectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SectorPayload>
          }
          findMany: {
            args: Prisma.Lkup_SectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SectorPayload>[]
          }
          create: {
            args: Prisma.Lkup_SectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SectorPayload>
          }
          createMany: {
            args: Prisma.Lkup_SectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_SectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SectorPayload>
          }
          update: {
            args: Prisma.Lkup_SectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SectorPayload>
          }
          deleteMany: {
            args: Prisma.Lkup_SectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_SectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_SectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SectorPayload>
          }
          aggregate: {
            args: Prisma.Lkup_SectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_Sector>
          }
          groupBy: {
            args: Prisma.Lkup_SectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_SectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_SectorCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_SectorCountAggregateOutputType> | number
          }
        }
      }
      Lkup_SocialSecuritySector: {
        payload: Prisma.$Lkup_SocialSecuritySectorPayload<ExtArgs>
        fields: Prisma.Lkup_SocialSecuritySectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_SocialSecuritySectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SocialSecuritySectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_SocialSecuritySectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SocialSecuritySectorPayload>
          }
          findFirst: {
            args: Prisma.Lkup_SocialSecuritySectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SocialSecuritySectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_SocialSecuritySectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SocialSecuritySectorPayload>
          }
          findMany: {
            args: Prisma.Lkup_SocialSecuritySectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SocialSecuritySectorPayload>[]
          }
          create: {
            args: Prisma.Lkup_SocialSecuritySectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SocialSecuritySectorPayload>
          }
          createMany: {
            args: Prisma.Lkup_SocialSecuritySectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_SocialSecuritySectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SocialSecuritySectorPayload>
          }
          update: {
            args: Prisma.Lkup_SocialSecuritySectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SocialSecuritySectorPayload>
          }
          deleteMany: {
            args: Prisma.Lkup_SocialSecuritySectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_SocialSecuritySectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_SocialSecuritySectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_SocialSecuritySectorPayload>
          }
          aggregate: {
            args: Prisma.Lkup_SocialSecuritySectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_SocialSecuritySector>
          }
          groupBy: {
            args: Prisma.Lkup_SocialSecuritySectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_SocialSecuritySectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_SocialSecuritySectorCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_SocialSecuritySectorCountAggregateOutputType> | number
          }
        }
      }
      Lkup_street: {
        payload: Prisma.$Lkup_streetPayload<ExtArgs>
        fields: Prisma.Lkup_streetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_streetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_streetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_streetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_streetPayload>
          }
          findFirst: {
            args: Prisma.Lkup_streetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_streetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_streetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_streetPayload>
          }
          findMany: {
            args: Prisma.Lkup_streetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_streetPayload>[]
          }
          create: {
            args: Prisma.Lkup_streetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_streetPayload>
          }
          createMany: {
            args: Prisma.Lkup_streetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_streetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_streetPayload>
          }
          update: {
            args: Prisma.Lkup_streetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_streetPayload>
          }
          deleteMany: {
            args: Prisma.Lkup_streetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_streetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_streetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_streetPayload>
          }
          aggregate: {
            args: Prisma.Lkup_streetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_street>
          }
          groupBy: {
            args: Prisma.Lkup_streetGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_streetGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_streetCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_streetCountAggregateOutputType> | number
          }
        }
      }
      PensionDetail: {
        payload: Prisma.$PensionDetailPayload<ExtArgs>
        fields: Prisma.PensionDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PensionDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PensionDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PensionDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PensionDetailPayload>
          }
          findFirst: {
            args: Prisma.PensionDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PensionDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PensionDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PensionDetailPayload>
          }
          findMany: {
            args: Prisma.PensionDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PensionDetailPayload>[]
          }
          create: {
            args: Prisma.PensionDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PensionDetailPayload>
          }
          createMany: {
            args: Prisma.PensionDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PensionDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PensionDetailPayload>
          }
          update: {
            args: Prisma.PensionDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PensionDetailPayload>
          }
          deleteMany: {
            args: Prisma.PensionDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PensionDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PensionDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PensionDetailPayload>
          }
          aggregate: {
            args: Prisma.PensionDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePensionDetail>
          }
          groupBy: {
            args: Prisma.PensionDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<PensionDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.PensionDetailCountArgs<ExtArgs>
            result: $Utils.Optional<PensionDetailCountAggregateOutputType> | number
          }
        }
      }
      Products: {
        payload: Prisma.$ProductsPayload<ExtArgs>
        fields: Prisma.ProductsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          findFirst: {
            args: Prisma.ProductsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          findMany: {
            args: Prisma.ProductsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          create: {
            args: Prisma.ProductsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          createMany: {
            args: Prisma.ProductsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          update: {
            args: Prisma.ProductsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          deleteMany: {
            args: Prisma.ProductsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.ProductsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      Rank: {
        payload: Prisma.$RankPayload<ExtArgs>
        fields: Prisma.RankFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RankFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RankFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>
          }
          findFirst: {
            args: Prisma.RankFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RankFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>
          }
          findMany: {
            args: Prisma.RankFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>[]
          }
          create: {
            args: Prisma.RankCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>
          }
          createMany: {
            args: Prisma.RankCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RankDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>
          }
          update: {
            args: Prisma.RankUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>
          }
          deleteMany: {
            args: Prisma.RankDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RankUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RankUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankPayload>
          }
          aggregate: {
            args: Prisma.RankAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRank>
          }
          groupBy: {
            args: Prisma.RankGroupByArgs<ExtArgs>
            result: $Utils.Optional<RankGroupByOutputType>[]
          }
          count: {
            args: Prisma.RankCountArgs<ExtArgs>
            result: $Utils.Optional<RankCountAggregateOutputType> | number
          }
        }
      }
      RecoveryDefinition: {
        payload: Prisma.$RecoveryDefinitionPayload<ExtArgs>
        fields: Prisma.RecoveryDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecoveryDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecoveryDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionPayload>
          }
          findFirst: {
            args: Prisma.RecoveryDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecoveryDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionPayload>
          }
          findMany: {
            args: Prisma.RecoveryDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionPayload>[]
          }
          create: {
            args: Prisma.RecoveryDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionPayload>
          }
          createMany: {
            args: Prisma.RecoveryDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RecoveryDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionPayload>
          }
          update: {
            args: Prisma.RecoveryDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.RecoveryDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecoveryDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecoveryDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionPayload>
          }
          aggregate: {
            args: Prisma.RecoveryDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecoveryDefinition>
          }
          groupBy: {
            args: Prisma.RecoveryDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecoveryDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecoveryDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<RecoveryDefinitionCountAggregateOutputType> | number
          }
        }
      }
      RecoveryDefinitionDetails: {
        payload: Prisma.$RecoveryDefinitionDetailsPayload<ExtArgs>
        fields: Prisma.RecoveryDefinitionDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecoveryDefinitionDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecoveryDefinitionDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionDetailsPayload>
          }
          findFirst: {
            args: Prisma.RecoveryDefinitionDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecoveryDefinitionDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionDetailsPayload>
          }
          findMany: {
            args: Prisma.RecoveryDefinitionDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionDetailsPayload>[]
          }
          create: {
            args: Prisma.RecoveryDefinitionDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionDetailsPayload>
          }
          createMany: {
            args: Prisma.RecoveryDefinitionDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RecoveryDefinitionDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionDetailsPayload>
          }
          update: {
            args: Prisma.RecoveryDefinitionDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionDetailsPayload>
          }
          deleteMany: {
            args: Prisma.RecoveryDefinitionDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecoveryDefinitionDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecoveryDefinitionDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionDetailsPayload>
          }
          aggregate: {
            args: Prisma.RecoveryDefinitionDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecoveryDefinitionDetails>
          }
          groupBy: {
            args: Prisma.RecoveryDefinitionDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecoveryDefinitionDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecoveryDefinitionDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<RecoveryDefinitionDetailsCountAggregateOutputType> | number
          }
        }
      }
      RecoveryDefinitionRateDetails: {
        payload: Prisma.$RecoveryDefinitionRateDetailsPayload<ExtArgs>
        fields: Prisma.RecoveryDefinitionRateDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecoveryDefinitionRateDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionRateDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecoveryDefinitionRateDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionRateDetailsPayload>
          }
          findFirst: {
            args: Prisma.RecoveryDefinitionRateDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionRateDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecoveryDefinitionRateDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionRateDetailsPayload>
          }
          findMany: {
            args: Prisma.RecoveryDefinitionRateDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionRateDetailsPayload>[]
          }
          create: {
            args: Prisma.RecoveryDefinitionRateDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionRateDetailsPayload>
          }
          createMany: {
            args: Prisma.RecoveryDefinitionRateDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RecoveryDefinitionRateDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionRateDetailsPayload>
          }
          update: {
            args: Prisma.RecoveryDefinitionRateDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionRateDetailsPayload>
          }
          deleteMany: {
            args: Prisma.RecoveryDefinitionRateDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecoveryDefinitionRateDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecoveryDefinitionRateDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryDefinitionRateDetailsPayload>
          }
          aggregate: {
            args: Prisma.RecoveryDefinitionRateDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecoveryDefinitionRateDetails>
          }
          groupBy: {
            args: Prisma.RecoveryDefinitionRateDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecoveryDefinitionRateDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecoveryDefinitionRateDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<RecoveryDefinitionRateDetailsCountAggregateOutputType> | number
          }
        }
      }
      ReportDefinitions: {
        payload: Prisma.$ReportDefinitionsPayload<ExtArgs>
        fields: Prisma.ReportDefinitionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportDefinitionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDefinitionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportDefinitionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDefinitionsPayload>
          }
          findFirst: {
            args: Prisma.ReportDefinitionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDefinitionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportDefinitionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDefinitionsPayload>
          }
          findMany: {
            args: Prisma.ReportDefinitionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDefinitionsPayload>[]
          }
          create: {
            args: Prisma.ReportDefinitionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDefinitionsPayload>
          }
          createMany: {
            args: Prisma.ReportDefinitionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReportDefinitionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDefinitionsPayload>
          }
          update: {
            args: Prisma.ReportDefinitionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDefinitionsPayload>
          }
          deleteMany: {
            args: Prisma.ReportDefinitionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportDefinitionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportDefinitionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDefinitionsPayload>
          }
          aggregate: {
            args: Prisma.ReportDefinitionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportDefinitions>
          }
          groupBy: {
            args: Prisma.ReportDefinitionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportDefinitionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportDefinitionsCountArgs<ExtArgs>
            result: $Utils.Optional<ReportDefinitionsCountAggregateOutputType> | number
          }
        }
      }
      RewardRecoveryRate: {
        payload: Prisma.$RewardRecoveryRatePayload<ExtArgs>
        fields: Prisma.RewardRecoveryRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardRecoveryRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardRecoveryRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryRatePayload>
          }
          findFirst: {
            args: Prisma.RewardRecoveryRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardRecoveryRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryRatePayload>
          }
          findMany: {
            args: Prisma.RewardRecoveryRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryRatePayload>[]
          }
          create: {
            args: Prisma.RewardRecoveryRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryRatePayload>
          }
          createMany: {
            args: Prisma.RewardRecoveryRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RewardRecoveryRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryRatePayload>
          }
          update: {
            args: Prisma.RewardRecoveryRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryRatePayload>
          }
          deleteMany: {
            args: Prisma.RewardRecoveryRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardRecoveryRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RewardRecoveryRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryRatePayload>
          }
          aggregate: {
            args: Prisma.RewardRecoveryRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardRecoveryRate>
          }
          groupBy: {
            args: Prisma.RewardRecoveryRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardRecoveryRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardRecoveryRateCountArgs<ExtArgs>
            result: $Utils.Optional<RewardRecoveryRateCountAggregateOutputType> | number
          }
        }
      }
      RewardRecoveryVector: {
        payload: Prisma.$RewardRecoveryVectorPayload<ExtArgs>
        fields: Prisma.RewardRecoveryVectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardRecoveryVectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryVectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardRecoveryVectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryVectorPayload>
          }
          findFirst: {
            args: Prisma.RewardRecoveryVectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryVectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardRecoveryVectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryVectorPayload>
          }
          findMany: {
            args: Prisma.RewardRecoveryVectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryVectorPayload>[]
          }
          create: {
            args: Prisma.RewardRecoveryVectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryVectorPayload>
          }
          createMany: {
            args: Prisma.RewardRecoveryVectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RewardRecoveryVectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryVectorPayload>
          }
          update: {
            args: Prisma.RewardRecoveryVectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryVectorPayload>
          }
          deleteMany: {
            args: Prisma.RewardRecoveryVectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardRecoveryVectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RewardRecoveryVectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardRecoveryVectorPayload>
          }
          aggregate: {
            args: Prisma.RewardRecoveryVectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardRecoveryVector>
          }
          groupBy: {
            args: Prisma.RewardRecoveryVectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardRecoveryVectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardRecoveryVectorCountArgs<ExtArgs>
            result: $Utils.Optional<RewardRecoveryVectorCountAggregateOutputType> | number
          }
        }
      }
      RewardSickVector: {
        payload: Prisma.$RewardSickVectorPayload<ExtArgs>
        fields: Prisma.RewardSickVectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardSickVectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardSickVectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardSickVectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardSickVectorPayload>
          }
          findFirst: {
            args: Prisma.RewardSickVectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardSickVectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardSickVectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardSickVectorPayload>
          }
          findMany: {
            args: Prisma.RewardSickVectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardSickVectorPayload>[]
          }
          create: {
            args: Prisma.RewardSickVectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardSickVectorPayload>
          }
          createMany: {
            args: Prisma.RewardSickVectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RewardSickVectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardSickVectorPayload>
          }
          update: {
            args: Prisma.RewardSickVectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardSickVectorPayload>
          }
          deleteMany: {
            args: Prisma.RewardSickVectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardSickVectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RewardSickVectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardSickVectorPayload>
          }
          aggregate: {
            args: Prisma.RewardSickVectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardSickVector>
          }
          groupBy: {
            args: Prisma.RewardSickVectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardSickVectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardSickVectorCountArgs<ExtArgs>
            result: $Utils.Optional<RewardSickVectorCountAggregateOutputType> | number
          }
        }
      }
      RewardVacationVector: {
        payload: Prisma.$RewardVacationVectorPayload<ExtArgs>
        fields: Prisma.RewardVacationVectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardVacationVectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardVacationVectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardVacationVectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardVacationVectorPayload>
          }
          findFirst: {
            args: Prisma.RewardVacationVectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardVacationVectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardVacationVectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardVacationVectorPayload>
          }
          findMany: {
            args: Prisma.RewardVacationVectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardVacationVectorPayload>[]
          }
          create: {
            args: Prisma.RewardVacationVectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardVacationVectorPayload>
          }
          createMany: {
            args: Prisma.RewardVacationVectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RewardVacationVectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardVacationVectorPayload>
          }
          update: {
            args: Prisma.RewardVacationVectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardVacationVectorPayload>
          }
          deleteMany: {
            args: Prisma.RewardVacationVectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardVacationVectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RewardVacationVectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardVacationVectorPayload>
          }
          aggregate: {
            args: Prisma.RewardVacationVectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardVacationVector>
          }
          groupBy: {
            args: Prisma.RewardVacationVectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardVacationVectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardVacationVectorCountArgs<ExtArgs>
            result: $Utils.Optional<RewardVacationVectorCountAggregateOutputType> | number
          }
        }
      }
      SickDefinition: {
        payload: Prisma.$SickDefinitionPayload<ExtArgs>
        fields: Prisma.SickDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SickDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SickDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionPayload>
          }
          findFirst: {
            args: Prisma.SickDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SickDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionPayload>
          }
          findMany: {
            args: Prisma.SickDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionPayload>[]
          }
          create: {
            args: Prisma.SickDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionPayload>
          }
          createMany: {
            args: Prisma.SickDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SickDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionPayload>
          }
          update: {
            args: Prisma.SickDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.SickDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SickDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SickDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionPayload>
          }
          aggregate: {
            args: Prisma.SickDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSickDefinition>
          }
          groupBy: {
            args: Prisma.SickDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SickDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SickDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<SickDefinitionCountAggregateOutputType> | number
          }
        }
      }
      SickDefinitionDetail: {
        payload: Prisma.$SickDefinitionDetailPayload<ExtArgs>
        fields: Prisma.SickDefinitionDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SickDefinitionDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SickDefinitionDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionDetailPayload>
          }
          findFirst: {
            args: Prisma.SickDefinitionDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SickDefinitionDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionDetailPayload>
          }
          findMany: {
            args: Prisma.SickDefinitionDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionDetailPayload>[]
          }
          create: {
            args: Prisma.SickDefinitionDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionDetailPayload>
          }
          createMany: {
            args: Prisma.SickDefinitionDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SickDefinitionDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionDetailPayload>
          }
          update: {
            args: Prisma.SickDefinitionDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionDetailPayload>
          }
          deleteMany: {
            args: Prisma.SickDefinitionDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SickDefinitionDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SickDefinitionDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SickDefinitionDetailPayload>
          }
          aggregate: {
            args: Prisma.SickDefinitionDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSickDefinitionDetail>
          }
          groupBy: {
            args: Prisma.SickDefinitionDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<SickDefinitionDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.SickDefinitionDetailCountArgs<ExtArgs>
            result: $Utils.Optional<SickDefinitionDetailCountAggregateOutputType> | number
          }
        }
      }
      SocialSecurity: {
        payload: Prisma.$SocialSecurityPayload<ExtArgs>
        fields: Prisma.SocialSecurityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialSecurityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialSecurityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityPayload>
          }
          findFirst: {
            args: Prisma.SocialSecurityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialSecurityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityPayload>
          }
          findMany: {
            args: Prisma.SocialSecurityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityPayload>[]
          }
          create: {
            args: Prisma.SocialSecurityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityPayload>
          }
          createMany: {
            args: Prisma.SocialSecurityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SocialSecurityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityPayload>
          }
          update: {
            args: Prisma.SocialSecurityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityPayload>
          }
          deleteMany: {
            args: Prisma.SocialSecurityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialSecurityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocialSecurityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityPayload>
          }
          aggregate: {
            args: Prisma.SocialSecurityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialSecurity>
          }
          groupBy: {
            args: Prisma.SocialSecurityGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialSecurityGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialSecurityCountArgs<ExtArgs>
            result: $Utils.Optional<SocialSecurityCountAggregateOutputType> | number
          }
        }
      }
      SocialSecurityDetile: {
        payload: Prisma.$SocialSecurityDetilePayload<ExtArgs>
        fields: Prisma.SocialSecurityDetileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialSecurityDetileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityDetilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialSecurityDetileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityDetilePayload>
          }
          findFirst: {
            args: Prisma.SocialSecurityDetileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityDetilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialSecurityDetileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityDetilePayload>
          }
          findMany: {
            args: Prisma.SocialSecurityDetileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityDetilePayload>[]
          }
          create: {
            args: Prisma.SocialSecurityDetileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityDetilePayload>
          }
          createMany: {
            args: Prisma.SocialSecurityDetileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SocialSecurityDetileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityDetilePayload>
          }
          update: {
            args: Prisma.SocialSecurityDetileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityDetilePayload>
          }
          deleteMany: {
            args: Prisma.SocialSecurityDetileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialSecurityDetileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocialSecurityDetileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialSecurityDetilePayload>
          }
          aggregate: {
            args: Prisma.SocialSecurityDetileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialSecurityDetile>
          }
          groupBy: {
            args: Prisma.SocialSecurityDetileGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialSecurityDetileGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialSecurityDetileCountArgs<ExtArgs>
            result: $Utils.Optional<SocialSecurityDetileCountAggregateOutputType> | number
          }
        }
      }
      sysdiagrams: {
        payload: Prisma.$sysdiagramsPayload<ExtArgs>
        fields: Prisma.sysdiagramsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sysdiagramsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sysdiagramsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findFirst: {
            args: Prisma.sysdiagramsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sysdiagramsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findMany: {
            args: Prisma.sysdiagramsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>[]
          }
          create: {
            args: Prisma.sysdiagramsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          createMany: {
            args: Prisma.sysdiagramsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sysdiagramsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          update: {
            args: Prisma.sysdiagramsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          deleteMany: {
            args: Prisma.sysdiagramsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sysdiagramsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sysdiagramsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          aggregate: {
            args: Prisma.SysdiagramsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSysdiagrams>
          }
          groupBy: {
            args: Prisma.sysdiagramsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sysdiagramsCountArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsCountAggregateOutputType> | number
          }
        }
      }
      SystemDefinition: {
        payload: Prisma.$SystemDefinitionPayload<ExtArgs>
        fields: Prisma.SystemDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemDefinitionPayload>
          }
          findFirst: {
            args: Prisma.SystemDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemDefinitionPayload>
          }
          findMany: {
            args: Prisma.SystemDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemDefinitionPayload>[]
          }
          create: {
            args: Prisma.SystemDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemDefinitionPayload>
          }
          createMany: {
            args: Prisma.SystemDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemDefinitionPayload>
          }
          update: {
            args: Prisma.SystemDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.SystemDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemDefinitionPayload>
          }
          aggregate: {
            args: Prisma.SystemDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemDefinition>
          }
          groupBy: {
            args: Prisma.SystemDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<SystemDefinitionCountAggregateOutputType> | number
          }
        }
      }
      SystemMaintenanc: {
        payload: Prisma.$SystemMaintenancPayload<ExtArgs>
        fields: Prisma.SystemMaintenancFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemMaintenancFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMaintenancPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemMaintenancFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMaintenancPayload>
          }
          findFirst: {
            args: Prisma.SystemMaintenancFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMaintenancPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemMaintenancFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMaintenancPayload>
          }
          findMany: {
            args: Prisma.SystemMaintenancFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMaintenancPayload>[]
          }
          create: {
            args: Prisma.SystemMaintenancCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMaintenancPayload>
          }
          createMany: {
            args: Prisma.SystemMaintenancCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemMaintenancDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMaintenancPayload>
          }
          update: {
            args: Prisma.SystemMaintenancUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMaintenancPayload>
          }
          deleteMany: {
            args: Prisma.SystemMaintenancDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemMaintenancUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemMaintenancUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMaintenancPayload>
          }
          aggregate: {
            args: Prisma.SystemMaintenancAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemMaintenanc>
          }
          groupBy: {
            args: Prisma.SystemMaintenancGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemMaintenancGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemMaintenancCountArgs<ExtArgs>
            result: $Utils.Optional<SystemMaintenancCountAggregateOutputType> | number
          }
        }
      }
      TaxStepDetile: {
        payload: Prisma.$TaxStepDetilePayload<ExtArgs>
        fields: Prisma.TaxStepDetileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxStepDetileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepDetilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxStepDetileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepDetilePayload>
          }
          findFirst: {
            args: Prisma.TaxStepDetileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepDetilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxStepDetileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepDetilePayload>
          }
          findMany: {
            args: Prisma.TaxStepDetileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepDetilePayload>[]
          }
          create: {
            args: Prisma.TaxStepDetileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepDetilePayload>
          }
          createMany: {
            args: Prisma.TaxStepDetileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaxStepDetileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepDetilePayload>
          }
          update: {
            args: Prisma.TaxStepDetileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepDetilePayload>
          }
          deleteMany: {
            args: Prisma.TaxStepDetileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxStepDetileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaxStepDetileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepDetilePayload>
          }
          aggregate: {
            args: Prisma.TaxStepDetileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxStepDetile>
          }
          groupBy: {
            args: Prisma.TaxStepDetileGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxStepDetileGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxStepDetileCountArgs<ExtArgs>
            result: $Utils.Optional<TaxStepDetileCountAggregateOutputType> | number
          }
        }
      }
      TaxSteps: {
        payload: Prisma.$TaxStepsPayload<ExtArgs>
        fields: Prisma.TaxStepsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxStepsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxStepsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepsPayload>
          }
          findFirst: {
            args: Prisma.TaxStepsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxStepsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepsPayload>
          }
          findMany: {
            args: Prisma.TaxStepsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepsPayload>[]
          }
          create: {
            args: Prisma.TaxStepsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepsPayload>
          }
          createMany: {
            args: Prisma.TaxStepsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaxStepsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepsPayload>
          }
          update: {
            args: Prisma.TaxStepsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepsPayload>
          }
          deleteMany: {
            args: Prisma.TaxStepsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxStepsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaxStepsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxStepsPayload>
          }
          aggregate: {
            args: Prisma.TaxStepsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxSteps>
          }
          groupBy: {
            args: Prisma.TaxStepsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxStepsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxStepsCountArgs<ExtArgs>
            result: $Utils.Optional<TaxStepsCountAggregateOutputType> | number
          }
        }
      }
      UnionFee: {
        payload: Prisma.$UnionFeePayload<ExtArgs>
        fields: Prisma.UnionFeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnionFeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnionFeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeePayload>
          }
          findFirst: {
            args: Prisma.UnionFeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnionFeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeePayload>
          }
          findMany: {
            args: Prisma.UnionFeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeePayload>[]
          }
          create: {
            args: Prisma.UnionFeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeePayload>
          }
          createMany: {
            args: Prisma.UnionFeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnionFeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeePayload>
          }
          update: {
            args: Prisma.UnionFeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeePayload>
          }
          deleteMany: {
            args: Prisma.UnionFeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnionFeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnionFeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeePayload>
          }
          aggregate: {
            args: Prisma.UnionFeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnionFee>
          }
          groupBy: {
            args: Prisma.UnionFeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnionFeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnionFeeCountArgs<ExtArgs>
            result: $Utils.Optional<UnionFeeCountAggregateOutputType> | number
          }
        }
      }
      UnionFeeDetile: {
        payload: Prisma.$UnionFeeDetilePayload<ExtArgs>
        fields: Prisma.UnionFeeDetileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnionFeeDetileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeeDetilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnionFeeDetileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeeDetilePayload>
          }
          findFirst: {
            args: Prisma.UnionFeeDetileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeeDetilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnionFeeDetileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeeDetilePayload>
          }
          findMany: {
            args: Prisma.UnionFeeDetileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeeDetilePayload>[]
          }
          create: {
            args: Prisma.UnionFeeDetileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeeDetilePayload>
          }
          createMany: {
            args: Prisma.UnionFeeDetileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnionFeeDetileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeeDetilePayload>
          }
          update: {
            args: Prisma.UnionFeeDetileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeeDetilePayload>
          }
          deleteMany: {
            args: Prisma.UnionFeeDetileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnionFeeDetileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnionFeeDetileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnionFeeDetilePayload>
          }
          aggregate: {
            args: Prisma.UnionFeeDetileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnionFeeDetile>
          }
          groupBy: {
            args: Prisma.UnionFeeDetileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnionFeeDetileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnionFeeDetileCountArgs<ExtArgs>
            result: $Utils.Optional<UnionFeeDetileCountAggregateOutputType> | number
          }
        }
      }
      VacationDefinitionDetails: {
        payload: Prisma.$VacationDefinitionDetailsPayload<ExtArgs>
        fields: Prisma.VacationDefinitionDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VacationDefinitionDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationDefinitionDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VacationDefinitionDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationDefinitionDetailsPayload>
          }
          findFirst: {
            args: Prisma.VacationDefinitionDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationDefinitionDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VacationDefinitionDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationDefinitionDetailsPayload>
          }
          findMany: {
            args: Prisma.VacationDefinitionDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationDefinitionDetailsPayload>[]
          }
          create: {
            args: Prisma.VacationDefinitionDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationDefinitionDetailsPayload>
          }
          createMany: {
            args: Prisma.VacationDefinitionDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VacationDefinitionDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationDefinitionDetailsPayload>
          }
          update: {
            args: Prisma.VacationDefinitionDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationDefinitionDetailsPayload>
          }
          deleteMany: {
            args: Prisma.VacationDefinitionDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VacationDefinitionDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VacationDefinitionDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationDefinitionDetailsPayload>
          }
          aggregate: {
            args: Prisma.VacationDefinitionDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVacationDefinitionDetails>
          }
          groupBy: {
            args: Prisma.VacationDefinitionDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VacationDefinitionDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VacationDefinitionDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<VacationDefinitionDetailsCountAggregateOutputType> | number
          }
        }
      }
      VacationlDefinition: {
        payload: Prisma.$VacationlDefinitionPayload<ExtArgs>
        fields: Prisma.VacationlDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VacationlDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationlDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VacationlDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationlDefinitionPayload>
          }
          findFirst: {
            args: Prisma.VacationlDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationlDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VacationlDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationlDefinitionPayload>
          }
          findMany: {
            args: Prisma.VacationlDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationlDefinitionPayload>[]
          }
          create: {
            args: Prisma.VacationlDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationlDefinitionPayload>
          }
          createMany: {
            args: Prisma.VacationlDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VacationlDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationlDefinitionPayload>
          }
          update: {
            args: Prisma.VacationlDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationlDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.VacationlDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VacationlDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VacationlDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VacationlDefinitionPayload>
          }
          aggregate: {
            args: Prisma.VacationlDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVacationlDefinition>
          }
          groupBy: {
            args: Prisma.VacationlDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VacationlDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VacationlDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<VacationlDefinitionCountAggregateOutputType> | number
          }
        }
      }
      ValueOfVehicleUse: {
        payload: Prisma.$ValueOfVehicleUsePayload<ExtArgs>
        fields: Prisma.ValueOfVehicleUseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ValueOfVehicleUseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ValueOfVehicleUseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUsePayload>
          }
          findFirst: {
            args: Prisma.ValueOfVehicleUseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ValueOfVehicleUseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUsePayload>
          }
          findMany: {
            args: Prisma.ValueOfVehicleUseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUsePayload>[]
          }
          create: {
            args: Prisma.ValueOfVehicleUseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUsePayload>
          }
          createMany: {
            args: Prisma.ValueOfVehicleUseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ValueOfVehicleUseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUsePayload>
          }
          update: {
            args: Prisma.ValueOfVehicleUseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUsePayload>
          }
          deleteMany: {
            args: Prisma.ValueOfVehicleUseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ValueOfVehicleUseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ValueOfVehicleUseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUsePayload>
          }
          aggregate: {
            args: Prisma.ValueOfVehicleUseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateValueOfVehicleUse>
          }
          groupBy: {
            args: Prisma.ValueOfVehicleUseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ValueOfVehicleUseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ValueOfVehicleUseCountArgs<ExtArgs>
            result: $Utils.Optional<ValueOfVehicleUseCountAggregateOutputType> | number
          }
        }
      }
      ValueOfVehicleUseByDetile: {
        payload: Prisma.$ValueOfVehicleUseByDetilePayload<ExtArgs>
        fields: Prisma.ValueOfVehicleUseByDetileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ValueOfVehicleUseByDetileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUseByDetilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ValueOfVehicleUseByDetileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUseByDetilePayload>
          }
          findFirst: {
            args: Prisma.ValueOfVehicleUseByDetileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUseByDetilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ValueOfVehicleUseByDetileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUseByDetilePayload>
          }
          findMany: {
            args: Prisma.ValueOfVehicleUseByDetileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUseByDetilePayload>[]
          }
          create: {
            args: Prisma.ValueOfVehicleUseByDetileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUseByDetilePayload>
          }
          createMany: {
            args: Prisma.ValueOfVehicleUseByDetileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ValueOfVehicleUseByDetileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUseByDetilePayload>
          }
          update: {
            args: Prisma.ValueOfVehicleUseByDetileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUseByDetilePayload>
          }
          deleteMany: {
            args: Prisma.ValueOfVehicleUseByDetileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ValueOfVehicleUseByDetileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ValueOfVehicleUseByDetileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValueOfVehicleUseByDetilePayload>
          }
          aggregate: {
            args: Prisma.ValueOfVehicleUseByDetileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateValueOfVehicleUseByDetile>
          }
          groupBy: {
            args: Prisma.ValueOfVehicleUseByDetileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ValueOfVehicleUseByDetileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ValueOfVehicleUseByDetileCountArgs<ExtArgs>
            result: $Utils.Optional<ValueOfVehicleUseByDetileCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AutoWordReportCountOutputType
   */

  export type AutoWordReportCountOutputType = {
    AutoWordReportSub: number
  }

  export type AutoWordReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AutoWordReportSub?: boolean | AutoWordReportCountOutputTypeCountAutoWordReportSubArgs
  }

  // Custom InputTypes
  /**
   * AutoWordReportCountOutputType without action
   */
  export type AutoWordReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReportCountOutputType
     */
    select?: AutoWordReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutoWordReportCountOutputType without action
   */
  export type AutoWordReportCountOutputTypeCountAutoWordReportSubArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoWordReportSubWhereInput
  }


  /**
   * Count Type CompaniesCountOutputType
   */

  export type CompaniesCountOutputType = {
    CompaniesProducts: number
    CompaniesProductsExpireDates: number
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies: number
    CompaniesUsersProductsExpireDates: number
  }

  export type CompaniesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CompaniesProducts?: boolean | CompaniesCountOutputTypeCountCompaniesProductsArgs
    CompaniesProductsExpireDates?: boolean | CompaniesCountOutputTypeCountCompaniesProductsExpireDatesArgs
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: boolean | CompaniesCountOutputTypeCountCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesArgs
    CompaniesUsersProductsExpireDates?: boolean | CompaniesCountOutputTypeCountCompaniesUsersProductsExpireDatesArgs
  }

  // Custom InputTypes
  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesCountOutputType
     */
    select?: CompaniesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompaniesProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesProductsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompaniesProductsExpireDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesProductsExpireDatesWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesUsersWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompaniesUsersProductsExpireDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesUsersProductsExpireDatesWhereInput
  }


  /**
   * Count Type CompaniesTypeCountOutputType
   */

  export type CompaniesTypeCountOutputType = {
    Companies: number
  }

  export type CompaniesTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Companies?: boolean | CompaniesTypeCountOutputTypeCountCompaniesArgs
  }

  // Custom InputTypes
  /**
   * CompaniesTypeCountOutputType without action
   */
  export type CompaniesTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesTypeCountOutputType
     */
    select?: CompaniesTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesTypeCountOutputType without action
   */
  export type CompaniesTypeCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesWhereInput
  }


  /**
   * Count Type CompaniesUsersCountOutputType
   */

  export type CompaniesUsersCountOutputType = {
    Companies_Companies_UserIdToCompaniesUsers: number
    CompaniesProducts: number
    CompaniesProductsExpireDates: number
    other_CompaniesUsers: number
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers: number
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers: number
  }

  export type CompaniesUsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Companies_Companies_UserIdToCompaniesUsers?: boolean | CompaniesUsersCountOutputTypeCountCompanies_Companies_UserIdToCompaniesUsersArgs
    CompaniesProducts?: boolean | CompaniesUsersCountOutputTypeCountCompaniesProductsArgs
    CompaniesProductsExpireDates?: boolean | CompaniesUsersCountOutputTypeCountCompaniesProductsExpireDatesArgs
    other_CompaniesUsers?: boolean | CompaniesUsersCountOutputTypeCountOther_CompaniesUsersArgs
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: boolean | CompaniesUsersCountOutputTypeCountCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersArgs
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: boolean | CompaniesUsersCountOutputTypeCountCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersArgs
  }

  // Custom InputTypes
  /**
   * CompaniesUsersCountOutputType without action
   */
  export type CompaniesUsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersCountOutputType
     */
    select?: CompaniesUsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesUsersCountOutputType without action
   */
  export type CompaniesUsersCountOutputTypeCountCompanies_Companies_UserIdToCompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesWhereInput
  }

  /**
   * CompaniesUsersCountOutputType without action
   */
  export type CompaniesUsersCountOutputTypeCountCompaniesProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesProductsWhereInput
  }

  /**
   * CompaniesUsersCountOutputType without action
   */
  export type CompaniesUsersCountOutputTypeCountCompaniesProductsExpireDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesProductsExpireDatesWhereInput
  }

  /**
   * CompaniesUsersCountOutputType without action
   */
  export type CompaniesUsersCountOutputTypeCountOther_CompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesUsersWhereInput
  }

  /**
   * CompaniesUsersCountOutputType without action
   */
  export type CompaniesUsersCountOutputTypeCountCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesUsersProductsExpireDatesWhereInput
  }

  /**
   * CompaniesUsersCountOutputType without action
   */
  export type CompaniesUsersCountOutputTypeCountCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesUsersProductsExpireDatesWhereInput
  }


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    CompaniesProducts: number
    CompaniesProductsExpireDates: number
    CompaniesUsersProductsExpireDates: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CompaniesProducts?: boolean | ProductsCountOutputTypeCountCompaniesProductsArgs
    CompaniesProductsExpireDates?: boolean | ProductsCountOutputTypeCountCompaniesProductsExpireDatesArgs
    CompaniesUsersProductsExpireDates?: boolean | ProductsCountOutputTypeCountCompaniesUsersProductsExpireDatesArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountCompaniesProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesProductsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountCompaniesProductsExpireDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesProductsExpireDatesWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountCompaniesUsersProductsExpireDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesUsersProductsExpireDatesWhereInput
  }


  /**
   * Count Type RecoveryDefinitionCountOutputType
   */

  export type RecoveryDefinitionCountOutputType = {
    RecoveryDefinitionDetails: number
    RecoveryDefinitionRateDetails: number
  }

  export type RecoveryDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RecoveryDefinitionDetails?: boolean | RecoveryDefinitionCountOutputTypeCountRecoveryDefinitionDetailsArgs
    RecoveryDefinitionRateDetails?: boolean | RecoveryDefinitionCountOutputTypeCountRecoveryDefinitionRateDetailsArgs
  }

  // Custom InputTypes
  /**
   * RecoveryDefinitionCountOutputType without action
   */
  export type RecoveryDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionCountOutputType
     */
    select?: RecoveryDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecoveryDefinitionCountOutputType without action
   */
  export type RecoveryDefinitionCountOutputTypeCountRecoveryDefinitionDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryDefinitionDetailsWhereInput
  }

  /**
   * RecoveryDefinitionCountOutputType without action
   */
  export type RecoveryDefinitionCountOutputTypeCountRecoveryDefinitionRateDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryDefinitionRateDetailsWhereInput
  }


  /**
   * Count Type SickDefinitionCountOutputType
   */

  export type SickDefinitionCountOutputType = {
    SickDefinitionDetail: number
  }

  export type SickDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SickDefinitionDetail?: boolean | SickDefinitionCountOutputTypeCountSickDefinitionDetailArgs
  }

  // Custom InputTypes
  /**
   * SickDefinitionCountOutputType without action
   */
  export type SickDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinitionCountOutputType
     */
    select?: SickDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SickDefinitionCountOutputType without action
   */
  export type SickDefinitionCountOutputTypeCountSickDefinitionDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SickDefinitionDetailWhereInput
  }


  /**
   * Count Type SocialSecurityCountOutputType
   */

  export type SocialSecurityCountOutputType = {
    SocialSecurityDetile: number
  }

  export type SocialSecurityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SocialSecurityDetile?: boolean | SocialSecurityCountOutputTypeCountSocialSecurityDetileArgs
  }

  // Custom InputTypes
  /**
   * SocialSecurityCountOutputType without action
   */
  export type SocialSecurityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurityCountOutputType
     */
    select?: SocialSecurityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SocialSecurityCountOutputType without action
   */
  export type SocialSecurityCountOutputTypeCountSocialSecurityDetileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialSecurityDetileWhereInput
  }


  /**
   * Count Type TaxStepsCountOutputType
   */

  export type TaxStepsCountOutputType = {
    TaxStepDetile: number
  }

  export type TaxStepsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TaxStepDetile?: boolean | TaxStepsCountOutputTypeCountTaxStepDetileArgs
  }

  // Custom InputTypes
  /**
   * TaxStepsCountOutputType without action
   */
  export type TaxStepsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxStepsCountOutputType
     */
    select?: TaxStepsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaxStepsCountOutputType without action
   */
  export type TaxStepsCountOutputTypeCountTaxStepDetileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxStepDetileWhereInput
  }


  /**
   * Count Type UnionFeeCountOutputType
   */

  export type UnionFeeCountOutputType = {
    UnionFeeDetile: number
  }

  export type UnionFeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UnionFeeDetile?: boolean | UnionFeeCountOutputTypeCountUnionFeeDetileArgs
  }

  // Custom InputTypes
  /**
   * UnionFeeCountOutputType without action
   */
  export type UnionFeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFeeCountOutputType
     */
    select?: UnionFeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnionFeeCountOutputType without action
   */
  export type UnionFeeCountOutputTypeCountUnionFeeDetileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnionFeeDetileWhereInput
  }


  /**
   * Count Type VacationlDefinitionCountOutputType
   */

  export type VacationlDefinitionCountOutputType = {
    VacationDefinitionDetails: number
  }

  export type VacationlDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VacationDefinitionDetails?: boolean | VacationlDefinitionCountOutputTypeCountVacationDefinitionDetailsArgs
  }

  // Custom InputTypes
  /**
   * VacationlDefinitionCountOutputType without action
   */
  export type VacationlDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationlDefinitionCountOutputType
     */
    select?: VacationlDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VacationlDefinitionCountOutputType without action
   */
  export type VacationlDefinitionCountOutputTypeCountVacationDefinitionDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VacationDefinitionDetailsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AdvanceNotice
   */

  export type AggregateAdvanceNotice = {
    _count: AdvanceNoticeCountAggregateOutputType | null
    _avg: AdvanceNoticeAvgAggregateOutputType | null
    _sum: AdvanceNoticeSumAggregateOutputType | null
    _min: AdvanceNoticeMinAggregateOutputType | null
    _max: AdvanceNoticeMaxAggregateOutputType | null
  }

  export type AdvanceNoticeAvgAggregateOutputType = {
    AdvanceNoticeID: number | null
    StartPeriod: number | null
    EndPeriod: number | null
    DaysOfNotice: number | null
  }

  export type AdvanceNoticeSumAggregateOutputType = {
    AdvanceNoticeID: number | null
    StartPeriod: number | null
    EndPeriod: number | null
    DaysOfNotice: number | null
  }

  export type AdvanceNoticeMinAggregateOutputType = {
    AdvanceNoticeID: number | null
    StartPeriod: number | null
    EndPeriod: number | null
    DaysOfNotice: number | null
  }

  export type AdvanceNoticeMaxAggregateOutputType = {
    AdvanceNoticeID: number | null
    StartPeriod: number | null
    EndPeriod: number | null
    DaysOfNotice: number | null
  }

  export type AdvanceNoticeCountAggregateOutputType = {
    AdvanceNoticeID: number
    StartPeriod: number
    EndPeriod: number
    DaysOfNotice: number
    _all: number
  }


  export type AdvanceNoticeAvgAggregateInputType = {
    AdvanceNoticeID?: true
    StartPeriod?: true
    EndPeriod?: true
    DaysOfNotice?: true
  }

  export type AdvanceNoticeSumAggregateInputType = {
    AdvanceNoticeID?: true
    StartPeriod?: true
    EndPeriod?: true
    DaysOfNotice?: true
  }

  export type AdvanceNoticeMinAggregateInputType = {
    AdvanceNoticeID?: true
    StartPeriod?: true
    EndPeriod?: true
    DaysOfNotice?: true
  }

  export type AdvanceNoticeMaxAggregateInputType = {
    AdvanceNoticeID?: true
    StartPeriod?: true
    EndPeriod?: true
    DaysOfNotice?: true
  }

  export type AdvanceNoticeCountAggregateInputType = {
    AdvanceNoticeID?: true
    StartPeriod?: true
    EndPeriod?: true
    DaysOfNotice?: true
    _all?: true
  }

  export type AdvanceNoticeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvanceNotice to aggregate.
     */
    where?: AdvanceNoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvanceNotices to fetch.
     */
    orderBy?: AdvanceNoticeOrderByWithRelationInput | AdvanceNoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvanceNoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvanceNotices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvanceNotices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdvanceNotices
    **/
    _count?: true | AdvanceNoticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvanceNoticeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvanceNoticeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvanceNoticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvanceNoticeMaxAggregateInputType
  }

  export type GetAdvanceNoticeAggregateType<T extends AdvanceNoticeAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvanceNotice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvanceNotice[P]>
      : GetScalarType<T[P], AggregateAdvanceNotice[P]>
  }




  export type AdvanceNoticeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvanceNoticeWhereInput
    orderBy?: AdvanceNoticeOrderByWithAggregationInput | AdvanceNoticeOrderByWithAggregationInput[]
    by: AdvanceNoticeScalarFieldEnum[] | AdvanceNoticeScalarFieldEnum
    having?: AdvanceNoticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvanceNoticeCountAggregateInputType | true
    _avg?: AdvanceNoticeAvgAggregateInputType
    _sum?: AdvanceNoticeSumAggregateInputType
    _min?: AdvanceNoticeMinAggregateInputType
    _max?: AdvanceNoticeMaxAggregateInputType
  }

  export type AdvanceNoticeGroupByOutputType = {
    AdvanceNoticeID: number
    StartPeriod: number | null
    EndPeriod: number | null
    DaysOfNotice: number | null
    _count: AdvanceNoticeCountAggregateOutputType | null
    _avg: AdvanceNoticeAvgAggregateOutputType | null
    _sum: AdvanceNoticeSumAggregateOutputType | null
    _min: AdvanceNoticeMinAggregateOutputType | null
    _max: AdvanceNoticeMaxAggregateOutputType | null
  }

  type GetAdvanceNoticeGroupByPayload<T extends AdvanceNoticeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvanceNoticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvanceNoticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvanceNoticeGroupByOutputType[P]>
            : GetScalarType<T[P], AdvanceNoticeGroupByOutputType[P]>
        }
      >
    >


  export type AdvanceNoticeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AdvanceNoticeID?: boolean
    StartPeriod?: boolean
    EndPeriod?: boolean
    DaysOfNotice?: boolean
  }, ExtArgs["result"]["advanceNotice"]>


  export type AdvanceNoticeSelectScalar = {
    AdvanceNoticeID?: boolean
    StartPeriod?: boolean
    EndPeriod?: boolean
    DaysOfNotice?: boolean
  }


  export type $AdvanceNoticePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdvanceNotice"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      AdvanceNoticeID: number
      StartPeriod: number | null
      EndPeriod: number | null
      DaysOfNotice: number | null
    }, ExtArgs["result"]["advanceNotice"]>
    composites: {}
  }

  type AdvanceNoticeGetPayload<S extends boolean | null | undefined | AdvanceNoticeDefaultArgs> = $Result.GetResult<Prisma.$AdvanceNoticePayload, S>

  type AdvanceNoticeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdvanceNoticeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdvanceNoticeCountAggregateInputType | true
    }

  export interface AdvanceNoticeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdvanceNotice'], meta: { name: 'AdvanceNotice' } }
    /**
     * Find zero or one AdvanceNotice that matches the filter.
     * @param {AdvanceNoticeFindUniqueArgs} args - Arguments to find a AdvanceNotice
     * @example
     * // Get one AdvanceNotice
     * const advanceNotice = await prisma.advanceNotice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvanceNoticeFindUniqueArgs>(args: SelectSubset<T, AdvanceNoticeFindUniqueArgs<ExtArgs>>): Prisma__AdvanceNoticeClient<$Result.GetResult<Prisma.$AdvanceNoticePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdvanceNotice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdvanceNoticeFindUniqueOrThrowArgs} args - Arguments to find a AdvanceNotice
     * @example
     * // Get one AdvanceNotice
     * const advanceNotice = await prisma.advanceNotice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvanceNoticeFindUniqueOrThrowArgs>(args: SelectSubset<T, AdvanceNoticeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdvanceNoticeClient<$Result.GetResult<Prisma.$AdvanceNoticePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdvanceNotice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceNoticeFindFirstArgs} args - Arguments to find a AdvanceNotice
     * @example
     * // Get one AdvanceNotice
     * const advanceNotice = await prisma.advanceNotice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvanceNoticeFindFirstArgs>(args?: SelectSubset<T, AdvanceNoticeFindFirstArgs<ExtArgs>>): Prisma__AdvanceNoticeClient<$Result.GetResult<Prisma.$AdvanceNoticePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdvanceNotice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceNoticeFindFirstOrThrowArgs} args - Arguments to find a AdvanceNotice
     * @example
     * // Get one AdvanceNotice
     * const advanceNotice = await prisma.advanceNotice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvanceNoticeFindFirstOrThrowArgs>(args?: SelectSubset<T, AdvanceNoticeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdvanceNoticeClient<$Result.GetResult<Prisma.$AdvanceNoticePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdvanceNotices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceNoticeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdvanceNotices
     * const advanceNotices = await prisma.advanceNotice.findMany()
     * 
     * // Get first 10 AdvanceNotices
     * const advanceNotices = await prisma.advanceNotice.findMany({ take: 10 })
     * 
     * // Only select the `AdvanceNoticeID`
     * const advanceNoticeWithAdvanceNoticeIDOnly = await prisma.advanceNotice.findMany({ select: { AdvanceNoticeID: true } })
     * 
     */
    findMany<T extends AdvanceNoticeFindManyArgs>(args?: SelectSubset<T, AdvanceNoticeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvanceNoticePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdvanceNotice.
     * @param {AdvanceNoticeCreateArgs} args - Arguments to create a AdvanceNotice.
     * @example
     * // Create one AdvanceNotice
     * const AdvanceNotice = await prisma.advanceNotice.create({
     *   data: {
     *     // ... data to create a AdvanceNotice
     *   }
     * })
     * 
     */
    create<T extends AdvanceNoticeCreateArgs>(args: SelectSubset<T, AdvanceNoticeCreateArgs<ExtArgs>>): Prisma__AdvanceNoticeClient<$Result.GetResult<Prisma.$AdvanceNoticePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdvanceNotices.
     * @param {AdvanceNoticeCreateManyArgs} args - Arguments to create many AdvanceNotices.
     * @example
     * // Create many AdvanceNotices
     * const advanceNotice = await prisma.advanceNotice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdvanceNoticeCreateManyArgs>(args?: SelectSubset<T, AdvanceNoticeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdvanceNotice.
     * @param {AdvanceNoticeDeleteArgs} args - Arguments to delete one AdvanceNotice.
     * @example
     * // Delete one AdvanceNotice
     * const AdvanceNotice = await prisma.advanceNotice.delete({
     *   where: {
     *     // ... filter to delete one AdvanceNotice
     *   }
     * })
     * 
     */
    delete<T extends AdvanceNoticeDeleteArgs>(args: SelectSubset<T, AdvanceNoticeDeleteArgs<ExtArgs>>): Prisma__AdvanceNoticeClient<$Result.GetResult<Prisma.$AdvanceNoticePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdvanceNotice.
     * @param {AdvanceNoticeUpdateArgs} args - Arguments to update one AdvanceNotice.
     * @example
     * // Update one AdvanceNotice
     * const advanceNotice = await prisma.advanceNotice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdvanceNoticeUpdateArgs>(args: SelectSubset<T, AdvanceNoticeUpdateArgs<ExtArgs>>): Prisma__AdvanceNoticeClient<$Result.GetResult<Prisma.$AdvanceNoticePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdvanceNotices.
     * @param {AdvanceNoticeDeleteManyArgs} args - Arguments to filter AdvanceNotices to delete.
     * @example
     * // Delete a few AdvanceNotices
     * const { count } = await prisma.advanceNotice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdvanceNoticeDeleteManyArgs>(args?: SelectSubset<T, AdvanceNoticeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdvanceNotices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceNoticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdvanceNotices
     * const advanceNotice = await prisma.advanceNotice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdvanceNoticeUpdateManyArgs>(args: SelectSubset<T, AdvanceNoticeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdvanceNotice.
     * @param {AdvanceNoticeUpsertArgs} args - Arguments to update or create a AdvanceNotice.
     * @example
     * // Update or create a AdvanceNotice
     * const advanceNotice = await prisma.advanceNotice.upsert({
     *   create: {
     *     // ... data to create a AdvanceNotice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdvanceNotice we want to update
     *   }
     * })
     */
    upsert<T extends AdvanceNoticeUpsertArgs>(args: SelectSubset<T, AdvanceNoticeUpsertArgs<ExtArgs>>): Prisma__AdvanceNoticeClient<$Result.GetResult<Prisma.$AdvanceNoticePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdvanceNotices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceNoticeCountArgs} args - Arguments to filter AdvanceNotices to count.
     * @example
     * // Count the number of AdvanceNotices
     * const count = await prisma.advanceNotice.count({
     *   where: {
     *     // ... the filter for the AdvanceNotices we want to count
     *   }
     * })
    **/
    count<T extends AdvanceNoticeCountArgs>(
      args?: Subset<T, AdvanceNoticeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvanceNoticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdvanceNotice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceNoticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvanceNoticeAggregateArgs>(args: Subset<T, AdvanceNoticeAggregateArgs>): Prisma.PrismaPromise<GetAdvanceNoticeAggregateType<T>>

    /**
     * Group by AdvanceNotice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceNoticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvanceNoticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvanceNoticeGroupByArgs['orderBy'] }
        : { orderBy?: AdvanceNoticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvanceNoticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvanceNoticeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdvanceNotice model
   */
  readonly fields: AdvanceNoticeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdvanceNotice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvanceNoticeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdvanceNotice model
   */ 
  interface AdvanceNoticeFieldRefs {
    readonly AdvanceNoticeID: FieldRef<"AdvanceNotice", 'Int'>
    readonly StartPeriod: FieldRef<"AdvanceNotice", 'Float'>
    readonly EndPeriod: FieldRef<"AdvanceNotice", 'Float'>
    readonly DaysOfNotice: FieldRef<"AdvanceNotice", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * AdvanceNotice findUnique
   */
  export type AdvanceNoticeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceNotice
     */
    select?: AdvanceNoticeSelect<ExtArgs> | null
    /**
     * Filter, which AdvanceNotice to fetch.
     */
    where: AdvanceNoticeWhereUniqueInput
  }

  /**
   * AdvanceNotice findUniqueOrThrow
   */
  export type AdvanceNoticeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceNotice
     */
    select?: AdvanceNoticeSelect<ExtArgs> | null
    /**
     * Filter, which AdvanceNotice to fetch.
     */
    where: AdvanceNoticeWhereUniqueInput
  }

  /**
   * AdvanceNotice findFirst
   */
  export type AdvanceNoticeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceNotice
     */
    select?: AdvanceNoticeSelect<ExtArgs> | null
    /**
     * Filter, which AdvanceNotice to fetch.
     */
    where?: AdvanceNoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvanceNotices to fetch.
     */
    orderBy?: AdvanceNoticeOrderByWithRelationInput | AdvanceNoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvanceNotices.
     */
    cursor?: AdvanceNoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvanceNotices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvanceNotices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvanceNotices.
     */
    distinct?: AdvanceNoticeScalarFieldEnum | AdvanceNoticeScalarFieldEnum[]
  }

  /**
   * AdvanceNotice findFirstOrThrow
   */
  export type AdvanceNoticeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceNotice
     */
    select?: AdvanceNoticeSelect<ExtArgs> | null
    /**
     * Filter, which AdvanceNotice to fetch.
     */
    where?: AdvanceNoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvanceNotices to fetch.
     */
    orderBy?: AdvanceNoticeOrderByWithRelationInput | AdvanceNoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvanceNotices.
     */
    cursor?: AdvanceNoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvanceNotices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvanceNotices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvanceNotices.
     */
    distinct?: AdvanceNoticeScalarFieldEnum | AdvanceNoticeScalarFieldEnum[]
  }

  /**
   * AdvanceNotice findMany
   */
  export type AdvanceNoticeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceNotice
     */
    select?: AdvanceNoticeSelect<ExtArgs> | null
    /**
     * Filter, which AdvanceNotices to fetch.
     */
    where?: AdvanceNoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvanceNotices to fetch.
     */
    orderBy?: AdvanceNoticeOrderByWithRelationInput | AdvanceNoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdvanceNotices.
     */
    cursor?: AdvanceNoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvanceNotices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvanceNotices.
     */
    skip?: number
    distinct?: AdvanceNoticeScalarFieldEnum | AdvanceNoticeScalarFieldEnum[]
  }

  /**
   * AdvanceNotice create
   */
  export type AdvanceNoticeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceNotice
     */
    select?: AdvanceNoticeSelect<ExtArgs> | null
    /**
     * The data needed to create a AdvanceNotice.
     */
    data?: XOR<AdvanceNoticeCreateInput, AdvanceNoticeUncheckedCreateInput>
  }

  /**
   * AdvanceNotice createMany
   */
  export type AdvanceNoticeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdvanceNotices.
     */
    data: AdvanceNoticeCreateManyInput | AdvanceNoticeCreateManyInput[]
  }

  /**
   * AdvanceNotice update
   */
  export type AdvanceNoticeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceNotice
     */
    select?: AdvanceNoticeSelect<ExtArgs> | null
    /**
     * The data needed to update a AdvanceNotice.
     */
    data: XOR<AdvanceNoticeUpdateInput, AdvanceNoticeUncheckedUpdateInput>
    /**
     * Choose, which AdvanceNotice to update.
     */
    where: AdvanceNoticeWhereUniqueInput
  }

  /**
   * AdvanceNotice updateMany
   */
  export type AdvanceNoticeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdvanceNotices.
     */
    data: XOR<AdvanceNoticeUpdateManyMutationInput, AdvanceNoticeUncheckedUpdateManyInput>
    /**
     * Filter which AdvanceNotices to update
     */
    where?: AdvanceNoticeWhereInput
  }

  /**
   * AdvanceNotice upsert
   */
  export type AdvanceNoticeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceNotice
     */
    select?: AdvanceNoticeSelect<ExtArgs> | null
    /**
     * The filter to search for the AdvanceNotice to update in case it exists.
     */
    where: AdvanceNoticeWhereUniqueInput
    /**
     * In case the AdvanceNotice found by the `where` argument doesn't exist, create a new AdvanceNotice with this data.
     */
    create: XOR<AdvanceNoticeCreateInput, AdvanceNoticeUncheckedCreateInput>
    /**
     * In case the AdvanceNotice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvanceNoticeUpdateInput, AdvanceNoticeUncheckedUpdateInput>
  }

  /**
   * AdvanceNotice delete
   */
  export type AdvanceNoticeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceNotice
     */
    select?: AdvanceNoticeSelect<ExtArgs> | null
    /**
     * Filter which AdvanceNotice to delete.
     */
    where: AdvanceNoticeWhereUniqueInput
  }

  /**
   * AdvanceNotice deleteMany
   */
  export type AdvanceNoticeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvanceNotices to delete
     */
    where?: AdvanceNoticeWhereInput
  }

  /**
   * AdvanceNotice without action
   */
  export type AdvanceNoticeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvanceNotice
     */
    select?: AdvanceNoticeSelect<ExtArgs> | null
  }


  /**
   * Model AutoWordReport
   */

  export type AggregateAutoWordReport = {
    _count: AutoWordReportCountAggregateOutputType | null
    _avg: AutoWordReportAvgAggregateOutputType | null
    _sum: AutoWordReportSumAggregateOutputType | null
    _min: AutoWordReportMinAggregateOutputType | null
    _max: AutoWordReportMaxAggregateOutputType | null
  }

  export type AutoWordReportAvgAggregateOutputType = {
    ReportID: number | null
    SaveInArchive: number | null
  }

  export type AutoWordReportSumAggregateOutputType = {
    ReportID: number | null
    SaveInArchive: number | null
  }

  export type AutoWordReportMinAggregateOutputType = {
    ReportID: number | null
    ReportName: string | null
    ReportTemplateName: string | null
    IsEmployee: boolean | null
    IsCustomer: boolean | null
    StrSQL: string | null
    IsChossCustomerOrEmployee: boolean | null
    SaveInArchive: number | null
    IsView: boolean | null
  }

  export type AutoWordReportMaxAggregateOutputType = {
    ReportID: number | null
    ReportName: string | null
    ReportTemplateName: string | null
    IsEmployee: boolean | null
    IsCustomer: boolean | null
    StrSQL: string | null
    IsChossCustomerOrEmployee: boolean | null
    SaveInArchive: number | null
    IsView: boolean | null
  }

  export type AutoWordReportCountAggregateOutputType = {
    ReportID: number
    ReportName: number
    ReportTemplateName: number
    IsEmployee: number
    IsCustomer: number
    StrSQL: number
    IsChossCustomerOrEmployee: number
    SaveInArchive: number
    IsView: number
    _all: number
  }


  export type AutoWordReportAvgAggregateInputType = {
    ReportID?: true
    SaveInArchive?: true
  }

  export type AutoWordReportSumAggregateInputType = {
    ReportID?: true
    SaveInArchive?: true
  }

  export type AutoWordReportMinAggregateInputType = {
    ReportID?: true
    ReportName?: true
    ReportTemplateName?: true
    IsEmployee?: true
    IsCustomer?: true
    StrSQL?: true
    IsChossCustomerOrEmployee?: true
    SaveInArchive?: true
    IsView?: true
  }

  export type AutoWordReportMaxAggregateInputType = {
    ReportID?: true
    ReportName?: true
    ReportTemplateName?: true
    IsEmployee?: true
    IsCustomer?: true
    StrSQL?: true
    IsChossCustomerOrEmployee?: true
    SaveInArchive?: true
    IsView?: true
  }

  export type AutoWordReportCountAggregateInputType = {
    ReportID?: true
    ReportName?: true
    ReportTemplateName?: true
    IsEmployee?: true
    IsCustomer?: true
    StrSQL?: true
    IsChossCustomerOrEmployee?: true
    SaveInArchive?: true
    IsView?: true
    _all?: true
  }

  export type AutoWordReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoWordReport to aggregate.
     */
    where?: AutoWordReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoWordReports to fetch.
     */
    orderBy?: AutoWordReportOrderByWithRelationInput | AutoWordReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoWordReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoWordReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoWordReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoWordReports
    **/
    _count?: true | AutoWordReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutoWordReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutoWordReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoWordReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoWordReportMaxAggregateInputType
  }

  export type GetAutoWordReportAggregateType<T extends AutoWordReportAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoWordReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoWordReport[P]>
      : GetScalarType<T[P], AggregateAutoWordReport[P]>
  }




  export type AutoWordReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoWordReportWhereInput
    orderBy?: AutoWordReportOrderByWithAggregationInput | AutoWordReportOrderByWithAggregationInput[]
    by: AutoWordReportScalarFieldEnum[] | AutoWordReportScalarFieldEnum
    having?: AutoWordReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoWordReportCountAggregateInputType | true
    _avg?: AutoWordReportAvgAggregateInputType
    _sum?: AutoWordReportSumAggregateInputType
    _min?: AutoWordReportMinAggregateInputType
    _max?: AutoWordReportMaxAggregateInputType
  }

  export type AutoWordReportGroupByOutputType = {
    ReportID: number
    ReportName: string | null
    ReportTemplateName: string | null
    IsEmployee: boolean
    IsCustomer: boolean
    StrSQL: string | null
    IsChossCustomerOrEmployee: boolean
    SaveInArchive: number | null
    IsView: boolean
    _count: AutoWordReportCountAggregateOutputType | null
    _avg: AutoWordReportAvgAggregateOutputType | null
    _sum: AutoWordReportSumAggregateOutputType | null
    _min: AutoWordReportMinAggregateOutputType | null
    _max: AutoWordReportMaxAggregateOutputType | null
  }

  type GetAutoWordReportGroupByPayload<T extends AutoWordReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoWordReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoWordReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoWordReportGroupByOutputType[P]>
            : GetScalarType<T[P], AutoWordReportGroupByOutputType[P]>
        }
      >
    >


  export type AutoWordReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ReportID?: boolean
    ReportName?: boolean
    ReportTemplateName?: boolean
    IsEmployee?: boolean
    IsCustomer?: boolean
    StrSQL?: boolean
    IsChossCustomerOrEmployee?: boolean
    SaveInArchive?: boolean
    IsView?: boolean
    AutoWordReportSub?: boolean | AutoWordReport$AutoWordReportSubArgs<ExtArgs>
    _count?: boolean | AutoWordReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoWordReport"]>


  export type AutoWordReportSelectScalar = {
    ReportID?: boolean
    ReportName?: boolean
    ReportTemplateName?: boolean
    IsEmployee?: boolean
    IsCustomer?: boolean
    StrSQL?: boolean
    IsChossCustomerOrEmployee?: boolean
    SaveInArchive?: boolean
    IsView?: boolean
  }

  export type AutoWordReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AutoWordReportSub?: boolean | AutoWordReport$AutoWordReportSubArgs<ExtArgs>
    _count?: boolean | AutoWordReportCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AutoWordReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoWordReport"
    objects: {
      AutoWordReportSub: Prisma.$AutoWordReportSubPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ReportID: number
      ReportName: string | null
      ReportTemplateName: string | null
      IsEmployee: boolean
      IsCustomer: boolean
      StrSQL: string | null
      IsChossCustomerOrEmployee: boolean
      SaveInArchive: number | null
      IsView: boolean
    }, ExtArgs["result"]["autoWordReport"]>
    composites: {}
  }

  type AutoWordReportGetPayload<S extends boolean | null | undefined | AutoWordReportDefaultArgs> = $Result.GetResult<Prisma.$AutoWordReportPayload, S>

  type AutoWordReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutoWordReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutoWordReportCountAggregateInputType | true
    }

  export interface AutoWordReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoWordReport'], meta: { name: 'AutoWordReport' } }
    /**
     * Find zero or one AutoWordReport that matches the filter.
     * @param {AutoWordReportFindUniqueArgs} args - Arguments to find a AutoWordReport
     * @example
     * // Get one AutoWordReport
     * const autoWordReport = await prisma.autoWordReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoWordReportFindUniqueArgs>(args: SelectSubset<T, AutoWordReportFindUniqueArgs<ExtArgs>>): Prisma__AutoWordReportClient<$Result.GetResult<Prisma.$AutoWordReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutoWordReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutoWordReportFindUniqueOrThrowArgs} args - Arguments to find a AutoWordReport
     * @example
     * // Get one AutoWordReport
     * const autoWordReport = await prisma.autoWordReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoWordReportFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoWordReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoWordReportClient<$Result.GetResult<Prisma.$AutoWordReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutoWordReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportFindFirstArgs} args - Arguments to find a AutoWordReport
     * @example
     * // Get one AutoWordReport
     * const autoWordReport = await prisma.autoWordReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoWordReportFindFirstArgs>(args?: SelectSubset<T, AutoWordReportFindFirstArgs<ExtArgs>>): Prisma__AutoWordReportClient<$Result.GetResult<Prisma.$AutoWordReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutoWordReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportFindFirstOrThrowArgs} args - Arguments to find a AutoWordReport
     * @example
     * // Get one AutoWordReport
     * const autoWordReport = await prisma.autoWordReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoWordReportFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoWordReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoWordReportClient<$Result.GetResult<Prisma.$AutoWordReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutoWordReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoWordReports
     * const autoWordReports = await prisma.autoWordReport.findMany()
     * 
     * // Get first 10 AutoWordReports
     * const autoWordReports = await prisma.autoWordReport.findMany({ take: 10 })
     * 
     * // Only select the `ReportID`
     * const autoWordReportWithReportIDOnly = await prisma.autoWordReport.findMany({ select: { ReportID: true } })
     * 
     */
    findMany<T extends AutoWordReportFindManyArgs>(args?: SelectSubset<T, AutoWordReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoWordReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutoWordReport.
     * @param {AutoWordReportCreateArgs} args - Arguments to create a AutoWordReport.
     * @example
     * // Create one AutoWordReport
     * const AutoWordReport = await prisma.autoWordReport.create({
     *   data: {
     *     // ... data to create a AutoWordReport
     *   }
     * })
     * 
     */
    create<T extends AutoWordReportCreateArgs>(args: SelectSubset<T, AutoWordReportCreateArgs<ExtArgs>>): Prisma__AutoWordReportClient<$Result.GetResult<Prisma.$AutoWordReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutoWordReports.
     * @param {AutoWordReportCreateManyArgs} args - Arguments to create many AutoWordReports.
     * @example
     * // Create many AutoWordReports
     * const autoWordReport = await prisma.autoWordReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoWordReportCreateManyArgs>(args?: SelectSubset<T, AutoWordReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AutoWordReport.
     * @param {AutoWordReportDeleteArgs} args - Arguments to delete one AutoWordReport.
     * @example
     * // Delete one AutoWordReport
     * const AutoWordReport = await prisma.autoWordReport.delete({
     *   where: {
     *     // ... filter to delete one AutoWordReport
     *   }
     * })
     * 
     */
    delete<T extends AutoWordReportDeleteArgs>(args: SelectSubset<T, AutoWordReportDeleteArgs<ExtArgs>>): Prisma__AutoWordReportClient<$Result.GetResult<Prisma.$AutoWordReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutoWordReport.
     * @param {AutoWordReportUpdateArgs} args - Arguments to update one AutoWordReport.
     * @example
     * // Update one AutoWordReport
     * const autoWordReport = await prisma.autoWordReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoWordReportUpdateArgs>(args: SelectSubset<T, AutoWordReportUpdateArgs<ExtArgs>>): Prisma__AutoWordReportClient<$Result.GetResult<Prisma.$AutoWordReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutoWordReports.
     * @param {AutoWordReportDeleteManyArgs} args - Arguments to filter AutoWordReports to delete.
     * @example
     * // Delete a few AutoWordReports
     * const { count } = await prisma.autoWordReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoWordReportDeleteManyArgs>(args?: SelectSubset<T, AutoWordReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoWordReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoWordReports
     * const autoWordReport = await prisma.autoWordReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoWordReportUpdateManyArgs>(args: SelectSubset<T, AutoWordReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoWordReport.
     * @param {AutoWordReportUpsertArgs} args - Arguments to update or create a AutoWordReport.
     * @example
     * // Update or create a AutoWordReport
     * const autoWordReport = await prisma.autoWordReport.upsert({
     *   create: {
     *     // ... data to create a AutoWordReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoWordReport we want to update
     *   }
     * })
     */
    upsert<T extends AutoWordReportUpsertArgs>(args: SelectSubset<T, AutoWordReportUpsertArgs<ExtArgs>>): Prisma__AutoWordReportClient<$Result.GetResult<Prisma.$AutoWordReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutoWordReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportCountArgs} args - Arguments to filter AutoWordReports to count.
     * @example
     * // Count the number of AutoWordReports
     * const count = await prisma.autoWordReport.count({
     *   where: {
     *     // ... the filter for the AutoWordReports we want to count
     *   }
     * })
    **/
    count<T extends AutoWordReportCountArgs>(
      args?: Subset<T, AutoWordReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoWordReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoWordReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoWordReportAggregateArgs>(args: Subset<T, AutoWordReportAggregateArgs>): Prisma.PrismaPromise<GetAutoWordReportAggregateType<T>>

    /**
     * Group by AutoWordReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoWordReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoWordReportGroupByArgs['orderBy'] }
        : { orderBy?: AutoWordReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoWordReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoWordReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoWordReport model
   */
  readonly fields: AutoWordReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoWordReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoWordReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AutoWordReportSub<T extends AutoWordReport$AutoWordReportSubArgs<ExtArgs> = {}>(args?: Subset<T, AutoWordReport$AutoWordReportSubArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoWordReportSubPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoWordReport model
   */ 
  interface AutoWordReportFieldRefs {
    readonly ReportID: FieldRef<"AutoWordReport", 'Int'>
    readonly ReportName: FieldRef<"AutoWordReport", 'String'>
    readonly ReportTemplateName: FieldRef<"AutoWordReport", 'String'>
    readonly IsEmployee: FieldRef<"AutoWordReport", 'Boolean'>
    readonly IsCustomer: FieldRef<"AutoWordReport", 'Boolean'>
    readonly StrSQL: FieldRef<"AutoWordReport", 'String'>
    readonly IsChossCustomerOrEmployee: FieldRef<"AutoWordReport", 'Boolean'>
    readonly SaveInArchive: FieldRef<"AutoWordReport", 'Int'>
    readonly IsView: FieldRef<"AutoWordReport", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AutoWordReport findUnique
   */
  export type AutoWordReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReport
     */
    select?: AutoWordReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportInclude<ExtArgs> | null
    /**
     * Filter, which AutoWordReport to fetch.
     */
    where: AutoWordReportWhereUniqueInput
  }

  /**
   * AutoWordReport findUniqueOrThrow
   */
  export type AutoWordReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReport
     */
    select?: AutoWordReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportInclude<ExtArgs> | null
    /**
     * Filter, which AutoWordReport to fetch.
     */
    where: AutoWordReportWhereUniqueInput
  }

  /**
   * AutoWordReport findFirst
   */
  export type AutoWordReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReport
     */
    select?: AutoWordReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportInclude<ExtArgs> | null
    /**
     * Filter, which AutoWordReport to fetch.
     */
    where?: AutoWordReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoWordReports to fetch.
     */
    orderBy?: AutoWordReportOrderByWithRelationInput | AutoWordReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoWordReports.
     */
    cursor?: AutoWordReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoWordReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoWordReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoWordReports.
     */
    distinct?: AutoWordReportScalarFieldEnum | AutoWordReportScalarFieldEnum[]
  }

  /**
   * AutoWordReport findFirstOrThrow
   */
  export type AutoWordReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReport
     */
    select?: AutoWordReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportInclude<ExtArgs> | null
    /**
     * Filter, which AutoWordReport to fetch.
     */
    where?: AutoWordReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoWordReports to fetch.
     */
    orderBy?: AutoWordReportOrderByWithRelationInput | AutoWordReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoWordReports.
     */
    cursor?: AutoWordReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoWordReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoWordReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoWordReports.
     */
    distinct?: AutoWordReportScalarFieldEnum | AutoWordReportScalarFieldEnum[]
  }

  /**
   * AutoWordReport findMany
   */
  export type AutoWordReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReport
     */
    select?: AutoWordReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportInclude<ExtArgs> | null
    /**
     * Filter, which AutoWordReports to fetch.
     */
    where?: AutoWordReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoWordReports to fetch.
     */
    orderBy?: AutoWordReportOrderByWithRelationInput | AutoWordReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoWordReports.
     */
    cursor?: AutoWordReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoWordReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoWordReports.
     */
    skip?: number
    distinct?: AutoWordReportScalarFieldEnum | AutoWordReportScalarFieldEnum[]
  }

  /**
   * AutoWordReport create
   */
  export type AutoWordReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReport
     */
    select?: AutoWordReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportInclude<ExtArgs> | null
    /**
     * The data needed to create a AutoWordReport.
     */
    data: XOR<AutoWordReportCreateInput, AutoWordReportUncheckedCreateInput>
  }

  /**
   * AutoWordReport createMany
   */
  export type AutoWordReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoWordReports.
     */
    data: AutoWordReportCreateManyInput | AutoWordReportCreateManyInput[]
  }

  /**
   * AutoWordReport update
   */
  export type AutoWordReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReport
     */
    select?: AutoWordReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportInclude<ExtArgs> | null
    /**
     * The data needed to update a AutoWordReport.
     */
    data: XOR<AutoWordReportUpdateInput, AutoWordReportUncheckedUpdateInput>
    /**
     * Choose, which AutoWordReport to update.
     */
    where: AutoWordReportWhereUniqueInput
  }

  /**
   * AutoWordReport updateMany
   */
  export type AutoWordReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoWordReports.
     */
    data: XOR<AutoWordReportUpdateManyMutationInput, AutoWordReportUncheckedUpdateManyInput>
    /**
     * Filter which AutoWordReports to update
     */
    where?: AutoWordReportWhereInput
  }

  /**
   * AutoWordReport upsert
   */
  export type AutoWordReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReport
     */
    select?: AutoWordReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportInclude<ExtArgs> | null
    /**
     * The filter to search for the AutoWordReport to update in case it exists.
     */
    where: AutoWordReportWhereUniqueInput
    /**
     * In case the AutoWordReport found by the `where` argument doesn't exist, create a new AutoWordReport with this data.
     */
    create: XOR<AutoWordReportCreateInput, AutoWordReportUncheckedCreateInput>
    /**
     * In case the AutoWordReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoWordReportUpdateInput, AutoWordReportUncheckedUpdateInput>
  }

  /**
   * AutoWordReport delete
   */
  export type AutoWordReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReport
     */
    select?: AutoWordReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportInclude<ExtArgs> | null
    /**
     * Filter which AutoWordReport to delete.
     */
    where: AutoWordReportWhereUniqueInput
  }

  /**
   * AutoWordReport deleteMany
   */
  export type AutoWordReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoWordReports to delete
     */
    where?: AutoWordReportWhereInput
  }

  /**
   * AutoWordReport.AutoWordReportSub
   */
  export type AutoWordReport$AutoWordReportSubArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReportSub
     */
    select?: AutoWordReportSubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportSubInclude<ExtArgs> | null
    where?: AutoWordReportSubWhereInput
    orderBy?: AutoWordReportSubOrderByWithRelationInput | AutoWordReportSubOrderByWithRelationInput[]
    cursor?: AutoWordReportSubWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoWordReportSubScalarFieldEnum | AutoWordReportSubScalarFieldEnum[]
  }

  /**
   * AutoWordReport without action
   */
  export type AutoWordReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReport
     */
    select?: AutoWordReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportInclude<ExtArgs> | null
  }


  /**
   * Model AutoWordReportSub
   */

  export type AggregateAutoWordReportSub = {
    _count: AutoWordReportSubCountAggregateOutputType | null
    _avg: AutoWordReportSubAvgAggregateOutputType | null
    _sum: AutoWordReportSubSumAggregateOutputType | null
    _min: AutoWordReportSubMinAggregateOutputType | null
    _max: AutoWordReportSubMaxAggregateOutputType | null
  }

  export type AutoWordReportSubAvgAggregateOutputType = {
    ReportSubID: number | null
    ReportID: number | null
  }

  export type AutoWordReportSubSumAggregateOutputType = {
    ReportSubID: number | null
    ReportID: number | null
  }

  export type AutoWordReportSubMinAggregateOutputType = {
    ReportSubID: number | null
    ReportID: number | null
    FieldNameTB: string | null
    FieldNameReport: string | null
  }

  export type AutoWordReportSubMaxAggregateOutputType = {
    ReportSubID: number | null
    ReportID: number | null
    FieldNameTB: string | null
    FieldNameReport: string | null
  }

  export type AutoWordReportSubCountAggregateOutputType = {
    ReportSubID: number
    ReportID: number
    FieldNameTB: number
    FieldNameReport: number
    _all: number
  }


  export type AutoWordReportSubAvgAggregateInputType = {
    ReportSubID?: true
    ReportID?: true
  }

  export type AutoWordReportSubSumAggregateInputType = {
    ReportSubID?: true
    ReportID?: true
  }

  export type AutoWordReportSubMinAggregateInputType = {
    ReportSubID?: true
    ReportID?: true
    FieldNameTB?: true
    FieldNameReport?: true
  }

  export type AutoWordReportSubMaxAggregateInputType = {
    ReportSubID?: true
    ReportID?: true
    FieldNameTB?: true
    FieldNameReport?: true
  }

  export type AutoWordReportSubCountAggregateInputType = {
    ReportSubID?: true
    ReportID?: true
    FieldNameTB?: true
    FieldNameReport?: true
    _all?: true
  }

  export type AutoWordReportSubAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoWordReportSub to aggregate.
     */
    where?: AutoWordReportSubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoWordReportSubs to fetch.
     */
    orderBy?: AutoWordReportSubOrderByWithRelationInput | AutoWordReportSubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoWordReportSubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoWordReportSubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoWordReportSubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoWordReportSubs
    **/
    _count?: true | AutoWordReportSubCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutoWordReportSubAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutoWordReportSubSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoWordReportSubMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoWordReportSubMaxAggregateInputType
  }

  export type GetAutoWordReportSubAggregateType<T extends AutoWordReportSubAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoWordReportSub]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoWordReportSub[P]>
      : GetScalarType<T[P], AggregateAutoWordReportSub[P]>
  }




  export type AutoWordReportSubGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoWordReportSubWhereInput
    orderBy?: AutoWordReportSubOrderByWithAggregationInput | AutoWordReportSubOrderByWithAggregationInput[]
    by: AutoWordReportSubScalarFieldEnum[] | AutoWordReportSubScalarFieldEnum
    having?: AutoWordReportSubScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoWordReportSubCountAggregateInputType | true
    _avg?: AutoWordReportSubAvgAggregateInputType
    _sum?: AutoWordReportSubSumAggregateInputType
    _min?: AutoWordReportSubMinAggregateInputType
    _max?: AutoWordReportSubMaxAggregateInputType
  }

  export type AutoWordReportSubGroupByOutputType = {
    ReportSubID: number
    ReportID: number | null
    FieldNameTB: string | null
    FieldNameReport: string | null
    _count: AutoWordReportSubCountAggregateOutputType | null
    _avg: AutoWordReportSubAvgAggregateOutputType | null
    _sum: AutoWordReportSubSumAggregateOutputType | null
    _min: AutoWordReportSubMinAggregateOutputType | null
    _max: AutoWordReportSubMaxAggregateOutputType | null
  }

  type GetAutoWordReportSubGroupByPayload<T extends AutoWordReportSubGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoWordReportSubGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoWordReportSubGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoWordReportSubGroupByOutputType[P]>
            : GetScalarType<T[P], AutoWordReportSubGroupByOutputType[P]>
        }
      >
    >


  export type AutoWordReportSubSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ReportSubID?: boolean
    ReportID?: boolean
    FieldNameTB?: boolean
    FieldNameReport?: boolean
    AutoWordReport?: boolean | AutoWordReportSub$AutoWordReportArgs<ExtArgs>
  }, ExtArgs["result"]["autoWordReportSub"]>


  export type AutoWordReportSubSelectScalar = {
    ReportSubID?: boolean
    ReportID?: boolean
    FieldNameTB?: boolean
    FieldNameReport?: boolean
  }

  export type AutoWordReportSubInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AutoWordReport?: boolean | AutoWordReportSub$AutoWordReportArgs<ExtArgs>
  }

  export type $AutoWordReportSubPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoWordReportSub"
    objects: {
      AutoWordReport: Prisma.$AutoWordReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ReportSubID: number
      ReportID: number | null
      FieldNameTB: string | null
      FieldNameReport: string | null
    }, ExtArgs["result"]["autoWordReportSub"]>
    composites: {}
  }

  type AutoWordReportSubGetPayload<S extends boolean | null | undefined | AutoWordReportSubDefaultArgs> = $Result.GetResult<Prisma.$AutoWordReportSubPayload, S>

  type AutoWordReportSubCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutoWordReportSubFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutoWordReportSubCountAggregateInputType | true
    }

  export interface AutoWordReportSubDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoWordReportSub'], meta: { name: 'AutoWordReportSub' } }
    /**
     * Find zero or one AutoWordReportSub that matches the filter.
     * @param {AutoWordReportSubFindUniqueArgs} args - Arguments to find a AutoWordReportSub
     * @example
     * // Get one AutoWordReportSub
     * const autoWordReportSub = await prisma.autoWordReportSub.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoWordReportSubFindUniqueArgs>(args: SelectSubset<T, AutoWordReportSubFindUniqueArgs<ExtArgs>>): Prisma__AutoWordReportSubClient<$Result.GetResult<Prisma.$AutoWordReportSubPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutoWordReportSub that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutoWordReportSubFindUniqueOrThrowArgs} args - Arguments to find a AutoWordReportSub
     * @example
     * // Get one AutoWordReportSub
     * const autoWordReportSub = await prisma.autoWordReportSub.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoWordReportSubFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoWordReportSubFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoWordReportSubClient<$Result.GetResult<Prisma.$AutoWordReportSubPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutoWordReportSub that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportSubFindFirstArgs} args - Arguments to find a AutoWordReportSub
     * @example
     * // Get one AutoWordReportSub
     * const autoWordReportSub = await prisma.autoWordReportSub.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoWordReportSubFindFirstArgs>(args?: SelectSubset<T, AutoWordReportSubFindFirstArgs<ExtArgs>>): Prisma__AutoWordReportSubClient<$Result.GetResult<Prisma.$AutoWordReportSubPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutoWordReportSub that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportSubFindFirstOrThrowArgs} args - Arguments to find a AutoWordReportSub
     * @example
     * // Get one AutoWordReportSub
     * const autoWordReportSub = await prisma.autoWordReportSub.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoWordReportSubFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoWordReportSubFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoWordReportSubClient<$Result.GetResult<Prisma.$AutoWordReportSubPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutoWordReportSubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportSubFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoWordReportSubs
     * const autoWordReportSubs = await prisma.autoWordReportSub.findMany()
     * 
     * // Get first 10 AutoWordReportSubs
     * const autoWordReportSubs = await prisma.autoWordReportSub.findMany({ take: 10 })
     * 
     * // Only select the `ReportSubID`
     * const autoWordReportSubWithReportSubIDOnly = await prisma.autoWordReportSub.findMany({ select: { ReportSubID: true } })
     * 
     */
    findMany<T extends AutoWordReportSubFindManyArgs>(args?: SelectSubset<T, AutoWordReportSubFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoWordReportSubPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutoWordReportSub.
     * @param {AutoWordReportSubCreateArgs} args - Arguments to create a AutoWordReportSub.
     * @example
     * // Create one AutoWordReportSub
     * const AutoWordReportSub = await prisma.autoWordReportSub.create({
     *   data: {
     *     // ... data to create a AutoWordReportSub
     *   }
     * })
     * 
     */
    create<T extends AutoWordReportSubCreateArgs>(args: SelectSubset<T, AutoWordReportSubCreateArgs<ExtArgs>>): Prisma__AutoWordReportSubClient<$Result.GetResult<Prisma.$AutoWordReportSubPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutoWordReportSubs.
     * @param {AutoWordReportSubCreateManyArgs} args - Arguments to create many AutoWordReportSubs.
     * @example
     * // Create many AutoWordReportSubs
     * const autoWordReportSub = await prisma.autoWordReportSub.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoWordReportSubCreateManyArgs>(args?: SelectSubset<T, AutoWordReportSubCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AutoWordReportSub.
     * @param {AutoWordReportSubDeleteArgs} args - Arguments to delete one AutoWordReportSub.
     * @example
     * // Delete one AutoWordReportSub
     * const AutoWordReportSub = await prisma.autoWordReportSub.delete({
     *   where: {
     *     // ... filter to delete one AutoWordReportSub
     *   }
     * })
     * 
     */
    delete<T extends AutoWordReportSubDeleteArgs>(args: SelectSubset<T, AutoWordReportSubDeleteArgs<ExtArgs>>): Prisma__AutoWordReportSubClient<$Result.GetResult<Prisma.$AutoWordReportSubPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutoWordReportSub.
     * @param {AutoWordReportSubUpdateArgs} args - Arguments to update one AutoWordReportSub.
     * @example
     * // Update one AutoWordReportSub
     * const autoWordReportSub = await prisma.autoWordReportSub.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoWordReportSubUpdateArgs>(args: SelectSubset<T, AutoWordReportSubUpdateArgs<ExtArgs>>): Prisma__AutoWordReportSubClient<$Result.GetResult<Prisma.$AutoWordReportSubPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutoWordReportSubs.
     * @param {AutoWordReportSubDeleteManyArgs} args - Arguments to filter AutoWordReportSubs to delete.
     * @example
     * // Delete a few AutoWordReportSubs
     * const { count } = await prisma.autoWordReportSub.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoWordReportSubDeleteManyArgs>(args?: SelectSubset<T, AutoWordReportSubDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoWordReportSubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportSubUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoWordReportSubs
     * const autoWordReportSub = await prisma.autoWordReportSub.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoWordReportSubUpdateManyArgs>(args: SelectSubset<T, AutoWordReportSubUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoWordReportSub.
     * @param {AutoWordReportSubUpsertArgs} args - Arguments to update or create a AutoWordReportSub.
     * @example
     * // Update or create a AutoWordReportSub
     * const autoWordReportSub = await prisma.autoWordReportSub.upsert({
     *   create: {
     *     // ... data to create a AutoWordReportSub
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoWordReportSub we want to update
     *   }
     * })
     */
    upsert<T extends AutoWordReportSubUpsertArgs>(args: SelectSubset<T, AutoWordReportSubUpsertArgs<ExtArgs>>): Prisma__AutoWordReportSubClient<$Result.GetResult<Prisma.$AutoWordReportSubPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutoWordReportSubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportSubCountArgs} args - Arguments to filter AutoWordReportSubs to count.
     * @example
     * // Count the number of AutoWordReportSubs
     * const count = await prisma.autoWordReportSub.count({
     *   where: {
     *     // ... the filter for the AutoWordReportSubs we want to count
     *   }
     * })
    **/
    count<T extends AutoWordReportSubCountArgs>(
      args?: Subset<T, AutoWordReportSubCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoWordReportSubCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoWordReportSub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportSubAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoWordReportSubAggregateArgs>(args: Subset<T, AutoWordReportSubAggregateArgs>): Prisma.PrismaPromise<GetAutoWordReportSubAggregateType<T>>

    /**
     * Group by AutoWordReportSub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoWordReportSubGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoWordReportSubGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoWordReportSubGroupByArgs['orderBy'] }
        : { orderBy?: AutoWordReportSubGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoWordReportSubGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoWordReportSubGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoWordReportSub model
   */
  readonly fields: AutoWordReportSubFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoWordReportSub.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoWordReportSubClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AutoWordReport<T extends AutoWordReportSub$AutoWordReportArgs<ExtArgs> = {}>(args?: Subset<T, AutoWordReportSub$AutoWordReportArgs<ExtArgs>>): Prisma__AutoWordReportClient<$Result.GetResult<Prisma.$AutoWordReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoWordReportSub model
   */ 
  interface AutoWordReportSubFieldRefs {
    readonly ReportSubID: FieldRef<"AutoWordReportSub", 'Int'>
    readonly ReportID: FieldRef<"AutoWordReportSub", 'Int'>
    readonly FieldNameTB: FieldRef<"AutoWordReportSub", 'String'>
    readonly FieldNameReport: FieldRef<"AutoWordReportSub", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AutoWordReportSub findUnique
   */
  export type AutoWordReportSubFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReportSub
     */
    select?: AutoWordReportSubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportSubInclude<ExtArgs> | null
    /**
     * Filter, which AutoWordReportSub to fetch.
     */
    where: AutoWordReportSubWhereUniqueInput
  }

  /**
   * AutoWordReportSub findUniqueOrThrow
   */
  export type AutoWordReportSubFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReportSub
     */
    select?: AutoWordReportSubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportSubInclude<ExtArgs> | null
    /**
     * Filter, which AutoWordReportSub to fetch.
     */
    where: AutoWordReportSubWhereUniqueInput
  }

  /**
   * AutoWordReportSub findFirst
   */
  export type AutoWordReportSubFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReportSub
     */
    select?: AutoWordReportSubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportSubInclude<ExtArgs> | null
    /**
     * Filter, which AutoWordReportSub to fetch.
     */
    where?: AutoWordReportSubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoWordReportSubs to fetch.
     */
    orderBy?: AutoWordReportSubOrderByWithRelationInput | AutoWordReportSubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoWordReportSubs.
     */
    cursor?: AutoWordReportSubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoWordReportSubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoWordReportSubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoWordReportSubs.
     */
    distinct?: AutoWordReportSubScalarFieldEnum | AutoWordReportSubScalarFieldEnum[]
  }

  /**
   * AutoWordReportSub findFirstOrThrow
   */
  export type AutoWordReportSubFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReportSub
     */
    select?: AutoWordReportSubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportSubInclude<ExtArgs> | null
    /**
     * Filter, which AutoWordReportSub to fetch.
     */
    where?: AutoWordReportSubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoWordReportSubs to fetch.
     */
    orderBy?: AutoWordReportSubOrderByWithRelationInput | AutoWordReportSubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoWordReportSubs.
     */
    cursor?: AutoWordReportSubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoWordReportSubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoWordReportSubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoWordReportSubs.
     */
    distinct?: AutoWordReportSubScalarFieldEnum | AutoWordReportSubScalarFieldEnum[]
  }

  /**
   * AutoWordReportSub findMany
   */
  export type AutoWordReportSubFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReportSub
     */
    select?: AutoWordReportSubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportSubInclude<ExtArgs> | null
    /**
     * Filter, which AutoWordReportSubs to fetch.
     */
    where?: AutoWordReportSubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoWordReportSubs to fetch.
     */
    orderBy?: AutoWordReportSubOrderByWithRelationInput | AutoWordReportSubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoWordReportSubs.
     */
    cursor?: AutoWordReportSubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoWordReportSubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoWordReportSubs.
     */
    skip?: number
    distinct?: AutoWordReportSubScalarFieldEnum | AutoWordReportSubScalarFieldEnum[]
  }

  /**
   * AutoWordReportSub create
   */
  export type AutoWordReportSubCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReportSub
     */
    select?: AutoWordReportSubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportSubInclude<ExtArgs> | null
    /**
     * The data needed to create a AutoWordReportSub.
     */
    data?: XOR<AutoWordReportSubCreateInput, AutoWordReportSubUncheckedCreateInput>
  }

  /**
   * AutoWordReportSub createMany
   */
  export type AutoWordReportSubCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoWordReportSubs.
     */
    data: AutoWordReportSubCreateManyInput | AutoWordReportSubCreateManyInput[]
  }

  /**
   * AutoWordReportSub update
   */
  export type AutoWordReportSubUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReportSub
     */
    select?: AutoWordReportSubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportSubInclude<ExtArgs> | null
    /**
     * The data needed to update a AutoWordReportSub.
     */
    data: XOR<AutoWordReportSubUpdateInput, AutoWordReportSubUncheckedUpdateInput>
    /**
     * Choose, which AutoWordReportSub to update.
     */
    where: AutoWordReportSubWhereUniqueInput
  }

  /**
   * AutoWordReportSub updateMany
   */
  export type AutoWordReportSubUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoWordReportSubs.
     */
    data: XOR<AutoWordReportSubUpdateManyMutationInput, AutoWordReportSubUncheckedUpdateManyInput>
    /**
     * Filter which AutoWordReportSubs to update
     */
    where?: AutoWordReportSubWhereInput
  }

  /**
   * AutoWordReportSub upsert
   */
  export type AutoWordReportSubUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReportSub
     */
    select?: AutoWordReportSubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportSubInclude<ExtArgs> | null
    /**
     * The filter to search for the AutoWordReportSub to update in case it exists.
     */
    where: AutoWordReportSubWhereUniqueInput
    /**
     * In case the AutoWordReportSub found by the `where` argument doesn't exist, create a new AutoWordReportSub with this data.
     */
    create: XOR<AutoWordReportSubCreateInput, AutoWordReportSubUncheckedCreateInput>
    /**
     * In case the AutoWordReportSub was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoWordReportSubUpdateInput, AutoWordReportSubUncheckedUpdateInput>
  }

  /**
   * AutoWordReportSub delete
   */
  export type AutoWordReportSubDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReportSub
     */
    select?: AutoWordReportSubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportSubInclude<ExtArgs> | null
    /**
     * Filter which AutoWordReportSub to delete.
     */
    where: AutoWordReportSubWhereUniqueInput
  }

  /**
   * AutoWordReportSub deleteMany
   */
  export type AutoWordReportSubDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoWordReportSubs to delete
     */
    where?: AutoWordReportSubWhereInput
  }

  /**
   * AutoWordReportSub.AutoWordReport
   */
  export type AutoWordReportSub$AutoWordReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReport
     */
    select?: AutoWordReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportInclude<ExtArgs> | null
    where?: AutoWordReportWhereInput
  }

  /**
   * AutoWordReportSub without action
   */
  export type AutoWordReportSubDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoWordReportSub
     */
    select?: AutoWordReportSubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoWordReportSubInclude<ExtArgs> | null
  }


  /**
   * Model ChangeHistory
   */

  export type AggregateChangeHistory = {
    _count: ChangeHistoryCountAggregateOutputType | null
    _avg: ChangeHistoryAvgAggregateOutputType | null
    _sum: ChangeHistorySumAggregateOutputType | null
    _min: ChangeHistoryMinAggregateOutputType | null
    _max: ChangeHistoryMaxAggregateOutputType | null
  }

  export type ChangeHistoryAvgAggregateOutputType = {
    ChangeHistoryID: number | null
  }

  export type ChangeHistorySumAggregateOutputType = {
    ChangeHistoryID: number | null
  }

  export type ChangeHistoryMinAggregateOutputType = {
    ChangeHistoryID: number | null
    Application_Name: string | null
    ChangeDate: Date | null
    Version_Number: string | null
    ChangeDescription: string | null
    ConvertDatabase: boolean | null
  }

  export type ChangeHistoryMaxAggregateOutputType = {
    ChangeHistoryID: number | null
    Application_Name: string | null
    ChangeDate: Date | null
    Version_Number: string | null
    ChangeDescription: string | null
    ConvertDatabase: boolean | null
  }

  export type ChangeHistoryCountAggregateOutputType = {
    ChangeHistoryID: number
    Application_Name: number
    ChangeDate: number
    Version_Number: number
    ChangeDescription: number
    ConvertDatabase: number
    _all: number
  }


  export type ChangeHistoryAvgAggregateInputType = {
    ChangeHistoryID?: true
  }

  export type ChangeHistorySumAggregateInputType = {
    ChangeHistoryID?: true
  }

  export type ChangeHistoryMinAggregateInputType = {
    ChangeHistoryID?: true
    Application_Name?: true
    ChangeDate?: true
    Version_Number?: true
    ChangeDescription?: true
    ConvertDatabase?: true
  }

  export type ChangeHistoryMaxAggregateInputType = {
    ChangeHistoryID?: true
    Application_Name?: true
    ChangeDate?: true
    Version_Number?: true
    ChangeDescription?: true
    ConvertDatabase?: true
  }

  export type ChangeHistoryCountAggregateInputType = {
    ChangeHistoryID?: true
    Application_Name?: true
    ChangeDate?: true
    Version_Number?: true
    ChangeDescription?: true
    ConvertDatabase?: true
    _all?: true
  }

  export type ChangeHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeHistory to aggregate.
     */
    where?: ChangeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeHistories to fetch.
     */
    orderBy?: ChangeHistoryOrderByWithRelationInput | ChangeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangeHistories
    **/
    _count?: true | ChangeHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChangeHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChangeHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangeHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangeHistoryMaxAggregateInputType
  }

  export type GetChangeHistoryAggregateType<T extends ChangeHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateChangeHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangeHistory[P]>
      : GetScalarType<T[P], AggregateChangeHistory[P]>
  }




  export type ChangeHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeHistoryWhereInput
    orderBy?: ChangeHistoryOrderByWithAggregationInput | ChangeHistoryOrderByWithAggregationInput[]
    by: ChangeHistoryScalarFieldEnum[] | ChangeHistoryScalarFieldEnum
    having?: ChangeHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangeHistoryCountAggregateInputType | true
    _avg?: ChangeHistoryAvgAggregateInputType
    _sum?: ChangeHistorySumAggregateInputType
    _min?: ChangeHistoryMinAggregateInputType
    _max?: ChangeHistoryMaxAggregateInputType
  }

  export type ChangeHistoryGroupByOutputType = {
    ChangeHistoryID: number
    Application_Name: string | null
    ChangeDate: Date | null
    Version_Number: string | null
    ChangeDescription: string | null
    ConvertDatabase: boolean
    _count: ChangeHistoryCountAggregateOutputType | null
    _avg: ChangeHistoryAvgAggregateOutputType | null
    _sum: ChangeHistorySumAggregateOutputType | null
    _min: ChangeHistoryMinAggregateOutputType | null
    _max: ChangeHistoryMaxAggregateOutputType | null
  }

  type GetChangeHistoryGroupByPayload<T extends ChangeHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangeHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangeHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangeHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ChangeHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ChangeHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ChangeHistoryID?: boolean
    Application_Name?: boolean
    ChangeDate?: boolean
    Version_Number?: boolean
    ChangeDescription?: boolean
    ConvertDatabase?: boolean
  }, ExtArgs["result"]["changeHistory"]>


  export type ChangeHistorySelectScalar = {
    ChangeHistoryID?: boolean
    Application_Name?: boolean
    ChangeDate?: boolean
    Version_Number?: boolean
    ChangeDescription?: boolean
    ConvertDatabase?: boolean
  }


  export type $ChangeHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChangeHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ChangeHistoryID: number
      Application_Name: string | null
      ChangeDate: Date | null
      Version_Number: string | null
      ChangeDescription: string | null
      ConvertDatabase: boolean
    }, ExtArgs["result"]["changeHistory"]>
    composites: {}
  }

  type ChangeHistoryGetPayload<S extends boolean | null | undefined | ChangeHistoryDefaultArgs> = $Result.GetResult<Prisma.$ChangeHistoryPayload, S>

  type ChangeHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChangeHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChangeHistoryCountAggregateInputType | true
    }

  export interface ChangeHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChangeHistory'], meta: { name: 'ChangeHistory' } }
    /**
     * Find zero or one ChangeHistory that matches the filter.
     * @param {ChangeHistoryFindUniqueArgs} args - Arguments to find a ChangeHistory
     * @example
     * // Get one ChangeHistory
     * const changeHistory = await prisma.changeHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChangeHistoryFindUniqueArgs>(args: SelectSubset<T, ChangeHistoryFindUniqueArgs<ExtArgs>>): Prisma__ChangeHistoryClient<$Result.GetResult<Prisma.$ChangeHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChangeHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChangeHistoryFindUniqueOrThrowArgs} args - Arguments to find a ChangeHistory
     * @example
     * // Get one ChangeHistory
     * const changeHistory = await prisma.changeHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChangeHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ChangeHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChangeHistoryClient<$Result.GetResult<Prisma.$ChangeHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChangeHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeHistoryFindFirstArgs} args - Arguments to find a ChangeHistory
     * @example
     * // Get one ChangeHistory
     * const changeHistory = await prisma.changeHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChangeHistoryFindFirstArgs>(args?: SelectSubset<T, ChangeHistoryFindFirstArgs<ExtArgs>>): Prisma__ChangeHistoryClient<$Result.GetResult<Prisma.$ChangeHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChangeHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeHistoryFindFirstOrThrowArgs} args - Arguments to find a ChangeHistory
     * @example
     * // Get one ChangeHistory
     * const changeHistory = await prisma.changeHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChangeHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ChangeHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChangeHistoryClient<$Result.GetResult<Prisma.$ChangeHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChangeHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangeHistories
     * const changeHistories = await prisma.changeHistory.findMany()
     * 
     * // Get first 10 ChangeHistories
     * const changeHistories = await prisma.changeHistory.findMany({ take: 10 })
     * 
     * // Only select the `ChangeHistoryID`
     * const changeHistoryWithChangeHistoryIDOnly = await prisma.changeHistory.findMany({ select: { ChangeHistoryID: true } })
     * 
     */
    findMany<T extends ChangeHistoryFindManyArgs>(args?: SelectSubset<T, ChangeHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChangeHistory.
     * @param {ChangeHistoryCreateArgs} args - Arguments to create a ChangeHistory.
     * @example
     * // Create one ChangeHistory
     * const ChangeHistory = await prisma.changeHistory.create({
     *   data: {
     *     // ... data to create a ChangeHistory
     *   }
     * })
     * 
     */
    create<T extends ChangeHistoryCreateArgs>(args: SelectSubset<T, ChangeHistoryCreateArgs<ExtArgs>>): Prisma__ChangeHistoryClient<$Result.GetResult<Prisma.$ChangeHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChangeHistories.
     * @param {ChangeHistoryCreateManyArgs} args - Arguments to create many ChangeHistories.
     * @example
     * // Create many ChangeHistories
     * const changeHistory = await prisma.changeHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChangeHistoryCreateManyArgs>(args?: SelectSubset<T, ChangeHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChangeHistory.
     * @param {ChangeHistoryDeleteArgs} args - Arguments to delete one ChangeHistory.
     * @example
     * // Delete one ChangeHistory
     * const ChangeHistory = await prisma.changeHistory.delete({
     *   where: {
     *     // ... filter to delete one ChangeHistory
     *   }
     * })
     * 
     */
    delete<T extends ChangeHistoryDeleteArgs>(args: SelectSubset<T, ChangeHistoryDeleteArgs<ExtArgs>>): Prisma__ChangeHistoryClient<$Result.GetResult<Prisma.$ChangeHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChangeHistory.
     * @param {ChangeHistoryUpdateArgs} args - Arguments to update one ChangeHistory.
     * @example
     * // Update one ChangeHistory
     * const changeHistory = await prisma.changeHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChangeHistoryUpdateArgs>(args: SelectSubset<T, ChangeHistoryUpdateArgs<ExtArgs>>): Prisma__ChangeHistoryClient<$Result.GetResult<Prisma.$ChangeHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChangeHistories.
     * @param {ChangeHistoryDeleteManyArgs} args - Arguments to filter ChangeHistories to delete.
     * @example
     * // Delete a few ChangeHistories
     * const { count } = await prisma.changeHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChangeHistoryDeleteManyArgs>(args?: SelectSubset<T, ChangeHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangeHistories
     * const changeHistory = await prisma.changeHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChangeHistoryUpdateManyArgs>(args: SelectSubset<T, ChangeHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChangeHistory.
     * @param {ChangeHistoryUpsertArgs} args - Arguments to update or create a ChangeHistory.
     * @example
     * // Update or create a ChangeHistory
     * const changeHistory = await prisma.changeHistory.upsert({
     *   create: {
     *     // ... data to create a ChangeHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangeHistory we want to update
     *   }
     * })
     */
    upsert<T extends ChangeHistoryUpsertArgs>(args: SelectSubset<T, ChangeHistoryUpsertArgs<ExtArgs>>): Prisma__ChangeHistoryClient<$Result.GetResult<Prisma.$ChangeHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChangeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeHistoryCountArgs} args - Arguments to filter ChangeHistories to count.
     * @example
     * // Count the number of ChangeHistories
     * const count = await prisma.changeHistory.count({
     *   where: {
     *     // ... the filter for the ChangeHistories we want to count
     *   }
     * })
    **/
    count<T extends ChangeHistoryCountArgs>(
      args?: Subset<T, ChangeHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangeHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangeHistoryAggregateArgs>(args: Subset<T, ChangeHistoryAggregateArgs>): Prisma.PrismaPromise<GetChangeHistoryAggregateType<T>>

    /**
     * Group by ChangeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangeHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangeHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ChangeHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangeHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangeHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChangeHistory model
   */
  readonly fields: ChangeHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangeHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangeHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChangeHistory model
   */ 
  interface ChangeHistoryFieldRefs {
    readonly ChangeHistoryID: FieldRef<"ChangeHistory", 'Int'>
    readonly Application_Name: FieldRef<"ChangeHistory", 'String'>
    readonly ChangeDate: FieldRef<"ChangeHistory", 'DateTime'>
    readonly Version_Number: FieldRef<"ChangeHistory", 'String'>
    readonly ChangeDescription: FieldRef<"ChangeHistory", 'String'>
    readonly ConvertDatabase: FieldRef<"ChangeHistory", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ChangeHistory findUnique
   */
  export type ChangeHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeHistory
     */
    select?: ChangeHistorySelect<ExtArgs> | null
    /**
     * Filter, which ChangeHistory to fetch.
     */
    where: ChangeHistoryWhereUniqueInput
  }

  /**
   * ChangeHistory findUniqueOrThrow
   */
  export type ChangeHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeHistory
     */
    select?: ChangeHistorySelect<ExtArgs> | null
    /**
     * Filter, which ChangeHistory to fetch.
     */
    where: ChangeHistoryWhereUniqueInput
  }

  /**
   * ChangeHistory findFirst
   */
  export type ChangeHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeHistory
     */
    select?: ChangeHistorySelect<ExtArgs> | null
    /**
     * Filter, which ChangeHistory to fetch.
     */
    where?: ChangeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeHistories to fetch.
     */
    orderBy?: ChangeHistoryOrderByWithRelationInput | ChangeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeHistories.
     */
    cursor?: ChangeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeHistories.
     */
    distinct?: ChangeHistoryScalarFieldEnum | ChangeHistoryScalarFieldEnum[]
  }

  /**
   * ChangeHistory findFirstOrThrow
   */
  export type ChangeHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeHistory
     */
    select?: ChangeHistorySelect<ExtArgs> | null
    /**
     * Filter, which ChangeHistory to fetch.
     */
    where?: ChangeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeHistories to fetch.
     */
    orderBy?: ChangeHistoryOrderByWithRelationInput | ChangeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeHistories.
     */
    cursor?: ChangeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeHistories.
     */
    distinct?: ChangeHistoryScalarFieldEnum | ChangeHistoryScalarFieldEnum[]
  }

  /**
   * ChangeHistory findMany
   */
  export type ChangeHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeHistory
     */
    select?: ChangeHistorySelect<ExtArgs> | null
    /**
     * Filter, which ChangeHistories to fetch.
     */
    where?: ChangeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeHistories to fetch.
     */
    orderBy?: ChangeHistoryOrderByWithRelationInput | ChangeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangeHistories.
     */
    cursor?: ChangeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeHistories.
     */
    skip?: number
    distinct?: ChangeHistoryScalarFieldEnum | ChangeHistoryScalarFieldEnum[]
  }

  /**
   * ChangeHistory create
   */
  export type ChangeHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeHistory
     */
    select?: ChangeHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a ChangeHistory.
     */
    data: XOR<ChangeHistoryCreateInput, ChangeHistoryUncheckedCreateInput>
  }

  /**
   * ChangeHistory createMany
   */
  export type ChangeHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChangeHistories.
     */
    data: ChangeHistoryCreateManyInput | ChangeHistoryCreateManyInput[]
  }

  /**
   * ChangeHistory update
   */
  export type ChangeHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeHistory
     */
    select?: ChangeHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a ChangeHistory.
     */
    data: XOR<ChangeHistoryUpdateInput, ChangeHistoryUncheckedUpdateInput>
    /**
     * Choose, which ChangeHistory to update.
     */
    where: ChangeHistoryWhereUniqueInput
  }

  /**
   * ChangeHistory updateMany
   */
  export type ChangeHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChangeHistories.
     */
    data: XOR<ChangeHistoryUpdateManyMutationInput, ChangeHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ChangeHistories to update
     */
    where?: ChangeHistoryWhereInput
  }

  /**
   * ChangeHistory upsert
   */
  export type ChangeHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeHistory
     */
    select?: ChangeHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the ChangeHistory to update in case it exists.
     */
    where: ChangeHistoryWhereUniqueInput
    /**
     * In case the ChangeHistory found by the `where` argument doesn't exist, create a new ChangeHistory with this data.
     */
    create: XOR<ChangeHistoryCreateInput, ChangeHistoryUncheckedCreateInput>
    /**
     * In case the ChangeHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangeHistoryUpdateInput, ChangeHistoryUncheckedUpdateInput>
  }

  /**
   * ChangeHistory delete
   */
  export type ChangeHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeHistory
     */
    select?: ChangeHistorySelect<ExtArgs> | null
    /**
     * Filter which ChangeHistory to delete.
     */
    where: ChangeHistoryWhereUniqueInput
  }

  /**
   * ChangeHistory deleteMany
   */
  export type ChangeHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeHistories to delete
     */
    where?: ChangeHistoryWhereInput
  }

  /**
   * ChangeHistory without action
   */
  export type ChangeHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeHistory
     */
    select?: ChangeHistorySelect<ExtArgs> | null
  }


  /**
   * Model CitysIncomeTaxDiscount
   */

  export type AggregateCitysIncomeTaxDiscount = {
    _count: CitysIncomeTaxDiscountCountAggregateOutputType | null
    _avg: CitysIncomeTaxDiscountAvgAggregateOutputType | null
    _sum: CitysIncomeTaxDiscountSumAggregateOutputType | null
    _min: CitysIncomeTaxDiscountMinAggregateOutputType | null
    _max: CitysIncomeTaxDiscountMaxAggregateOutputType | null
  }

  export type CitysIncomeTaxDiscountAvgAggregateOutputType = {
    ID: number | null
    Year: number | null
    GroupCode: number | null
    DiscountPercent: number | null
    MaximumIncome: number | null
    MaximumIncomePerMonth: number | null
  }

  export type CitysIncomeTaxDiscountSumAggregateOutputType = {
    ID: number | null
    Year: number | null
    GroupCode: number | null
    DiscountPercent: number | null
    MaximumIncome: number | null
    MaximumIncomePerMonth: number | null
  }

  export type CitysIncomeTaxDiscountMinAggregateOutputType = {
    ID: number | null
    Year: number | null
    GroupCode: number | null
    CityName: string | null
    DiscountPercent: number | null
    MaximumIncome: number | null
    MaximumIncomePerMonth: number | null
  }

  export type CitysIncomeTaxDiscountMaxAggregateOutputType = {
    ID: number | null
    Year: number | null
    GroupCode: number | null
    CityName: string | null
    DiscountPercent: number | null
    MaximumIncome: number | null
    MaximumIncomePerMonth: number | null
  }

  export type CitysIncomeTaxDiscountCountAggregateOutputType = {
    ID: number
    Year: number
    GroupCode: number
    CityName: number
    DiscountPercent: number
    MaximumIncome: number
    MaximumIncomePerMonth: number
    _all: number
  }


  export type CitysIncomeTaxDiscountAvgAggregateInputType = {
    ID?: true
    Year?: true
    GroupCode?: true
    DiscountPercent?: true
    MaximumIncome?: true
    MaximumIncomePerMonth?: true
  }

  export type CitysIncomeTaxDiscountSumAggregateInputType = {
    ID?: true
    Year?: true
    GroupCode?: true
    DiscountPercent?: true
    MaximumIncome?: true
    MaximumIncomePerMonth?: true
  }

  export type CitysIncomeTaxDiscountMinAggregateInputType = {
    ID?: true
    Year?: true
    GroupCode?: true
    CityName?: true
    DiscountPercent?: true
    MaximumIncome?: true
    MaximumIncomePerMonth?: true
  }

  export type CitysIncomeTaxDiscountMaxAggregateInputType = {
    ID?: true
    Year?: true
    GroupCode?: true
    CityName?: true
    DiscountPercent?: true
    MaximumIncome?: true
    MaximumIncomePerMonth?: true
  }

  export type CitysIncomeTaxDiscountCountAggregateInputType = {
    ID?: true
    Year?: true
    GroupCode?: true
    CityName?: true
    DiscountPercent?: true
    MaximumIncome?: true
    MaximumIncomePerMonth?: true
    _all?: true
  }

  export type CitysIncomeTaxDiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CitysIncomeTaxDiscount to aggregate.
     */
    where?: CitysIncomeTaxDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CitysIncomeTaxDiscounts to fetch.
     */
    orderBy?: CitysIncomeTaxDiscountOrderByWithRelationInput | CitysIncomeTaxDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CitysIncomeTaxDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CitysIncomeTaxDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CitysIncomeTaxDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CitysIncomeTaxDiscounts
    **/
    _count?: true | CitysIncomeTaxDiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CitysIncomeTaxDiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitysIncomeTaxDiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitysIncomeTaxDiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitysIncomeTaxDiscountMaxAggregateInputType
  }

  export type GetCitysIncomeTaxDiscountAggregateType<T extends CitysIncomeTaxDiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateCitysIncomeTaxDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCitysIncomeTaxDiscount[P]>
      : GetScalarType<T[P], AggregateCitysIncomeTaxDiscount[P]>
  }




  export type CitysIncomeTaxDiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitysIncomeTaxDiscountWhereInput
    orderBy?: CitysIncomeTaxDiscountOrderByWithAggregationInput | CitysIncomeTaxDiscountOrderByWithAggregationInput[]
    by: CitysIncomeTaxDiscountScalarFieldEnum[] | CitysIncomeTaxDiscountScalarFieldEnum
    having?: CitysIncomeTaxDiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitysIncomeTaxDiscountCountAggregateInputType | true
    _avg?: CitysIncomeTaxDiscountAvgAggregateInputType
    _sum?: CitysIncomeTaxDiscountSumAggregateInputType
    _min?: CitysIncomeTaxDiscountMinAggregateInputType
    _max?: CitysIncomeTaxDiscountMaxAggregateInputType
  }

  export type CitysIncomeTaxDiscountGroupByOutputType = {
    ID: number
    Year: number
    GroupCode: number
    CityName: string
    DiscountPercent: number | null
    MaximumIncome: number | null
    MaximumIncomePerMonth: number | null
    _count: CitysIncomeTaxDiscountCountAggregateOutputType | null
    _avg: CitysIncomeTaxDiscountAvgAggregateOutputType | null
    _sum: CitysIncomeTaxDiscountSumAggregateOutputType | null
    _min: CitysIncomeTaxDiscountMinAggregateOutputType | null
    _max: CitysIncomeTaxDiscountMaxAggregateOutputType | null
  }

  type GetCitysIncomeTaxDiscountGroupByPayload<T extends CitysIncomeTaxDiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CitysIncomeTaxDiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CitysIncomeTaxDiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CitysIncomeTaxDiscountGroupByOutputType[P]>
            : GetScalarType<T[P], CitysIncomeTaxDiscountGroupByOutputType[P]>
        }
      >
    >


  export type CitysIncomeTaxDiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Year?: boolean
    GroupCode?: boolean
    CityName?: boolean
    DiscountPercent?: boolean
    MaximumIncome?: boolean
    MaximumIncomePerMonth?: boolean
  }, ExtArgs["result"]["citysIncomeTaxDiscount"]>


  export type CitysIncomeTaxDiscountSelectScalar = {
    ID?: boolean
    Year?: boolean
    GroupCode?: boolean
    CityName?: boolean
    DiscountPercent?: boolean
    MaximumIncome?: boolean
    MaximumIncomePerMonth?: boolean
  }


  export type $CitysIncomeTaxDiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CitysIncomeTaxDiscount"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Year: number
      GroupCode: number
      CityName: string
      DiscountPercent: number | null
      MaximumIncome: number | null
      MaximumIncomePerMonth: number | null
    }, ExtArgs["result"]["citysIncomeTaxDiscount"]>
    composites: {}
  }

  type CitysIncomeTaxDiscountGetPayload<S extends boolean | null | undefined | CitysIncomeTaxDiscountDefaultArgs> = $Result.GetResult<Prisma.$CitysIncomeTaxDiscountPayload, S>

  type CitysIncomeTaxDiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CitysIncomeTaxDiscountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CitysIncomeTaxDiscountCountAggregateInputType | true
    }

  export interface CitysIncomeTaxDiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CitysIncomeTaxDiscount'], meta: { name: 'CitysIncomeTaxDiscount' } }
    /**
     * Find zero or one CitysIncomeTaxDiscount that matches the filter.
     * @param {CitysIncomeTaxDiscountFindUniqueArgs} args - Arguments to find a CitysIncomeTaxDiscount
     * @example
     * // Get one CitysIncomeTaxDiscount
     * const citysIncomeTaxDiscount = await prisma.citysIncomeTaxDiscount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CitysIncomeTaxDiscountFindUniqueArgs>(args: SelectSubset<T, CitysIncomeTaxDiscountFindUniqueArgs<ExtArgs>>): Prisma__CitysIncomeTaxDiscountClient<$Result.GetResult<Prisma.$CitysIncomeTaxDiscountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CitysIncomeTaxDiscount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CitysIncomeTaxDiscountFindUniqueOrThrowArgs} args - Arguments to find a CitysIncomeTaxDiscount
     * @example
     * // Get one CitysIncomeTaxDiscount
     * const citysIncomeTaxDiscount = await prisma.citysIncomeTaxDiscount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CitysIncomeTaxDiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, CitysIncomeTaxDiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CitysIncomeTaxDiscountClient<$Result.GetResult<Prisma.$CitysIncomeTaxDiscountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CitysIncomeTaxDiscount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitysIncomeTaxDiscountFindFirstArgs} args - Arguments to find a CitysIncomeTaxDiscount
     * @example
     * // Get one CitysIncomeTaxDiscount
     * const citysIncomeTaxDiscount = await prisma.citysIncomeTaxDiscount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CitysIncomeTaxDiscountFindFirstArgs>(args?: SelectSubset<T, CitysIncomeTaxDiscountFindFirstArgs<ExtArgs>>): Prisma__CitysIncomeTaxDiscountClient<$Result.GetResult<Prisma.$CitysIncomeTaxDiscountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CitysIncomeTaxDiscount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitysIncomeTaxDiscountFindFirstOrThrowArgs} args - Arguments to find a CitysIncomeTaxDiscount
     * @example
     * // Get one CitysIncomeTaxDiscount
     * const citysIncomeTaxDiscount = await prisma.citysIncomeTaxDiscount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CitysIncomeTaxDiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, CitysIncomeTaxDiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__CitysIncomeTaxDiscountClient<$Result.GetResult<Prisma.$CitysIncomeTaxDiscountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CitysIncomeTaxDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitysIncomeTaxDiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CitysIncomeTaxDiscounts
     * const citysIncomeTaxDiscounts = await prisma.citysIncomeTaxDiscount.findMany()
     * 
     * // Get first 10 CitysIncomeTaxDiscounts
     * const citysIncomeTaxDiscounts = await prisma.citysIncomeTaxDiscount.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const citysIncomeTaxDiscountWithIDOnly = await prisma.citysIncomeTaxDiscount.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends CitysIncomeTaxDiscountFindManyArgs>(args?: SelectSubset<T, CitysIncomeTaxDiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitysIncomeTaxDiscountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CitysIncomeTaxDiscount.
     * @param {CitysIncomeTaxDiscountCreateArgs} args - Arguments to create a CitysIncomeTaxDiscount.
     * @example
     * // Create one CitysIncomeTaxDiscount
     * const CitysIncomeTaxDiscount = await prisma.citysIncomeTaxDiscount.create({
     *   data: {
     *     // ... data to create a CitysIncomeTaxDiscount
     *   }
     * })
     * 
     */
    create<T extends CitysIncomeTaxDiscountCreateArgs>(args: SelectSubset<T, CitysIncomeTaxDiscountCreateArgs<ExtArgs>>): Prisma__CitysIncomeTaxDiscountClient<$Result.GetResult<Prisma.$CitysIncomeTaxDiscountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CitysIncomeTaxDiscounts.
     * @param {CitysIncomeTaxDiscountCreateManyArgs} args - Arguments to create many CitysIncomeTaxDiscounts.
     * @example
     * // Create many CitysIncomeTaxDiscounts
     * const citysIncomeTaxDiscount = await prisma.citysIncomeTaxDiscount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CitysIncomeTaxDiscountCreateManyArgs>(args?: SelectSubset<T, CitysIncomeTaxDiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CitysIncomeTaxDiscount.
     * @param {CitysIncomeTaxDiscountDeleteArgs} args - Arguments to delete one CitysIncomeTaxDiscount.
     * @example
     * // Delete one CitysIncomeTaxDiscount
     * const CitysIncomeTaxDiscount = await prisma.citysIncomeTaxDiscount.delete({
     *   where: {
     *     // ... filter to delete one CitysIncomeTaxDiscount
     *   }
     * })
     * 
     */
    delete<T extends CitysIncomeTaxDiscountDeleteArgs>(args: SelectSubset<T, CitysIncomeTaxDiscountDeleteArgs<ExtArgs>>): Prisma__CitysIncomeTaxDiscountClient<$Result.GetResult<Prisma.$CitysIncomeTaxDiscountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CitysIncomeTaxDiscount.
     * @param {CitysIncomeTaxDiscountUpdateArgs} args - Arguments to update one CitysIncomeTaxDiscount.
     * @example
     * // Update one CitysIncomeTaxDiscount
     * const citysIncomeTaxDiscount = await prisma.citysIncomeTaxDiscount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CitysIncomeTaxDiscountUpdateArgs>(args: SelectSubset<T, CitysIncomeTaxDiscountUpdateArgs<ExtArgs>>): Prisma__CitysIncomeTaxDiscountClient<$Result.GetResult<Prisma.$CitysIncomeTaxDiscountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CitysIncomeTaxDiscounts.
     * @param {CitysIncomeTaxDiscountDeleteManyArgs} args - Arguments to filter CitysIncomeTaxDiscounts to delete.
     * @example
     * // Delete a few CitysIncomeTaxDiscounts
     * const { count } = await prisma.citysIncomeTaxDiscount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CitysIncomeTaxDiscountDeleteManyArgs>(args?: SelectSubset<T, CitysIncomeTaxDiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CitysIncomeTaxDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitysIncomeTaxDiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CitysIncomeTaxDiscounts
     * const citysIncomeTaxDiscount = await prisma.citysIncomeTaxDiscount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CitysIncomeTaxDiscountUpdateManyArgs>(args: SelectSubset<T, CitysIncomeTaxDiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CitysIncomeTaxDiscount.
     * @param {CitysIncomeTaxDiscountUpsertArgs} args - Arguments to update or create a CitysIncomeTaxDiscount.
     * @example
     * // Update or create a CitysIncomeTaxDiscount
     * const citysIncomeTaxDiscount = await prisma.citysIncomeTaxDiscount.upsert({
     *   create: {
     *     // ... data to create a CitysIncomeTaxDiscount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CitysIncomeTaxDiscount we want to update
     *   }
     * })
     */
    upsert<T extends CitysIncomeTaxDiscountUpsertArgs>(args: SelectSubset<T, CitysIncomeTaxDiscountUpsertArgs<ExtArgs>>): Prisma__CitysIncomeTaxDiscountClient<$Result.GetResult<Prisma.$CitysIncomeTaxDiscountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CitysIncomeTaxDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitysIncomeTaxDiscountCountArgs} args - Arguments to filter CitysIncomeTaxDiscounts to count.
     * @example
     * // Count the number of CitysIncomeTaxDiscounts
     * const count = await prisma.citysIncomeTaxDiscount.count({
     *   where: {
     *     // ... the filter for the CitysIncomeTaxDiscounts we want to count
     *   }
     * })
    **/
    count<T extends CitysIncomeTaxDiscountCountArgs>(
      args?: Subset<T, CitysIncomeTaxDiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitysIncomeTaxDiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CitysIncomeTaxDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitysIncomeTaxDiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitysIncomeTaxDiscountAggregateArgs>(args: Subset<T, CitysIncomeTaxDiscountAggregateArgs>): Prisma.PrismaPromise<GetCitysIncomeTaxDiscountAggregateType<T>>

    /**
     * Group by CitysIncomeTaxDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitysIncomeTaxDiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CitysIncomeTaxDiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CitysIncomeTaxDiscountGroupByArgs['orderBy'] }
        : { orderBy?: CitysIncomeTaxDiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CitysIncomeTaxDiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitysIncomeTaxDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CitysIncomeTaxDiscount model
   */
  readonly fields: CitysIncomeTaxDiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CitysIncomeTaxDiscount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CitysIncomeTaxDiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CitysIncomeTaxDiscount model
   */ 
  interface CitysIncomeTaxDiscountFieldRefs {
    readonly ID: FieldRef<"CitysIncomeTaxDiscount", 'Int'>
    readonly Year: FieldRef<"CitysIncomeTaxDiscount", 'Float'>
    readonly GroupCode: FieldRef<"CitysIncomeTaxDiscount", 'Int'>
    readonly CityName: FieldRef<"CitysIncomeTaxDiscount", 'String'>
    readonly DiscountPercent: FieldRef<"CitysIncomeTaxDiscount", 'Int'>
    readonly MaximumIncome: FieldRef<"CitysIncomeTaxDiscount", 'Float'>
    readonly MaximumIncomePerMonth: FieldRef<"CitysIncomeTaxDiscount", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * CitysIncomeTaxDiscount findUnique
   */
  export type CitysIncomeTaxDiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitysIncomeTaxDiscount
     */
    select?: CitysIncomeTaxDiscountSelect<ExtArgs> | null
    /**
     * Filter, which CitysIncomeTaxDiscount to fetch.
     */
    where: CitysIncomeTaxDiscountWhereUniqueInput
  }

  /**
   * CitysIncomeTaxDiscount findUniqueOrThrow
   */
  export type CitysIncomeTaxDiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitysIncomeTaxDiscount
     */
    select?: CitysIncomeTaxDiscountSelect<ExtArgs> | null
    /**
     * Filter, which CitysIncomeTaxDiscount to fetch.
     */
    where: CitysIncomeTaxDiscountWhereUniqueInput
  }

  /**
   * CitysIncomeTaxDiscount findFirst
   */
  export type CitysIncomeTaxDiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitysIncomeTaxDiscount
     */
    select?: CitysIncomeTaxDiscountSelect<ExtArgs> | null
    /**
     * Filter, which CitysIncomeTaxDiscount to fetch.
     */
    where?: CitysIncomeTaxDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CitysIncomeTaxDiscounts to fetch.
     */
    orderBy?: CitysIncomeTaxDiscountOrderByWithRelationInput | CitysIncomeTaxDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CitysIncomeTaxDiscounts.
     */
    cursor?: CitysIncomeTaxDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CitysIncomeTaxDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CitysIncomeTaxDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CitysIncomeTaxDiscounts.
     */
    distinct?: CitysIncomeTaxDiscountScalarFieldEnum | CitysIncomeTaxDiscountScalarFieldEnum[]
  }

  /**
   * CitysIncomeTaxDiscount findFirstOrThrow
   */
  export type CitysIncomeTaxDiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitysIncomeTaxDiscount
     */
    select?: CitysIncomeTaxDiscountSelect<ExtArgs> | null
    /**
     * Filter, which CitysIncomeTaxDiscount to fetch.
     */
    where?: CitysIncomeTaxDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CitysIncomeTaxDiscounts to fetch.
     */
    orderBy?: CitysIncomeTaxDiscountOrderByWithRelationInput | CitysIncomeTaxDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CitysIncomeTaxDiscounts.
     */
    cursor?: CitysIncomeTaxDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CitysIncomeTaxDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CitysIncomeTaxDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CitysIncomeTaxDiscounts.
     */
    distinct?: CitysIncomeTaxDiscountScalarFieldEnum | CitysIncomeTaxDiscountScalarFieldEnum[]
  }

  /**
   * CitysIncomeTaxDiscount findMany
   */
  export type CitysIncomeTaxDiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitysIncomeTaxDiscount
     */
    select?: CitysIncomeTaxDiscountSelect<ExtArgs> | null
    /**
     * Filter, which CitysIncomeTaxDiscounts to fetch.
     */
    where?: CitysIncomeTaxDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CitysIncomeTaxDiscounts to fetch.
     */
    orderBy?: CitysIncomeTaxDiscountOrderByWithRelationInput | CitysIncomeTaxDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CitysIncomeTaxDiscounts.
     */
    cursor?: CitysIncomeTaxDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CitysIncomeTaxDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CitysIncomeTaxDiscounts.
     */
    skip?: number
    distinct?: CitysIncomeTaxDiscountScalarFieldEnum | CitysIncomeTaxDiscountScalarFieldEnum[]
  }

  /**
   * CitysIncomeTaxDiscount create
   */
  export type CitysIncomeTaxDiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitysIncomeTaxDiscount
     */
    select?: CitysIncomeTaxDiscountSelect<ExtArgs> | null
    /**
     * The data needed to create a CitysIncomeTaxDiscount.
     */
    data: XOR<CitysIncomeTaxDiscountCreateInput, CitysIncomeTaxDiscountUncheckedCreateInput>
  }

  /**
   * CitysIncomeTaxDiscount createMany
   */
  export type CitysIncomeTaxDiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CitysIncomeTaxDiscounts.
     */
    data: CitysIncomeTaxDiscountCreateManyInput | CitysIncomeTaxDiscountCreateManyInput[]
  }

  /**
   * CitysIncomeTaxDiscount update
   */
  export type CitysIncomeTaxDiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitysIncomeTaxDiscount
     */
    select?: CitysIncomeTaxDiscountSelect<ExtArgs> | null
    /**
     * The data needed to update a CitysIncomeTaxDiscount.
     */
    data: XOR<CitysIncomeTaxDiscountUpdateInput, CitysIncomeTaxDiscountUncheckedUpdateInput>
    /**
     * Choose, which CitysIncomeTaxDiscount to update.
     */
    where: CitysIncomeTaxDiscountWhereUniqueInput
  }

  /**
   * CitysIncomeTaxDiscount updateMany
   */
  export type CitysIncomeTaxDiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CitysIncomeTaxDiscounts.
     */
    data: XOR<CitysIncomeTaxDiscountUpdateManyMutationInput, CitysIncomeTaxDiscountUncheckedUpdateManyInput>
    /**
     * Filter which CitysIncomeTaxDiscounts to update
     */
    where?: CitysIncomeTaxDiscountWhereInput
  }

  /**
   * CitysIncomeTaxDiscount upsert
   */
  export type CitysIncomeTaxDiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitysIncomeTaxDiscount
     */
    select?: CitysIncomeTaxDiscountSelect<ExtArgs> | null
    /**
     * The filter to search for the CitysIncomeTaxDiscount to update in case it exists.
     */
    where: CitysIncomeTaxDiscountWhereUniqueInput
    /**
     * In case the CitysIncomeTaxDiscount found by the `where` argument doesn't exist, create a new CitysIncomeTaxDiscount with this data.
     */
    create: XOR<CitysIncomeTaxDiscountCreateInput, CitysIncomeTaxDiscountUncheckedCreateInput>
    /**
     * In case the CitysIncomeTaxDiscount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CitysIncomeTaxDiscountUpdateInput, CitysIncomeTaxDiscountUncheckedUpdateInput>
  }

  /**
   * CitysIncomeTaxDiscount delete
   */
  export type CitysIncomeTaxDiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitysIncomeTaxDiscount
     */
    select?: CitysIncomeTaxDiscountSelect<ExtArgs> | null
    /**
     * Filter which CitysIncomeTaxDiscount to delete.
     */
    where: CitysIncomeTaxDiscountWhereUniqueInput
  }

  /**
   * CitysIncomeTaxDiscount deleteMany
   */
  export type CitysIncomeTaxDiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CitysIncomeTaxDiscounts to delete
     */
    where?: CitysIncomeTaxDiscountWhereInput
  }

  /**
   * CitysIncomeTaxDiscount without action
   */
  export type CitysIncomeTaxDiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitysIncomeTaxDiscount
     */
    select?: CitysIncomeTaxDiscountSelect<ExtArgs> | null
  }


  /**
   * Model Companies
   */

  export type AggregateCompanies = {
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  export type CompaniesAvgAggregateOutputType = {
    CompanyID_OLD: number | null
    CompanyNumber: number | null
    DeductionsNumber: number | null
    AgencyNumber: number | null
    CityID: number | null
    NumOfPaySlipDisplay: number | null
    PaySlipDefinitionID: number | null
    DisplayTypeID: number | null
    IsSuperAdminCompany: number | null
    IsActive: number | null
    IsExportAccounts: number | null
    IsGetTaxAccountsCode: number | null
  }

  export type CompaniesSumAggregateOutputType = {
    CompanyID_OLD: number | null
    CompanyNumber: number | null
    DeductionsNumber: number | null
    AgencyNumber: number | null
    CityID: number | null
    NumOfPaySlipDisplay: number | null
    PaySlipDefinitionID: number | null
    DisplayTypeID: number | null
    IsSuperAdminCompany: number | null
    IsActive: number | null
    IsExportAccounts: number | null
    IsGetTaxAccountsCode: number | null
  }

  export type CompaniesMinAggregateOutputType = {
    CompanyID: string | null
    CompanyID_OLD: number | null
    CompanyNumber: number | null
    DeductionsNumber: number | null
    AgencyNumber: number | null
    CompanyName: string | null
    CompanyNameEng: string | null
    Address: string | null
    CityID: number | null
    ZipCode: string | null
    POB: string | null
    POB_ZipCode: string | null
    Email: string | null
    WebSite: string | null
    Phone: string | null
    Fax: string | null
    NumOfPaySlipDisplay: number | null
    PaySlipDefinitionID: number | null
    DbPathOnCloud: string | null
    DocFilesPathOnCloud: string | null
    DbPathAgricultureCRM: string | null
    DisplayTypeID: number | null
    IsSuperAdminCompany: number | null
    IsActive: number | null
    IsExportAccounts: number | null
    TaxAccountsToken: string | null
    IsGetTaxAccountsCode: number | null
    CompanyTaxAutoLink: string | null
    UserId: string | null
    CompanyTypeID: string | null
  }

  export type CompaniesMaxAggregateOutputType = {
    CompanyID: string | null
    CompanyID_OLD: number | null
    CompanyNumber: number | null
    DeductionsNumber: number | null
    AgencyNumber: number | null
    CompanyName: string | null
    CompanyNameEng: string | null
    Address: string | null
    CityID: number | null
    ZipCode: string | null
    POB: string | null
    POB_ZipCode: string | null
    Email: string | null
    WebSite: string | null
    Phone: string | null
    Fax: string | null
    NumOfPaySlipDisplay: number | null
    PaySlipDefinitionID: number | null
    DbPathOnCloud: string | null
    DocFilesPathOnCloud: string | null
    DbPathAgricultureCRM: string | null
    DisplayTypeID: number | null
    IsSuperAdminCompany: number | null
    IsActive: number | null
    IsExportAccounts: number | null
    TaxAccountsToken: string | null
    IsGetTaxAccountsCode: number | null
    CompanyTaxAutoLink: string | null
    UserId: string | null
    CompanyTypeID: string | null
  }

  export type CompaniesCountAggregateOutputType = {
    CompanyID: number
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber: number
    AgencyNumber: number
    CompanyName: number
    CompanyNameEng: number
    Address: number
    CityID: number
    ZipCode: number
    POB: number
    POB_ZipCode: number
    Email: number
    WebSite: number
    Phone: number
    Fax: number
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID: number
    DbPathOnCloud: number
    DocFilesPathOnCloud: number
    DbPathAgricultureCRM: number
    DisplayTypeID: number
    IsSuperAdminCompany: number
    IsActive: number
    IsExportAccounts: number
    TaxAccountsToken: number
    IsGetTaxAccountsCode: number
    CompanyTaxAutoLink: number
    UserId: number
    CompanyTypeID: number
    _all: number
  }


  export type CompaniesAvgAggregateInputType = {
    CompanyID_OLD?: true
    CompanyNumber?: true
    DeductionsNumber?: true
    AgencyNumber?: true
    CityID?: true
    NumOfPaySlipDisplay?: true
    PaySlipDefinitionID?: true
    DisplayTypeID?: true
    IsSuperAdminCompany?: true
    IsActive?: true
    IsExportAccounts?: true
    IsGetTaxAccountsCode?: true
  }

  export type CompaniesSumAggregateInputType = {
    CompanyID_OLD?: true
    CompanyNumber?: true
    DeductionsNumber?: true
    AgencyNumber?: true
    CityID?: true
    NumOfPaySlipDisplay?: true
    PaySlipDefinitionID?: true
    DisplayTypeID?: true
    IsSuperAdminCompany?: true
    IsActive?: true
    IsExportAccounts?: true
    IsGetTaxAccountsCode?: true
  }

  export type CompaniesMinAggregateInputType = {
    CompanyID?: true
    CompanyID_OLD?: true
    CompanyNumber?: true
    DeductionsNumber?: true
    AgencyNumber?: true
    CompanyName?: true
    CompanyNameEng?: true
    Address?: true
    CityID?: true
    ZipCode?: true
    POB?: true
    POB_ZipCode?: true
    Email?: true
    WebSite?: true
    Phone?: true
    Fax?: true
    NumOfPaySlipDisplay?: true
    PaySlipDefinitionID?: true
    DbPathOnCloud?: true
    DocFilesPathOnCloud?: true
    DbPathAgricultureCRM?: true
    DisplayTypeID?: true
    IsSuperAdminCompany?: true
    IsActive?: true
    IsExportAccounts?: true
    TaxAccountsToken?: true
    IsGetTaxAccountsCode?: true
    CompanyTaxAutoLink?: true
    UserId?: true
    CompanyTypeID?: true
  }

  export type CompaniesMaxAggregateInputType = {
    CompanyID?: true
    CompanyID_OLD?: true
    CompanyNumber?: true
    DeductionsNumber?: true
    AgencyNumber?: true
    CompanyName?: true
    CompanyNameEng?: true
    Address?: true
    CityID?: true
    ZipCode?: true
    POB?: true
    POB_ZipCode?: true
    Email?: true
    WebSite?: true
    Phone?: true
    Fax?: true
    NumOfPaySlipDisplay?: true
    PaySlipDefinitionID?: true
    DbPathOnCloud?: true
    DocFilesPathOnCloud?: true
    DbPathAgricultureCRM?: true
    DisplayTypeID?: true
    IsSuperAdminCompany?: true
    IsActive?: true
    IsExportAccounts?: true
    TaxAccountsToken?: true
    IsGetTaxAccountsCode?: true
    CompanyTaxAutoLink?: true
    UserId?: true
    CompanyTypeID?: true
  }

  export type CompaniesCountAggregateInputType = {
    CompanyID?: true
    CompanyID_OLD?: true
    CompanyNumber?: true
    DeductionsNumber?: true
    AgencyNumber?: true
    CompanyName?: true
    CompanyNameEng?: true
    Address?: true
    CityID?: true
    ZipCode?: true
    POB?: true
    POB_ZipCode?: true
    Email?: true
    WebSite?: true
    Phone?: true
    Fax?: true
    NumOfPaySlipDisplay?: true
    PaySlipDefinitionID?: true
    DbPathOnCloud?: true
    DocFilesPathOnCloud?: true
    DbPathAgricultureCRM?: true
    DisplayTypeID?: true
    IsSuperAdminCompany?: true
    IsActive?: true
    IsExportAccounts?: true
    TaxAccountsToken?: true
    IsGetTaxAccountsCode?: true
    CompanyTaxAutoLink?: true
    UserId?: true
    CompanyTypeID?: true
    _all?: true
  }

  export type CompaniesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to aggregate.
     */
    where?: CompaniesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompaniesOrderByWithRelationInput | CompaniesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompaniesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesMaxAggregateInputType
  }

  export type GetCompaniesAggregateType<T extends CompaniesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanies[P]>
      : GetScalarType<T[P], AggregateCompanies[P]>
  }




  export type CompaniesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesWhereInput
    orderBy?: CompaniesOrderByWithAggregationInput | CompaniesOrderByWithAggregationInput[]
    by: CompaniesScalarFieldEnum[] | CompaniesScalarFieldEnum
    having?: CompaniesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesCountAggregateInputType | true
    _avg?: CompaniesAvgAggregateInputType
    _sum?: CompaniesSumAggregateInputType
    _min?: CompaniesMinAggregateInputType
    _max?: CompaniesMaxAggregateInputType
  }

  export type CompaniesGroupByOutputType = {
    CompanyID: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber: number | null
    AgencyNumber: number | null
    CompanyName: string
    CompanyNameEng: string | null
    Address: string | null
    CityID: number | null
    ZipCode: string | null
    POB: string | null
    POB_ZipCode: string | null
    Email: string | null
    WebSite: string | null
    Phone: string | null
    Fax: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID: number | null
    DbPathOnCloud: string | null
    DocFilesPathOnCloud: string | null
    DbPathAgricultureCRM: string | null
    DisplayTypeID: number
    IsSuperAdminCompany: number | null
    IsActive: number | null
    IsExportAccounts: number | null
    TaxAccountsToken: string | null
    IsGetTaxAccountsCode: number | null
    CompanyTaxAutoLink: string | null
    UserId: string | null
    CompanyTypeID: string
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  type GetCompaniesGroupByPayload<T extends CompaniesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
        }
      >
    >


  export type CompaniesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CompanyID?: boolean
    CompanyID_OLD?: boolean
    CompanyNumber?: boolean
    DeductionsNumber?: boolean
    AgencyNumber?: boolean
    CompanyName?: boolean
    CompanyNameEng?: boolean
    Address?: boolean
    CityID?: boolean
    ZipCode?: boolean
    POB?: boolean
    POB_ZipCode?: boolean
    Email?: boolean
    WebSite?: boolean
    Phone?: boolean
    Fax?: boolean
    NumOfPaySlipDisplay?: boolean
    PaySlipDefinitionID?: boolean
    DbPathOnCloud?: boolean
    DocFilesPathOnCloud?: boolean
    DbPathAgricultureCRM?: boolean
    DisplayTypeID?: boolean
    IsSuperAdminCompany?: boolean
    IsActive?: boolean
    IsExportAccounts?: boolean
    TaxAccountsToken?: boolean
    IsGetTaxAccountsCode?: boolean
    CompanyTaxAutoLink?: boolean
    UserId?: boolean
    CompanyTypeID?: boolean
    CompaniesType?: boolean | CompaniesTypeDefaultArgs<ExtArgs>
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: boolean | Companies$CompaniesUsers_Companies_UserIdToCompaniesUsersArgs<ExtArgs>
    CompaniesProducts?: boolean | Companies$CompaniesProductsArgs<ExtArgs>
    CompaniesProductsExpireDates?: boolean | Companies$CompaniesProductsExpireDatesArgs<ExtArgs>
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: boolean | Companies$CompaniesUsers_CompaniesUsers_CompanyIDToCompaniesArgs<ExtArgs>
    CompaniesUsersProductsExpireDates?: boolean | Companies$CompaniesUsersProductsExpireDatesArgs<ExtArgs>
    LandPages?: boolean | Companies$LandPagesArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>


  export type CompaniesSelectScalar = {
    CompanyID?: boolean
    CompanyID_OLD?: boolean
    CompanyNumber?: boolean
    DeductionsNumber?: boolean
    AgencyNumber?: boolean
    CompanyName?: boolean
    CompanyNameEng?: boolean
    Address?: boolean
    CityID?: boolean
    ZipCode?: boolean
    POB?: boolean
    POB_ZipCode?: boolean
    Email?: boolean
    WebSite?: boolean
    Phone?: boolean
    Fax?: boolean
    NumOfPaySlipDisplay?: boolean
    PaySlipDefinitionID?: boolean
    DbPathOnCloud?: boolean
    DocFilesPathOnCloud?: boolean
    DbPathAgricultureCRM?: boolean
    DisplayTypeID?: boolean
    IsSuperAdminCompany?: boolean
    IsActive?: boolean
    IsExportAccounts?: boolean
    TaxAccountsToken?: boolean
    IsGetTaxAccountsCode?: boolean
    CompanyTaxAutoLink?: boolean
    UserId?: boolean
    CompanyTypeID?: boolean
  }

  export type CompaniesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CompaniesType?: boolean | CompaniesTypeDefaultArgs<ExtArgs>
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: boolean | Companies$CompaniesUsers_Companies_UserIdToCompaniesUsersArgs<ExtArgs>
    CompaniesProducts?: boolean | Companies$CompaniesProductsArgs<ExtArgs>
    CompaniesProductsExpireDates?: boolean | Companies$CompaniesProductsExpireDatesArgs<ExtArgs>
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: boolean | Companies$CompaniesUsers_CompaniesUsers_CompanyIDToCompaniesArgs<ExtArgs>
    CompaniesUsersProductsExpireDates?: boolean | Companies$CompaniesUsersProductsExpireDatesArgs<ExtArgs>
    LandPages?: boolean | Companies$LandPagesArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompaniesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Companies"
    objects: {
      CompaniesType: Prisma.$CompaniesTypePayload<ExtArgs>
      CompaniesUsers_Companies_UserIdToCompaniesUsers: Prisma.$CompaniesUsersPayload<ExtArgs> | null
      CompaniesProducts: Prisma.$CompaniesProductsPayload<ExtArgs>[]
      CompaniesProductsExpireDates: Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>[]
      CompaniesUsers_CompaniesUsers_CompanyIDToCompanies: Prisma.$CompaniesUsersPayload<ExtArgs>[]
      CompaniesUsersProductsExpireDates: Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>[]
      LandPages: Prisma.$LandPagesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      CompanyID: string
      CompanyID_OLD: number
      CompanyNumber: number
      DeductionsNumber: number | null
      AgencyNumber: number | null
      CompanyName: string
      CompanyNameEng: string | null
      Address: string | null
      CityID: number | null
      ZipCode: string | null
      POB: string | null
      POB_ZipCode: string | null
      Email: string | null
      WebSite: string | null
      Phone: string | null
      Fax: string | null
      NumOfPaySlipDisplay: number
      PaySlipDefinitionID: number | null
      DbPathOnCloud: string | null
      DocFilesPathOnCloud: string | null
      DbPathAgricultureCRM: string | null
      DisplayTypeID: number
      IsSuperAdminCompany: number | null
      IsActive: number | null
      IsExportAccounts: number | null
      TaxAccountsToken: string | null
      IsGetTaxAccountsCode: number | null
      CompanyTaxAutoLink: string | null
      UserId: string | null
      CompanyTypeID: string
    }, ExtArgs["result"]["companies"]>
    composites: {}
  }

  type CompaniesGetPayload<S extends boolean | null | undefined | CompaniesDefaultArgs> = $Result.GetResult<Prisma.$CompaniesPayload, S>

  type CompaniesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompaniesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompaniesCountAggregateInputType | true
    }

  export interface CompaniesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Companies'], meta: { name: 'Companies' } }
    /**
     * Find zero or one Companies that matches the filter.
     * @param {CompaniesFindUniqueArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompaniesFindUniqueArgs>(args: SelectSubset<T, CompaniesFindUniqueArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Companies that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompaniesFindUniqueOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompaniesFindUniqueOrThrowArgs>(args: SelectSubset<T, CompaniesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesFindFirstArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompaniesFindFirstArgs>(args?: SelectSubset<T, CompaniesFindFirstArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Companies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesFindFirstOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompaniesFindFirstOrThrowArgs>(args?: SelectSubset<T, CompaniesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.companies.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.companies.findMany({ take: 10 })
     * 
     * // Only select the `CompanyID`
     * const companiesWithCompanyIDOnly = await prisma.companies.findMany({ select: { CompanyID: true } })
     * 
     */
    findMany<T extends CompaniesFindManyArgs>(args?: SelectSubset<T, CompaniesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Companies.
     * @param {CompaniesCreateArgs} args - Arguments to create a Companies.
     * @example
     * // Create one Companies
     * const Companies = await prisma.companies.create({
     *   data: {
     *     // ... data to create a Companies
     *   }
     * })
     * 
     */
    create<T extends CompaniesCreateArgs>(args: SelectSubset<T, CompaniesCreateArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompaniesCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompaniesCreateManyArgs>(args?: SelectSubset<T, CompaniesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Companies.
     * @param {CompaniesDeleteArgs} args - Arguments to delete one Companies.
     * @example
     * // Delete one Companies
     * const Companies = await prisma.companies.delete({
     *   where: {
     *     // ... filter to delete one Companies
     *   }
     * })
     * 
     */
    delete<T extends CompaniesDeleteArgs>(args: SelectSubset<T, CompaniesDeleteArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Companies.
     * @param {CompaniesUpdateArgs} args - Arguments to update one Companies.
     * @example
     * // Update one Companies
     * const companies = await prisma.companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompaniesUpdateArgs>(args: SelectSubset<T, CompaniesUpdateArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompaniesDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompaniesDeleteManyArgs>(args?: SelectSubset<T, CompaniesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompaniesUpdateManyArgs>(args: SelectSubset<T, CompaniesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Companies.
     * @param {CompaniesUpsertArgs} args - Arguments to update or create a Companies.
     * @example
     * // Update or create a Companies
     * const companies = await prisma.companies.upsert({
     *   create: {
     *     // ... data to create a Companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companies we want to update
     *   }
     * })
     */
    upsert<T extends CompaniesUpsertArgs>(args: SelectSubset<T, CompaniesUpsertArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.companies.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompaniesCountArgs>(
      args?: Subset<T, CompaniesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesAggregateArgs>(args: Subset<T, CompaniesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesAggregateType<T>>

    /**
     * Group by Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompaniesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompaniesGroupByArgs['orderBy'] }
        : { orderBy?: CompaniesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompaniesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Companies model
   */
  readonly fields: CompaniesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompaniesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CompaniesType<T extends CompaniesTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesTypeDefaultArgs<ExtArgs>>): Prisma__CompaniesTypeClient<$Result.GetResult<Prisma.$CompaniesTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    CompaniesUsers_Companies_UserIdToCompaniesUsers<T extends Companies$CompaniesUsers_Companies_UserIdToCompaniesUsersArgs<ExtArgs> = {}>(args?: Subset<T, Companies$CompaniesUsers_Companies_UserIdToCompaniesUsersArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    CompaniesProducts<T extends Companies$CompaniesProductsArgs<ExtArgs> = {}>(args?: Subset<T, Companies$CompaniesProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesProductsPayload<ExtArgs>, T, "findMany"> | Null>
    CompaniesProductsExpireDates<T extends Companies$CompaniesProductsExpireDatesArgs<ExtArgs> = {}>(args?: Subset<T, Companies$CompaniesProductsExpireDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>, T, "findMany"> | Null>
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies<T extends Companies$CompaniesUsers_CompaniesUsers_CompanyIDToCompaniesArgs<ExtArgs> = {}>(args?: Subset<T, Companies$CompaniesUsers_CompaniesUsers_CompanyIDToCompaniesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findMany"> | Null>
    CompaniesUsersProductsExpireDates<T extends Companies$CompaniesUsersProductsExpireDatesArgs<ExtArgs> = {}>(args?: Subset<T, Companies$CompaniesUsersProductsExpireDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "findMany"> | Null>
    LandPages<T extends Companies$LandPagesArgs<ExtArgs> = {}>(args?: Subset<T, Companies$LandPagesArgs<ExtArgs>>): Prisma__LandPagesClient<$Result.GetResult<Prisma.$LandPagesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Companies model
   */ 
  interface CompaniesFieldRefs {
    readonly CompanyID: FieldRef<"Companies", 'String'>
    readonly CompanyID_OLD: FieldRef<"Companies", 'Int'>
    readonly CompanyNumber: FieldRef<"Companies", 'Int'>
    readonly DeductionsNumber: FieldRef<"Companies", 'Int'>
    readonly AgencyNumber: FieldRef<"Companies", 'Int'>
    readonly CompanyName: FieldRef<"Companies", 'String'>
    readonly CompanyNameEng: FieldRef<"Companies", 'String'>
    readonly Address: FieldRef<"Companies", 'String'>
    readonly CityID: FieldRef<"Companies", 'Int'>
    readonly ZipCode: FieldRef<"Companies", 'String'>
    readonly POB: FieldRef<"Companies", 'String'>
    readonly POB_ZipCode: FieldRef<"Companies", 'String'>
    readonly Email: FieldRef<"Companies", 'String'>
    readonly WebSite: FieldRef<"Companies", 'String'>
    readonly Phone: FieldRef<"Companies", 'String'>
    readonly Fax: FieldRef<"Companies", 'String'>
    readonly NumOfPaySlipDisplay: FieldRef<"Companies", 'Int'>
    readonly PaySlipDefinitionID: FieldRef<"Companies", 'Int'>
    readonly DbPathOnCloud: FieldRef<"Companies", 'String'>
    readonly DocFilesPathOnCloud: FieldRef<"Companies", 'String'>
    readonly DbPathAgricultureCRM: FieldRef<"Companies", 'String'>
    readonly DisplayTypeID: FieldRef<"Companies", 'Int'>
    readonly IsSuperAdminCompany: FieldRef<"Companies", 'Int'>
    readonly IsActive: FieldRef<"Companies", 'Int'>
    readonly IsExportAccounts: FieldRef<"Companies", 'Int'>
    readonly TaxAccountsToken: FieldRef<"Companies", 'String'>
    readonly IsGetTaxAccountsCode: FieldRef<"Companies", 'Int'>
    readonly CompanyTaxAutoLink: FieldRef<"Companies", 'String'>
    readonly UserId: FieldRef<"Companies", 'String'>
    readonly CompanyTypeID: FieldRef<"Companies", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Companies findUnique
   */
  export type CompaniesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companies
     */
    select?: CompaniesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where: CompaniesWhereUniqueInput
  }

  /**
   * Companies findUniqueOrThrow
   */
  export type CompaniesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companies
     */
    select?: CompaniesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where: CompaniesWhereUniqueInput
  }

  /**
   * Companies findFirst
   */
  export type CompaniesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companies
     */
    select?: CompaniesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompaniesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompaniesOrderByWithRelationInput | CompaniesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompaniesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * Companies findFirstOrThrow
   */
  export type CompaniesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companies
     */
    select?: CompaniesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompaniesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompaniesOrderByWithRelationInput | CompaniesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompaniesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * Companies findMany
   */
  export type CompaniesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companies
     */
    select?: CompaniesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompaniesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompaniesOrderByWithRelationInput | CompaniesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompaniesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * Companies create
   */
  export type CompaniesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companies
     */
    select?: CompaniesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesInclude<ExtArgs> | null
    /**
     * The data needed to create a Companies.
     */
    data: XOR<CompaniesCreateInput, CompaniesUncheckedCreateInput>
  }

  /**
   * Companies createMany
   */
  export type CompaniesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompaniesCreateManyInput | CompaniesCreateManyInput[]
  }

  /**
   * Companies update
   */
  export type CompaniesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companies
     */
    select?: CompaniesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesInclude<ExtArgs> | null
    /**
     * The data needed to update a Companies.
     */
    data: XOR<CompaniesUpdateInput, CompaniesUncheckedUpdateInput>
    /**
     * Choose, which Companies to update.
     */
    where: CompaniesWhereUniqueInput
  }

  /**
   * Companies updateMany
   */
  export type CompaniesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompaniesUpdateManyMutationInput, CompaniesUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompaniesWhereInput
  }

  /**
   * Companies upsert
   */
  export type CompaniesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companies
     */
    select?: CompaniesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesInclude<ExtArgs> | null
    /**
     * The filter to search for the Companies to update in case it exists.
     */
    where: CompaniesWhereUniqueInput
    /**
     * In case the Companies found by the `where` argument doesn't exist, create a new Companies with this data.
     */
    create: XOR<CompaniesCreateInput, CompaniesUncheckedCreateInput>
    /**
     * In case the Companies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompaniesUpdateInput, CompaniesUncheckedUpdateInput>
  }

  /**
   * Companies delete
   */
  export type CompaniesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companies
     */
    select?: CompaniesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesInclude<ExtArgs> | null
    /**
     * Filter which Companies to delete.
     */
    where: CompaniesWhereUniqueInput
  }

  /**
   * Companies deleteMany
   */
  export type CompaniesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompaniesWhereInput
  }

  /**
   * Companies.CompaniesUsers_Companies_UserIdToCompaniesUsers
   */
  export type Companies$CompaniesUsers_Companies_UserIdToCompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    where?: CompaniesUsersWhereInput
  }

  /**
   * Companies.CompaniesProducts
   */
  export type Companies$CompaniesProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
    where?: CompaniesProductsWhereInput
    orderBy?: CompaniesProductsOrderByWithRelationInput | CompaniesProductsOrderByWithRelationInput[]
    cursor?: CompaniesProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesProductsScalarFieldEnum | CompaniesProductsScalarFieldEnum[]
  }

  /**
   * Companies.CompaniesProductsExpireDates
   */
  export type Companies$CompaniesProductsExpireDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
    where?: CompaniesProductsExpireDatesWhereInput
    orderBy?: CompaniesProductsExpireDatesOrderByWithRelationInput | CompaniesProductsExpireDatesOrderByWithRelationInput[]
    cursor?: CompaniesProductsExpireDatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesProductsExpireDatesScalarFieldEnum | CompaniesProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * Companies.CompaniesUsers_CompaniesUsers_CompanyIDToCompanies
   */
  export type Companies$CompaniesUsers_CompaniesUsers_CompanyIDToCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    where?: CompaniesUsersWhereInput
    orderBy?: CompaniesUsersOrderByWithRelationInput | CompaniesUsersOrderByWithRelationInput[]
    cursor?: CompaniesUsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesUsersScalarFieldEnum | CompaniesUsersScalarFieldEnum[]
  }

  /**
   * Companies.CompaniesUsersProductsExpireDates
   */
  export type Companies$CompaniesUsersProductsExpireDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    where?: CompaniesUsersProductsExpireDatesWhereInput
    orderBy?: CompaniesUsersProductsExpireDatesOrderByWithRelationInput | CompaniesUsersProductsExpireDatesOrderByWithRelationInput[]
    cursor?: CompaniesUsersProductsExpireDatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesUsersProductsExpireDatesScalarFieldEnum | CompaniesUsersProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * Companies.LandPages
   */
  export type Companies$LandPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandPages
     */
    select?: LandPagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandPagesInclude<ExtArgs> | null
    where?: LandPagesWhereInput
  }

  /**
   * Companies without action
   */
  export type CompaniesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companies
     */
    select?: CompaniesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesInclude<ExtArgs> | null
  }


  /**
   * Model CompaniesProducts
   */

  export type AggregateCompaniesProducts = {
    _count: CompaniesProductsCountAggregateOutputType | null
    _min: CompaniesProductsMinAggregateOutputType | null
    _max: CompaniesProductsMaxAggregateOutputType | null
  }

  export type CompaniesProductsMinAggregateOutputType = {
    CompaniesProductsId: string | null
    CreatedAt: Date | null
    ProductId: string | null
    CompanyID: string | null
    UserId: string | null
    LastVersionDate_Salary: Date | null
    LastVersionDate_ManPower: Date | null
  }

  export type CompaniesProductsMaxAggregateOutputType = {
    CompaniesProductsId: string | null
    CreatedAt: Date | null
    ProductId: string | null
    CompanyID: string | null
    UserId: string | null
    LastVersionDate_Salary: Date | null
    LastVersionDate_ManPower: Date | null
  }

  export type CompaniesProductsCountAggregateOutputType = {
    CompaniesProductsId: number
    CreatedAt: number
    ProductId: number
    CompanyID: number
    UserId: number
    LastVersionDate_Salary: number
    LastVersionDate_ManPower: number
    _all: number
  }


  export type CompaniesProductsMinAggregateInputType = {
    CompaniesProductsId?: true
    CreatedAt?: true
    ProductId?: true
    CompanyID?: true
    UserId?: true
    LastVersionDate_Salary?: true
    LastVersionDate_ManPower?: true
  }

  export type CompaniesProductsMaxAggregateInputType = {
    CompaniesProductsId?: true
    CreatedAt?: true
    ProductId?: true
    CompanyID?: true
    UserId?: true
    LastVersionDate_Salary?: true
    LastVersionDate_ManPower?: true
  }

  export type CompaniesProductsCountAggregateInputType = {
    CompaniesProductsId?: true
    CreatedAt?: true
    ProductId?: true
    CompanyID?: true
    UserId?: true
    LastVersionDate_Salary?: true
    LastVersionDate_ManPower?: true
    _all?: true
  }

  export type CompaniesProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesProducts to aggregate.
     */
    where?: CompaniesProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesProducts to fetch.
     */
    orderBy?: CompaniesProductsOrderByWithRelationInput | CompaniesProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompaniesProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompaniesProducts
    **/
    _count?: true | CompaniesProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesProductsMaxAggregateInputType
  }

  export type GetCompaniesProductsAggregateType<T extends CompaniesProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompaniesProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompaniesProducts[P]>
      : GetScalarType<T[P], AggregateCompaniesProducts[P]>
  }




  export type CompaniesProductsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesProductsWhereInput
    orderBy?: CompaniesProductsOrderByWithAggregationInput | CompaniesProductsOrderByWithAggregationInput[]
    by: CompaniesProductsScalarFieldEnum[] | CompaniesProductsScalarFieldEnum
    having?: CompaniesProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesProductsCountAggregateInputType | true
    _min?: CompaniesProductsMinAggregateInputType
    _max?: CompaniesProductsMaxAggregateInputType
  }

  export type CompaniesProductsGroupByOutputType = {
    CompaniesProductsId: string
    CreatedAt: Date | null
    ProductId: string
    CompanyID: string
    UserId: string | null
    LastVersionDate_Salary: Date | null
    LastVersionDate_ManPower: Date | null
    _count: CompaniesProductsCountAggregateOutputType | null
    _min: CompaniesProductsMinAggregateOutputType | null
    _max: CompaniesProductsMaxAggregateOutputType | null
  }

  type GetCompaniesProductsGroupByPayload<T extends CompaniesProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesProductsGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesProductsGroupByOutputType[P]>
        }
      >
    >


  export type CompaniesProductsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CompaniesProductsId?: boolean
    CreatedAt?: boolean
    ProductId?: boolean
    CompanyID?: boolean
    UserId?: boolean
    LastVersionDate_Salary?: boolean
    LastVersionDate_ManPower?: boolean
    CompaniesUsers?: boolean | CompaniesProducts$CompaniesUsersArgs<ExtArgs>
    Companies?: boolean | CompaniesDefaultArgs<ExtArgs>
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companiesProducts"]>


  export type CompaniesProductsSelectScalar = {
    CompaniesProductsId?: boolean
    CreatedAt?: boolean
    ProductId?: boolean
    CompanyID?: boolean
    UserId?: boolean
    LastVersionDate_Salary?: boolean
    LastVersionDate_ManPower?: boolean
  }

  export type CompaniesProductsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CompaniesUsers?: boolean | CompaniesProducts$CompaniesUsersArgs<ExtArgs>
    Companies?: boolean | CompaniesDefaultArgs<ExtArgs>
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
  }

  export type $CompaniesProductsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompaniesProducts"
    objects: {
      CompaniesUsers: Prisma.$CompaniesUsersPayload<ExtArgs> | null
      Companies: Prisma.$CompaniesPayload<ExtArgs>
      Products: Prisma.$ProductsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      CompaniesProductsId: string
      CreatedAt: Date | null
      ProductId: string
      CompanyID: string
      UserId: string | null
      LastVersionDate_Salary: Date | null
      LastVersionDate_ManPower: Date | null
    }, ExtArgs["result"]["companiesProducts"]>
    composites: {}
  }

  type CompaniesProductsGetPayload<S extends boolean | null | undefined | CompaniesProductsDefaultArgs> = $Result.GetResult<Prisma.$CompaniesProductsPayload, S>

  type CompaniesProductsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompaniesProductsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompaniesProductsCountAggregateInputType | true
    }

  export interface CompaniesProductsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompaniesProducts'], meta: { name: 'CompaniesProducts' } }
    /**
     * Find zero or one CompaniesProducts that matches the filter.
     * @param {CompaniesProductsFindUniqueArgs} args - Arguments to find a CompaniesProducts
     * @example
     * // Get one CompaniesProducts
     * const companiesProducts = await prisma.companiesProducts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompaniesProductsFindUniqueArgs>(args: SelectSubset<T, CompaniesProductsFindUniqueArgs<ExtArgs>>): Prisma__CompaniesProductsClient<$Result.GetResult<Prisma.$CompaniesProductsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompaniesProducts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompaniesProductsFindUniqueOrThrowArgs} args - Arguments to find a CompaniesProducts
     * @example
     * // Get one CompaniesProducts
     * const companiesProducts = await prisma.companiesProducts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompaniesProductsFindUniqueOrThrowArgs>(args: SelectSubset<T, CompaniesProductsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompaniesProductsClient<$Result.GetResult<Prisma.$CompaniesProductsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompaniesProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsFindFirstArgs} args - Arguments to find a CompaniesProducts
     * @example
     * // Get one CompaniesProducts
     * const companiesProducts = await prisma.companiesProducts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompaniesProductsFindFirstArgs>(args?: SelectSubset<T, CompaniesProductsFindFirstArgs<ExtArgs>>): Prisma__CompaniesProductsClient<$Result.GetResult<Prisma.$CompaniesProductsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompaniesProducts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsFindFirstOrThrowArgs} args - Arguments to find a CompaniesProducts
     * @example
     * // Get one CompaniesProducts
     * const companiesProducts = await prisma.companiesProducts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompaniesProductsFindFirstOrThrowArgs>(args?: SelectSubset<T, CompaniesProductsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompaniesProductsClient<$Result.GetResult<Prisma.$CompaniesProductsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompaniesProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompaniesProducts
     * const companiesProducts = await prisma.companiesProducts.findMany()
     * 
     * // Get first 10 CompaniesProducts
     * const companiesProducts = await prisma.companiesProducts.findMany({ take: 10 })
     * 
     * // Only select the `CompaniesProductsId`
     * const companiesProductsWithCompaniesProductsIdOnly = await prisma.companiesProducts.findMany({ select: { CompaniesProductsId: true } })
     * 
     */
    findMany<T extends CompaniesProductsFindManyArgs>(args?: SelectSubset<T, CompaniesProductsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesProductsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompaniesProducts.
     * @param {CompaniesProductsCreateArgs} args - Arguments to create a CompaniesProducts.
     * @example
     * // Create one CompaniesProducts
     * const CompaniesProducts = await prisma.companiesProducts.create({
     *   data: {
     *     // ... data to create a CompaniesProducts
     *   }
     * })
     * 
     */
    create<T extends CompaniesProductsCreateArgs>(args: SelectSubset<T, CompaniesProductsCreateArgs<ExtArgs>>): Prisma__CompaniesProductsClient<$Result.GetResult<Prisma.$CompaniesProductsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompaniesProducts.
     * @param {CompaniesProductsCreateManyArgs} args - Arguments to create many CompaniesProducts.
     * @example
     * // Create many CompaniesProducts
     * const companiesProducts = await prisma.companiesProducts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompaniesProductsCreateManyArgs>(args?: SelectSubset<T, CompaniesProductsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompaniesProducts.
     * @param {CompaniesProductsDeleteArgs} args - Arguments to delete one CompaniesProducts.
     * @example
     * // Delete one CompaniesProducts
     * const CompaniesProducts = await prisma.companiesProducts.delete({
     *   where: {
     *     // ... filter to delete one CompaniesProducts
     *   }
     * })
     * 
     */
    delete<T extends CompaniesProductsDeleteArgs>(args: SelectSubset<T, CompaniesProductsDeleteArgs<ExtArgs>>): Prisma__CompaniesProductsClient<$Result.GetResult<Prisma.$CompaniesProductsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompaniesProducts.
     * @param {CompaniesProductsUpdateArgs} args - Arguments to update one CompaniesProducts.
     * @example
     * // Update one CompaniesProducts
     * const companiesProducts = await prisma.companiesProducts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompaniesProductsUpdateArgs>(args: SelectSubset<T, CompaniesProductsUpdateArgs<ExtArgs>>): Prisma__CompaniesProductsClient<$Result.GetResult<Prisma.$CompaniesProductsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompaniesProducts.
     * @param {CompaniesProductsDeleteManyArgs} args - Arguments to filter CompaniesProducts to delete.
     * @example
     * // Delete a few CompaniesProducts
     * const { count } = await prisma.companiesProducts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompaniesProductsDeleteManyArgs>(args?: SelectSubset<T, CompaniesProductsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompaniesProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompaniesProducts
     * const companiesProducts = await prisma.companiesProducts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompaniesProductsUpdateManyArgs>(args: SelectSubset<T, CompaniesProductsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompaniesProducts.
     * @param {CompaniesProductsUpsertArgs} args - Arguments to update or create a CompaniesProducts.
     * @example
     * // Update or create a CompaniesProducts
     * const companiesProducts = await prisma.companiesProducts.upsert({
     *   create: {
     *     // ... data to create a CompaniesProducts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompaniesProducts we want to update
     *   }
     * })
     */
    upsert<T extends CompaniesProductsUpsertArgs>(args: SelectSubset<T, CompaniesProductsUpsertArgs<ExtArgs>>): Prisma__CompaniesProductsClient<$Result.GetResult<Prisma.$CompaniesProductsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompaniesProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsCountArgs} args - Arguments to filter CompaniesProducts to count.
     * @example
     * // Count the number of CompaniesProducts
     * const count = await prisma.companiesProducts.count({
     *   where: {
     *     // ... the filter for the CompaniesProducts we want to count
     *   }
     * })
    **/
    count<T extends CompaniesProductsCountArgs>(
      args?: Subset<T, CompaniesProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompaniesProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesProductsAggregateArgs>(args: Subset<T, CompaniesProductsAggregateArgs>): Prisma.PrismaPromise<GetCompaniesProductsAggregateType<T>>

    /**
     * Group by CompaniesProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompaniesProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompaniesProductsGroupByArgs['orderBy'] }
        : { orderBy?: CompaniesProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompaniesProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompaniesProducts model
   */
  readonly fields: CompaniesProductsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompaniesProducts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompaniesProductsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CompaniesUsers<T extends CompaniesProducts$CompaniesUsersArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesProducts$CompaniesUsersArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Companies<T extends CompaniesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesDefaultArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Products<T extends ProductsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductsDefaultArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompaniesProducts model
   */ 
  interface CompaniesProductsFieldRefs {
    readonly CompaniesProductsId: FieldRef<"CompaniesProducts", 'String'>
    readonly CreatedAt: FieldRef<"CompaniesProducts", 'DateTime'>
    readonly ProductId: FieldRef<"CompaniesProducts", 'String'>
    readonly CompanyID: FieldRef<"CompaniesProducts", 'String'>
    readonly UserId: FieldRef<"CompaniesProducts", 'String'>
    readonly LastVersionDate_Salary: FieldRef<"CompaniesProducts", 'DateTime'>
    readonly LastVersionDate_ManPower: FieldRef<"CompaniesProducts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompaniesProducts findUnique
   */
  export type CompaniesProductsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesProducts to fetch.
     */
    where: CompaniesProductsWhereUniqueInput
  }

  /**
   * CompaniesProducts findUniqueOrThrow
   */
  export type CompaniesProductsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesProducts to fetch.
     */
    where: CompaniesProductsWhereUniqueInput
  }

  /**
   * CompaniesProducts findFirst
   */
  export type CompaniesProductsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesProducts to fetch.
     */
    where?: CompaniesProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesProducts to fetch.
     */
    orderBy?: CompaniesProductsOrderByWithRelationInput | CompaniesProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesProducts.
     */
    cursor?: CompaniesProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesProducts.
     */
    distinct?: CompaniesProductsScalarFieldEnum | CompaniesProductsScalarFieldEnum[]
  }

  /**
   * CompaniesProducts findFirstOrThrow
   */
  export type CompaniesProductsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesProducts to fetch.
     */
    where?: CompaniesProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesProducts to fetch.
     */
    orderBy?: CompaniesProductsOrderByWithRelationInput | CompaniesProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesProducts.
     */
    cursor?: CompaniesProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesProducts.
     */
    distinct?: CompaniesProductsScalarFieldEnum | CompaniesProductsScalarFieldEnum[]
  }

  /**
   * CompaniesProducts findMany
   */
  export type CompaniesProductsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesProducts to fetch.
     */
    where?: CompaniesProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesProducts to fetch.
     */
    orderBy?: CompaniesProductsOrderByWithRelationInput | CompaniesProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompaniesProducts.
     */
    cursor?: CompaniesProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesProducts.
     */
    skip?: number
    distinct?: CompaniesProductsScalarFieldEnum | CompaniesProductsScalarFieldEnum[]
  }

  /**
   * CompaniesProducts create
   */
  export type CompaniesProductsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
    /**
     * The data needed to create a CompaniesProducts.
     */
    data: XOR<CompaniesProductsCreateInput, CompaniesProductsUncheckedCreateInput>
  }

  /**
   * CompaniesProducts createMany
   */
  export type CompaniesProductsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompaniesProducts.
     */
    data: CompaniesProductsCreateManyInput | CompaniesProductsCreateManyInput[]
  }

  /**
   * CompaniesProducts update
   */
  export type CompaniesProductsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
    /**
     * The data needed to update a CompaniesProducts.
     */
    data: XOR<CompaniesProductsUpdateInput, CompaniesProductsUncheckedUpdateInput>
    /**
     * Choose, which CompaniesProducts to update.
     */
    where: CompaniesProductsWhereUniqueInput
  }

  /**
   * CompaniesProducts updateMany
   */
  export type CompaniesProductsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompaniesProducts.
     */
    data: XOR<CompaniesProductsUpdateManyMutationInput, CompaniesProductsUncheckedUpdateManyInput>
    /**
     * Filter which CompaniesProducts to update
     */
    where?: CompaniesProductsWhereInput
  }

  /**
   * CompaniesProducts upsert
   */
  export type CompaniesProductsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
    /**
     * The filter to search for the CompaniesProducts to update in case it exists.
     */
    where: CompaniesProductsWhereUniqueInput
    /**
     * In case the CompaniesProducts found by the `where` argument doesn't exist, create a new CompaniesProducts with this data.
     */
    create: XOR<CompaniesProductsCreateInput, CompaniesProductsUncheckedCreateInput>
    /**
     * In case the CompaniesProducts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompaniesProductsUpdateInput, CompaniesProductsUncheckedUpdateInput>
  }

  /**
   * CompaniesProducts delete
   */
  export type CompaniesProductsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
    /**
     * Filter which CompaniesProducts to delete.
     */
    where: CompaniesProductsWhereUniqueInput
  }

  /**
   * CompaniesProducts deleteMany
   */
  export type CompaniesProductsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesProducts to delete
     */
    where?: CompaniesProductsWhereInput
  }

  /**
   * CompaniesProducts.CompaniesUsers
   */
  export type CompaniesProducts$CompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    where?: CompaniesUsersWhereInput
  }

  /**
   * CompaniesProducts without action
   */
  export type CompaniesProductsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
  }


  /**
   * Model CompaniesProductsExpireDates
   */

  export type AggregateCompaniesProductsExpireDates = {
    _count: CompaniesProductsExpireDatesCountAggregateOutputType | null
    _min: CompaniesProductsExpireDatesMinAggregateOutputType | null
    _max: CompaniesProductsExpireDatesMaxAggregateOutputType | null
  }

  export type CompaniesProductsExpireDatesMinAggregateOutputType = {
    CompaniesProductsExpireDateId: string | null
    CreatedAt: Date | null
    ProductId: string | null
    CompanyID: string | null
    StartDate: Date | null
    EndDate: Date | null
    Comments: string | null
    UserId: string | null
  }

  export type CompaniesProductsExpireDatesMaxAggregateOutputType = {
    CompaniesProductsExpireDateId: string | null
    CreatedAt: Date | null
    ProductId: string | null
    CompanyID: string | null
    StartDate: Date | null
    EndDate: Date | null
    Comments: string | null
    UserId: string | null
  }

  export type CompaniesProductsExpireDatesCountAggregateOutputType = {
    CompaniesProductsExpireDateId: number
    CreatedAt: number
    ProductId: number
    CompanyID: number
    StartDate: number
    EndDate: number
    Comments: number
    UserId: number
    _all: number
  }


  export type CompaniesProductsExpireDatesMinAggregateInputType = {
    CompaniesProductsExpireDateId?: true
    CreatedAt?: true
    ProductId?: true
    CompanyID?: true
    StartDate?: true
    EndDate?: true
    Comments?: true
    UserId?: true
  }

  export type CompaniesProductsExpireDatesMaxAggregateInputType = {
    CompaniesProductsExpireDateId?: true
    CreatedAt?: true
    ProductId?: true
    CompanyID?: true
    StartDate?: true
    EndDate?: true
    Comments?: true
    UserId?: true
  }

  export type CompaniesProductsExpireDatesCountAggregateInputType = {
    CompaniesProductsExpireDateId?: true
    CreatedAt?: true
    ProductId?: true
    CompanyID?: true
    StartDate?: true
    EndDate?: true
    Comments?: true
    UserId?: true
    _all?: true
  }

  export type CompaniesProductsExpireDatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesProductsExpireDates to aggregate.
     */
    where?: CompaniesProductsExpireDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesProductsExpireDates to fetch.
     */
    orderBy?: CompaniesProductsExpireDatesOrderByWithRelationInput | CompaniesProductsExpireDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompaniesProductsExpireDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesProductsExpireDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesProductsExpireDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompaniesProductsExpireDates
    **/
    _count?: true | CompaniesProductsExpireDatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesProductsExpireDatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesProductsExpireDatesMaxAggregateInputType
  }

  export type GetCompaniesProductsExpireDatesAggregateType<T extends CompaniesProductsExpireDatesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompaniesProductsExpireDates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompaniesProductsExpireDates[P]>
      : GetScalarType<T[P], AggregateCompaniesProductsExpireDates[P]>
  }




  export type CompaniesProductsExpireDatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesProductsExpireDatesWhereInput
    orderBy?: CompaniesProductsExpireDatesOrderByWithAggregationInput | CompaniesProductsExpireDatesOrderByWithAggregationInput[]
    by: CompaniesProductsExpireDatesScalarFieldEnum[] | CompaniesProductsExpireDatesScalarFieldEnum
    having?: CompaniesProductsExpireDatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesProductsExpireDatesCountAggregateInputType | true
    _min?: CompaniesProductsExpireDatesMinAggregateInputType
    _max?: CompaniesProductsExpireDatesMaxAggregateInputType
  }

  export type CompaniesProductsExpireDatesGroupByOutputType = {
    CompaniesProductsExpireDateId: string
    CreatedAt: Date | null
    ProductId: string
    CompanyID: string
    StartDate: Date
    EndDate: Date
    Comments: string | null
    UserId: string | null
    _count: CompaniesProductsExpireDatesCountAggregateOutputType | null
    _min: CompaniesProductsExpireDatesMinAggregateOutputType | null
    _max: CompaniesProductsExpireDatesMaxAggregateOutputType | null
  }

  type GetCompaniesProductsExpireDatesGroupByPayload<T extends CompaniesProductsExpireDatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesProductsExpireDatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesProductsExpireDatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesProductsExpireDatesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesProductsExpireDatesGroupByOutputType[P]>
        }
      >
    >


  export type CompaniesProductsExpireDatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CompaniesProductsExpireDateId?: boolean
    CreatedAt?: boolean
    ProductId?: boolean
    CompanyID?: boolean
    StartDate?: boolean
    EndDate?: boolean
    Comments?: boolean
    UserId?: boolean
    CompaniesUsers?: boolean | CompaniesProductsExpireDates$CompaniesUsersArgs<ExtArgs>
    Companies?: boolean | CompaniesDefaultArgs<ExtArgs>
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companiesProductsExpireDates"]>


  export type CompaniesProductsExpireDatesSelectScalar = {
    CompaniesProductsExpireDateId?: boolean
    CreatedAt?: boolean
    ProductId?: boolean
    CompanyID?: boolean
    StartDate?: boolean
    EndDate?: boolean
    Comments?: boolean
    UserId?: boolean
  }

  export type CompaniesProductsExpireDatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CompaniesUsers?: boolean | CompaniesProductsExpireDates$CompaniesUsersArgs<ExtArgs>
    Companies?: boolean | CompaniesDefaultArgs<ExtArgs>
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
  }

  export type $CompaniesProductsExpireDatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompaniesProductsExpireDates"
    objects: {
      CompaniesUsers: Prisma.$CompaniesUsersPayload<ExtArgs> | null
      Companies: Prisma.$CompaniesPayload<ExtArgs>
      Products: Prisma.$ProductsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      CompaniesProductsExpireDateId: string
      CreatedAt: Date | null
      ProductId: string
      CompanyID: string
      StartDate: Date
      EndDate: Date
      Comments: string | null
      UserId: string | null
    }, ExtArgs["result"]["companiesProductsExpireDates"]>
    composites: {}
  }

  type CompaniesProductsExpireDatesGetPayload<S extends boolean | null | undefined | CompaniesProductsExpireDatesDefaultArgs> = $Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload, S>

  type CompaniesProductsExpireDatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompaniesProductsExpireDatesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompaniesProductsExpireDatesCountAggregateInputType | true
    }

  export interface CompaniesProductsExpireDatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompaniesProductsExpireDates'], meta: { name: 'CompaniesProductsExpireDates' } }
    /**
     * Find zero or one CompaniesProductsExpireDates that matches the filter.
     * @param {CompaniesProductsExpireDatesFindUniqueArgs} args - Arguments to find a CompaniesProductsExpireDates
     * @example
     * // Get one CompaniesProductsExpireDates
     * const companiesProductsExpireDates = await prisma.companiesProductsExpireDates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompaniesProductsExpireDatesFindUniqueArgs>(args: SelectSubset<T, CompaniesProductsExpireDatesFindUniqueArgs<ExtArgs>>): Prisma__CompaniesProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompaniesProductsExpireDates that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompaniesProductsExpireDatesFindUniqueOrThrowArgs} args - Arguments to find a CompaniesProductsExpireDates
     * @example
     * // Get one CompaniesProductsExpireDates
     * const companiesProductsExpireDates = await prisma.companiesProductsExpireDates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompaniesProductsExpireDatesFindUniqueOrThrowArgs>(args: SelectSubset<T, CompaniesProductsExpireDatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompaniesProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompaniesProductsExpireDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsExpireDatesFindFirstArgs} args - Arguments to find a CompaniesProductsExpireDates
     * @example
     * // Get one CompaniesProductsExpireDates
     * const companiesProductsExpireDates = await prisma.companiesProductsExpireDates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompaniesProductsExpireDatesFindFirstArgs>(args?: SelectSubset<T, CompaniesProductsExpireDatesFindFirstArgs<ExtArgs>>): Prisma__CompaniesProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompaniesProductsExpireDates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsExpireDatesFindFirstOrThrowArgs} args - Arguments to find a CompaniesProductsExpireDates
     * @example
     * // Get one CompaniesProductsExpireDates
     * const companiesProductsExpireDates = await prisma.companiesProductsExpireDates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompaniesProductsExpireDatesFindFirstOrThrowArgs>(args?: SelectSubset<T, CompaniesProductsExpireDatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompaniesProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompaniesProductsExpireDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsExpireDatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompaniesProductsExpireDates
     * const companiesProductsExpireDates = await prisma.companiesProductsExpireDates.findMany()
     * 
     * // Get first 10 CompaniesProductsExpireDates
     * const companiesProductsExpireDates = await prisma.companiesProductsExpireDates.findMany({ take: 10 })
     * 
     * // Only select the `CompaniesProductsExpireDateId`
     * const companiesProductsExpireDatesWithCompaniesProductsExpireDateIdOnly = await prisma.companiesProductsExpireDates.findMany({ select: { CompaniesProductsExpireDateId: true } })
     * 
     */
    findMany<T extends CompaniesProductsExpireDatesFindManyArgs>(args?: SelectSubset<T, CompaniesProductsExpireDatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompaniesProductsExpireDates.
     * @param {CompaniesProductsExpireDatesCreateArgs} args - Arguments to create a CompaniesProductsExpireDates.
     * @example
     * // Create one CompaniesProductsExpireDates
     * const CompaniesProductsExpireDates = await prisma.companiesProductsExpireDates.create({
     *   data: {
     *     // ... data to create a CompaniesProductsExpireDates
     *   }
     * })
     * 
     */
    create<T extends CompaniesProductsExpireDatesCreateArgs>(args: SelectSubset<T, CompaniesProductsExpireDatesCreateArgs<ExtArgs>>): Prisma__CompaniesProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompaniesProductsExpireDates.
     * @param {CompaniesProductsExpireDatesCreateManyArgs} args - Arguments to create many CompaniesProductsExpireDates.
     * @example
     * // Create many CompaniesProductsExpireDates
     * const companiesProductsExpireDates = await prisma.companiesProductsExpireDates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompaniesProductsExpireDatesCreateManyArgs>(args?: SelectSubset<T, CompaniesProductsExpireDatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompaniesProductsExpireDates.
     * @param {CompaniesProductsExpireDatesDeleteArgs} args - Arguments to delete one CompaniesProductsExpireDates.
     * @example
     * // Delete one CompaniesProductsExpireDates
     * const CompaniesProductsExpireDates = await prisma.companiesProductsExpireDates.delete({
     *   where: {
     *     // ... filter to delete one CompaniesProductsExpireDates
     *   }
     * })
     * 
     */
    delete<T extends CompaniesProductsExpireDatesDeleteArgs>(args: SelectSubset<T, CompaniesProductsExpireDatesDeleteArgs<ExtArgs>>): Prisma__CompaniesProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompaniesProductsExpireDates.
     * @param {CompaniesProductsExpireDatesUpdateArgs} args - Arguments to update one CompaniesProductsExpireDates.
     * @example
     * // Update one CompaniesProductsExpireDates
     * const companiesProductsExpireDates = await prisma.companiesProductsExpireDates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompaniesProductsExpireDatesUpdateArgs>(args: SelectSubset<T, CompaniesProductsExpireDatesUpdateArgs<ExtArgs>>): Prisma__CompaniesProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompaniesProductsExpireDates.
     * @param {CompaniesProductsExpireDatesDeleteManyArgs} args - Arguments to filter CompaniesProductsExpireDates to delete.
     * @example
     * // Delete a few CompaniesProductsExpireDates
     * const { count } = await prisma.companiesProductsExpireDates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompaniesProductsExpireDatesDeleteManyArgs>(args?: SelectSubset<T, CompaniesProductsExpireDatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompaniesProductsExpireDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsExpireDatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompaniesProductsExpireDates
     * const companiesProductsExpireDates = await prisma.companiesProductsExpireDates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompaniesProductsExpireDatesUpdateManyArgs>(args: SelectSubset<T, CompaniesProductsExpireDatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompaniesProductsExpireDates.
     * @param {CompaniesProductsExpireDatesUpsertArgs} args - Arguments to update or create a CompaniesProductsExpireDates.
     * @example
     * // Update or create a CompaniesProductsExpireDates
     * const companiesProductsExpireDates = await prisma.companiesProductsExpireDates.upsert({
     *   create: {
     *     // ... data to create a CompaniesProductsExpireDates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompaniesProductsExpireDates we want to update
     *   }
     * })
     */
    upsert<T extends CompaniesProductsExpireDatesUpsertArgs>(args: SelectSubset<T, CompaniesProductsExpireDatesUpsertArgs<ExtArgs>>): Prisma__CompaniesProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompaniesProductsExpireDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsExpireDatesCountArgs} args - Arguments to filter CompaniesProductsExpireDates to count.
     * @example
     * // Count the number of CompaniesProductsExpireDates
     * const count = await prisma.companiesProductsExpireDates.count({
     *   where: {
     *     // ... the filter for the CompaniesProductsExpireDates we want to count
     *   }
     * })
    **/
    count<T extends CompaniesProductsExpireDatesCountArgs>(
      args?: Subset<T, CompaniesProductsExpireDatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesProductsExpireDatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompaniesProductsExpireDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsExpireDatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesProductsExpireDatesAggregateArgs>(args: Subset<T, CompaniesProductsExpireDatesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesProductsExpireDatesAggregateType<T>>

    /**
     * Group by CompaniesProductsExpireDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesProductsExpireDatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompaniesProductsExpireDatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompaniesProductsExpireDatesGroupByArgs['orderBy'] }
        : { orderBy?: CompaniesProductsExpireDatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompaniesProductsExpireDatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesProductsExpireDatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompaniesProductsExpireDates model
   */
  readonly fields: CompaniesProductsExpireDatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompaniesProductsExpireDates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompaniesProductsExpireDatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CompaniesUsers<T extends CompaniesProductsExpireDates$CompaniesUsersArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesProductsExpireDates$CompaniesUsersArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Companies<T extends CompaniesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesDefaultArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Products<T extends ProductsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductsDefaultArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompaniesProductsExpireDates model
   */ 
  interface CompaniesProductsExpireDatesFieldRefs {
    readonly CompaniesProductsExpireDateId: FieldRef<"CompaniesProductsExpireDates", 'String'>
    readonly CreatedAt: FieldRef<"CompaniesProductsExpireDates", 'DateTime'>
    readonly ProductId: FieldRef<"CompaniesProductsExpireDates", 'String'>
    readonly CompanyID: FieldRef<"CompaniesProductsExpireDates", 'String'>
    readonly StartDate: FieldRef<"CompaniesProductsExpireDates", 'DateTime'>
    readonly EndDate: FieldRef<"CompaniesProductsExpireDates", 'DateTime'>
    readonly Comments: FieldRef<"CompaniesProductsExpireDates", 'String'>
    readonly UserId: FieldRef<"CompaniesProductsExpireDates", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompaniesProductsExpireDates findUnique
   */
  export type CompaniesProductsExpireDatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesProductsExpireDates to fetch.
     */
    where: CompaniesProductsExpireDatesWhereUniqueInput
  }

  /**
   * CompaniesProductsExpireDates findUniqueOrThrow
   */
  export type CompaniesProductsExpireDatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesProductsExpireDates to fetch.
     */
    where: CompaniesProductsExpireDatesWhereUniqueInput
  }

  /**
   * CompaniesProductsExpireDates findFirst
   */
  export type CompaniesProductsExpireDatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesProductsExpireDates to fetch.
     */
    where?: CompaniesProductsExpireDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesProductsExpireDates to fetch.
     */
    orderBy?: CompaniesProductsExpireDatesOrderByWithRelationInput | CompaniesProductsExpireDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesProductsExpireDates.
     */
    cursor?: CompaniesProductsExpireDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesProductsExpireDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesProductsExpireDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesProductsExpireDates.
     */
    distinct?: CompaniesProductsExpireDatesScalarFieldEnum | CompaniesProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * CompaniesProductsExpireDates findFirstOrThrow
   */
  export type CompaniesProductsExpireDatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesProductsExpireDates to fetch.
     */
    where?: CompaniesProductsExpireDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesProductsExpireDates to fetch.
     */
    orderBy?: CompaniesProductsExpireDatesOrderByWithRelationInput | CompaniesProductsExpireDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesProductsExpireDates.
     */
    cursor?: CompaniesProductsExpireDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesProductsExpireDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesProductsExpireDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesProductsExpireDates.
     */
    distinct?: CompaniesProductsExpireDatesScalarFieldEnum | CompaniesProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * CompaniesProductsExpireDates findMany
   */
  export type CompaniesProductsExpireDatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesProductsExpireDates to fetch.
     */
    where?: CompaniesProductsExpireDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesProductsExpireDates to fetch.
     */
    orderBy?: CompaniesProductsExpireDatesOrderByWithRelationInput | CompaniesProductsExpireDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompaniesProductsExpireDates.
     */
    cursor?: CompaniesProductsExpireDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesProductsExpireDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesProductsExpireDates.
     */
    skip?: number
    distinct?: CompaniesProductsExpireDatesScalarFieldEnum | CompaniesProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * CompaniesProductsExpireDates create
   */
  export type CompaniesProductsExpireDatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
    /**
     * The data needed to create a CompaniesProductsExpireDates.
     */
    data: XOR<CompaniesProductsExpireDatesCreateInput, CompaniesProductsExpireDatesUncheckedCreateInput>
  }

  /**
   * CompaniesProductsExpireDates createMany
   */
  export type CompaniesProductsExpireDatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompaniesProductsExpireDates.
     */
    data: CompaniesProductsExpireDatesCreateManyInput | CompaniesProductsExpireDatesCreateManyInput[]
  }

  /**
   * CompaniesProductsExpireDates update
   */
  export type CompaniesProductsExpireDatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
    /**
     * The data needed to update a CompaniesProductsExpireDates.
     */
    data: XOR<CompaniesProductsExpireDatesUpdateInput, CompaniesProductsExpireDatesUncheckedUpdateInput>
    /**
     * Choose, which CompaniesProductsExpireDates to update.
     */
    where: CompaniesProductsExpireDatesWhereUniqueInput
  }

  /**
   * CompaniesProductsExpireDates updateMany
   */
  export type CompaniesProductsExpireDatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompaniesProductsExpireDates.
     */
    data: XOR<CompaniesProductsExpireDatesUpdateManyMutationInput, CompaniesProductsExpireDatesUncheckedUpdateManyInput>
    /**
     * Filter which CompaniesProductsExpireDates to update
     */
    where?: CompaniesProductsExpireDatesWhereInput
  }

  /**
   * CompaniesProductsExpireDates upsert
   */
  export type CompaniesProductsExpireDatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
    /**
     * The filter to search for the CompaniesProductsExpireDates to update in case it exists.
     */
    where: CompaniesProductsExpireDatesWhereUniqueInput
    /**
     * In case the CompaniesProductsExpireDates found by the `where` argument doesn't exist, create a new CompaniesProductsExpireDates with this data.
     */
    create: XOR<CompaniesProductsExpireDatesCreateInput, CompaniesProductsExpireDatesUncheckedCreateInput>
    /**
     * In case the CompaniesProductsExpireDates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompaniesProductsExpireDatesUpdateInput, CompaniesProductsExpireDatesUncheckedUpdateInput>
  }

  /**
   * CompaniesProductsExpireDates delete
   */
  export type CompaniesProductsExpireDatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
    /**
     * Filter which CompaniesProductsExpireDates to delete.
     */
    where: CompaniesProductsExpireDatesWhereUniqueInput
  }

  /**
   * CompaniesProductsExpireDates deleteMany
   */
  export type CompaniesProductsExpireDatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesProductsExpireDates to delete
     */
    where?: CompaniesProductsExpireDatesWhereInput
  }

  /**
   * CompaniesProductsExpireDates.CompaniesUsers
   */
  export type CompaniesProductsExpireDates$CompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    where?: CompaniesUsersWhereInput
  }

  /**
   * CompaniesProductsExpireDates without action
   */
  export type CompaniesProductsExpireDatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
  }


  /**
   * Model CompaniesType
   */

  export type AggregateCompaniesType = {
    _count: CompaniesTypeCountAggregateOutputType | null
    _min: CompaniesTypeMinAggregateOutputType | null
    _max: CompaniesTypeMaxAggregateOutputType | null
  }

  export type CompaniesTypeMinAggregateOutputType = {
    CompaniesTypeID: string | null
    CompaniesType: string | null
  }

  export type CompaniesTypeMaxAggregateOutputType = {
    CompaniesTypeID: string | null
    CompaniesType: string | null
  }

  export type CompaniesTypeCountAggregateOutputType = {
    CompaniesTypeID: number
    CompaniesType: number
    _all: number
  }


  export type CompaniesTypeMinAggregateInputType = {
    CompaniesTypeID?: true
    CompaniesType?: true
  }

  export type CompaniesTypeMaxAggregateInputType = {
    CompaniesTypeID?: true
    CompaniesType?: true
  }

  export type CompaniesTypeCountAggregateInputType = {
    CompaniesTypeID?: true
    CompaniesType?: true
    _all?: true
  }

  export type CompaniesTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesType to aggregate.
     */
    where?: CompaniesTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesTypes to fetch.
     */
    orderBy?: CompaniesTypeOrderByWithRelationInput | CompaniesTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompaniesTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompaniesTypes
    **/
    _count?: true | CompaniesTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesTypeMaxAggregateInputType
  }

  export type GetCompaniesTypeAggregateType<T extends CompaniesTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateCompaniesType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompaniesType[P]>
      : GetScalarType<T[P], AggregateCompaniesType[P]>
  }




  export type CompaniesTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesTypeWhereInput
    orderBy?: CompaniesTypeOrderByWithAggregationInput | CompaniesTypeOrderByWithAggregationInput[]
    by: CompaniesTypeScalarFieldEnum[] | CompaniesTypeScalarFieldEnum
    having?: CompaniesTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesTypeCountAggregateInputType | true
    _min?: CompaniesTypeMinAggregateInputType
    _max?: CompaniesTypeMaxAggregateInputType
  }

  export type CompaniesTypeGroupByOutputType = {
    CompaniesTypeID: string
    CompaniesType: string
    _count: CompaniesTypeCountAggregateOutputType | null
    _min: CompaniesTypeMinAggregateOutputType | null
    _max: CompaniesTypeMaxAggregateOutputType | null
  }

  type GetCompaniesTypeGroupByPayload<T extends CompaniesTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesTypeGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesTypeGroupByOutputType[P]>
        }
      >
    >


  export type CompaniesTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CompaniesTypeID?: boolean
    CompaniesType?: boolean
    Companies?: boolean | CompaniesType$CompaniesArgs<ExtArgs>
    _count?: boolean | CompaniesTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companiesType"]>


  export type CompaniesTypeSelectScalar = {
    CompaniesTypeID?: boolean
    CompaniesType?: boolean
  }

  export type CompaniesTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Companies?: boolean | CompaniesType$CompaniesArgs<ExtArgs>
    _count?: boolean | CompaniesTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompaniesTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompaniesType"
    objects: {
      Companies: Prisma.$CompaniesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      CompaniesTypeID: string
      CompaniesType: string
    }, ExtArgs["result"]["companiesType"]>
    composites: {}
  }

  type CompaniesTypeGetPayload<S extends boolean | null | undefined | CompaniesTypeDefaultArgs> = $Result.GetResult<Prisma.$CompaniesTypePayload, S>

  type CompaniesTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompaniesTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompaniesTypeCountAggregateInputType | true
    }

  export interface CompaniesTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompaniesType'], meta: { name: 'CompaniesType' } }
    /**
     * Find zero or one CompaniesType that matches the filter.
     * @param {CompaniesTypeFindUniqueArgs} args - Arguments to find a CompaniesType
     * @example
     * // Get one CompaniesType
     * const companiesType = await prisma.companiesType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompaniesTypeFindUniqueArgs>(args: SelectSubset<T, CompaniesTypeFindUniqueArgs<ExtArgs>>): Prisma__CompaniesTypeClient<$Result.GetResult<Prisma.$CompaniesTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompaniesType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompaniesTypeFindUniqueOrThrowArgs} args - Arguments to find a CompaniesType
     * @example
     * // Get one CompaniesType
     * const companiesType = await prisma.companiesType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompaniesTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, CompaniesTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompaniesTypeClient<$Result.GetResult<Prisma.$CompaniesTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompaniesType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesTypeFindFirstArgs} args - Arguments to find a CompaniesType
     * @example
     * // Get one CompaniesType
     * const companiesType = await prisma.companiesType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompaniesTypeFindFirstArgs>(args?: SelectSubset<T, CompaniesTypeFindFirstArgs<ExtArgs>>): Prisma__CompaniesTypeClient<$Result.GetResult<Prisma.$CompaniesTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompaniesType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesTypeFindFirstOrThrowArgs} args - Arguments to find a CompaniesType
     * @example
     * // Get one CompaniesType
     * const companiesType = await prisma.companiesType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompaniesTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, CompaniesTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompaniesTypeClient<$Result.GetResult<Prisma.$CompaniesTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompaniesTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompaniesTypes
     * const companiesTypes = await prisma.companiesType.findMany()
     * 
     * // Get first 10 CompaniesTypes
     * const companiesTypes = await prisma.companiesType.findMany({ take: 10 })
     * 
     * // Only select the `CompaniesTypeID`
     * const companiesTypeWithCompaniesTypeIDOnly = await prisma.companiesType.findMany({ select: { CompaniesTypeID: true } })
     * 
     */
    findMany<T extends CompaniesTypeFindManyArgs>(args?: SelectSubset<T, CompaniesTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompaniesType.
     * @param {CompaniesTypeCreateArgs} args - Arguments to create a CompaniesType.
     * @example
     * // Create one CompaniesType
     * const CompaniesType = await prisma.companiesType.create({
     *   data: {
     *     // ... data to create a CompaniesType
     *   }
     * })
     * 
     */
    create<T extends CompaniesTypeCreateArgs>(args: SelectSubset<T, CompaniesTypeCreateArgs<ExtArgs>>): Prisma__CompaniesTypeClient<$Result.GetResult<Prisma.$CompaniesTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompaniesTypes.
     * @param {CompaniesTypeCreateManyArgs} args - Arguments to create many CompaniesTypes.
     * @example
     * // Create many CompaniesTypes
     * const companiesType = await prisma.companiesType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompaniesTypeCreateManyArgs>(args?: SelectSubset<T, CompaniesTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompaniesType.
     * @param {CompaniesTypeDeleteArgs} args - Arguments to delete one CompaniesType.
     * @example
     * // Delete one CompaniesType
     * const CompaniesType = await prisma.companiesType.delete({
     *   where: {
     *     // ... filter to delete one CompaniesType
     *   }
     * })
     * 
     */
    delete<T extends CompaniesTypeDeleteArgs>(args: SelectSubset<T, CompaniesTypeDeleteArgs<ExtArgs>>): Prisma__CompaniesTypeClient<$Result.GetResult<Prisma.$CompaniesTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompaniesType.
     * @param {CompaniesTypeUpdateArgs} args - Arguments to update one CompaniesType.
     * @example
     * // Update one CompaniesType
     * const companiesType = await prisma.companiesType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompaniesTypeUpdateArgs>(args: SelectSubset<T, CompaniesTypeUpdateArgs<ExtArgs>>): Prisma__CompaniesTypeClient<$Result.GetResult<Prisma.$CompaniesTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompaniesTypes.
     * @param {CompaniesTypeDeleteManyArgs} args - Arguments to filter CompaniesTypes to delete.
     * @example
     * // Delete a few CompaniesTypes
     * const { count } = await prisma.companiesType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompaniesTypeDeleteManyArgs>(args?: SelectSubset<T, CompaniesTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompaniesTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompaniesTypes
     * const companiesType = await prisma.companiesType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompaniesTypeUpdateManyArgs>(args: SelectSubset<T, CompaniesTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompaniesType.
     * @param {CompaniesTypeUpsertArgs} args - Arguments to update or create a CompaniesType.
     * @example
     * // Update or create a CompaniesType
     * const companiesType = await prisma.companiesType.upsert({
     *   create: {
     *     // ... data to create a CompaniesType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompaniesType we want to update
     *   }
     * })
     */
    upsert<T extends CompaniesTypeUpsertArgs>(args: SelectSubset<T, CompaniesTypeUpsertArgs<ExtArgs>>): Prisma__CompaniesTypeClient<$Result.GetResult<Prisma.$CompaniesTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompaniesTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesTypeCountArgs} args - Arguments to filter CompaniesTypes to count.
     * @example
     * // Count the number of CompaniesTypes
     * const count = await prisma.companiesType.count({
     *   where: {
     *     // ... the filter for the CompaniesTypes we want to count
     *   }
     * })
    **/
    count<T extends CompaniesTypeCountArgs>(
      args?: Subset<T, CompaniesTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompaniesType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesTypeAggregateArgs>(args: Subset<T, CompaniesTypeAggregateArgs>): Prisma.PrismaPromise<GetCompaniesTypeAggregateType<T>>

    /**
     * Group by CompaniesType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompaniesTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompaniesTypeGroupByArgs['orderBy'] }
        : { orderBy?: CompaniesTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompaniesTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompaniesType model
   */
  readonly fields: CompaniesTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompaniesType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompaniesTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Companies<T extends CompaniesType$CompaniesArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesType$CompaniesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompaniesType model
   */ 
  interface CompaniesTypeFieldRefs {
    readonly CompaniesTypeID: FieldRef<"CompaniesType", 'String'>
    readonly CompaniesType: FieldRef<"CompaniesType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompaniesType findUnique
   */
  export type CompaniesTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesType
     */
    select?: CompaniesTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesTypeInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesType to fetch.
     */
    where: CompaniesTypeWhereUniqueInput
  }

  /**
   * CompaniesType findUniqueOrThrow
   */
  export type CompaniesTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesType
     */
    select?: CompaniesTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesTypeInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesType to fetch.
     */
    where: CompaniesTypeWhereUniqueInput
  }

  /**
   * CompaniesType findFirst
   */
  export type CompaniesTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesType
     */
    select?: CompaniesTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesTypeInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesType to fetch.
     */
    where?: CompaniesTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesTypes to fetch.
     */
    orderBy?: CompaniesTypeOrderByWithRelationInput | CompaniesTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesTypes.
     */
    cursor?: CompaniesTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesTypes.
     */
    distinct?: CompaniesTypeScalarFieldEnum | CompaniesTypeScalarFieldEnum[]
  }

  /**
   * CompaniesType findFirstOrThrow
   */
  export type CompaniesTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesType
     */
    select?: CompaniesTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesTypeInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesType to fetch.
     */
    where?: CompaniesTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesTypes to fetch.
     */
    orderBy?: CompaniesTypeOrderByWithRelationInput | CompaniesTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesTypes.
     */
    cursor?: CompaniesTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesTypes.
     */
    distinct?: CompaniesTypeScalarFieldEnum | CompaniesTypeScalarFieldEnum[]
  }

  /**
   * CompaniesType findMany
   */
  export type CompaniesTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesType
     */
    select?: CompaniesTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesTypeInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesTypes to fetch.
     */
    where?: CompaniesTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesTypes to fetch.
     */
    orderBy?: CompaniesTypeOrderByWithRelationInput | CompaniesTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompaniesTypes.
     */
    cursor?: CompaniesTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesTypes.
     */
    skip?: number
    distinct?: CompaniesTypeScalarFieldEnum | CompaniesTypeScalarFieldEnum[]
  }

  /**
   * CompaniesType create
   */
  export type CompaniesTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesType
     */
    select?: CompaniesTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a CompaniesType.
     */
    data: XOR<CompaniesTypeCreateInput, CompaniesTypeUncheckedCreateInput>
  }

  /**
   * CompaniesType createMany
   */
  export type CompaniesTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompaniesTypes.
     */
    data: CompaniesTypeCreateManyInput | CompaniesTypeCreateManyInput[]
  }

  /**
   * CompaniesType update
   */
  export type CompaniesTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesType
     */
    select?: CompaniesTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a CompaniesType.
     */
    data: XOR<CompaniesTypeUpdateInput, CompaniesTypeUncheckedUpdateInput>
    /**
     * Choose, which CompaniesType to update.
     */
    where: CompaniesTypeWhereUniqueInput
  }

  /**
   * CompaniesType updateMany
   */
  export type CompaniesTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompaniesTypes.
     */
    data: XOR<CompaniesTypeUpdateManyMutationInput, CompaniesTypeUncheckedUpdateManyInput>
    /**
     * Filter which CompaniesTypes to update
     */
    where?: CompaniesTypeWhereInput
  }

  /**
   * CompaniesType upsert
   */
  export type CompaniesTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesType
     */
    select?: CompaniesTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the CompaniesType to update in case it exists.
     */
    where: CompaniesTypeWhereUniqueInput
    /**
     * In case the CompaniesType found by the `where` argument doesn't exist, create a new CompaniesType with this data.
     */
    create: XOR<CompaniesTypeCreateInput, CompaniesTypeUncheckedCreateInput>
    /**
     * In case the CompaniesType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompaniesTypeUpdateInput, CompaniesTypeUncheckedUpdateInput>
  }

  /**
   * CompaniesType delete
   */
  export type CompaniesTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesType
     */
    select?: CompaniesTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesTypeInclude<ExtArgs> | null
    /**
     * Filter which CompaniesType to delete.
     */
    where: CompaniesTypeWhereUniqueInput
  }

  /**
   * CompaniesType deleteMany
   */
  export type CompaniesTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesTypes to delete
     */
    where?: CompaniesTypeWhereInput
  }

  /**
   * CompaniesType.Companies
   */
  export type CompaniesType$CompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companies
     */
    select?: CompaniesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesInclude<ExtArgs> | null
    where?: CompaniesWhereInput
    orderBy?: CompaniesOrderByWithRelationInput | CompaniesOrderByWithRelationInput[]
    cursor?: CompaniesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * CompaniesType without action
   */
  export type CompaniesTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesType
     */
    select?: CompaniesTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesTypeInclude<ExtArgs> | null
  }


  /**
   * Model CompaniesUsers
   */

  export type AggregateCompaniesUsers = {
    _count: CompaniesUsersCountAggregateOutputType | null
    _avg: CompaniesUsersAvgAggregateOutputType | null
    _sum: CompaniesUsersSumAggregateOutputType | null
    _min: CompaniesUsersMinAggregateOutputType | null
    _max: CompaniesUsersMaxAggregateOutputType | null
  }

  export type CompaniesUsersAvgAggregateOutputType = {
    CompanyID_OLD: number | null
    JobsID: number | null
    Gender: number | null
    IsAdmin: number | null
    IsAllowAccess2WebSite: number | null
  }

  export type CompaniesUsersSumAggregateOutputType = {
    CompanyID_OLD: number | null
    JobsID: number | null
    Gender: number | null
    IsAdmin: number | null
    IsAllowAccess2WebSite: number | null
  }

  export type CompaniesUsersMinAggregateOutputType = {
    CompaniesUsersID: string | null
    CompanyID: string | null
    CompanyID_OLD: number | null
    EmployeeIdentity: string | null
    BirthDate: Date | null
    LastName: string | null
    FirstName: string | null
    JobsID: number | null
    Gender: number | null
    MobileNumber: string | null
    Phone: string | null
    Fax: string | null
    Email: string | null
    UserName: string | null
    Password: string | null
    AreaMan: string | null
    IsAdmin: number | null
    LastEntry: Date | null
    IsAllowAccess2WebSite: number | null
    UserId: string | null
    CreatedAt: Date | null
    TwoFactorBase32Secret: string | null
    DeviceData: string | null
  }

  export type CompaniesUsersMaxAggregateOutputType = {
    CompaniesUsersID: string | null
    CompanyID: string | null
    CompanyID_OLD: number | null
    EmployeeIdentity: string | null
    BirthDate: Date | null
    LastName: string | null
    FirstName: string | null
    JobsID: number | null
    Gender: number | null
    MobileNumber: string | null
    Phone: string | null
    Fax: string | null
    Email: string | null
    UserName: string | null
    Password: string | null
    AreaMan: string | null
    IsAdmin: number | null
    LastEntry: Date | null
    IsAllowAccess2WebSite: number | null
    UserId: string | null
    CreatedAt: Date | null
    TwoFactorBase32Secret: string | null
    DeviceData: string | null
  }

  export type CompaniesUsersCountAggregateOutputType = {
    CompaniesUsersID: number
    CompanyID: number
    CompanyID_OLD: number
    EmployeeIdentity: number
    BirthDate: number
    LastName: number
    FirstName: number
    JobsID: number
    Gender: number
    MobileNumber: number
    Phone: number
    Fax: number
    Email: number
    UserName: number
    Password: number
    AreaMan: number
    IsAdmin: number
    LastEntry: number
    IsAllowAccess2WebSite: number
    UserId: number
    CreatedAt: number
    TwoFactorBase32Secret: number
    DeviceData: number
    _all: number
  }


  export type CompaniesUsersAvgAggregateInputType = {
    CompanyID_OLD?: true
    JobsID?: true
    Gender?: true
    IsAdmin?: true
    IsAllowAccess2WebSite?: true
  }

  export type CompaniesUsersSumAggregateInputType = {
    CompanyID_OLD?: true
    JobsID?: true
    Gender?: true
    IsAdmin?: true
    IsAllowAccess2WebSite?: true
  }

  export type CompaniesUsersMinAggregateInputType = {
    CompaniesUsersID?: true
    CompanyID?: true
    CompanyID_OLD?: true
    EmployeeIdentity?: true
    BirthDate?: true
    LastName?: true
    FirstName?: true
    JobsID?: true
    Gender?: true
    MobileNumber?: true
    Phone?: true
    Fax?: true
    Email?: true
    UserName?: true
    Password?: true
    AreaMan?: true
    IsAdmin?: true
    LastEntry?: true
    IsAllowAccess2WebSite?: true
    UserId?: true
    CreatedAt?: true
    TwoFactorBase32Secret?: true
    DeviceData?: true
  }

  export type CompaniesUsersMaxAggregateInputType = {
    CompaniesUsersID?: true
    CompanyID?: true
    CompanyID_OLD?: true
    EmployeeIdentity?: true
    BirthDate?: true
    LastName?: true
    FirstName?: true
    JobsID?: true
    Gender?: true
    MobileNumber?: true
    Phone?: true
    Fax?: true
    Email?: true
    UserName?: true
    Password?: true
    AreaMan?: true
    IsAdmin?: true
    LastEntry?: true
    IsAllowAccess2WebSite?: true
    UserId?: true
    CreatedAt?: true
    TwoFactorBase32Secret?: true
    DeviceData?: true
  }

  export type CompaniesUsersCountAggregateInputType = {
    CompaniesUsersID?: true
    CompanyID?: true
    CompanyID_OLD?: true
    EmployeeIdentity?: true
    BirthDate?: true
    LastName?: true
    FirstName?: true
    JobsID?: true
    Gender?: true
    MobileNumber?: true
    Phone?: true
    Fax?: true
    Email?: true
    UserName?: true
    Password?: true
    AreaMan?: true
    IsAdmin?: true
    LastEntry?: true
    IsAllowAccess2WebSite?: true
    UserId?: true
    CreatedAt?: true
    TwoFactorBase32Secret?: true
    DeviceData?: true
    _all?: true
  }

  export type CompaniesUsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesUsers to aggregate.
     */
    where?: CompaniesUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUsers to fetch.
     */
    orderBy?: CompaniesUsersOrderByWithRelationInput | CompaniesUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompaniesUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompaniesUsers
    **/
    _count?: true | CompaniesUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniesUsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniesUsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesUsersMaxAggregateInputType
  }

  export type GetCompaniesUsersAggregateType<T extends CompaniesUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateCompaniesUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompaniesUsers[P]>
      : GetScalarType<T[P], AggregateCompaniesUsers[P]>
  }




  export type CompaniesUsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesUsersWhereInput
    orderBy?: CompaniesUsersOrderByWithAggregationInput | CompaniesUsersOrderByWithAggregationInput[]
    by: CompaniesUsersScalarFieldEnum[] | CompaniesUsersScalarFieldEnum
    having?: CompaniesUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesUsersCountAggregateInputType | true
    _avg?: CompaniesUsersAvgAggregateInputType
    _sum?: CompaniesUsersSumAggregateInputType
    _min?: CompaniesUsersMinAggregateInputType
    _max?: CompaniesUsersMaxAggregateInputType
  }

  export type CompaniesUsersGroupByOutputType = {
    CompaniesUsersID: string
    CompanyID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate: Date | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone: string | null
    Fax: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan: string | null
    IsAdmin: number
    LastEntry: Date | null
    IsAllowAccess2WebSite: number
    UserId: string | null
    CreatedAt: Date | null
    TwoFactorBase32Secret: string | null
    DeviceData: string | null
    _count: CompaniesUsersCountAggregateOutputType | null
    _avg: CompaniesUsersAvgAggregateOutputType | null
    _sum: CompaniesUsersSumAggregateOutputType | null
    _min: CompaniesUsersMinAggregateOutputType | null
    _max: CompaniesUsersMaxAggregateOutputType | null
  }

  type GetCompaniesUsersGroupByPayload<T extends CompaniesUsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesUsersGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesUsersGroupByOutputType[P]>
        }
      >
    >


  export type CompaniesUsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CompaniesUsersID?: boolean
    CompanyID?: boolean
    CompanyID_OLD?: boolean
    EmployeeIdentity?: boolean
    BirthDate?: boolean
    LastName?: boolean
    FirstName?: boolean
    JobsID?: boolean
    Gender?: boolean
    MobileNumber?: boolean
    Phone?: boolean
    Fax?: boolean
    Email?: boolean
    UserName?: boolean
    Password?: boolean
    AreaMan?: boolean
    IsAdmin?: boolean
    LastEntry?: boolean
    IsAllowAccess2WebSite?: boolean
    UserId?: boolean
    CreatedAt?: boolean
    TwoFactorBase32Secret?: boolean
    DeviceData?: boolean
    Companies_Companies_UserIdToCompaniesUsers?: boolean | CompaniesUsers$Companies_Companies_UserIdToCompaniesUsersArgs<ExtArgs>
    CompaniesProducts?: boolean | CompaniesUsers$CompaniesProductsArgs<ExtArgs>
    CompaniesProductsExpireDates?: boolean | CompaniesUsers$CompaniesProductsExpireDatesArgs<ExtArgs>
    CompaniesUsers?: boolean | CompaniesUsers$CompaniesUsersArgs<ExtArgs>
    other_CompaniesUsers?: boolean | CompaniesUsers$other_CompaniesUsersArgs<ExtArgs>
    Companies_CompaniesUsers_CompanyIDToCompanies?: boolean | CompaniesDefaultArgs<ExtArgs>
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: boolean | CompaniesUsers$CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersArgs<ExtArgs>
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: boolean | CompaniesUsers$CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersArgs<ExtArgs>
    _count?: boolean | CompaniesUsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companiesUsers"]>


  export type CompaniesUsersSelectScalar = {
    CompaniesUsersID?: boolean
    CompanyID?: boolean
    CompanyID_OLD?: boolean
    EmployeeIdentity?: boolean
    BirthDate?: boolean
    LastName?: boolean
    FirstName?: boolean
    JobsID?: boolean
    Gender?: boolean
    MobileNumber?: boolean
    Phone?: boolean
    Fax?: boolean
    Email?: boolean
    UserName?: boolean
    Password?: boolean
    AreaMan?: boolean
    IsAdmin?: boolean
    LastEntry?: boolean
    IsAllowAccess2WebSite?: boolean
    UserId?: boolean
    CreatedAt?: boolean
    TwoFactorBase32Secret?: boolean
    DeviceData?: boolean
  }

  export type CompaniesUsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Companies_Companies_UserIdToCompaniesUsers?: boolean | CompaniesUsers$Companies_Companies_UserIdToCompaniesUsersArgs<ExtArgs>
    CompaniesProducts?: boolean | CompaniesUsers$CompaniesProductsArgs<ExtArgs>
    CompaniesProductsExpireDates?: boolean | CompaniesUsers$CompaniesProductsExpireDatesArgs<ExtArgs>
    CompaniesUsers?: boolean | CompaniesUsers$CompaniesUsersArgs<ExtArgs>
    other_CompaniesUsers?: boolean | CompaniesUsers$other_CompaniesUsersArgs<ExtArgs>
    Companies_CompaniesUsers_CompanyIDToCompanies?: boolean | CompaniesDefaultArgs<ExtArgs>
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: boolean | CompaniesUsers$CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersArgs<ExtArgs>
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: boolean | CompaniesUsers$CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersArgs<ExtArgs>
    _count?: boolean | CompaniesUsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompaniesUsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompaniesUsers"
    objects: {
      Companies_Companies_UserIdToCompaniesUsers: Prisma.$CompaniesPayload<ExtArgs>[]
      CompaniesProducts: Prisma.$CompaniesProductsPayload<ExtArgs>[]
      CompaniesProductsExpireDates: Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>[]
      CompaniesUsers: Prisma.$CompaniesUsersPayload<ExtArgs> | null
      other_CompaniesUsers: Prisma.$CompaniesUsersPayload<ExtArgs>[]
      Companies_CompaniesUsers_CompanyIDToCompanies: Prisma.$CompaniesPayload<ExtArgs>
      CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers: Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>[]
      CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers: Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      CompaniesUsersID: string
      CompanyID: string
      CompanyID_OLD: number
      EmployeeIdentity: string
      BirthDate: Date | null
      LastName: string
      FirstName: string
      JobsID: number
      Gender: number
      MobileNumber: string
      Phone: string | null
      Fax: string | null
      Email: string
      UserName: string
      Password: string
      AreaMan: string | null
      IsAdmin: number
      LastEntry: Date | null
      IsAllowAccess2WebSite: number
      UserId: string | null
      CreatedAt: Date | null
      TwoFactorBase32Secret: string | null
      DeviceData: string | null
    }, ExtArgs["result"]["companiesUsers"]>
    composites: {}
  }

  type CompaniesUsersGetPayload<S extends boolean | null | undefined | CompaniesUsersDefaultArgs> = $Result.GetResult<Prisma.$CompaniesUsersPayload, S>

  type CompaniesUsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompaniesUsersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompaniesUsersCountAggregateInputType | true
    }

  export interface CompaniesUsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompaniesUsers'], meta: { name: 'CompaniesUsers' } }
    /**
     * Find zero or one CompaniesUsers that matches the filter.
     * @param {CompaniesUsersFindUniqueArgs} args - Arguments to find a CompaniesUsers
     * @example
     * // Get one CompaniesUsers
     * const companiesUsers = await prisma.companiesUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompaniesUsersFindUniqueArgs>(args: SelectSubset<T, CompaniesUsersFindUniqueArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompaniesUsers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompaniesUsersFindUniqueOrThrowArgs} args - Arguments to find a CompaniesUsers
     * @example
     * // Get one CompaniesUsers
     * const companiesUsers = await prisma.companiesUsers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompaniesUsersFindUniqueOrThrowArgs>(args: SelectSubset<T, CompaniesUsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompaniesUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersFindFirstArgs} args - Arguments to find a CompaniesUsers
     * @example
     * // Get one CompaniesUsers
     * const companiesUsers = await prisma.companiesUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompaniesUsersFindFirstArgs>(args?: SelectSubset<T, CompaniesUsersFindFirstArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompaniesUsers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersFindFirstOrThrowArgs} args - Arguments to find a CompaniesUsers
     * @example
     * // Get one CompaniesUsers
     * const companiesUsers = await prisma.companiesUsers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompaniesUsersFindFirstOrThrowArgs>(args?: SelectSubset<T, CompaniesUsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompaniesUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompaniesUsers
     * const companiesUsers = await prisma.companiesUsers.findMany()
     * 
     * // Get first 10 CompaniesUsers
     * const companiesUsers = await prisma.companiesUsers.findMany({ take: 10 })
     * 
     * // Only select the `CompaniesUsersID`
     * const companiesUsersWithCompaniesUsersIDOnly = await prisma.companiesUsers.findMany({ select: { CompaniesUsersID: true } })
     * 
     */
    findMany<T extends CompaniesUsersFindManyArgs>(args?: SelectSubset<T, CompaniesUsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompaniesUsers.
     * @param {CompaniesUsersCreateArgs} args - Arguments to create a CompaniesUsers.
     * @example
     * // Create one CompaniesUsers
     * const CompaniesUsers = await prisma.companiesUsers.create({
     *   data: {
     *     // ... data to create a CompaniesUsers
     *   }
     * })
     * 
     */
    create<T extends CompaniesUsersCreateArgs>(args: SelectSubset<T, CompaniesUsersCreateArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompaniesUsers.
     * @param {CompaniesUsersCreateManyArgs} args - Arguments to create many CompaniesUsers.
     * @example
     * // Create many CompaniesUsers
     * const companiesUsers = await prisma.companiesUsers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompaniesUsersCreateManyArgs>(args?: SelectSubset<T, CompaniesUsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompaniesUsers.
     * @param {CompaniesUsersDeleteArgs} args - Arguments to delete one CompaniesUsers.
     * @example
     * // Delete one CompaniesUsers
     * const CompaniesUsers = await prisma.companiesUsers.delete({
     *   where: {
     *     // ... filter to delete one CompaniesUsers
     *   }
     * })
     * 
     */
    delete<T extends CompaniesUsersDeleteArgs>(args: SelectSubset<T, CompaniesUsersDeleteArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompaniesUsers.
     * @param {CompaniesUsersUpdateArgs} args - Arguments to update one CompaniesUsers.
     * @example
     * // Update one CompaniesUsers
     * const companiesUsers = await prisma.companiesUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompaniesUsersUpdateArgs>(args: SelectSubset<T, CompaniesUsersUpdateArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompaniesUsers.
     * @param {CompaniesUsersDeleteManyArgs} args - Arguments to filter CompaniesUsers to delete.
     * @example
     * // Delete a few CompaniesUsers
     * const { count } = await prisma.companiesUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompaniesUsersDeleteManyArgs>(args?: SelectSubset<T, CompaniesUsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompaniesUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompaniesUsers
     * const companiesUsers = await prisma.companiesUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompaniesUsersUpdateManyArgs>(args: SelectSubset<T, CompaniesUsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompaniesUsers.
     * @param {CompaniesUsersUpsertArgs} args - Arguments to update or create a CompaniesUsers.
     * @example
     * // Update or create a CompaniesUsers
     * const companiesUsers = await prisma.companiesUsers.upsert({
     *   create: {
     *     // ... data to create a CompaniesUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompaniesUsers we want to update
     *   }
     * })
     */
    upsert<T extends CompaniesUsersUpsertArgs>(args: SelectSubset<T, CompaniesUsersUpsertArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompaniesUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersCountArgs} args - Arguments to filter CompaniesUsers to count.
     * @example
     * // Count the number of CompaniesUsers
     * const count = await prisma.companiesUsers.count({
     *   where: {
     *     // ... the filter for the CompaniesUsers we want to count
     *   }
     * })
    **/
    count<T extends CompaniesUsersCountArgs>(
      args?: Subset<T, CompaniesUsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompaniesUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesUsersAggregateArgs>(args: Subset<T, CompaniesUsersAggregateArgs>): Prisma.PrismaPromise<GetCompaniesUsersAggregateType<T>>

    /**
     * Group by CompaniesUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompaniesUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompaniesUsersGroupByArgs['orderBy'] }
        : { orderBy?: CompaniesUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompaniesUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompaniesUsers model
   */
  readonly fields: CompaniesUsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompaniesUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompaniesUsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Companies_Companies_UserIdToCompaniesUsers<T extends CompaniesUsers$Companies_Companies_UserIdToCompaniesUsersArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUsers$Companies_Companies_UserIdToCompaniesUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "findMany"> | Null>
    CompaniesProducts<T extends CompaniesUsers$CompaniesProductsArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUsers$CompaniesProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesProductsPayload<ExtArgs>, T, "findMany"> | Null>
    CompaniesProductsExpireDates<T extends CompaniesUsers$CompaniesProductsExpireDatesArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUsers$CompaniesProductsExpireDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>, T, "findMany"> | Null>
    CompaniesUsers<T extends CompaniesUsers$CompaniesUsersArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUsers$CompaniesUsersArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    other_CompaniesUsers<T extends CompaniesUsers$other_CompaniesUsersArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUsers$other_CompaniesUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findMany"> | Null>
    Companies_CompaniesUsers_CompanyIDToCompanies<T extends CompaniesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesDefaultArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers<T extends CompaniesUsers$CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUsers$CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "findMany"> | Null>
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers<T extends CompaniesUsers$CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUsers$CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompaniesUsers model
   */ 
  interface CompaniesUsersFieldRefs {
    readonly CompaniesUsersID: FieldRef<"CompaniesUsers", 'String'>
    readonly CompanyID: FieldRef<"CompaniesUsers", 'String'>
    readonly CompanyID_OLD: FieldRef<"CompaniesUsers", 'Int'>
    readonly EmployeeIdentity: FieldRef<"CompaniesUsers", 'String'>
    readonly BirthDate: FieldRef<"CompaniesUsers", 'DateTime'>
    readonly LastName: FieldRef<"CompaniesUsers", 'String'>
    readonly FirstName: FieldRef<"CompaniesUsers", 'String'>
    readonly JobsID: FieldRef<"CompaniesUsers", 'Int'>
    readonly Gender: FieldRef<"CompaniesUsers", 'Int'>
    readonly MobileNumber: FieldRef<"CompaniesUsers", 'String'>
    readonly Phone: FieldRef<"CompaniesUsers", 'String'>
    readonly Fax: FieldRef<"CompaniesUsers", 'String'>
    readonly Email: FieldRef<"CompaniesUsers", 'String'>
    readonly UserName: FieldRef<"CompaniesUsers", 'String'>
    readonly Password: FieldRef<"CompaniesUsers", 'String'>
    readonly AreaMan: FieldRef<"CompaniesUsers", 'String'>
    readonly IsAdmin: FieldRef<"CompaniesUsers", 'Int'>
    readonly LastEntry: FieldRef<"CompaniesUsers", 'DateTime'>
    readonly IsAllowAccess2WebSite: FieldRef<"CompaniesUsers", 'Int'>
    readonly UserId: FieldRef<"CompaniesUsers", 'String'>
    readonly CreatedAt: FieldRef<"CompaniesUsers", 'DateTime'>
    readonly TwoFactorBase32Secret: FieldRef<"CompaniesUsers", 'String'>
    readonly DeviceData: FieldRef<"CompaniesUsers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompaniesUsers findUnique
   */
  export type CompaniesUsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUsers to fetch.
     */
    where: CompaniesUsersWhereUniqueInput
  }

  /**
   * CompaniesUsers findUniqueOrThrow
   */
  export type CompaniesUsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUsers to fetch.
     */
    where: CompaniesUsersWhereUniqueInput
  }

  /**
   * CompaniesUsers findFirst
   */
  export type CompaniesUsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUsers to fetch.
     */
    where?: CompaniesUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUsers to fetch.
     */
    orderBy?: CompaniesUsersOrderByWithRelationInput | CompaniesUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesUsers.
     */
    cursor?: CompaniesUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesUsers.
     */
    distinct?: CompaniesUsersScalarFieldEnum | CompaniesUsersScalarFieldEnum[]
  }

  /**
   * CompaniesUsers findFirstOrThrow
   */
  export type CompaniesUsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUsers to fetch.
     */
    where?: CompaniesUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUsers to fetch.
     */
    orderBy?: CompaniesUsersOrderByWithRelationInput | CompaniesUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesUsers.
     */
    cursor?: CompaniesUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesUsers.
     */
    distinct?: CompaniesUsersScalarFieldEnum | CompaniesUsersScalarFieldEnum[]
  }

  /**
   * CompaniesUsers findMany
   */
  export type CompaniesUsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUsers to fetch.
     */
    where?: CompaniesUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUsers to fetch.
     */
    orderBy?: CompaniesUsersOrderByWithRelationInput | CompaniesUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompaniesUsers.
     */
    cursor?: CompaniesUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUsers.
     */
    skip?: number
    distinct?: CompaniesUsersScalarFieldEnum | CompaniesUsersScalarFieldEnum[]
  }

  /**
   * CompaniesUsers create
   */
  export type CompaniesUsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    /**
     * The data needed to create a CompaniesUsers.
     */
    data: XOR<CompaniesUsersCreateInput, CompaniesUsersUncheckedCreateInput>
  }

  /**
   * CompaniesUsers createMany
   */
  export type CompaniesUsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompaniesUsers.
     */
    data: CompaniesUsersCreateManyInput | CompaniesUsersCreateManyInput[]
  }

  /**
   * CompaniesUsers update
   */
  export type CompaniesUsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    /**
     * The data needed to update a CompaniesUsers.
     */
    data: XOR<CompaniesUsersUpdateInput, CompaniesUsersUncheckedUpdateInput>
    /**
     * Choose, which CompaniesUsers to update.
     */
    where: CompaniesUsersWhereUniqueInput
  }

  /**
   * CompaniesUsers updateMany
   */
  export type CompaniesUsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompaniesUsers.
     */
    data: XOR<CompaniesUsersUpdateManyMutationInput, CompaniesUsersUncheckedUpdateManyInput>
    /**
     * Filter which CompaniesUsers to update
     */
    where?: CompaniesUsersWhereInput
  }

  /**
   * CompaniesUsers upsert
   */
  export type CompaniesUsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    /**
     * The filter to search for the CompaniesUsers to update in case it exists.
     */
    where: CompaniesUsersWhereUniqueInput
    /**
     * In case the CompaniesUsers found by the `where` argument doesn't exist, create a new CompaniesUsers with this data.
     */
    create: XOR<CompaniesUsersCreateInput, CompaniesUsersUncheckedCreateInput>
    /**
     * In case the CompaniesUsers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompaniesUsersUpdateInput, CompaniesUsersUncheckedUpdateInput>
  }

  /**
   * CompaniesUsers delete
   */
  export type CompaniesUsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    /**
     * Filter which CompaniesUsers to delete.
     */
    where: CompaniesUsersWhereUniqueInput
  }

  /**
   * CompaniesUsers deleteMany
   */
  export type CompaniesUsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesUsers to delete
     */
    where?: CompaniesUsersWhereInput
  }

  /**
   * CompaniesUsers.Companies_Companies_UserIdToCompaniesUsers
   */
  export type CompaniesUsers$Companies_Companies_UserIdToCompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companies
     */
    select?: CompaniesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesInclude<ExtArgs> | null
    where?: CompaniesWhereInput
    orderBy?: CompaniesOrderByWithRelationInput | CompaniesOrderByWithRelationInput[]
    cursor?: CompaniesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * CompaniesUsers.CompaniesProducts
   */
  export type CompaniesUsers$CompaniesProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
    where?: CompaniesProductsWhereInput
    orderBy?: CompaniesProductsOrderByWithRelationInput | CompaniesProductsOrderByWithRelationInput[]
    cursor?: CompaniesProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesProductsScalarFieldEnum | CompaniesProductsScalarFieldEnum[]
  }

  /**
   * CompaniesUsers.CompaniesProductsExpireDates
   */
  export type CompaniesUsers$CompaniesProductsExpireDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
    where?: CompaniesProductsExpireDatesWhereInput
    orderBy?: CompaniesProductsExpireDatesOrderByWithRelationInput | CompaniesProductsExpireDatesOrderByWithRelationInput[]
    cursor?: CompaniesProductsExpireDatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesProductsExpireDatesScalarFieldEnum | CompaniesProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * CompaniesUsers.CompaniesUsers
   */
  export type CompaniesUsers$CompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    where?: CompaniesUsersWhereInput
  }

  /**
   * CompaniesUsers.other_CompaniesUsers
   */
  export type CompaniesUsers$other_CompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    where?: CompaniesUsersWhereInput
    orderBy?: CompaniesUsersOrderByWithRelationInput | CompaniesUsersOrderByWithRelationInput[]
    cursor?: CompaniesUsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesUsersScalarFieldEnum | CompaniesUsersScalarFieldEnum[]
  }

  /**
   * CompaniesUsers.CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers
   */
  export type CompaniesUsers$CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    where?: CompaniesUsersProductsExpireDatesWhereInput
    orderBy?: CompaniesUsersProductsExpireDatesOrderByWithRelationInput | CompaniesUsersProductsExpireDatesOrderByWithRelationInput[]
    cursor?: CompaniesUsersProductsExpireDatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesUsersProductsExpireDatesScalarFieldEnum | CompaniesUsersProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * CompaniesUsers.CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers
   */
  export type CompaniesUsers$CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    where?: CompaniesUsersProductsExpireDatesWhereInput
    orderBy?: CompaniesUsersProductsExpireDatesOrderByWithRelationInput | CompaniesUsersProductsExpireDatesOrderByWithRelationInput[]
    cursor?: CompaniesUsersProductsExpireDatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesUsersProductsExpireDatesScalarFieldEnum | CompaniesUsersProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * CompaniesUsers without action
   */
  export type CompaniesUsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
  }


  /**
   * Model CompaniesUsersProductsExpireDates
   */

  export type AggregateCompaniesUsersProductsExpireDates = {
    _count: CompaniesUsersProductsExpireDatesCountAggregateOutputType | null
    _min: CompaniesUsersProductsExpireDatesMinAggregateOutputType | null
    _max: CompaniesUsersProductsExpireDatesMaxAggregateOutputType | null
  }

  export type CompaniesUsersProductsExpireDatesMinAggregateOutputType = {
    CompaniesUsersProductsExpireDateId: string | null
    CreatedAt: Date | null
    ProductId: string | null
    CompanyID: string | null
    CompaniesUsersID: string | null
    StartDate: Date | null
    EndDate: Date | null
    UserId: string | null
    Comments: string | null
  }

  export type CompaniesUsersProductsExpireDatesMaxAggregateOutputType = {
    CompaniesUsersProductsExpireDateId: string | null
    CreatedAt: Date | null
    ProductId: string | null
    CompanyID: string | null
    CompaniesUsersID: string | null
    StartDate: Date | null
    EndDate: Date | null
    UserId: string | null
    Comments: string | null
  }

  export type CompaniesUsersProductsExpireDatesCountAggregateOutputType = {
    CompaniesUsersProductsExpireDateId: number
    CreatedAt: number
    ProductId: number
    CompanyID: number
    CompaniesUsersID: number
    StartDate: number
    EndDate: number
    UserId: number
    Comments: number
    _all: number
  }


  export type CompaniesUsersProductsExpireDatesMinAggregateInputType = {
    CompaniesUsersProductsExpireDateId?: true
    CreatedAt?: true
    ProductId?: true
    CompanyID?: true
    CompaniesUsersID?: true
    StartDate?: true
    EndDate?: true
    UserId?: true
    Comments?: true
  }

  export type CompaniesUsersProductsExpireDatesMaxAggregateInputType = {
    CompaniesUsersProductsExpireDateId?: true
    CreatedAt?: true
    ProductId?: true
    CompanyID?: true
    CompaniesUsersID?: true
    StartDate?: true
    EndDate?: true
    UserId?: true
    Comments?: true
  }

  export type CompaniesUsersProductsExpireDatesCountAggregateInputType = {
    CompaniesUsersProductsExpireDateId?: true
    CreatedAt?: true
    ProductId?: true
    CompanyID?: true
    CompaniesUsersID?: true
    StartDate?: true
    EndDate?: true
    UserId?: true
    Comments?: true
    _all?: true
  }

  export type CompaniesUsersProductsExpireDatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesUsersProductsExpireDates to aggregate.
     */
    where?: CompaniesUsersProductsExpireDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUsersProductsExpireDates to fetch.
     */
    orderBy?: CompaniesUsersProductsExpireDatesOrderByWithRelationInput | CompaniesUsersProductsExpireDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompaniesUsersProductsExpireDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUsersProductsExpireDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUsersProductsExpireDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompaniesUsersProductsExpireDates
    **/
    _count?: true | CompaniesUsersProductsExpireDatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesUsersProductsExpireDatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesUsersProductsExpireDatesMaxAggregateInputType
  }

  export type GetCompaniesUsersProductsExpireDatesAggregateType<T extends CompaniesUsersProductsExpireDatesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompaniesUsersProductsExpireDates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompaniesUsersProductsExpireDates[P]>
      : GetScalarType<T[P], AggregateCompaniesUsersProductsExpireDates[P]>
  }




  export type CompaniesUsersProductsExpireDatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesUsersProductsExpireDatesWhereInput
    orderBy?: CompaniesUsersProductsExpireDatesOrderByWithAggregationInput | CompaniesUsersProductsExpireDatesOrderByWithAggregationInput[]
    by: CompaniesUsersProductsExpireDatesScalarFieldEnum[] | CompaniesUsersProductsExpireDatesScalarFieldEnum
    having?: CompaniesUsersProductsExpireDatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesUsersProductsExpireDatesCountAggregateInputType | true
    _min?: CompaniesUsersProductsExpireDatesMinAggregateInputType
    _max?: CompaniesUsersProductsExpireDatesMaxAggregateInputType
  }

  export type CompaniesUsersProductsExpireDatesGroupByOutputType = {
    CompaniesUsersProductsExpireDateId: string
    CreatedAt: Date | null
    ProductId: string
    CompanyID: string
    CompaniesUsersID: string
    StartDate: Date
    EndDate: Date
    UserId: string | null
    Comments: string | null
    _count: CompaniesUsersProductsExpireDatesCountAggregateOutputType | null
    _min: CompaniesUsersProductsExpireDatesMinAggregateOutputType | null
    _max: CompaniesUsersProductsExpireDatesMaxAggregateOutputType | null
  }

  type GetCompaniesUsersProductsExpireDatesGroupByPayload<T extends CompaniesUsersProductsExpireDatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesUsersProductsExpireDatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesUsersProductsExpireDatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesUsersProductsExpireDatesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesUsersProductsExpireDatesGroupByOutputType[P]>
        }
      >
    >


  export type CompaniesUsersProductsExpireDatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CompaniesUsersProductsExpireDateId?: boolean
    CreatedAt?: boolean
    ProductId?: boolean
    CompanyID?: boolean
    CompaniesUsersID?: boolean
    StartDate?: boolean
    EndDate?: boolean
    UserId?: boolean
    Comments?: boolean
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: boolean | CompaniesUsersDefaultArgs<ExtArgs>
    Companies?: boolean | CompaniesDefaultArgs<ExtArgs>
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: boolean | CompaniesUsersProductsExpireDates$CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersArgs<ExtArgs>
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companiesUsersProductsExpireDates"]>


  export type CompaniesUsersProductsExpireDatesSelectScalar = {
    CompaniesUsersProductsExpireDateId?: boolean
    CreatedAt?: boolean
    ProductId?: boolean
    CompanyID?: boolean
    CompaniesUsersID?: boolean
    StartDate?: boolean
    EndDate?: boolean
    UserId?: boolean
    Comments?: boolean
  }

  export type CompaniesUsersProductsExpireDatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: boolean | CompaniesUsersDefaultArgs<ExtArgs>
    Companies?: boolean | CompaniesDefaultArgs<ExtArgs>
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: boolean | CompaniesUsersProductsExpireDates$CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersArgs<ExtArgs>
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
  }

  export type $CompaniesUsersProductsExpireDatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompaniesUsersProductsExpireDates"
    objects: {
      CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers: Prisma.$CompaniesUsersPayload<ExtArgs>
      Companies: Prisma.$CompaniesPayload<ExtArgs>
      CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers: Prisma.$CompaniesUsersPayload<ExtArgs> | null
      Products: Prisma.$ProductsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      CompaniesUsersProductsExpireDateId: string
      CreatedAt: Date | null
      ProductId: string
      CompanyID: string
      CompaniesUsersID: string
      StartDate: Date
      EndDate: Date
      UserId: string | null
      Comments: string | null
    }, ExtArgs["result"]["companiesUsersProductsExpireDates"]>
    composites: {}
  }

  type CompaniesUsersProductsExpireDatesGetPayload<S extends boolean | null | undefined | CompaniesUsersProductsExpireDatesDefaultArgs> = $Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload, S>

  type CompaniesUsersProductsExpireDatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompaniesUsersProductsExpireDatesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompaniesUsersProductsExpireDatesCountAggregateInputType | true
    }

  export interface CompaniesUsersProductsExpireDatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompaniesUsersProductsExpireDates'], meta: { name: 'CompaniesUsersProductsExpireDates' } }
    /**
     * Find zero or one CompaniesUsersProductsExpireDates that matches the filter.
     * @param {CompaniesUsersProductsExpireDatesFindUniqueArgs} args - Arguments to find a CompaniesUsersProductsExpireDates
     * @example
     * // Get one CompaniesUsersProductsExpireDates
     * const companiesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompaniesUsersProductsExpireDatesFindUniqueArgs>(args: SelectSubset<T, CompaniesUsersProductsExpireDatesFindUniqueArgs<ExtArgs>>): Prisma__CompaniesUsersProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompaniesUsersProductsExpireDates that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompaniesUsersProductsExpireDatesFindUniqueOrThrowArgs} args - Arguments to find a CompaniesUsersProductsExpireDates
     * @example
     * // Get one CompaniesUsersProductsExpireDates
     * const companiesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompaniesUsersProductsExpireDatesFindUniqueOrThrowArgs>(args: SelectSubset<T, CompaniesUsersProductsExpireDatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompaniesUsersProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompaniesUsersProductsExpireDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersProductsExpireDatesFindFirstArgs} args - Arguments to find a CompaniesUsersProductsExpireDates
     * @example
     * // Get one CompaniesUsersProductsExpireDates
     * const companiesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompaniesUsersProductsExpireDatesFindFirstArgs>(args?: SelectSubset<T, CompaniesUsersProductsExpireDatesFindFirstArgs<ExtArgs>>): Prisma__CompaniesUsersProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompaniesUsersProductsExpireDates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersProductsExpireDatesFindFirstOrThrowArgs} args - Arguments to find a CompaniesUsersProductsExpireDates
     * @example
     * // Get one CompaniesUsersProductsExpireDates
     * const companiesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompaniesUsersProductsExpireDatesFindFirstOrThrowArgs>(args?: SelectSubset<T, CompaniesUsersProductsExpireDatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompaniesUsersProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompaniesUsersProductsExpireDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersProductsExpireDatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompaniesUsersProductsExpireDates
     * const companiesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.findMany()
     * 
     * // Get first 10 CompaniesUsersProductsExpireDates
     * const companiesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.findMany({ take: 10 })
     * 
     * // Only select the `CompaniesUsersProductsExpireDateId`
     * const companiesUsersProductsExpireDatesWithCompaniesUsersProductsExpireDateIdOnly = await prisma.companiesUsersProductsExpireDates.findMany({ select: { CompaniesUsersProductsExpireDateId: true } })
     * 
     */
    findMany<T extends CompaniesUsersProductsExpireDatesFindManyArgs>(args?: SelectSubset<T, CompaniesUsersProductsExpireDatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompaniesUsersProductsExpireDates.
     * @param {CompaniesUsersProductsExpireDatesCreateArgs} args - Arguments to create a CompaniesUsersProductsExpireDates.
     * @example
     * // Create one CompaniesUsersProductsExpireDates
     * const CompaniesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.create({
     *   data: {
     *     // ... data to create a CompaniesUsersProductsExpireDates
     *   }
     * })
     * 
     */
    create<T extends CompaniesUsersProductsExpireDatesCreateArgs>(args: SelectSubset<T, CompaniesUsersProductsExpireDatesCreateArgs<ExtArgs>>): Prisma__CompaniesUsersProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompaniesUsersProductsExpireDates.
     * @param {CompaniesUsersProductsExpireDatesCreateManyArgs} args - Arguments to create many CompaniesUsersProductsExpireDates.
     * @example
     * // Create many CompaniesUsersProductsExpireDates
     * const companiesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompaniesUsersProductsExpireDatesCreateManyArgs>(args?: SelectSubset<T, CompaniesUsersProductsExpireDatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompaniesUsersProductsExpireDates.
     * @param {CompaniesUsersProductsExpireDatesDeleteArgs} args - Arguments to delete one CompaniesUsersProductsExpireDates.
     * @example
     * // Delete one CompaniesUsersProductsExpireDates
     * const CompaniesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.delete({
     *   where: {
     *     // ... filter to delete one CompaniesUsersProductsExpireDates
     *   }
     * })
     * 
     */
    delete<T extends CompaniesUsersProductsExpireDatesDeleteArgs>(args: SelectSubset<T, CompaniesUsersProductsExpireDatesDeleteArgs<ExtArgs>>): Prisma__CompaniesUsersProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompaniesUsersProductsExpireDates.
     * @param {CompaniesUsersProductsExpireDatesUpdateArgs} args - Arguments to update one CompaniesUsersProductsExpireDates.
     * @example
     * // Update one CompaniesUsersProductsExpireDates
     * const companiesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompaniesUsersProductsExpireDatesUpdateArgs>(args: SelectSubset<T, CompaniesUsersProductsExpireDatesUpdateArgs<ExtArgs>>): Prisma__CompaniesUsersProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompaniesUsersProductsExpireDates.
     * @param {CompaniesUsersProductsExpireDatesDeleteManyArgs} args - Arguments to filter CompaniesUsersProductsExpireDates to delete.
     * @example
     * // Delete a few CompaniesUsersProductsExpireDates
     * const { count } = await prisma.companiesUsersProductsExpireDates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompaniesUsersProductsExpireDatesDeleteManyArgs>(args?: SelectSubset<T, CompaniesUsersProductsExpireDatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompaniesUsersProductsExpireDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersProductsExpireDatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompaniesUsersProductsExpireDates
     * const companiesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompaniesUsersProductsExpireDatesUpdateManyArgs>(args: SelectSubset<T, CompaniesUsersProductsExpireDatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompaniesUsersProductsExpireDates.
     * @param {CompaniesUsersProductsExpireDatesUpsertArgs} args - Arguments to update or create a CompaniesUsersProductsExpireDates.
     * @example
     * // Update or create a CompaniesUsersProductsExpireDates
     * const companiesUsersProductsExpireDates = await prisma.companiesUsersProductsExpireDates.upsert({
     *   create: {
     *     // ... data to create a CompaniesUsersProductsExpireDates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompaniesUsersProductsExpireDates we want to update
     *   }
     * })
     */
    upsert<T extends CompaniesUsersProductsExpireDatesUpsertArgs>(args: SelectSubset<T, CompaniesUsersProductsExpireDatesUpsertArgs<ExtArgs>>): Prisma__CompaniesUsersProductsExpireDatesClient<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompaniesUsersProductsExpireDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersProductsExpireDatesCountArgs} args - Arguments to filter CompaniesUsersProductsExpireDates to count.
     * @example
     * // Count the number of CompaniesUsersProductsExpireDates
     * const count = await prisma.companiesUsersProductsExpireDates.count({
     *   where: {
     *     // ... the filter for the CompaniesUsersProductsExpireDates we want to count
     *   }
     * })
    **/
    count<T extends CompaniesUsersProductsExpireDatesCountArgs>(
      args?: Subset<T, CompaniesUsersProductsExpireDatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesUsersProductsExpireDatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompaniesUsersProductsExpireDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersProductsExpireDatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesUsersProductsExpireDatesAggregateArgs>(args: Subset<T, CompaniesUsersProductsExpireDatesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesUsersProductsExpireDatesAggregateType<T>>

    /**
     * Group by CompaniesUsersProductsExpireDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUsersProductsExpireDatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompaniesUsersProductsExpireDatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompaniesUsersProductsExpireDatesGroupByArgs['orderBy'] }
        : { orderBy?: CompaniesUsersProductsExpireDatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompaniesUsersProductsExpireDatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesUsersProductsExpireDatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompaniesUsersProductsExpireDates model
   */
  readonly fields: CompaniesUsersProductsExpireDatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompaniesUsersProductsExpireDates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompaniesUsersProductsExpireDatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers<T extends CompaniesUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUsersDefaultArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Companies<T extends CompaniesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesDefaultArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers<T extends CompaniesUsersProductsExpireDates$CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUsersProductsExpireDates$CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersArgs<ExtArgs>>): Prisma__CompaniesUsersClient<$Result.GetResult<Prisma.$CompaniesUsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Products<T extends ProductsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductsDefaultArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompaniesUsersProductsExpireDates model
   */ 
  interface CompaniesUsersProductsExpireDatesFieldRefs {
    readonly CompaniesUsersProductsExpireDateId: FieldRef<"CompaniesUsersProductsExpireDates", 'String'>
    readonly CreatedAt: FieldRef<"CompaniesUsersProductsExpireDates", 'DateTime'>
    readonly ProductId: FieldRef<"CompaniesUsersProductsExpireDates", 'String'>
    readonly CompanyID: FieldRef<"CompaniesUsersProductsExpireDates", 'String'>
    readonly CompaniesUsersID: FieldRef<"CompaniesUsersProductsExpireDates", 'String'>
    readonly StartDate: FieldRef<"CompaniesUsersProductsExpireDates", 'DateTime'>
    readonly EndDate: FieldRef<"CompaniesUsersProductsExpireDates", 'DateTime'>
    readonly UserId: FieldRef<"CompaniesUsersProductsExpireDates", 'String'>
    readonly Comments: FieldRef<"CompaniesUsersProductsExpireDates", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompaniesUsersProductsExpireDates findUnique
   */
  export type CompaniesUsersProductsExpireDatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUsersProductsExpireDates to fetch.
     */
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
  }

  /**
   * CompaniesUsersProductsExpireDates findUniqueOrThrow
   */
  export type CompaniesUsersProductsExpireDatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUsersProductsExpireDates to fetch.
     */
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
  }

  /**
   * CompaniesUsersProductsExpireDates findFirst
   */
  export type CompaniesUsersProductsExpireDatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUsersProductsExpireDates to fetch.
     */
    where?: CompaniesUsersProductsExpireDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUsersProductsExpireDates to fetch.
     */
    orderBy?: CompaniesUsersProductsExpireDatesOrderByWithRelationInput | CompaniesUsersProductsExpireDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesUsersProductsExpireDates.
     */
    cursor?: CompaniesUsersProductsExpireDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUsersProductsExpireDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUsersProductsExpireDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesUsersProductsExpireDates.
     */
    distinct?: CompaniesUsersProductsExpireDatesScalarFieldEnum | CompaniesUsersProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * CompaniesUsersProductsExpireDates findFirstOrThrow
   */
  export type CompaniesUsersProductsExpireDatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUsersProductsExpireDates to fetch.
     */
    where?: CompaniesUsersProductsExpireDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUsersProductsExpireDates to fetch.
     */
    orderBy?: CompaniesUsersProductsExpireDatesOrderByWithRelationInput | CompaniesUsersProductsExpireDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesUsersProductsExpireDates.
     */
    cursor?: CompaniesUsersProductsExpireDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUsersProductsExpireDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUsersProductsExpireDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesUsersProductsExpireDates.
     */
    distinct?: CompaniesUsersProductsExpireDatesScalarFieldEnum | CompaniesUsersProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * CompaniesUsersProductsExpireDates findMany
   */
  export type CompaniesUsersProductsExpireDatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUsersProductsExpireDates to fetch.
     */
    where?: CompaniesUsersProductsExpireDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUsersProductsExpireDates to fetch.
     */
    orderBy?: CompaniesUsersProductsExpireDatesOrderByWithRelationInput | CompaniesUsersProductsExpireDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompaniesUsersProductsExpireDates.
     */
    cursor?: CompaniesUsersProductsExpireDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUsersProductsExpireDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUsersProductsExpireDates.
     */
    skip?: number
    distinct?: CompaniesUsersProductsExpireDatesScalarFieldEnum | CompaniesUsersProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * CompaniesUsersProductsExpireDates create
   */
  export type CompaniesUsersProductsExpireDatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    /**
     * The data needed to create a CompaniesUsersProductsExpireDates.
     */
    data: XOR<CompaniesUsersProductsExpireDatesCreateInput, CompaniesUsersProductsExpireDatesUncheckedCreateInput>
  }

  /**
   * CompaniesUsersProductsExpireDates createMany
   */
  export type CompaniesUsersProductsExpireDatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompaniesUsersProductsExpireDates.
     */
    data: CompaniesUsersProductsExpireDatesCreateManyInput | CompaniesUsersProductsExpireDatesCreateManyInput[]
  }

  /**
   * CompaniesUsersProductsExpireDates update
   */
  export type CompaniesUsersProductsExpireDatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    /**
     * The data needed to update a CompaniesUsersProductsExpireDates.
     */
    data: XOR<CompaniesUsersProductsExpireDatesUpdateInput, CompaniesUsersProductsExpireDatesUncheckedUpdateInput>
    /**
     * Choose, which CompaniesUsersProductsExpireDates to update.
     */
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
  }

  /**
   * CompaniesUsersProductsExpireDates updateMany
   */
  export type CompaniesUsersProductsExpireDatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompaniesUsersProductsExpireDates.
     */
    data: XOR<CompaniesUsersProductsExpireDatesUpdateManyMutationInput, CompaniesUsersProductsExpireDatesUncheckedUpdateManyInput>
    /**
     * Filter which CompaniesUsersProductsExpireDates to update
     */
    where?: CompaniesUsersProductsExpireDatesWhereInput
  }

  /**
   * CompaniesUsersProductsExpireDates upsert
   */
  export type CompaniesUsersProductsExpireDatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    /**
     * The filter to search for the CompaniesUsersProductsExpireDates to update in case it exists.
     */
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    /**
     * In case the CompaniesUsersProductsExpireDates found by the `where` argument doesn't exist, create a new CompaniesUsersProductsExpireDates with this data.
     */
    create: XOR<CompaniesUsersProductsExpireDatesCreateInput, CompaniesUsersProductsExpireDatesUncheckedCreateInput>
    /**
     * In case the CompaniesUsersProductsExpireDates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompaniesUsersProductsExpireDatesUpdateInput, CompaniesUsersProductsExpireDatesUncheckedUpdateInput>
  }

  /**
   * CompaniesUsersProductsExpireDates delete
   */
  export type CompaniesUsersProductsExpireDatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    /**
     * Filter which CompaniesUsersProductsExpireDates to delete.
     */
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
  }

  /**
   * CompaniesUsersProductsExpireDates deleteMany
   */
  export type CompaniesUsersProductsExpireDatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesUsersProductsExpireDates to delete
     */
    where?: CompaniesUsersProductsExpireDatesWhereInput
  }

  /**
   * CompaniesUsersProductsExpireDates.CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers
   */
  export type CompaniesUsersProductsExpireDates$CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsers
     */
    select?: CompaniesUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersInclude<ExtArgs> | null
    where?: CompaniesUsersWhereInput
  }

  /**
   * CompaniesUsersProductsExpireDates without action
   */
  export type CompaniesUsersProductsExpireDatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
  }


  /**
   * Model Copyright
   */

  export type AggregateCopyright = {
    _count: CopyrightCountAggregateOutputType | null
    _avg: CopyrightAvgAggregateOutputType | null
    _sum: CopyrightSumAggregateOutputType | null
    _min: CopyrightMinAggregateOutputType | null
    _max: CopyrightMaxAggregateOutputType | null
  }

  export type CopyrightAvgAggregateOutputType = {
    CopyrightID: number | null
    DbGeneralVer: number | null
  }

  export type CopyrightSumAggregateOutputType = {
    CopyrightID: number | null
    DbGeneralVer: number | null
  }

  export type CopyrightMinAggregateOutputType = {
    CopyrightID: number | null
    Copyright: string | null
    DbGeneralVer: number | null
  }

  export type CopyrightMaxAggregateOutputType = {
    CopyrightID: number | null
    Copyright: string | null
    DbGeneralVer: number | null
  }

  export type CopyrightCountAggregateOutputType = {
    CopyrightID: number
    Copyright: number
    DbGeneralVer: number
    _all: number
  }


  export type CopyrightAvgAggregateInputType = {
    CopyrightID?: true
    DbGeneralVer?: true
  }

  export type CopyrightSumAggregateInputType = {
    CopyrightID?: true
    DbGeneralVer?: true
  }

  export type CopyrightMinAggregateInputType = {
    CopyrightID?: true
    Copyright?: true
    DbGeneralVer?: true
  }

  export type CopyrightMaxAggregateInputType = {
    CopyrightID?: true
    Copyright?: true
    DbGeneralVer?: true
  }

  export type CopyrightCountAggregateInputType = {
    CopyrightID?: true
    Copyright?: true
    DbGeneralVer?: true
    _all?: true
  }

  export type CopyrightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Copyright to aggregate.
     */
    where?: CopyrightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Copyrights to fetch.
     */
    orderBy?: CopyrightOrderByWithRelationInput | CopyrightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CopyrightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Copyrights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Copyrights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Copyrights
    **/
    _count?: true | CopyrightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CopyrightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CopyrightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CopyrightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CopyrightMaxAggregateInputType
  }

  export type GetCopyrightAggregateType<T extends CopyrightAggregateArgs> = {
        [P in keyof T & keyof AggregateCopyright]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCopyright[P]>
      : GetScalarType<T[P], AggregateCopyright[P]>
  }




  export type CopyrightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CopyrightWhereInput
    orderBy?: CopyrightOrderByWithAggregationInput | CopyrightOrderByWithAggregationInput[]
    by: CopyrightScalarFieldEnum[] | CopyrightScalarFieldEnum
    having?: CopyrightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CopyrightCountAggregateInputType | true
    _avg?: CopyrightAvgAggregateInputType
    _sum?: CopyrightSumAggregateInputType
    _min?: CopyrightMinAggregateInputType
    _max?: CopyrightMaxAggregateInputType
  }

  export type CopyrightGroupByOutputType = {
    CopyrightID: number
    Copyright: string
    DbGeneralVer: number
    _count: CopyrightCountAggregateOutputType | null
    _avg: CopyrightAvgAggregateOutputType | null
    _sum: CopyrightSumAggregateOutputType | null
    _min: CopyrightMinAggregateOutputType | null
    _max: CopyrightMaxAggregateOutputType | null
  }

  type GetCopyrightGroupByPayload<T extends CopyrightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CopyrightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CopyrightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CopyrightGroupByOutputType[P]>
            : GetScalarType<T[P], CopyrightGroupByOutputType[P]>
        }
      >
    >


  export type CopyrightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CopyrightID?: boolean
    Copyright?: boolean
    DbGeneralVer?: boolean
  }, ExtArgs["result"]["copyright"]>


  export type CopyrightSelectScalar = {
    CopyrightID?: boolean
    Copyright?: boolean
    DbGeneralVer?: boolean
  }


  export type $CopyrightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Copyright"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CopyrightID: number
      Copyright: string
      DbGeneralVer: number
    }, ExtArgs["result"]["copyright"]>
    composites: {}
  }

  type CopyrightGetPayload<S extends boolean | null | undefined | CopyrightDefaultArgs> = $Result.GetResult<Prisma.$CopyrightPayload, S>

  type CopyrightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CopyrightFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CopyrightCountAggregateInputType | true
    }

  export interface CopyrightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Copyright'], meta: { name: 'Copyright' } }
    /**
     * Find zero or one Copyright that matches the filter.
     * @param {CopyrightFindUniqueArgs} args - Arguments to find a Copyright
     * @example
     * // Get one Copyright
     * const copyright = await prisma.copyright.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CopyrightFindUniqueArgs>(args: SelectSubset<T, CopyrightFindUniqueArgs<ExtArgs>>): Prisma__CopyrightClient<$Result.GetResult<Prisma.$CopyrightPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Copyright that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CopyrightFindUniqueOrThrowArgs} args - Arguments to find a Copyright
     * @example
     * // Get one Copyright
     * const copyright = await prisma.copyright.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CopyrightFindUniqueOrThrowArgs>(args: SelectSubset<T, CopyrightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CopyrightClient<$Result.GetResult<Prisma.$CopyrightPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Copyright that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopyrightFindFirstArgs} args - Arguments to find a Copyright
     * @example
     * // Get one Copyright
     * const copyright = await prisma.copyright.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CopyrightFindFirstArgs>(args?: SelectSubset<T, CopyrightFindFirstArgs<ExtArgs>>): Prisma__CopyrightClient<$Result.GetResult<Prisma.$CopyrightPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Copyright that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopyrightFindFirstOrThrowArgs} args - Arguments to find a Copyright
     * @example
     * // Get one Copyright
     * const copyright = await prisma.copyright.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CopyrightFindFirstOrThrowArgs>(args?: SelectSubset<T, CopyrightFindFirstOrThrowArgs<ExtArgs>>): Prisma__CopyrightClient<$Result.GetResult<Prisma.$CopyrightPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Copyrights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopyrightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Copyrights
     * const copyrights = await prisma.copyright.findMany()
     * 
     * // Get first 10 Copyrights
     * const copyrights = await prisma.copyright.findMany({ take: 10 })
     * 
     * // Only select the `CopyrightID`
     * const copyrightWithCopyrightIDOnly = await prisma.copyright.findMany({ select: { CopyrightID: true } })
     * 
     */
    findMany<T extends CopyrightFindManyArgs>(args?: SelectSubset<T, CopyrightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CopyrightPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Copyright.
     * @param {CopyrightCreateArgs} args - Arguments to create a Copyright.
     * @example
     * // Create one Copyright
     * const Copyright = await prisma.copyright.create({
     *   data: {
     *     // ... data to create a Copyright
     *   }
     * })
     * 
     */
    create<T extends CopyrightCreateArgs>(args: SelectSubset<T, CopyrightCreateArgs<ExtArgs>>): Prisma__CopyrightClient<$Result.GetResult<Prisma.$CopyrightPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Copyrights.
     * @param {CopyrightCreateManyArgs} args - Arguments to create many Copyrights.
     * @example
     * // Create many Copyrights
     * const copyright = await prisma.copyright.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CopyrightCreateManyArgs>(args?: SelectSubset<T, CopyrightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Copyright.
     * @param {CopyrightDeleteArgs} args - Arguments to delete one Copyright.
     * @example
     * // Delete one Copyright
     * const Copyright = await prisma.copyright.delete({
     *   where: {
     *     // ... filter to delete one Copyright
     *   }
     * })
     * 
     */
    delete<T extends CopyrightDeleteArgs>(args: SelectSubset<T, CopyrightDeleteArgs<ExtArgs>>): Prisma__CopyrightClient<$Result.GetResult<Prisma.$CopyrightPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Copyright.
     * @param {CopyrightUpdateArgs} args - Arguments to update one Copyright.
     * @example
     * // Update one Copyright
     * const copyright = await prisma.copyright.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CopyrightUpdateArgs>(args: SelectSubset<T, CopyrightUpdateArgs<ExtArgs>>): Prisma__CopyrightClient<$Result.GetResult<Prisma.$CopyrightPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Copyrights.
     * @param {CopyrightDeleteManyArgs} args - Arguments to filter Copyrights to delete.
     * @example
     * // Delete a few Copyrights
     * const { count } = await prisma.copyright.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CopyrightDeleteManyArgs>(args?: SelectSubset<T, CopyrightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Copyrights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopyrightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Copyrights
     * const copyright = await prisma.copyright.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CopyrightUpdateManyArgs>(args: SelectSubset<T, CopyrightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Copyright.
     * @param {CopyrightUpsertArgs} args - Arguments to update or create a Copyright.
     * @example
     * // Update or create a Copyright
     * const copyright = await prisma.copyright.upsert({
     *   create: {
     *     // ... data to create a Copyright
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Copyright we want to update
     *   }
     * })
     */
    upsert<T extends CopyrightUpsertArgs>(args: SelectSubset<T, CopyrightUpsertArgs<ExtArgs>>): Prisma__CopyrightClient<$Result.GetResult<Prisma.$CopyrightPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Copyrights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopyrightCountArgs} args - Arguments to filter Copyrights to count.
     * @example
     * // Count the number of Copyrights
     * const count = await prisma.copyright.count({
     *   where: {
     *     // ... the filter for the Copyrights we want to count
     *   }
     * })
    **/
    count<T extends CopyrightCountArgs>(
      args?: Subset<T, CopyrightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CopyrightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Copyright.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopyrightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CopyrightAggregateArgs>(args: Subset<T, CopyrightAggregateArgs>): Prisma.PrismaPromise<GetCopyrightAggregateType<T>>

    /**
     * Group by Copyright.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopyrightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CopyrightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CopyrightGroupByArgs['orderBy'] }
        : { orderBy?: CopyrightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CopyrightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCopyrightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Copyright model
   */
  readonly fields: CopyrightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Copyright.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CopyrightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Copyright model
   */ 
  interface CopyrightFieldRefs {
    readonly CopyrightID: FieldRef<"Copyright", 'Int'>
    readonly Copyright: FieldRef<"Copyright", 'String'>
    readonly DbGeneralVer: FieldRef<"Copyright", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Copyright findUnique
   */
  export type CopyrightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Copyright
     */
    select?: CopyrightSelect<ExtArgs> | null
    /**
     * Filter, which Copyright to fetch.
     */
    where: CopyrightWhereUniqueInput
  }

  /**
   * Copyright findUniqueOrThrow
   */
  export type CopyrightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Copyright
     */
    select?: CopyrightSelect<ExtArgs> | null
    /**
     * Filter, which Copyright to fetch.
     */
    where: CopyrightWhereUniqueInput
  }

  /**
   * Copyright findFirst
   */
  export type CopyrightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Copyright
     */
    select?: CopyrightSelect<ExtArgs> | null
    /**
     * Filter, which Copyright to fetch.
     */
    where?: CopyrightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Copyrights to fetch.
     */
    orderBy?: CopyrightOrderByWithRelationInput | CopyrightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Copyrights.
     */
    cursor?: CopyrightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Copyrights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Copyrights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Copyrights.
     */
    distinct?: CopyrightScalarFieldEnum | CopyrightScalarFieldEnum[]
  }

  /**
   * Copyright findFirstOrThrow
   */
  export type CopyrightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Copyright
     */
    select?: CopyrightSelect<ExtArgs> | null
    /**
     * Filter, which Copyright to fetch.
     */
    where?: CopyrightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Copyrights to fetch.
     */
    orderBy?: CopyrightOrderByWithRelationInput | CopyrightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Copyrights.
     */
    cursor?: CopyrightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Copyrights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Copyrights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Copyrights.
     */
    distinct?: CopyrightScalarFieldEnum | CopyrightScalarFieldEnum[]
  }

  /**
   * Copyright findMany
   */
  export type CopyrightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Copyright
     */
    select?: CopyrightSelect<ExtArgs> | null
    /**
     * Filter, which Copyrights to fetch.
     */
    where?: CopyrightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Copyrights to fetch.
     */
    orderBy?: CopyrightOrderByWithRelationInput | CopyrightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Copyrights.
     */
    cursor?: CopyrightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Copyrights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Copyrights.
     */
    skip?: number
    distinct?: CopyrightScalarFieldEnum | CopyrightScalarFieldEnum[]
  }

  /**
   * Copyright create
   */
  export type CopyrightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Copyright
     */
    select?: CopyrightSelect<ExtArgs> | null
    /**
     * The data needed to create a Copyright.
     */
    data: XOR<CopyrightCreateInput, CopyrightUncheckedCreateInput>
  }

  /**
   * Copyright createMany
   */
  export type CopyrightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Copyrights.
     */
    data: CopyrightCreateManyInput | CopyrightCreateManyInput[]
  }

  /**
   * Copyright update
   */
  export type CopyrightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Copyright
     */
    select?: CopyrightSelect<ExtArgs> | null
    /**
     * The data needed to update a Copyright.
     */
    data: XOR<CopyrightUpdateInput, CopyrightUncheckedUpdateInput>
    /**
     * Choose, which Copyright to update.
     */
    where: CopyrightWhereUniqueInput
  }

  /**
   * Copyright updateMany
   */
  export type CopyrightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Copyrights.
     */
    data: XOR<CopyrightUpdateManyMutationInput, CopyrightUncheckedUpdateManyInput>
    /**
     * Filter which Copyrights to update
     */
    where?: CopyrightWhereInput
  }

  /**
   * Copyright upsert
   */
  export type CopyrightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Copyright
     */
    select?: CopyrightSelect<ExtArgs> | null
    /**
     * The filter to search for the Copyright to update in case it exists.
     */
    where: CopyrightWhereUniqueInput
    /**
     * In case the Copyright found by the `where` argument doesn't exist, create a new Copyright with this data.
     */
    create: XOR<CopyrightCreateInput, CopyrightUncheckedCreateInput>
    /**
     * In case the Copyright was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CopyrightUpdateInput, CopyrightUncheckedUpdateInput>
  }

  /**
   * Copyright delete
   */
  export type CopyrightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Copyright
     */
    select?: CopyrightSelect<ExtArgs> | null
    /**
     * Filter which Copyright to delete.
     */
    where: CopyrightWhereUniqueInput
  }

  /**
   * Copyright deleteMany
   */
  export type CopyrightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Copyrights to delete
     */
    where?: CopyrightWhereInput
  }

  /**
   * Copyright without action
   */
  export type CopyrightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Copyright
     */
    select?: CopyrightSelect<ExtArgs> | null
  }


  /**
   * Model Countries
   */

  export type AggregateCountries = {
    _count: CountriesCountAggregateOutputType | null
    _avg: CountriesAvgAggregateOutputType | null
    _sum: CountriesSumAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  export type CountriesAvgAggregateOutputType = {
    CountryID: number | null
    CountryCode: number | null
  }

  export type CountriesSumAggregateOutputType = {
    CountryID: number | null
    CountryCode: number | null
  }

  export type CountriesMinAggregateOutputType = {
    CountryID: number | null
    CountryCode: number | null
    CountryName: string | null
    CountryNameEnglish: string | null
    MultipleSelect: boolean | null
    CommentPayslip: string | null
    CommentHour: string | null
    DefaultLanguageCol: string | null
  }

  export type CountriesMaxAggregateOutputType = {
    CountryID: number | null
    CountryCode: number | null
    CountryName: string | null
    CountryNameEnglish: string | null
    MultipleSelect: boolean | null
    CommentPayslip: string | null
    CommentHour: string | null
    DefaultLanguageCol: string | null
  }

  export type CountriesCountAggregateOutputType = {
    CountryID: number
    CountryCode: number
    CountryName: number
    CountryNameEnglish: number
    MultipleSelect: number
    CommentPayslip: number
    CommentHour: number
    DefaultLanguageCol: number
    _all: number
  }


  export type CountriesAvgAggregateInputType = {
    CountryID?: true
    CountryCode?: true
  }

  export type CountriesSumAggregateInputType = {
    CountryID?: true
    CountryCode?: true
  }

  export type CountriesMinAggregateInputType = {
    CountryID?: true
    CountryCode?: true
    CountryName?: true
    CountryNameEnglish?: true
    MultipleSelect?: true
    CommentPayslip?: true
    CommentHour?: true
    DefaultLanguageCol?: true
  }

  export type CountriesMaxAggregateInputType = {
    CountryID?: true
    CountryCode?: true
    CountryName?: true
    CountryNameEnglish?: true
    MultipleSelect?: true
    CommentPayslip?: true
    CommentHour?: true
    DefaultLanguageCol?: true
  }

  export type CountriesCountAggregateInputType = {
    CountryID?: true
    CountryCode?: true
    CountryName?: true
    CountryNameEnglish?: true
    MultipleSelect?: true
    CommentPayslip?: true
    CommentHour?: true
    DefaultLanguageCol?: true
    _all?: true
  }

  export type CountriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to aggregate.
     */
    where?: CountriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountriesOrderByWithRelationInput | CountriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountriesMaxAggregateInputType
  }

  export type GetCountriesAggregateType<T extends CountriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCountries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountries[P]>
      : GetScalarType<T[P], AggregateCountries[P]>
  }




  export type CountriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountriesWhereInput
    orderBy?: CountriesOrderByWithAggregationInput | CountriesOrderByWithAggregationInput[]
    by: CountriesScalarFieldEnum[] | CountriesScalarFieldEnum
    having?: CountriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountriesCountAggregateInputType | true
    _avg?: CountriesAvgAggregateInputType
    _sum?: CountriesSumAggregateInputType
    _min?: CountriesMinAggregateInputType
    _max?: CountriesMaxAggregateInputType
  }

  export type CountriesGroupByOutputType = {
    CountryID: number
    CountryCode: number
    CountryName: string
    CountryNameEnglish: string
    MultipleSelect: boolean | null
    CommentPayslip: string | null
    CommentHour: string | null
    DefaultLanguageCol: string | null
    _count: CountriesCountAggregateOutputType | null
    _avg: CountriesAvgAggregateOutputType | null
    _sum: CountriesSumAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  type GetCountriesGroupByPayload<T extends CountriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountriesGroupByOutputType[P]>
            : GetScalarType<T[P], CountriesGroupByOutputType[P]>
        }
      >
    >


  export type CountriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CountryID?: boolean
    CountryCode?: boolean
    CountryName?: boolean
    CountryNameEnglish?: boolean
    MultipleSelect?: boolean
    CommentPayslip?: boolean
    CommentHour?: boolean
    DefaultLanguageCol?: boolean
  }, ExtArgs["result"]["countries"]>


  export type CountriesSelectScalar = {
    CountryID?: boolean
    CountryCode?: boolean
    CountryName?: boolean
    CountryNameEnglish?: boolean
    MultipleSelect?: boolean
    CommentPayslip?: boolean
    CommentHour?: boolean
    DefaultLanguageCol?: boolean
  }


  export type $CountriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Countries"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CountryID: number
      CountryCode: number
      CountryName: string
      CountryNameEnglish: string
      MultipleSelect: boolean | null
      CommentPayslip: string | null
      CommentHour: string | null
      DefaultLanguageCol: string | null
    }, ExtArgs["result"]["countries"]>
    composites: {}
  }

  type CountriesGetPayload<S extends boolean | null | undefined | CountriesDefaultArgs> = $Result.GetResult<Prisma.$CountriesPayload, S>

  type CountriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CountriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountriesCountAggregateInputType | true
    }

  export interface CountriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Countries'], meta: { name: 'Countries' } }
    /**
     * Find zero or one Countries that matches the filter.
     * @param {CountriesFindUniqueArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountriesFindUniqueArgs>(args: SelectSubset<T, CountriesFindUniqueArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Countries that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CountriesFindUniqueOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountriesFindUniqueOrThrowArgs>(args: SelectSubset<T, CountriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesFindFirstArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountriesFindFirstArgs>(args?: SelectSubset<T, CountriesFindFirstArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Countries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesFindFirstOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountriesFindFirstOrThrowArgs>(args?: SelectSubset<T, CountriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.countries.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.countries.findMany({ take: 10 })
     * 
     * // Only select the `CountryID`
     * const countriesWithCountryIDOnly = await prisma.countries.findMany({ select: { CountryID: true } })
     * 
     */
    findMany<T extends CountriesFindManyArgs>(args?: SelectSubset<T, CountriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Countries.
     * @param {CountriesCreateArgs} args - Arguments to create a Countries.
     * @example
     * // Create one Countries
     * const Countries = await prisma.countries.create({
     *   data: {
     *     // ... data to create a Countries
     *   }
     * })
     * 
     */
    create<T extends CountriesCreateArgs>(args: SelectSubset<T, CountriesCreateArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Countries.
     * @param {CountriesCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const countries = await prisma.countries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountriesCreateManyArgs>(args?: SelectSubset<T, CountriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Countries.
     * @param {CountriesDeleteArgs} args - Arguments to delete one Countries.
     * @example
     * // Delete one Countries
     * const Countries = await prisma.countries.delete({
     *   where: {
     *     // ... filter to delete one Countries
     *   }
     * })
     * 
     */
    delete<T extends CountriesDeleteArgs>(args: SelectSubset<T, CountriesDeleteArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Countries.
     * @param {CountriesUpdateArgs} args - Arguments to update one Countries.
     * @example
     * // Update one Countries
     * const countries = await prisma.countries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountriesUpdateArgs>(args: SelectSubset<T, CountriesUpdateArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountriesDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.countries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountriesDeleteManyArgs>(args?: SelectSubset<T, CountriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const countries = await prisma.countries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountriesUpdateManyArgs>(args: SelectSubset<T, CountriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Countries.
     * @param {CountriesUpsertArgs} args - Arguments to update or create a Countries.
     * @example
     * // Update or create a Countries
     * const countries = await prisma.countries.upsert({
     *   create: {
     *     // ... data to create a Countries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Countries we want to update
     *   }
     * })
     */
    upsert<T extends CountriesUpsertArgs>(args: SelectSubset<T, CountriesUpsertArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.countries.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountriesCountArgs>(
      args?: Subset<T, CountriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountriesAggregateArgs>(args: Subset<T, CountriesAggregateArgs>): Prisma.PrismaPromise<GetCountriesAggregateType<T>>

    /**
     * Group by Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountriesGroupByArgs['orderBy'] }
        : { orderBy?: CountriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Countries model
   */
  readonly fields: CountriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Countries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Countries model
   */ 
  interface CountriesFieldRefs {
    readonly CountryID: FieldRef<"Countries", 'Int'>
    readonly CountryCode: FieldRef<"Countries", 'Int'>
    readonly CountryName: FieldRef<"Countries", 'String'>
    readonly CountryNameEnglish: FieldRef<"Countries", 'String'>
    readonly MultipleSelect: FieldRef<"Countries", 'Boolean'>
    readonly CommentPayslip: FieldRef<"Countries", 'String'>
    readonly CommentHour: FieldRef<"Countries", 'String'>
    readonly DefaultLanguageCol: FieldRef<"Countries", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Countries findUnique
   */
  export type CountriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where: CountriesWhereUniqueInput
  }

  /**
   * Countries findUniqueOrThrow
   */
  export type CountriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where: CountriesWhereUniqueInput
  }

  /**
   * Countries findFirst
   */
  export type CountriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountriesOrderByWithRelationInput | CountriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }

  /**
   * Countries findFirstOrThrow
   */
  export type CountriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountriesOrderByWithRelationInput | CountriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }

  /**
   * Countries findMany
   */
  export type CountriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountriesOrderByWithRelationInput | CountriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }

  /**
   * Countries create
   */
  export type CountriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * The data needed to create a Countries.
     */
    data: XOR<CountriesCreateInput, CountriesUncheckedCreateInput>
  }

  /**
   * Countries createMany
   */
  export type CountriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountriesCreateManyInput | CountriesCreateManyInput[]
  }

  /**
   * Countries update
   */
  export type CountriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * The data needed to update a Countries.
     */
    data: XOR<CountriesUpdateInput, CountriesUncheckedUpdateInput>
    /**
     * Choose, which Countries to update.
     */
    where: CountriesWhereUniqueInput
  }

  /**
   * Countries updateMany
   */
  export type CountriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountriesUpdateManyMutationInput, CountriesUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountriesWhereInput
  }

  /**
   * Countries upsert
   */
  export type CountriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * The filter to search for the Countries to update in case it exists.
     */
    where: CountriesWhereUniqueInput
    /**
     * In case the Countries found by the `where` argument doesn't exist, create a new Countries with this data.
     */
    create: XOR<CountriesCreateInput, CountriesUncheckedCreateInput>
    /**
     * In case the Countries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountriesUpdateInput, CountriesUncheckedUpdateInput>
  }

  /**
   * Countries delete
   */
  export type CountriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Filter which Countries to delete.
     */
    where: CountriesWhereUniqueInput
  }

  /**
   * Countries deleteMany
   */
  export type CountriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountriesWhereInput
  }

  /**
   * Countries without action
   */
  export type CountriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
  }


  /**
   * Model CreditShift
   */

  export type AggregateCreditShift = {
    _count: CreditShiftCountAggregateOutputType | null
    _avg: CreditShiftAvgAggregateOutputType | null
    _sum: CreditShiftSumAggregateOutputType | null
    _min: CreditShiftMinAggregateOutputType | null
    _max: CreditShiftMaxAggregateOutputType | null
  }

  export type CreditShiftAvgAggregateOutputType = {
    CreditShiftID: number | null
    MaxCreditShiftPrecent: number | null
    MaxCreditShiftLimit: number | null
    CreditPrecent: number | null
  }

  export type CreditShiftSumAggregateOutputType = {
    CreditShiftID: number | null
    MaxCreditShiftPrecent: number | null
    MaxCreditShiftLimit: number | null
    CreditPrecent: number | null
  }

  export type CreditShiftMinAggregateOutputType = {
    CreditShiftID: number | null
    CreditShiftDate: Date | null
    MaxCreditShiftPrecent: number | null
    MaxCreditShiftLimit: number | null
    CreditPrecent: number | null
  }

  export type CreditShiftMaxAggregateOutputType = {
    CreditShiftID: number | null
    CreditShiftDate: Date | null
    MaxCreditShiftPrecent: number | null
    MaxCreditShiftLimit: number | null
    CreditPrecent: number | null
  }

  export type CreditShiftCountAggregateOutputType = {
    CreditShiftID: number
    CreditShiftDate: number
    MaxCreditShiftPrecent: number
    MaxCreditShiftLimit: number
    CreditPrecent: number
    _all: number
  }


  export type CreditShiftAvgAggregateInputType = {
    CreditShiftID?: true
    MaxCreditShiftPrecent?: true
    MaxCreditShiftLimit?: true
    CreditPrecent?: true
  }

  export type CreditShiftSumAggregateInputType = {
    CreditShiftID?: true
    MaxCreditShiftPrecent?: true
    MaxCreditShiftLimit?: true
    CreditPrecent?: true
  }

  export type CreditShiftMinAggregateInputType = {
    CreditShiftID?: true
    CreditShiftDate?: true
    MaxCreditShiftPrecent?: true
    MaxCreditShiftLimit?: true
    CreditPrecent?: true
  }

  export type CreditShiftMaxAggregateInputType = {
    CreditShiftID?: true
    CreditShiftDate?: true
    MaxCreditShiftPrecent?: true
    MaxCreditShiftLimit?: true
    CreditPrecent?: true
  }

  export type CreditShiftCountAggregateInputType = {
    CreditShiftID?: true
    CreditShiftDate?: true
    MaxCreditShiftPrecent?: true
    MaxCreditShiftLimit?: true
    CreditPrecent?: true
    _all?: true
  }

  export type CreditShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditShift to aggregate.
     */
    where?: CreditShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditShifts to fetch.
     */
    orderBy?: CreditShiftOrderByWithRelationInput | CreditShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditShifts
    **/
    _count?: true | CreditShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditShiftMaxAggregateInputType
  }

  export type GetCreditShiftAggregateType<T extends CreditShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditShift[P]>
      : GetScalarType<T[P], AggregateCreditShift[P]>
  }




  export type CreditShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditShiftWhereInput
    orderBy?: CreditShiftOrderByWithAggregationInput | CreditShiftOrderByWithAggregationInput[]
    by: CreditShiftScalarFieldEnum[] | CreditShiftScalarFieldEnum
    having?: CreditShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditShiftCountAggregateInputType | true
    _avg?: CreditShiftAvgAggregateInputType
    _sum?: CreditShiftSumAggregateInputType
    _min?: CreditShiftMinAggregateInputType
    _max?: CreditShiftMaxAggregateInputType
  }

  export type CreditShiftGroupByOutputType = {
    CreditShiftID: number
    CreditShiftDate: Date | null
    MaxCreditShiftPrecent: number | null
    MaxCreditShiftLimit: number | null
    CreditPrecent: number | null
    _count: CreditShiftCountAggregateOutputType | null
    _avg: CreditShiftAvgAggregateOutputType | null
    _sum: CreditShiftSumAggregateOutputType | null
    _min: CreditShiftMinAggregateOutputType | null
    _max: CreditShiftMaxAggregateOutputType | null
  }

  type GetCreditShiftGroupByPayload<T extends CreditShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditShiftGroupByOutputType[P]>
            : GetScalarType<T[P], CreditShiftGroupByOutputType[P]>
        }
      >
    >


  export type CreditShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CreditShiftID?: boolean
    CreditShiftDate?: boolean
    MaxCreditShiftPrecent?: boolean
    MaxCreditShiftLimit?: boolean
    CreditPrecent?: boolean
  }, ExtArgs["result"]["creditShift"]>


  export type CreditShiftSelectScalar = {
    CreditShiftID?: boolean
    CreditShiftDate?: boolean
    MaxCreditShiftPrecent?: boolean
    MaxCreditShiftLimit?: boolean
    CreditPrecent?: boolean
  }


  export type $CreditShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditShift"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CreditShiftID: number
      CreditShiftDate: Date | null
      MaxCreditShiftPrecent: number | null
      MaxCreditShiftLimit: number | null
      CreditPrecent: number | null
    }, ExtArgs["result"]["creditShift"]>
    composites: {}
  }

  type CreditShiftGetPayload<S extends boolean | null | undefined | CreditShiftDefaultArgs> = $Result.GetResult<Prisma.$CreditShiftPayload, S>

  type CreditShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreditShiftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreditShiftCountAggregateInputType | true
    }

  export interface CreditShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditShift'], meta: { name: 'CreditShift' } }
    /**
     * Find zero or one CreditShift that matches the filter.
     * @param {CreditShiftFindUniqueArgs} args - Arguments to find a CreditShift
     * @example
     * // Get one CreditShift
     * const creditShift = await prisma.creditShift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditShiftFindUniqueArgs>(args: SelectSubset<T, CreditShiftFindUniqueArgs<ExtArgs>>): Prisma__CreditShiftClient<$Result.GetResult<Prisma.$CreditShiftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CreditShift that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CreditShiftFindUniqueOrThrowArgs} args - Arguments to find a CreditShift
     * @example
     * // Get one CreditShift
     * const creditShift = await prisma.creditShift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditShiftClient<$Result.GetResult<Prisma.$CreditShiftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CreditShift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditShiftFindFirstArgs} args - Arguments to find a CreditShift
     * @example
     * // Get one CreditShift
     * const creditShift = await prisma.creditShift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditShiftFindFirstArgs>(args?: SelectSubset<T, CreditShiftFindFirstArgs<ExtArgs>>): Prisma__CreditShiftClient<$Result.GetResult<Prisma.$CreditShiftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CreditShift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditShiftFindFirstOrThrowArgs} args - Arguments to find a CreditShift
     * @example
     * // Get one CreditShift
     * const creditShift = await prisma.creditShift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditShiftClient<$Result.GetResult<Prisma.$CreditShiftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CreditShifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditShifts
     * const creditShifts = await prisma.creditShift.findMany()
     * 
     * // Get first 10 CreditShifts
     * const creditShifts = await prisma.creditShift.findMany({ take: 10 })
     * 
     * // Only select the `CreditShiftID`
     * const creditShiftWithCreditShiftIDOnly = await prisma.creditShift.findMany({ select: { CreditShiftID: true } })
     * 
     */
    findMany<T extends CreditShiftFindManyArgs>(args?: SelectSubset<T, CreditShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditShiftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CreditShift.
     * @param {CreditShiftCreateArgs} args - Arguments to create a CreditShift.
     * @example
     * // Create one CreditShift
     * const CreditShift = await prisma.creditShift.create({
     *   data: {
     *     // ... data to create a CreditShift
     *   }
     * })
     * 
     */
    create<T extends CreditShiftCreateArgs>(args: SelectSubset<T, CreditShiftCreateArgs<ExtArgs>>): Prisma__CreditShiftClient<$Result.GetResult<Prisma.$CreditShiftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CreditShifts.
     * @param {CreditShiftCreateManyArgs} args - Arguments to create many CreditShifts.
     * @example
     * // Create many CreditShifts
     * const creditShift = await prisma.creditShift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditShiftCreateManyArgs>(args?: SelectSubset<T, CreditShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CreditShift.
     * @param {CreditShiftDeleteArgs} args - Arguments to delete one CreditShift.
     * @example
     * // Delete one CreditShift
     * const CreditShift = await prisma.creditShift.delete({
     *   where: {
     *     // ... filter to delete one CreditShift
     *   }
     * })
     * 
     */
    delete<T extends CreditShiftDeleteArgs>(args: SelectSubset<T, CreditShiftDeleteArgs<ExtArgs>>): Prisma__CreditShiftClient<$Result.GetResult<Prisma.$CreditShiftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CreditShift.
     * @param {CreditShiftUpdateArgs} args - Arguments to update one CreditShift.
     * @example
     * // Update one CreditShift
     * const creditShift = await prisma.creditShift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditShiftUpdateArgs>(args: SelectSubset<T, CreditShiftUpdateArgs<ExtArgs>>): Prisma__CreditShiftClient<$Result.GetResult<Prisma.$CreditShiftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CreditShifts.
     * @param {CreditShiftDeleteManyArgs} args - Arguments to filter CreditShifts to delete.
     * @example
     * // Delete a few CreditShifts
     * const { count } = await prisma.creditShift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditShiftDeleteManyArgs>(args?: SelectSubset<T, CreditShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditShifts
     * const creditShift = await prisma.creditShift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditShiftUpdateManyArgs>(args: SelectSubset<T, CreditShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CreditShift.
     * @param {CreditShiftUpsertArgs} args - Arguments to update or create a CreditShift.
     * @example
     * // Update or create a CreditShift
     * const creditShift = await prisma.creditShift.upsert({
     *   create: {
     *     // ... data to create a CreditShift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditShift we want to update
     *   }
     * })
     */
    upsert<T extends CreditShiftUpsertArgs>(args: SelectSubset<T, CreditShiftUpsertArgs<ExtArgs>>): Prisma__CreditShiftClient<$Result.GetResult<Prisma.$CreditShiftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CreditShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditShiftCountArgs} args - Arguments to filter CreditShifts to count.
     * @example
     * // Count the number of CreditShifts
     * const count = await prisma.creditShift.count({
     *   where: {
     *     // ... the filter for the CreditShifts we want to count
     *   }
     * })
    **/
    count<T extends CreditShiftCountArgs>(
      args?: Subset<T, CreditShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditShiftAggregateArgs>(args: Subset<T, CreditShiftAggregateArgs>): Prisma.PrismaPromise<GetCreditShiftAggregateType<T>>

    /**
     * Group by CreditShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditShiftGroupByArgs['orderBy'] }
        : { orderBy?: CreditShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditShift model
   */
  readonly fields: CreditShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditShift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditShift model
   */ 
  interface CreditShiftFieldRefs {
    readonly CreditShiftID: FieldRef<"CreditShift", 'Int'>
    readonly CreditShiftDate: FieldRef<"CreditShift", 'DateTime'>
    readonly MaxCreditShiftPrecent: FieldRef<"CreditShift", 'Float'>
    readonly MaxCreditShiftLimit: FieldRef<"CreditShift", 'Float'>
    readonly CreditPrecent: FieldRef<"CreditShift", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * CreditShift findUnique
   */
  export type CreditShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditShift
     */
    select?: CreditShiftSelect<ExtArgs> | null
    /**
     * Filter, which CreditShift to fetch.
     */
    where: CreditShiftWhereUniqueInput
  }

  /**
   * CreditShift findUniqueOrThrow
   */
  export type CreditShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditShift
     */
    select?: CreditShiftSelect<ExtArgs> | null
    /**
     * Filter, which CreditShift to fetch.
     */
    where: CreditShiftWhereUniqueInput
  }

  /**
   * CreditShift findFirst
   */
  export type CreditShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditShift
     */
    select?: CreditShiftSelect<ExtArgs> | null
    /**
     * Filter, which CreditShift to fetch.
     */
    where?: CreditShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditShifts to fetch.
     */
    orderBy?: CreditShiftOrderByWithRelationInput | CreditShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditShifts.
     */
    cursor?: CreditShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditShifts.
     */
    distinct?: CreditShiftScalarFieldEnum | CreditShiftScalarFieldEnum[]
  }

  /**
   * CreditShift findFirstOrThrow
   */
  export type CreditShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditShift
     */
    select?: CreditShiftSelect<ExtArgs> | null
    /**
     * Filter, which CreditShift to fetch.
     */
    where?: CreditShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditShifts to fetch.
     */
    orderBy?: CreditShiftOrderByWithRelationInput | CreditShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditShifts.
     */
    cursor?: CreditShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditShifts.
     */
    distinct?: CreditShiftScalarFieldEnum | CreditShiftScalarFieldEnum[]
  }

  /**
   * CreditShift findMany
   */
  export type CreditShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditShift
     */
    select?: CreditShiftSelect<ExtArgs> | null
    /**
     * Filter, which CreditShifts to fetch.
     */
    where?: CreditShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditShifts to fetch.
     */
    orderBy?: CreditShiftOrderByWithRelationInput | CreditShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditShifts.
     */
    cursor?: CreditShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditShifts.
     */
    skip?: number
    distinct?: CreditShiftScalarFieldEnum | CreditShiftScalarFieldEnum[]
  }

  /**
   * CreditShift create
   */
  export type CreditShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditShift
     */
    select?: CreditShiftSelect<ExtArgs> | null
    /**
     * The data needed to create a CreditShift.
     */
    data?: XOR<CreditShiftCreateInput, CreditShiftUncheckedCreateInput>
  }

  /**
   * CreditShift createMany
   */
  export type CreditShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditShifts.
     */
    data: CreditShiftCreateManyInput | CreditShiftCreateManyInput[]
  }

  /**
   * CreditShift update
   */
  export type CreditShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditShift
     */
    select?: CreditShiftSelect<ExtArgs> | null
    /**
     * The data needed to update a CreditShift.
     */
    data: XOR<CreditShiftUpdateInput, CreditShiftUncheckedUpdateInput>
    /**
     * Choose, which CreditShift to update.
     */
    where: CreditShiftWhereUniqueInput
  }

  /**
   * CreditShift updateMany
   */
  export type CreditShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditShifts.
     */
    data: XOR<CreditShiftUpdateManyMutationInput, CreditShiftUncheckedUpdateManyInput>
    /**
     * Filter which CreditShifts to update
     */
    where?: CreditShiftWhereInput
  }

  /**
   * CreditShift upsert
   */
  export type CreditShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditShift
     */
    select?: CreditShiftSelect<ExtArgs> | null
    /**
     * The filter to search for the CreditShift to update in case it exists.
     */
    where: CreditShiftWhereUniqueInput
    /**
     * In case the CreditShift found by the `where` argument doesn't exist, create a new CreditShift with this data.
     */
    create: XOR<CreditShiftCreateInput, CreditShiftUncheckedCreateInput>
    /**
     * In case the CreditShift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditShiftUpdateInput, CreditShiftUncheckedUpdateInput>
  }

  /**
   * CreditShift delete
   */
  export type CreditShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditShift
     */
    select?: CreditShiftSelect<ExtArgs> | null
    /**
     * Filter which CreditShift to delete.
     */
    where: CreditShiftWhereUniqueInput
  }

  /**
   * CreditShift deleteMany
   */
  export type CreditShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditShifts to delete
     */
    where?: CreditShiftWhereInput
  }

  /**
   * CreditShift without action
   */
  export type CreditShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditShift
     */
    select?: CreditShiftSelect<ExtArgs> | null
  }


  /**
   * Model DaysInMonth
   */

  export type AggregateDaysInMonth = {
    _count: DaysInMonthCountAggregateOutputType | null
    _avg: DaysInMonthAvgAggregateOutputType | null
    _sum: DaysInMonthSumAggregateOutputType | null
    _min: DaysInMonthMinAggregateOutputType | null
    _max: DaysInMonthMaxAggregateOutputType | null
  }

  export type DaysInMonthAvgAggregateOutputType = {
    DateManagedID: number | null
    YearManaged: number | null
    MonthManaged: number | null
    DayInMonth: number | null
    DayInWeek: number | null
    WeekInYear: number | null
    WeekInMonth: number | null
    DayTypeID: number | null
  }

  export type DaysInMonthSumAggregateOutputType = {
    DateManagedID: number | null
    YearManaged: number | null
    MonthManaged: number | null
    DayInMonth: number | null
    DayInWeek: number | null
    WeekInYear: number | null
    WeekInMonth: number | null
    DayTypeID: number | null
  }

  export type DaysInMonthMinAggregateOutputType = {
    DateManagedID: number | null
    DateManaged: Date | null
    YearManaged: number | null
    MonthManaged: number | null
    DayInMonth: number | null
    DayInWeek: number | null
    WeekInYear: number | null
    WeekInMonth: number | null
    DayTypeID: number | null
    StartEndTimeSabat: Date | null
    HolidayName: string | null
  }

  export type DaysInMonthMaxAggregateOutputType = {
    DateManagedID: number | null
    DateManaged: Date | null
    YearManaged: number | null
    MonthManaged: number | null
    DayInMonth: number | null
    DayInWeek: number | null
    WeekInYear: number | null
    WeekInMonth: number | null
    DayTypeID: number | null
    StartEndTimeSabat: Date | null
    HolidayName: string | null
  }

  export type DaysInMonthCountAggregateOutputType = {
    DateManagedID: number
    DateManaged: number
    YearManaged: number
    MonthManaged: number
    DayInMonth: number
    DayInWeek: number
    WeekInYear: number
    WeekInMonth: number
    DayTypeID: number
    StartEndTimeSabat: number
    HolidayName: number
    _all: number
  }


  export type DaysInMonthAvgAggregateInputType = {
    DateManagedID?: true
    YearManaged?: true
    MonthManaged?: true
    DayInMonth?: true
    DayInWeek?: true
    WeekInYear?: true
    WeekInMonth?: true
    DayTypeID?: true
  }

  export type DaysInMonthSumAggregateInputType = {
    DateManagedID?: true
    YearManaged?: true
    MonthManaged?: true
    DayInMonth?: true
    DayInWeek?: true
    WeekInYear?: true
    WeekInMonth?: true
    DayTypeID?: true
  }

  export type DaysInMonthMinAggregateInputType = {
    DateManagedID?: true
    DateManaged?: true
    YearManaged?: true
    MonthManaged?: true
    DayInMonth?: true
    DayInWeek?: true
    WeekInYear?: true
    WeekInMonth?: true
    DayTypeID?: true
    StartEndTimeSabat?: true
    HolidayName?: true
  }

  export type DaysInMonthMaxAggregateInputType = {
    DateManagedID?: true
    DateManaged?: true
    YearManaged?: true
    MonthManaged?: true
    DayInMonth?: true
    DayInWeek?: true
    WeekInYear?: true
    WeekInMonth?: true
    DayTypeID?: true
    StartEndTimeSabat?: true
    HolidayName?: true
  }

  export type DaysInMonthCountAggregateInputType = {
    DateManagedID?: true
    DateManaged?: true
    YearManaged?: true
    MonthManaged?: true
    DayInMonth?: true
    DayInWeek?: true
    WeekInYear?: true
    WeekInMonth?: true
    DayTypeID?: true
    StartEndTimeSabat?: true
    HolidayName?: true
    _all?: true
  }

  export type DaysInMonthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DaysInMonth to aggregate.
     */
    where?: DaysInMonthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DaysInMonths to fetch.
     */
    orderBy?: DaysInMonthOrderByWithRelationInput | DaysInMonthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DaysInMonthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DaysInMonths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DaysInMonths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DaysInMonths
    **/
    _count?: true | DaysInMonthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DaysInMonthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DaysInMonthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DaysInMonthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DaysInMonthMaxAggregateInputType
  }

  export type GetDaysInMonthAggregateType<T extends DaysInMonthAggregateArgs> = {
        [P in keyof T & keyof AggregateDaysInMonth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDaysInMonth[P]>
      : GetScalarType<T[P], AggregateDaysInMonth[P]>
  }




  export type DaysInMonthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DaysInMonthWhereInput
    orderBy?: DaysInMonthOrderByWithAggregationInput | DaysInMonthOrderByWithAggregationInput[]
    by: DaysInMonthScalarFieldEnum[] | DaysInMonthScalarFieldEnum
    having?: DaysInMonthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DaysInMonthCountAggregateInputType | true
    _avg?: DaysInMonthAvgAggregateInputType
    _sum?: DaysInMonthSumAggregateInputType
    _min?: DaysInMonthMinAggregateInputType
    _max?: DaysInMonthMaxAggregateInputType
  }

  export type DaysInMonthGroupByOutputType = {
    DateManagedID: number
    DateManaged: Date
    YearManaged: number | null
    MonthManaged: number | null
    DayInMonth: number | null
    DayInWeek: number | null
    WeekInYear: number | null
    WeekInMonth: number | null
    DayTypeID: number | null
    StartEndTimeSabat: Date | null
    HolidayName: string | null
    _count: DaysInMonthCountAggregateOutputType | null
    _avg: DaysInMonthAvgAggregateOutputType | null
    _sum: DaysInMonthSumAggregateOutputType | null
    _min: DaysInMonthMinAggregateOutputType | null
    _max: DaysInMonthMaxAggregateOutputType | null
  }

  type GetDaysInMonthGroupByPayload<T extends DaysInMonthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DaysInMonthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DaysInMonthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DaysInMonthGroupByOutputType[P]>
            : GetScalarType<T[P], DaysInMonthGroupByOutputType[P]>
        }
      >
    >


  export type DaysInMonthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    DateManagedID?: boolean
    DateManaged?: boolean
    YearManaged?: boolean
    MonthManaged?: boolean
    DayInMonth?: boolean
    DayInWeek?: boolean
    WeekInYear?: boolean
    WeekInMonth?: boolean
    DayTypeID?: boolean
    StartEndTimeSabat?: boolean
    HolidayName?: boolean
  }, ExtArgs["result"]["daysInMonth"]>


  export type DaysInMonthSelectScalar = {
    DateManagedID?: boolean
    DateManaged?: boolean
    YearManaged?: boolean
    MonthManaged?: boolean
    DayInMonth?: boolean
    DayInWeek?: boolean
    WeekInYear?: boolean
    WeekInMonth?: boolean
    DayTypeID?: boolean
    StartEndTimeSabat?: boolean
    HolidayName?: boolean
  }


  export type $DaysInMonthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DaysInMonth"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      DateManagedID: number
      DateManaged: Date
      YearManaged: number | null
      MonthManaged: number | null
      DayInMonth: number | null
      DayInWeek: number | null
      WeekInYear: number | null
      WeekInMonth: number | null
      DayTypeID: number | null
      StartEndTimeSabat: Date | null
      HolidayName: string | null
    }, ExtArgs["result"]["daysInMonth"]>
    composites: {}
  }

  type DaysInMonthGetPayload<S extends boolean | null | undefined | DaysInMonthDefaultArgs> = $Result.GetResult<Prisma.$DaysInMonthPayload, S>

  type DaysInMonthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DaysInMonthFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DaysInMonthCountAggregateInputType | true
    }

  export interface DaysInMonthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DaysInMonth'], meta: { name: 'DaysInMonth' } }
    /**
     * Find zero or one DaysInMonth that matches the filter.
     * @param {DaysInMonthFindUniqueArgs} args - Arguments to find a DaysInMonth
     * @example
     * // Get one DaysInMonth
     * const daysInMonth = await prisma.daysInMonth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DaysInMonthFindUniqueArgs>(args: SelectSubset<T, DaysInMonthFindUniqueArgs<ExtArgs>>): Prisma__DaysInMonthClient<$Result.GetResult<Prisma.$DaysInMonthPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DaysInMonth that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DaysInMonthFindUniqueOrThrowArgs} args - Arguments to find a DaysInMonth
     * @example
     * // Get one DaysInMonth
     * const daysInMonth = await prisma.daysInMonth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DaysInMonthFindUniqueOrThrowArgs>(args: SelectSubset<T, DaysInMonthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DaysInMonthClient<$Result.GetResult<Prisma.$DaysInMonthPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DaysInMonth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonthFindFirstArgs} args - Arguments to find a DaysInMonth
     * @example
     * // Get one DaysInMonth
     * const daysInMonth = await prisma.daysInMonth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DaysInMonthFindFirstArgs>(args?: SelectSubset<T, DaysInMonthFindFirstArgs<ExtArgs>>): Prisma__DaysInMonthClient<$Result.GetResult<Prisma.$DaysInMonthPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DaysInMonth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonthFindFirstOrThrowArgs} args - Arguments to find a DaysInMonth
     * @example
     * // Get one DaysInMonth
     * const daysInMonth = await prisma.daysInMonth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DaysInMonthFindFirstOrThrowArgs>(args?: SelectSubset<T, DaysInMonthFindFirstOrThrowArgs<ExtArgs>>): Prisma__DaysInMonthClient<$Result.GetResult<Prisma.$DaysInMonthPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DaysInMonths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DaysInMonths
     * const daysInMonths = await prisma.daysInMonth.findMany()
     * 
     * // Get first 10 DaysInMonths
     * const daysInMonths = await prisma.daysInMonth.findMany({ take: 10 })
     * 
     * // Only select the `DateManagedID`
     * const daysInMonthWithDateManagedIDOnly = await prisma.daysInMonth.findMany({ select: { DateManagedID: true } })
     * 
     */
    findMany<T extends DaysInMonthFindManyArgs>(args?: SelectSubset<T, DaysInMonthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DaysInMonthPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DaysInMonth.
     * @param {DaysInMonthCreateArgs} args - Arguments to create a DaysInMonth.
     * @example
     * // Create one DaysInMonth
     * const DaysInMonth = await prisma.daysInMonth.create({
     *   data: {
     *     // ... data to create a DaysInMonth
     *   }
     * })
     * 
     */
    create<T extends DaysInMonthCreateArgs>(args: SelectSubset<T, DaysInMonthCreateArgs<ExtArgs>>): Prisma__DaysInMonthClient<$Result.GetResult<Prisma.$DaysInMonthPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DaysInMonths.
     * @param {DaysInMonthCreateManyArgs} args - Arguments to create many DaysInMonths.
     * @example
     * // Create many DaysInMonths
     * const daysInMonth = await prisma.daysInMonth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DaysInMonthCreateManyArgs>(args?: SelectSubset<T, DaysInMonthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DaysInMonth.
     * @param {DaysInMonthDeleteArgs} args - Arguments to delete one DaysInMonth.
     * @example
     * // Delete one DaysInMonth
     * const DaysInMonth = await prisma.daysInMonth.delete({
     *   where: {
     *     // ... filter to delete one DaysInMonth
     *   }
     * })
     * 
     */
    delete<T extends DaysInMonthDeleteArgs>(args: SelectSubset<T, DaysInMonthDeleteArgs<ExtArgs>>): Prisma__DaysInMonthClient<$Result.GetResult<Prisma.$DaysInMonthPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DaysInMonth.
     * @param {DaysInMonthUpdateArgs} args - Arguments to update one DaysInMonth.
     * @example
     * // Update one DaysInMonth
     * const daysInMonth = await prisma.daysInMonth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DaysInMonthUpdateArgs>(args: SelectSubset<T, DaysInMonthUpdateArgs<ExtArgs>>): Prisma__DaysInMonthClient<$Result.GetResult<Prisma.$DaysInMonthPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DaysInMonths.
     * @param {DaysInMonthDeleteManyArgs} args - Arguments to filter DaysInMonths to delete.
     * @example
     * // Delete a few DaysInMonths
     * const { count } = await prisma.daysInMonth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DaysInMonthDeleteManyArgs>(args?: SelectSubset<T, DaysInMonthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DaysInMonths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DaysInMonths
     * const daysInMonth = await prisma.daysInMonth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DaysInMonthUpdateManyArgs>(args: SelectSubset<T, DaysInMonthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DaysInMonth.
     * @param {DaysInMonthUpsertArgs} args - Arguments to update or create a DaysInMonth.
     * @example
     * // Update or create a DaysInMonth
     * const daysInMonth = await prisma.daysInMonth.upsert({
     *   create: {
     *     // ... data to create a DaysInMonth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DaysInMonth we want to update
     *   }
     * })
     */
    upsert<T extends DaysInMonthUpsertArgs>(args: SelectSubset<T, DaysInMonthUpsertArgs<ExtArgs>>): Prisma__DaysInMonthClient<$Result.GetResult<Prisma.$DaysInMonthPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DaysInMonths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonthCountArgs} args - Arguments to filter DaysInMonths to count.
     * @example
     * // Count the number of DaysInMonths
     * const count = await prisma.daysInMonth.count({
     *   where: {
     *     // ... the filter for the DaysInMonths we want to count
     *   }
     * })
    **/
    count<T extends DaysInMonthCountArgs>(
      args?: Subset<T, DaysInMonthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DaysInMonthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DaysInMonth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DaysInMonthAggregateArgs>(args: Subset<T, DaysInMonthAggregateArgs>): Prisma.PrismaPromise<GetDaysInMonthAggregateType<T>>

    /**
     * Group by DaysInMonth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DaysInMonthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DaysInMonthGroupByArgs['orderBy'] }
        : { orderBy?: DaysInMonthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DaysInMonthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDaysInMonthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DaysInMonth model
   */
  readonly fields: DaysInMonthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DaysInMonth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DaysInMonthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DaysInMonth model
   */ 
  interface DaysInMonthFieldRefs {
    readonly DateManagedID: FieldRef<"DaysInMonth", 'Int'>
    readonly DateManaged: FieldRef<"DaysInMonth", 'DateTime'>
    readonly YearManaged: FieldRef<"DaysInMonth", 'Int'>
    readonly MonthManaged: FieldRef<"DaysInMonth", 'Int'>
    readonly DayInMonth: FieldRef<"DaysInMonth", 'Float'>
    readonly DayInWeek: FieldRef<"DaysInMonth", 'Int'>
    readonly WeekInYear: FieldRef<"DaysInMonth", 'Int'>
    readonly WeekInMonth: FieldRef<"DaysInMonth", 'Int'>
    readonly DayTypeID: FieldRef<"DaysInMonth", 'Int'>
    readonly StartEndTimeSabat: FieldRef<"DaysInMonth", 'DateTime'>
    readonly HolidayName: FieldRef<"DaysInMonth", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DaysInMonth findUnique
   */
  export type DaysInMonthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth
     */
    select?: DaysInMonthSelect<ExtArgs> | null
    /**
     * Filter, which DaysInMonth to fetch.
     */
    where: DaysInMonthWhereUniqueInput
  }

  /**
   * DaysInMonth findUniqueOrThrow
   */
  export type DaysInMonthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth
     */
    select?: DaysInMonthSelect<ExtArgs> | null
    /**
     * Filter, which DaysInMonth to fetch.
     */
    where: DaysInMonthWhereUniqueInput
  }

  /**
   * DaysInMonth findFirst
   */
  export type DaysInMonthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth
     */
    select?: DaysInMonthSelect<ExtArgs> | null
    /**
     * Filter, which DaysInMonth to fetch.
     */
    where?: DaysInMonthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DaysInMonths to fetch.
     */
    orderBy?: DaysInMonthOrderByWithRelationInput | DaysInMonthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DaysInMonths.
     */
    cursor?: DaysInMonthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DaysInMonths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DaysInMonths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DaysInMonths.
     */
    distinct?: DaysInMonthScalarFieldEnum | DaysInMonthScalarFieldEnum[]
  }

  /**
   * DaysInMonth findFirstOrThrow
   */
  export type DaysInMonthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth
     */
    select?: DaysInMonthSelect<ExtArgs> | null
    /**
     * Filter, which DaysInMonth to fetch.
     */
    where?: DaysInMonthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DaysInMonths to fetch.
     */
    orderBy?: DaysInMonthOrderByWithRelationInput | DaysInMonthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DaysInMonths.
     */
    cursor?: DaysInMonthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DaysInMonths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DaysInMonths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DaysInMonths.
     */
    distinct?: DaysInMonthScalarFieldEnum | DaysInMonthScalarFieldEnum[]
  }

  /**
   * DaysInMonth findMany
   */
  export type DaysInMonthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth
     */
    select?: DaysInMonthSelect<ExtArgs> | null
    /**
     * Filter, which DaysInMonths to fetch.
     */
    where?: DaysInMonthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DaysInMonths to fetch.
     */
    orderBy?: DaysInMonthOrderByWithRelationInput | DaysInMonthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DaysInMonths.
     */
    cursor?: DaysInMonthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DaysInMonths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DaysInMonths.
     */
    skip?: number
    distinct?: DaysInMonthScalarFieldEnum | DaysInMonthScalarFieldEnum[]
  }

  /**
   * DaysInMonth create
   */
  export type DaysInMonthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth
     */
    select?: DaysInMonthSelect<ExtArgs> | null
    /**
     * The data needed to create a DaysInMonth.
     */
    data: XOR<DaysInMonthCreateInput, DaysInMonthUncheckedCreateInput>
  }

  /**
   * DaysInMonth createMany
   */
  export type DaysInMonthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DaysInMonths.
     */
    data: DaysInMonthCreateManyInput | DaysInMonthCreateManyInput[]
  }

  /**
   * DaysInMonth update
   */
  export type DaysInMonthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth
     */
    select?: DaysInMonthSelect<ExtArgs> | null
    /**
     * The data needed to update a DaysInMonth.
     */
    data: XOR<DaysInMonthUpdateInput, DaysInMonthUncheckedUpdateInput>
    /**
     * Choose, which DaysInMonth to update.
     */
    where: DaysInMonthWhereUniqueInput
  }

  /**
   * DaysInMonth updateMany
   */
  export type DaysInMonthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DaysInMonths.
     */
    data: XOR<DaysInMonthUpdateManyMutationInput, DaysInMonthUncheckedUpdateManyInput>
    /**
     * Filter which DaysInMonths to update
     */
    where?: DaysInMonthWhereInput
  }

  /**
   * DaysInMonth upsert
   */
  export type DaysInMonthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth
     */
    select?: DaysInMonthSelect<ExtArgs> | null
    /**
     * The filter to search for the DaysInMonth to update in case it exists.
     */
    where: DaysInMonthWhereUniqueInput
    /**
     * In case the DaysInMonth found by the `where` argument doesn't exist, create a new DaysInMonth with this data.
     */
    create: XOR<DaysInMonthCreateInput, DaysInMonthUncheckedCreateInput>
    /**
     * In case the DaysInMonth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DaysInMonthUpdateInput, DaysInMonthUncheckedUpdateInput>
  }

  /**
   * DaysInMonth delete
   */
  export type DaysInMonthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth
     */
    select?: DaysInMonthSelect<ExtArgs> | null
    /**
     * Filter which DaysInMonth to delete.
     */
    where: DaysInMonthWhereUniqueInput
  }

  /**
   * DaysInMonth deleteMany
   */
  export type DaysInMonthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DaysInMonths to delete
     */
    where?: DaysInMonthWhereInput
  }

  /**
   * DaysInMonth without action
   */
  export type DaysInMonthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth
     */
    select?: DaysInMonthSelect<ExtArgs> | null
  }


  /**
   * Model DaysInMonth_NewYear
   */

  export type AggregateDaysInMonth_NewYear = {
    _count: DaysInMonth_NewYearCountAggregateOutputType | null
    _avg: DaysInMonth_NewYearAvgAggregateOutputType | null
    _sum: DaysInMonth_NewYearSumAggregateOutputType | null
    _min: DaysInMonth_NewYearMinAggregateOutputType | null
    _max: DaysInMonth_NewYearMaxAggregateOutputType | null
  }

  export type DaysInMonth_NewYearAvgAggregateOutputType = {
    DateManagedID: number | null
    YearManaged: number | null
    MonthManaged: number | null
    DayInMonth: number | null
    DayInWeek: number | null
    WeekInYear: number | null
    WeekInMonth: number | null
    DayTypeID: number | null
  }

  export type DaysInMonth_NewYearSumAggregateOutputType = {
    DateManagedID: number | null
    YearManaged: number | null
    MonthManaged: number | null
    DayInMonth: number | null
    DayInWeek: number | null
    WeekInYear: number | null
    WeekInMonth: number | null
    DayTypeID: number | null
  }

  export type DaysInMonth_NewYearMinAggregateOutputType = {
    DateManagedID: number | null
    DateManaged: Date | null
    YearManaged: number | null
    MonthManaged: number | null
    DayInMonth: number | null
    DayInWeek: number | null
    WeekInYear: number | null
    WeekInMonth: number | null
    DayTypeID: number | null
    StartEndTimeSabat: Date | null
    HolidayName: string | null
  }

  export type DaysInMonth_NewYearMaxAggregateOutputType = {
    DateManagedID: number | null
    DateManaged: Date | null
    YearManaged: number | null
    MonthManaged: number | null
    DayInMonth: number | null
    DayInWeek: number | null
    WeekInYear: number | null
    WeekInMonth: number | null
    DayTypeID: number | null
    StartEndTimeSabat: Date | null
    HolidayName: string | null
  }

  export type DaysInMonth_NewYearCountAggregateOutputType = {
    DateManagedID: number
    DateManaged: number
    YearManaged: number
    MonthManaged: number
    DayInMonth: number
    DayInWeek: number
    WeekInYear: number
    WeekInMonth: number
    DayTypeID: number
    StartEndTimeSabat: number
    HolidayName: number
    _all: number
  }


  export type DaysInMonth_NewYearAvgAggregateInputType = {
    DateManagedID?: true
    YearManaged?: true
    MonthManaged?: true
    DayInMonth?: true
    DayInWeek?: true
    WeekInYear?: true
    WeekInMonth?: true
    DayTypeID?: true
  }

  export type DaysInMonth_NewYearSumAggregateInputType = {
    DateManagedID?: true
    YearManaged?: true
    MonthManaged?: true
    DayInMonth?: true
    DayInWeek?: true
    WeekInYear?: true
    WeekInMonth?: true
    DayTypeID?: true
  }

  export type DaysInMonth_NewYearMinAggregateInputType = {
    DateManagedID?: true
    DateManaged?: true
    YearManaged?: true
    MonthManaged?: true
    DayInMonth?: true
    DayInWeek?: true
    WeekInYear?: true
    WeekInMonth?: true
    DayTypeID?: true
    StartEndTimeSabat?: true
    HolidayName?: true
  }

  export type DaysInMonth_NewYearMaxAggregateInputType = {
    DateManagedID?: true
    DateManaged?: true
    YearManaged?: true
    MonthManaged?: true
    DayInMonth?: true
    DayInWeek?: true
    WeekInYear?: true
    WeekInMonth?: true
    DayTypeID?: true
    StartEndTimeSabat?: true
    HolidayName?: true
  }

  export type DaysInMonth_NewYearCountAggregateInputType = {
    DateManagedID?: true
    DateManaged?: true
    YearManaged?: true
    MonthManaged?: true
    DayInMonth?: true
    DayInWeek?: true
    WeekInYear?: true
    WeekInMonth?: true
    DayTypeID?: true
    StartEndTimeSabat?: true
    HolidayName?: true
    _all?: true
  }

  export type DaysInMonth_NewYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DaysInMonth_NewYear to aggregate.
     */
    where?: DaysInMonth_NewYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DaysInMonth_NewYears to fetch.
     */
    orderBy?: DaysInMonth_NewYearOrderByWithRelationInput | DaysInMonth_NewYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DaysInMonth_NewYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DaysInMonth_NewYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DaysInMonth_NewYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DaysInMonth_NewYears
    **/
    _count?: true | DaysInMonth_NewYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DaysInMonth_NewYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DaysInMonth_NewYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DaysInMonth_NewYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DaysInMonth_NewYearMaxAggregateInputType
  }

  export type GetDaysInMonth_NewYearAggregateType<T extends DaysInMonth_NewYearAggregateArgs> = {
        [P in keyof T & keyof AggregateDaysInMonth_NewYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDaysInMonth_NewYear[P]>
      : GetScalarType<T[P], AggregateDaysInMonth_NewYear[P]>
  }




  export type DaysInMonth_NewYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DaysInMonth_NewYearWhereInput
    orderBy?: DaysInMonth_NewYearOrderByWithAggregationInput | DaysInMonth_NewYearOrderByWithAggregationInput[]
    by: DaysInMonth_NewYearScalarFieldEnum[] | DaysInMonth_NewYearScalarFieldEnum
    having?: DaysInMonth_NewYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DaysInMonth_NewYearCountAggregateInputType | true
    _avg?: DaysInMonth_NewYearAvgAggregateInputType
    _sum?: DaysInMonth_NewYearSumAggregateInputType
    _min?: DaysInMonth_NewYearMinAggregateInputType
    _max?: DaysInMonth_NewYearMaxAggregateInputType
  }

  export type DaysInMonth_NewYearGroupByOutputType = {
    DateManagedID: number
    DateManaged: Date
    YearManaged: number | null
    MonthManaged: number | null
    DayInMonth: number | null
    DayInWeek: number | null
    WeekInYear: number | null
    WeekInMonth: number | null
    DayTypeID: number | null
    StartEndTimeSabat: Date | null
    HolidayName: string | null
    _count: DaysInMonth_NewYearCountAggregateOutputType | null
    _avg: DaysInMonth_NewYearAvgAggregateOutputType | null
    _sum: DaysInMonth_NewYearSumAggregateOutputType | null
    _min: DaysInMonth_NewYearMinAggregateOutputType | null
    _max: DaysInMonth_NewYearMaxAggregateOutputType | null
  }

  type GetDaysInMonth_NewYearGroupByPayload<T extends DaysInMonth_NewYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DaysInMonth_NewYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DaysInMonth_NewYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DaysInMonth_NewYearGroupByOutputType[P]>
            : GetScalarType<T[P], DaysInMonth_NewYearGroupByOutputType[P]>
        }
      >
    >


  export type DaysInMonth_NewYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    DateManagedID?: boolean
    DateManaged?: boolean
    YearManaged?: boolean
    MonthManaged?: boolean
    DayInMonth?: boolean
    DayInWeek?: boolean
    WeekInYear?: boolean
    WeekInMonth?: boolean
    DayTypeID?: boolean
    StartEndTimeSabat?: boolean
    HolidayName?: boolean
  }, ExtArgs["result"]["daysInMonth_NewYear"]>


  export type DaysInMonth_NewYearSelectScalar = {
    DateManagedID?: boolean
    DateManaged?: boolean
    YearManaged?: boolean
    MonthManaged?: boolean
    DayInMonth?: boolean
    DayInWeek?: boolean
    WeekInYear?: boolean
    WeekInMonth?: boolean
    DayTypeID?: boolean
    StartEndTimeSabat?: boolean
    HolidayName?: boolean
  }


  export type $DaysInMonth_NewYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DaysInMonth_NewYear"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      DateManagedID: number
      DateManaged: Date
      YearManaged: number | null
      MonthManaged: number | null
      DayInMonth: number | null
      DayInWeek: number | null
      WeekInYear: number | null
      WeekInMonth: number | null
      DayTypeID: number | null
      StartEndTimeSabat: Date | null
      HolidayName: string | null
    }, ExtArgs["result"]["daysInMonth_NewYear"]>
    composites: {}
  }

  type DaysInMonth_NewYearGetPayload<S extends boolean | null | undefined | DaysInMonth_NewYearDefaultArgs> = $Result.GetResult<Prisma.$DaysInMonth_NewYearPayload, S>

  type DaysInMonth_NewYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DaysInMonth_NewYearFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DaysInMonth_NewYearCountAggregateInputType | true
    }

  export interface DaysInMonth_NewYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DaysInMonth_NewYear'], meta: { name: 'DaysInMonth_NewYear' } }
    /**
     * Find zero or one DaysInMonth_NewYear that matches the filter.
     * @param {DaysInMonth_NewYearFindUniqueArgs} args - Arguments to find a DaysInMonth_NewYear
     * @example
     * // Get one DaysInMonth_NewYear
     * const daysInMonth_NewYear = await prisma.daysInMonth_NewYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DaysInMonth_NewYearFindUniqueArgs>(args: SelectSubset<T, DaysInMonth_NewYearFindUniqueArgs<ExtArgs>>): Prisma__DaysInMonth_NewYearClient<$Result.GetResult<Prisma.$DaysInMonth_NewYearPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DaysInMonth_NewYear that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DaysInMonth_NewYearFindUniqueOrThrowArgs} args - Arguments to find a DaysInMonth_NewYear
     * @example
     * // Get one DaysInMonth_NewYear
     * const daysInMonth_NewYear = await prisma.daysInMonth_NewYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DaysInMonth_NewYearFindUniqueOrThrowArgs>(args: SelectSubset<T, DaysInMonth_NewYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DaysInMonth_NewYearClient<$Result.GetResult<Prisma.$DaysInMonth_NewYearPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DaysInMonth_NewYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonth_NewYearFindFirstArgs} args - Arguments to find a DaysInMonth_NewYear
     * @example
     * // Get one DaysInMonth_NewYear
     * const daysInMonth_NewYear = await prisma.daysInMonth_NewYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DaysInMonth_NewYearFindFirstArgs>(args?: SelectSubset<T, DaysInMonth_NewYearFindFirstArgs<ExtArgs>>): Prisma__DaysInMonth_NewYearClient<$Result.GetResult<Prisma.$DaysInMonth_NewYearPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DaysInMonth_NewYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonth_NewYearFindFirstOrThrowArgs} args - Arguments to find a DaysInMonth_NewYear
     * @example
     * // Get one DaysInMonth_NewYear
     * const daysInMonth_NewYear = await prisma.daysInMonth_NewYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DaysInMonth_NewYearFindFirstOrThrowArgs>(args?: SelectSubset<T, DaysInMonth_NewYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__DaysInMonth_NewYearClient<$Result.GetResult<Prisma.$DaysInMonth_NewYearPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DaysInMonth_NewYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonth_NewYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DaysInMonth_NewYears
     * const daysInMonth_NewYears = await prisma.daysInMonth_NewYear.findMany()
     * 
     * // Get first 10 DaysInMonth_NewYears
     * const daysInMonth_NewYears = await prisma.daysInMonth_NewYear.findMany({ take: 10 })
     * 
     * // Only select the `DateManagedID`
     * const daysInMonth_NewYearWithDateManagedIDOnly = await prisma.daysInMonth_NewYear.findMany({ select: { DateManagedID: true } })
     * 
     */
    findMany<T extends DaysInMonth_NewYearFindManyArgs>(args?: SelectSubset<T, DaysInMonth_NewYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DaysInMonth_NewYearPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DaysInMonth_NewYear.
     * @param {DaysInMonth_NewYearCreateArgs} args - Arguments to create a DaysInMonth_NewYear.
     * @example
     * // Create one DaysInMonth_NewYear
     * const DaysInMonth_NewYear = await prisma.daysInMonth_NewYear.create({
     *   data: {
     *     // ... data to create a DaysInMonth_NewYear
     *   }
     * })
     * 
     */
    create<T extends DaysInMonth_NewYearCreateArgs>(args: SelectSubset<T, DaysInMonth_NewYearCreateArgs<ExtArgs>>): Prisma__DaysInMonth_NewYearClient<$Result.GetResult<Prisma.$DaysInMonth_NewYearPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DaysInMonth_NewYears.
     * @param {DaysInMonth_NewYearCreateManyArgs} args - Arguments to create many DaysInMonth_NewYears.
     * @example
     * // Create many DaysInMonth_NewYears
     * const daysInMonth_NewYear = await prisma.daysInMonth_NewYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DaysInMonth_NewYearCreateManyArgs>(args?: SelectSubset<T, DaysInMonth_NewYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DaysInMonth_NewYear.
     * @param {DaysInMonth_NewYearDeleteArgs} args - Arguments to delete one DaysInMonth_NewYear.
     * @example
     * // Delete one DaysInMonth_NewYear
     * const DaysInMonth_NewYear = await prisma.daysInMonth_NewYear.delete({
     *   where: {
     *     // ... filter to delete one DaysInMonth_NewYear
     *   }
     * })
     * 
     */
    delete<T extends DaysInMonth_NewYearDeleteArgs>(args: SelectSubset<T, DaysInMonth_NewYearDeleteArgs<ExtArgs>>): Prisma__DaysInMonth_NewYearClient<$Result.GetResult<Prisma.$DaysInMonth_NewYearPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DaysInMonth_NewYear.
     * @param {DaysInMonth_NewYearUpdateArgs} args - Arguments to update one DaysInMonth_NewYear.
     * @example
     * // Update one DaysInMonth_NewYear
     * const daysInMonth_NewYear = await prisma.daysInMonth_NewYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DaysInMonth_NewYearUpdateArgs>(args: SelectSubset<T, DaysInMonth_NewYearUpdateArgs<ExtArgs>>): Prisma__DaysInMonth_NewYearClient<$Result.GetResult<Prisma.$DaysInMonth_NewYearPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DaysInMonth_NewYears.
     * @param {DaysInMonth_NewYearDeleteManyArgs} args - Arguments to filter DaysInMonth_NewYears to delete.
     * @example
     * // Delete a few DaysInMonth_NewYears
     * const { count } = await prisma.daysInMonth_NewYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DaysInMonth_NewYearDeleteManyArgs>(args?: SelectSubset<T, DaysInMonth_NewYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DaysInMonth_NewYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonth_NewYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DaysInMonth_NewYears
     * const daysInMonth_NewYear = await prisma.daysInMonth_NewYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DaysInMonth_NewYearUpdateManyArgs>(args: SelectSubset<T, DaysInMonth_NewYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DaysInMonth_NewYear.
     * @param {DaysInMonth_NewYearUpsertArgs} args - Arguments to update or create a DaysInMonth_NewYear.
     * @example
     * // Update or create a DaysInMonth_NewYear
     * const daysInMonth_NewYear = await prisma.daysInMonth_NewYear.upsert({
     *   create: {
     *     // ... data to create a DaysInMonth_NewYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DaysInMonth_NewYear we want to update
     *   }
     * })
     */
    upsert<T extends DaysInMonth_NewYearUpsertArgs>(args: SelectSubset<T, DaysInMonth_NewYearUpsertArgs<ExtArgs>>): Prisma__DaysInMonth_NewYearClient<$Result.GetResult<Prisma.$DaysInMonth_NewYearPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DaysInMonth_NewYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonth_NewYearCountArgs} args - Arguments to filter DaysInMonth_NewYears to count.
     * @example
     * // Count the number of DaysInMonth_NewYears
     * const count = await prisma.daysInMonth_NewYear.count({
     *   where: {
     *     // ... the filter for the DaysInMonth_NewYears we want to count
     *   }
     * })
    **/
    count<T extends DaysInMonth_NewYearCountArgs>(
      args?: Subset<T, DaysInMonth_NewYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DaysInMonth_NewYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DaysInMonth_NewYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonth_NewYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DaysInMonth_NewYearAggregateArgs>(args: Subset<T, DaysInMonth_NewYearAggregateArgs>): Prisma.PrismaPromise<GetDaysInMonth_NewYearAggregateType<T>>

    /**
     * Group by DaysInMonth_NewYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DaysInMonth_NewYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DaysInMonth_NewYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DaysInMonth_NewYearGroupByArgs['orderBy'] }
        : { orderBy?: DaysInMonth_NewYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DaysInMonth_NewYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDaysInMonth_NewYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DaysInMonth_NewYear model
   */
  readonly fields: DaysInMonth_NewYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DaysInMonth_NewYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DaysInMonth_NewYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DaysInMonth_NewYear model
   */ 
  interface DaysInMonth_NewYearFieldRefs {
    readonly DateManagedID: FieldRef<"DaysInMonth_NewYear", 'Int'>
    readonly DateManaged: FieldRef<"DaysInMonth_NewYear", 'DateTime'>
    readonly YearManaged: FieldRef<"DaysInMonth_NewYear", 'Int'>
    readonly MonthManaged: FieldRef<"DaysInMonth_NewYear", 'Int'>
    readonly DayInMonth: FieldRef<"DaysInMonth_NewYear", 'Float'>
    readonly DayInWeek: FieldRef<"DaysInMonth_NewYear", 'Int'>
    readonly WeekInYear: FieldRef<"DaysInMonth_NewYear", 'Int'>
    readonly WeekInMonth: FieldRef<"DaysInMonth_NewYear", 'Int'>
    readonly DayTypeID: FieldRef<"DaysInMonth_NewYear", 'Int'>
    readonly StartEndTimeSabat: FieldRef<"DaysInMonth_NewYear", 'DateTime'>
    readonly HolidayName: FieldRef<"DaysInMonth_NewYear", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DaysInMonth_NewYear findUnique
   */
  export type DaysInMonth_NewYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth_NewYear
     */
    select?: DaysInMonth_NewYearSelect<ExtArgs> | null
    /**
     * Filter, which DaysInMonth_NewYear to fetch.
     */
    where: DaysInMonth_NewYearWhereUniqueInput
  }

  /**
   * DaysInMonth_NewYear findUniqueOrThrow
   */
  export type DaysInMonth_NewYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth_NewYear
     */
    select?: DaysInMonth_NewYearSelect<ExtArgs> | null
    /**
     * Filter, which DaysInMonth_NewYear to fetch.
     */
    where: DaysInMonth_NewYearWhereUniqueInput
  }

  /**
   * DaysInMonth_NewYear findFirst
   */
  export type DaysInMonth_NewYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth_NewYear
     */
    select?: DaysInMonth_NewYearSelect<ExtArgs> | null
    /**
     * Filter, which DaysInMonth_NewYear to fetch.
     */
    where?: DaysInMonth_NewYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DaysInMonth_NewYears to fetch.
     */
    orderBy?: DaysInMonth_NewYearOrderByWithRelationInput | DaysInMonth_NewYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DaysInMonth_NewYears.
     */
    cursor?: DaysInMonth_NewYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DaysInMonth_NewYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DaysInMonth_NewYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DaysInMonth_NewYears.
     */
    distinct?: DaysInMonth_NewYearScalarFieldEnum | DaysInMonth_NewYearScalarFieldEnum[]
  }

  /**
   * DaysInMonth_NewYear findFirstOrThrow
   */
  export type DaysInMonth_NewYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth_NewYear
     */
    select?: DaysInMonth_NewYearSelect<ExtArgs> | null
    /**
     * Filter, which DaysInMonth_NewYear to fetch.
     */
    where?: DaysInMonth_NewYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DaysInMonth_NewYears to fetch.
     */
    orderBy?: DaysInMonth_NewYearOrderByWithRelationInput | DaysInMonth_NewYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DaysInMonth_NewYears.
     */
    cursor?: DaysInMonth_NewYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DaysInMonth_NewYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DaysInMonth_NewYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DaysInMonth_NewYears.
     */
    distinct?: DaysInMonth_NewYearScalarFieldEnum | DaysInMonth_NewYearScalarFieldEnum[]
  }

  /**
   * DaysInMonth_NewYear findMany
   */
  export type DaysInMonth_NewYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth_NewYear
     */
    select?: DaysInMonth_NewYearSelect<ExtArgs> | null
    /**
     * Filter, which DaysInMonth_NewYears to fetch.
     */
    where?: DaysInMonth_NewYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DaysInMonth_NewYears to fetch.
     */
    orderBy?: DaysInMonth_NewYearOrderByWithRelationInput | DaysInMonth_NewYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DaysInMonth_NewYears.
     */
    cursor?: DaysInMonth_NewYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DaysInMonth_NewYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DaysInMonth_NewYears.
     */
    skip?: number
    distinct?: DaysInMonth_NewYearScalarFieldEnum | DaysInMonth_NewYearScalarFieldEnum[]
  }

  /**
   * DaysInMonth_NewYear create
   */
  export type DaysInMonth_NewYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth_NewYear
     */
    select?: DaysInMonth_NewYearSelect<ExtArgs> | null
    /**
     * The data needed to create a DaysInMonth_NewYear.
     */
    data: XOR<DaysInMonth_NewYearCreateInput, DaysInMonth_NewYearUncheckedCreateInput>
  }

  /**
   * DaysInMonth_NewYear createMany
   */
  export type DaysInMonth_NewYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DaysInMonth_NewYears.
     */
    data: DaysInMonth_NewYearCreateManyInput | DaysInMonth_NewYearCreateManyInput[]
  }

  /**
   * DaysInMonth_NewYear update
   */
  export type DaysInMonth_NewYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth_NewYear
     */
    select?: DaysInMonth_NewYearSelect<ExtArgs> | null
    /**
     * The data needed to update a DaysInMonth_NewYear.
     */
    data: XOR<DaysInMonth_NewYearUpdateInput, DaysInMonth_NewYearUncheckedUpdateInput>
    /**
     * Choose, which DaysInMonth_NewYear to update.
     */
    where: DaysInMonth_NewYearWhereUniqueInput
  }

  /**
   * DaysInMonth_NewYear updateMany
   */
  export type DaysInMonth_NewYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DaysInMonth_NewYears.
     */
    data: XOR<DaysInMonth_NewYearUpdateManyMutationInput, DaysInMonth_NewYearUncheckedUpdateManyInput>
    /**
     * Filter which DaysInMonth_NewYears to update
     */
    where?: DaysInMonth_NewYearWhereInput
  }

  /**
   * DaysInMonth_NewYear upsert
   */
  export type DaysInMonth_NewYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth_NewYear
     */
    select?: DaysInMonth_NewYearSelect<ExtArgs> | null
    /**
     * The filter to search for the DaysInMonth_NewYear to update in case it exists.
     */
    where: DaysInMonth_NewYearWhereUniqueInput
    /**
     * In case the DaysInMonth_NewYear found by the `where` argument doesn't exist, create a new DaysInMonth_NewYear with this data.
     */
    create: XOR<DaysInMonth_NewYearCreateInput, DaysInMonth_NewYearUncheckedCreateInput>
    /**
     * In case the DaysInMonth_NewYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DaysInMonth_NewYearUpdateInput, DaysInMonth_NewYearUncheckedUpdateInput>
  }

  /**
   * DaysInMonth_NewYear delete
   */
  export type DaysInMonth_NewYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth_NewYear
     */
    select?: DaysInMonth_NewYearSelect<ExtArgs> | null
    /**
     * Filter which DaysInMonth_NewYear to delete.
     */
    where: DaysInMonth_NewYearWhereUniqueInput
  }

  /**
   * DaysInMonth_NewYear deleteMany
   */
  export type DaysInMonth_NewYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DaysInMonth_NewYears to delete
     */
    where?: DaysInMonth_NewYearWhereInput
  }

  /**
   * DaysInMonth_NewYear without action
   */
  export type DaysInMonth_NewYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DaysInMonth_NewYear
     */
    select?: DaysInMonth_NewYearSelect<ExtArgs> | null
  }


  /**
   * Model DayType
   */

  export type AggregateDayType = {
    _count: DayTypeCountAggregateOutputType | null
    _avg: DayTypeAvgAggregateOutputType | null
    _sum: DayTypeSumAggregateOutputType | null
    _min: DayTypeMinAggregateOutputType | null
    _max: DayTypeMaxAggregateOutputType | null
  }

  export type DayTypeAvgAggregateOutputType = {
    DayTypeID: number | null
    SetOrder: number | null
  }

  export type DayTypeSumAggregateOutputType = {
    DayTypeID: number | null
    SetOrder: number | null
  }

  export type DayTypeMinAggregateOutputType = {
    DayTypeID: number | null
    DayTypeName: string | null
    SetOrder: number | null
  }

  export type DayTypeMaxAggregateOutputType = {
    DayTypeID: number | null
    DayTypeName: string | null
    SetOrder: number | null
  }

  export type DayTypeCountAggregateOutputType = {
    DayTypeID: number
    DayTypeName: number
    SetOrder: number
    _all: number
  }


  export type DayTypeAvgAggregateInputType = {
    DayTypeID?: true
    SetOrder?: true
  }

  export type DayTypeSumAggregateInputType = {
    DayTypeID?: true
    SetOrder?: true
  }

  export type DayTypeMinAggregateInputType = {
    DayTypeID?: true
    DayTypeName?: true
    SetOrder?: true
  }

  export type DayTypeMaxAggregateInputType = {
    DayTypeID?: true
    DayTypeName?: true
    SetOrder?: true
  }

  export type DayTypeCountAggregateInputType = {
    DayTypeID?: true
    DayTypeName?: true
    SetOrder?: true
    _all?: true
  }

  export type DayTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DayType to aggregate.
     */
    where?: DayTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayTypes to fetch.
     */
    orderBy?: DayTypeOrderByWithRelationInput | DayTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DayTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DayTypes
    **/
    _count?: true | DayTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DayTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DayTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DayTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DayTypeMaxAggregateInputType
  }

  export type GetDayTypeAggregateType<T extends DayTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDayType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDayType[P]>
      : GetScalarType<T[P], AggregateDayType[P]>
  }




  export type DayTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DayTypeWhereInput
    orderBy?: DayTypeOrderByWithAggregationInput | DayTypeOrderByWithAggregationInput[]
    by: DayTypeScalarFieldEnum[] | DayTypeScalarFieldEnum
    having?: DayTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DayTypeCountAggregateInputType | true
    _avg?: DayTypeAvgAggregateInputType
    _sum?: DayTypeSumAggregateInputType
    _min?: DayTypeMinAggregateInputType
    _max?: DayTypeMaxAggregateInputType
  }

  export type DayTypeGroupByOutputType = {
    DayTypeID: number
    DayTypeName: string
    SetOrder: number
    _count: DayTypeCountAggregateOutputType | null
    _avg: DayTypeAvgAggregateOutputType | null
    _sum: DayTypeSumAggregateOutputType | null
    _min: DayTypeMinAggregateOutputType | null
    _max: DayTypeMaxAggregateOutputType | null
  }

  type GetDayTypeGroupByPayload<T extends DayTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DayTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DayTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DayTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DayTypeGroupByOutputType[P]>
        }
      >
    >


  export type DayTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    DayTypeID?: boolean
    DayTypeName?: boolean
    SetOrder?: boolean
  }, ExtArgs["result"]["dayType"]>


  export type DayTypeSelectScalar = {
    DayTypeID?: boolean
    DayTypeName?: boolean
    SetOrder?: boolean
  }


  export type $DayTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DayType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      DayTypeID: number
      DayTypeName: string
      SetOrder: number
    }, ExtArgs["result"]["dayType"]>
    composites: {}
  }

  type DayTypeGetPayload<S extends boolean | null | undefined | DayTypeDefaultArgs> = $Result.GetResult<Prisma.$DayTypePayload, S>

  type DayTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DayTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DayTypeCountAggregateInputType | true
    }

  export interface DayTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DayType'], meta: { name: 'DayType' } }
    /**
     * Find zero or one DayType that matches the filter.
     * @param {DayTypeFindUniqueArgs} args - Arguments to find a DayType
     * @example
     * // Get one DayType
     * const dayType = await prisma.dayType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DayTypeFindUniqueArgs>(args: SelectSubset<T, DayTypeFindUniqueArgs<ExtArgs>>): Prisma__DayTypeClient<$Result.GetResult<Prisma.$DayTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DayType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DayTypeFindUniqueOrThrowArgs} args - Arguments to find a DayType
     * @example
     * // Get one DayType
     * const dayType = await prisma.dayType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DayTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, DayTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DayTypeClient<$Result.GetResult<Prisma.$DayTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DayType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayTypeFindFirstArgs} args - Arguments to find a DayType
     * @example
     * // Get one DayType
     * const dayType = await prisma.dayType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DayTypeFindFirstArgs>(args?: SelectSubset<T, DayTypeFindFirstArgs<ExtArgs>>): Prisma__DayTypeClient<$Result.GetResult<Prisma.$DayTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DayType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayTypeFindFirstOrThrowArgs} args - Arguments to find a DayType
     * @example
     * // Get one DayType
     * const dayType = await prisma.dayType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DayTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, DayTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DayTypeClient<$Result.GetResult<Prisma.$DayTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DayTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DayTypes
     * const dayTypes = await prisma.dayType.findMany()
     * 
     * // Get first 10 DayTypes
     * const dayTypes = await prisma.dayType.findMany({ take: 10 })
     * 
     * // Only select the `DayTypeID`
     * const dayTypeWithDayTypeIDOnly = await prisma.dayType.findMany({ select: { DayTypeID: true } })
     * 
     */
    findMany<T extends DayTypeFindManyArgs>(args?: SelectSubset<T, DayTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DayType.
     * @param {DayTypeCreateArgs} args - Arguments to create a DayType.
     * @example
     * // Create one DayType
     * const DayType = await prisma.dayType.create({
     *   data: {
     *     // ... data to create a DayType
     *   }
     * })
     * 
     */
    create<T extends DayTypeCreateArgs>(args: SelectSubset<T, DayTypeCreateArgs<ExtArgs>>): Prisma__DayTypeClient<$Result.GetResult<Prisma.$DayTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DayTypes.
     * @param {DayTypeCreateManyArgs} args - Arguments to create many DayTypes.
     * @example
     * // Create many DayTypes
     * const dayType = await prisma.dayType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DayTypeCreateManyArgs>(args?: SelectSubset<T, DayTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DayType.
     * @param {DayTypeDeleteArgs} args - Arguments to delete one DayType.
     * @example
     * // Delete one DayType
     * const DayType = await prisma.dayType.delete({
     *   where: {
     *     // ... filter to delete one DayType
     *   }
     * })
     * 
     */
    delete<T extends DayTypeDeleteArgs>(args: SelectSubset<T, DayTypeDeleteArgs<ExtArgs>>): Prisma__DayTypeClient<$Result.GetResult<Prisma.$DayTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DayType.
     * @param {DayTypeUpdateArgs} args - Arguments to update one DayType.
     * @example
     * // Update one DayType
     * const dayType = await prisma.dayType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DayTypeUpdateArgs>(args: SelectSubset<T, DayTypeUpdateArgs<ExtArgs>>): Prisma__DayTypeClient<$Result.GetResult<Prisma.$DayTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DayTypes.
     * @param {DayTypeDeleteManyArgs} args - Arguments to filter DayTypes to delete.
     * @example
     * // Delete a few DayTypes
     * const { count } = await prisma.dayType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DayTypeDeleteManyArgs>(args?: SelectSubset<T, DayTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DayTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DayTypes
     * const dayType = await prisma.dayType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DayTypeUpdateManyArgs>(args: SelectSubset<T, DayTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DayType.
     * @param {DayTypeUpsertArgs} args - Arguments to update or create a DayType.
     * @example
     * // Update or create a DayType
     * const dayType = await prisma.dayType.upsert({
     *   create: {
     *     // ... data to create a DayType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DayType we want to update
     *   }
     * })
     */
    upsert<T extends DayTypeUpsertArgs>(args: SelectSubset<T, DayTypeUpsertArgs<ExtArgs>>): Prisma__DayTypeClient<$Result.GetResult<Prisma.$DayTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DayTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayTypeCountArgs} args - Arguments to filter DayTypes to count.
     * @example
     * // Count the number of DayTypes
     * const count = await prisma.dayType.count({
     *   where: {
     *     // ... the filter for the DayTypes we want to count
     *   }
     * })
    **/
    count<T extends DayTypeCountArgs>(
      args?: Subset<T, DayTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DayTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DayType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DayTypeAggregateArgs>(args: Subset<T, DayTypeAggregateArgs>): Prisma.PrismaPromise<GetDayTypeAggregateType<T>>

    /**
     * Group by DayType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DayTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DayTypeGroupByArgs['orderBy'] }
        : { orderBy?: DayTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DayTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDayTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DayType model
   */
  readonly fields: DayTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DayType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DayTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DayType model
   */ 
  interface DayTypeFieldRefs {
    readonly DayTypeID: FieldRef<"DayType", 'Int'>
    readonly DayTypeName: FieldRef<"DayType", 'String'>
    readonly SetOrder: FieldRef<"DayType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DayType findUnique
   */
  export type DayTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayType
     */
    select?: DayTypeSelect<ExtArgs> | null
    /**
     * Filter, which DayType to fetch.
     */
    where: DayTypeWhereUniqueInput
  }

  /**
   * DayType findUniqueOrThrow
   */
  export type DayTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayType
     */
    select?: DayTypeSelect<ExtArgs> | null
    /**
     * Filter, which DayType to fetch.
     */
    where: DayTypeWhereUniqueInput
  }

  /**
   * DayType findFirst
   */
  export type DayTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayType
     */
    select?: DayTypeSelect<ExtArgs> | null
    /**
     * Filter, which DayType to fetch.
     */
    where?: DayTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayTypes to fetch.
     */
    orderBy?: DayTypeOrderByWithRelationInput | DayTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DayTypes.
     */
    cursor?: DayTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DayTypes.
     */
    distinct?: DayTypeScalarFieldEnum | DayTypeScalarFieldEnum[]
  }

  /**
   * DayType findFirstOrThrow
   */
  export type DayTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayType
     */
    select?: DayTypeSelect<ExtArgs> | null
    /**
     * Filter, which DayType to fetch.
     */
    where?: DayTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayTypes to fetch.
     */
    orderBy?: DayTypeOrderByWithRelationInput | DayTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DayTypes.
     */
    cursor?: DayTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DayTypes.
     */
    distinct?: DayTypeScalarFieldEnum | DayTypeScalarFieldEnum[]
  }

  /**
   * DayType findMany
   */
  export type DayTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayType
     */
    select?: DayTypeSelect<ExtArgs> | null
    /**
     * Filter, which DayTypes to fetch.
     */
    where?: DayTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayTypes to fetch.
     */
    orderBy?: DayTypeOrderByWithRelationInput | DayTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DayTypes.
     */
    cursor?: DayTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayTypes.
     */
    skip?: number
    distinct?: DayTypeScalarFieldEnum | DayTypeScalarFieldEnum[]
  }

  /**
   * DayType create
   */
  export type DayTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayType
     */
    select?: DayTypeSelect<ExtArgs> | null
    /**
     * The data needed to create a DayType.
     */
    data: XOR<DayTypeCreateInput, DayTypeUncheckedCreateInput>
  }

  /**
   * DayType createMany
   */
  export type DayTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DayTypes.
     */
    data: DayTypeCreateManyInput | DayTypeCreateManyInput[]
  }

  /**
   * DayType update
   */
  export type DayTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayType
     */
    select?: DayTypeSelect<ExtArgs> | null
    /**
     * The data needed to update a DayType.
     */
    data: XOR<DayTypeUpdateInput, DayTypeUncheckedUpdateInput>
    /**
     * Choose, which DayType to update.
     */
    where: DayTypeWhereUniqueInput
  }

  /**
   * DayType updateMany
   */
  export type DayTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DayTypes.
     */
    data: XOR<DayTypeUpdateManyMutationInput, DayTypeUncheckedUpdateManyInput>
    /**
     * Filter which DayTypes to update
     */
    where?: DayTypeWhereInput
  }

  /**
   * DayType upsert
   */
  export type DayTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayType
     */
    select?: DayTypeSelect<ExtArgs> | null
    /**
     * The filter to search for the DayType to update in case it exists.
     */
    where: DayTypeWhereUniqueInput
    /**
     * In case the DayType found by the `where` argument doesn't exist, create a new DayType with this data.
     */
    create: XOR<DayTypeCreateInput, DayTypeUncheckedCreateInput>
    /**
     * In case the DayType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DayTypeUpdateInput, DayTypeUncheckedUpdateInput>
  }

  /**
   * DayType delete
   */
  export type DayTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayType
     */
    select?: DayTypeSelect<ExtArgs> | null
    /**
     * Filter which DayType to delete.
     */
    where: DayTypeWhereUniqueInput
  }

  /**
   * DayType deleteMany
   */
  export type DayTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DayTypes to delete
     */
    where?: DayTypeWhereInput
  }

  /**
   * DayType without action
   */
  export type DayTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayType
     */
    select?: DayTypeSelect<ExtArgs> | null
  }


  /**
   * Model DisplayType
   */

  export type AggregateDisplayType = {
    _count: DisplayTypeCountAggregateOutputType | null
    _avg: DisplayTypeAvgAggregateOutputType | null
    _sum: DisplayTypeSumAggregateOutputType | null
    _min: DisplayTypeMinAggregateOutputType | null
    _max: DisplayTypeMaxAggregateOutputType | null
  }

  export type DisplayTypeAvgAggregateOutputType = {
    DisplayTypeID: number | null
    IsShowInDanzarCRM: number | null
  }

  export type DisplayTypeSumAggregateOutputType = {
    DisplayTypeID: number | null
    IsShowInDanzarCRM: number | null
  }

  export type DisplayTypeMinAggregateOutputType = {
    DisplayTypeID: number | null
    DisplayType: string | null
    URL: string | null
    IsShowInDanzarCRM: number | null
  }

  export type DisplayTypeMaxAggregateOutputType = {
    DisplayTypeID: number | null
    DisplayType: string | null
    URL: string | null
    IsShowInDanzarCRM: number | null
  }

  export type DisplayTypeCountAggregateOutputType = {
    DisplayTypeID: number
    DisplayType: number
    URL: number
    IsShowInDanzarCRM: number
    _all: number
  }


  export type DisplayTypeAvgAggregateInputType = {
    DisplayTypeID?: true
    IsShowInDanzarCRM?: true
  }

  export type DisplayTypeSumAggregateInputType = {
    DisplayTypeID?: true
    IsShowInDanzarCRM?: true
  }

  export type DisplayTypeMinAggregateInputType = {
    DisplayTypeID?: true
    DisplayType?: true
    URL?: true
    IsShowInDanzarCRM?: true
  }

  export type DisplayTypeMaxAggregateInputType = {
    DisplayTypeID?: true
    DisplayType?: true
    URL?: true
    IsShowInDanzarCRM?: true
  }

  export type DisplayTypeCountAggregateInputType = {
    DisplayTypeID?: true
    DisplayType?: true
    URL?: true
    IsShowInDanzarCRM?: true
    _all?: true
  }

  export type DisplayTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisplayType to aggregate.
     */
    where?: DisplayTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisplayTypes to fetch.
     */
    orderBy?: DisplayTypeOrderByWithRelationInput | DisplayTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisplayTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisplayTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisplayTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisplayTypes
    **/
    _count?: true | DisplayTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DisplayTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DisplayTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisplayTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisplayTypeMaxAggregateInputType
  }

  export type GetDisplayTypeAggregateType<T extends DisplayTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDisplayType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisplayType[P]>
      : GetScalarType<T[P], AggregateDisplayType[P]>
  }




  export type DisplayTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisplayTypeWhereInput
    orderBy?: DisplayTypeOrderByWithAggregationInput | DisplayTypeOrderByWithAggregationInput[]
    by: DisplayTypeScalarFieldEnum[] | DisplayTypeScalarFieldEnum
    having?: DisplayTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisplayTypeCountAggregateInputType | true
    _avg?: DisplayTypeAvgAggregateInputType
    _sum?: DisplayTypeSumAggregateInputType
    _min?: DisplayTypeMinAggregateInputType
    _max?: DisplayTypeMaxAggregateInputType
  }

  export type DisplayTypeGroupByOutputType = {
    DisplayTypeID: number
    DisplayType: string
    URL: string
    IsShowInDanzarCRM: number
    _count: DisplayTypeCountAggregateOutputType | null
    _avg: DisplayTypeAvgAggregateOutputType | null
    _sum: DisplayTypeSumAggregateOutputType | null
    _min: DisplayTypeMinAggregateOutputType | null
    _max: DisplayTypeMaxAggregateOutputType | null
  }

  type GetDisplayTypeGroupByPayload<T extends DisplayTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisplayTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisplayTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisplayTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DisplayTypeGroupByOutputType[P]>
        }
      >
    >


  export type DisplayTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    DisplayTypeID?: boolean
    DisplayType?: boolean
    URL?: boolean
    IsShowInDanzarCRM?: boolean
  }, ExtArgs["result"]["displayType"]>


  export type DisplayTypeSelectScalar = {
    DisplayTypeID?: boolean
    DisplayType?: boolean
    URL?: boolean
    IsShowInDanzarCRM?: boolean
  }


  export type $DisplayTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisplayType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      DisplayTypeID: number
      DisplayType: string
      URL: string
      IsShowInDanzarCRM: number
    }, ExtArgs["result"]["displayType"]>
    composites: {}
  }

  type DisplayTypeGetPayload<S extends boolean | null | undefined | DisplayTypeDefaultArgs> = $Result.GetResult<Prisma.$DisplayTypePayload, S>

  type DisplayTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DisplayTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DisplayTypeCountAggregateInputType | true
    }

  export interface DisplayTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisplayType'], meta: { name: 'DisplayType' } }
    /**
     * Find zero or one DisplayType that matches the filter.
     * @param {DisplayTypeFindUniqueArgs} args - Arguments to find a DisplayType
     * @example
     * // Get one DisplayType
     * const displayType = await prisma.displayType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisplayTypeFindUniqueArgs>(args: SelectSubset<T, DisplayTypeFindUniqueArgs<ExtArgs>>): Prisma__DisplayTypeClient<$Result.GetResult<Prisma.$DisplayTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DisplayType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DisplayTypeFindUniqueOrThrowArgs} args - Arguments to find a DisplayType
     * @example
     * // Get one DisplayType
     * const displayType = await prisma.displayType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisplayTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, DisplayTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisplayTypeClient<$Result.GetResult<Prisma.$DisplayTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DisplayType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisplayTypeFindFirstArgs} args - Arguments to find a DisplayType
     * @example
     * // Get one DisplayType
     * const displayType = await prisma.displayType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisplayTypeFindFirstArgs>(args?: SelectSubset<T, DisplayTypeFindFirstArgs<ExtArgs>>): Prisma__DisplayTypeClient<$Result.GetResult<Prisma.$DisplayTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DisplayType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisplayTypeFindFirstOrThrowArgs} args - Arguments to find a DisplayType
     * @example
     * // Get one DisplayType
     * const displayType = await prisma.displayType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisplayTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, DisplayTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisplayTypeClient<$Result.GetResult<Prisma.$DisplayTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DisplayTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisplayTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisplayTypes
     * const displayTypes = await prisma.displayType.findMany()
     * 
     * // Get first 10 DisplayTypes
     * const displayTypes = await prisma.displayType.findMany({ take: 10 })
     * 
     * // Only select the `DisplayTypeID`
     * const displayTypeWithDisplayTypeIDOnly = await prisma.displayType.findMany({ select: { DisplayTypeID: true } })
     * 
     */
    findMany<T extends DisplayTypeFindManyArgs>(args?: SelectSubset<T, DisplayTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisplayTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DisplayType.
     * @param {DisplayTypeCreateArgs} args - Arguments to create a DisplayType.
     * @example
     * // Create one DisplayType
     * const DisplayType = await prisma.displayType.create({
     *   data: {
     *     // ... data to create a DisplayType
     *   }
     * })
     * 
     */
    create<T extends DisplayTypeCreateArgs>(args: SelectSubset<T, DisplayTypeCreateArgs<ExtArgs>>): Prisma__DisplayTypeClient<$Result.GetResult<Prisma.$DisplayTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DisplayTypes.
     * @param {DisplayTypeCreateManyArgs} args - Arguments to create many DisplayTypes.
     * @example
     * // Create many DisplayTypes
     * const displayType = await prisma.displayType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisplayTypeCreateManyArgs>(args?: SelectSubset<T, DisplayTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DisplayType.
     * @param {DisplayTypeDeleteArgs} args - Arguments to delete one DisplayType.
     * @example
     * // Delete one DisplayType
     * const DisplayType = await prisma.displayType.delete({
     *   where: {
     *     // ... filter to delete one DisplayType
     *   }
     * })
     * 
     */
    delete<T extends DisplayTypeDeleteArgs>(args: SelectSubset<T, DisplayTypeDeleteArgs<ExtArgs>>): Prisma__DisplayTypeClient<$Result.GetResult<Prisma.$DisplayTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DisplayType.
     * @param {DisplayTypeUpdateArgs} args - Arguments to update one DisplayType.
     * @example
     * // Update one DisplayType
     * const displayType = await prisma.displayType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisplayTypeUpdateArgs>(args: SelectSubset<T, DisplayTypeUpdateArgs<ExtArgs>>): Prisma__DisplayTypeClient<$Result.GetResult<Prisma.$DisplayTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DisplayTypes.
     * @param {DisplayTypeDeleteManyArgs} args - Arguments to filter DisplayTypes to delete.
     * @example
     * // Delete a few DisplayTypes
     * const { count } = await prisma.displayType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisplayTypeDeleteManyArgs>(args?: SelectSubset<T, DisplayTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisplayTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisplayTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisplayTypes
     * const displayType = await prisma.displayType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisplayTypeUpdateManyArgs>(args: SelectSubset<T, DisplayTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DisplayType.
     * @param {DisplayTypeUpsertArgs} args - Arguments to update or create a DisplayType.
     * @example
     * // Update or create a DisplayType
     * const displayType = await prisma.displayType.upsert({
     *   create: {
     *     // ... data to create a DisplayType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisplayType we want to update
     *   }
     * })
     */
    upsert<T extends DisplayTypeUpsertArgs>(args: SelectSubset<T, DisplayTypeUpsertArgs<ExtArgs>>): Prisma__DisplayTypeClient<$Result.GetResult<Prisma.$DisplayTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DisplayTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisplayTypeCountArgs} args - Arguments to filter DisplayTypes to count.
     * @example
     * // Count the number of DisplayTypes
     * const count = await prisma.displayType.count({
     *   where: {
     *     // ... the filter for the DisplayTypes we want to count
     *   }
     * })
    **/
    count<T extends DisplayTypeCountArgs>(
      args?: Subset<T, DisplayTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisplayTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisplayType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisplayTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisplayTypeAggregateArgs>(args: Subset<T, DisplayTypeAggregateArgs>): Prisma.PrismaPromise<GetDisplayTypeAggregateType<T>>

    /**
     * Group by DisplayType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisplayTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisplayTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisplayTypeGroupByArgs['orderBy'] }
        : { orderBy?: DisplayTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisplayTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisplayTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisplayType model
   */
  readonly fields: DisplayTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisplayType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisplayTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisplayType model
   */ 
  interface DisplayTypeFieldRefs {
    readonly DisplayTypeID: FieldRef<"DisplayType", 'Int'>
    readonly DisplayType: FieldRef<"DisplayType", 'String'>
    readonly URL: FieldRef<"DisplayType", 'String'>
    readonly IsShowInDanzarCRM: FieldRef<"DisplayType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DisplayType findUnique
   */
  export type DisplayTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisplayType
     */
    select?: DisplayTypeSelect<ExtArgs> | null
    /**
     * Filter, which DisplayType to fetch.
     */
    where: DisplayTypeWhereUniqueInput
  }

  /**
   * DisplayType findUniqueOrThrow
   */
  export type DisplayTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisplayType
     */
    select?: DisplayTypeSelect<ExtArgs> | null
    /**
     * Filter, which DisplayType to fetch.
     */
    where: DisplayTypeWhereUniqueInput
  }

  /**
   * DisplayType findFirst
   */
  export type DisplayTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisplayType
     */
    select?: DisplayTypeSelect<ExtArgs> | null
    /**
     * Filter, which DisplayType to fetch.
     */
    where?: DisplayTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisplayTypes to fetch.
     */
    orderBy?: DisplayTypeOrderByWithRelationInput | DisplayTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisplayTypes.
     */
    cursor?: DisplayTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisplayTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisplayTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisplayTypes.
     */
    distinct?: DisplayTypeScalarFieldEnum | DisplayTypeScalarFieldEnum[]
  }

  /**
   * DisplayType findFirstOrThrow
   */
  export type DisplayTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisplayType
     */
    select?: DisplayTypeSelect<ExtArgs> | null
    /**
     * Filter, which DisplayType to fetch.
     */
    where?: DisplayTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisplayTypes to fetch.
     */
    orderBy?: DisplayTypeOrderByWithRelationInput | DisplayTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisplayTypes.
     */
    cursor?: DisplayTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisplayTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisplayTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisplayTypes.
     */
    distinct?: DisplayTypeScalarFieldEnum | DisplayTypeScalarFieldEnum[]
  }

  /**
   * DisplayType findMany
   */
  export type DisplayTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisplayType
     */
    select?: DisplayTypeSelect<ExtArgs> | null
    /**
     * Filter, which DisplayTypes to fetch.
     */
    where?: DisplayTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisplayTypes to fetch.
     */
    orderBy?: DisplayTypeOrderByWithRelationInput | DisplayTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisplayTypes.
     */
    cursor?: DisplayTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisplayTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisplayTypes.
     */
    skip?: number
    distinct?: DisplayTypeScalarFieldEnum | DisplayTypeScalarFieldEnum[]
  }

  /**
   * DisplayType create
   */
  export type DisplayTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisplayType
     */
    select?: DisplayTypeSelect<ExtArgs> | null
    /**
     * The data needed to create a DisplayType.
     */
    data: XOR<DisplayTypeCreateInput, DisplayTypeUncheckedCreateInput>
  }

  /**
   * DisplayType createMany
   */
  export type DisplayTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisplayTypes.
     */
    data: DisplayTypeCreateManyInput | DisplayTypeCreateManyInput[]
  }

  /**
   * DisplayType update
   */
  export type DisplayTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisplayType
     */
    select?: DisplayTypeSelect<ExtArgs> | null
    /**
     * The data needed to update a DisplayType.
     */
    data: XOR<DisplayTypeUpdateInput, DisplayTypeUncheckedUpdateInput>
    /**
     * Choose, which DisplayType to update.
     */
    where: DisplayTypeWhereUniqueInput
  }

  /**
   * DisplayType updateMany
   */
  export type DisplayTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisplayTypes.
     */
    data: XOR<DisplayTypeUpdateManyMutationInput, DisplayTypeUncheckedUpdateManyInput>
    /**
     * Filter which DisplayTypes to update
     */
    where?: DisplayTypeWhereInput
  }

  /**
   * DisplayType upsert
   */
  export type DisplayTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisplayType
     */
    select?: DisplayTypeSelect<ExtArgs> | null
    /**
     * The filter to search for the DisplayType to update in case it exists.
     */
    where: DisplayTypeWhereUniqueInput
    /**
     * In case the DisplayType found by the `where` argument doesn't exist, create a new DisplayType with this data.
     */
    create: XOR<DisplayTypeCreateInput, DisplayTypeUncheckedCreateInput>
    /**
     * In case the DisplayType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisplayTypeUpdateInput, DisplayTypeUncheckedUpdateInput>
  }

  /**
   * DisplayType delete
   */
  export type DisplayTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisplayType
     */
    select?: DisplayTypeSelect<ExtArgs> | null
    /**
     * Filter which DisplayType to delete.
     */
    where: DisplayTypeWhereUniqueInput
  }

  /**
   * DisplayType deleteMany
   */
  export type DisplayTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisplayTypes to delete
     */
    where?: DisplayTypeWhereInput
  }

  /**
   * DisplayType without action
   */
  export type DisplayTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisplayType
     */
    select?: DisplayTypeSelect<ExtArgs> | null
  }


  /**
   * Model HashIndexGeneral
   */

  export type AggregateHashIndexGeneral = {
    _count: HashIndexGeneralCountAggregateOutputType | null
    _avg: HashIndexGeneralAvgAggregateOutputType | null
    _sum: HashIndexGeneralSumAggregateOutputType | null
    _min: HashIndexGeneralMinAggregateOutputType | null
    _max: HashIndexGeneralMaxAggregateOutputType | null
  }

  export type HashIndexGeneralAvgAggregateOutputType = {
    HashCode: number | null
  }

  export type HashIndexGeneralSumAggregateOutputType = {
    HashCode: number | null
  }

  export type HashIndexGeneralMinAggregateOutputType = {
    HashCode: number | null
    HashName: string | null
  }

  export type HashIndexGeneralMaxAggregateOutputType = {
    HashCode: number | null
    HashName: string | null
  }

  export type HashIndexGeneralCountAggregateOutputType = {
    HashCode: number
    HashName: number
    _all: number
  }


  export type HashIndexGeneralAvgAggregateInputType = {
    HashCode?: true
  }

  export type HashIndexGeneralSumAggregateInputType = {
    HashCode?: true
  }

  export type HashIndexGeneralMinAggregateInputType = {
    HashCode?: true
    HashName?: true
  }

  export type HashIndexGeneralMaxAggregateInputType = {
    HashCode?: true
    HashName?: true
  }

  export type HashIndexGeneralCountAggregateInputType = {
    HashCode?: true
    HashName?: true
    _all?: true
  }

  export type HashIndexGeneralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HashIndexGeneral to aggregate.
     */
    where?: HashIndexGeneralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashIndexGenerals to fetch.
     */
    orderBy?: HashIndexGeneralOrderByWithRelationInput | HashIndexGeneralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HashIndexGeneralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashIndexGenerals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashIndexGenerals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HashIndexGenerals
    **/
    _count?: true | HashIndexGeneralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HashIndexGeneralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HashIndexGeneralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HashIndexGeneralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HashIndexGeneralMaxAggregateInputType
  }

  export type GetHashIndexGeneralAggregateType<T extends HashIndexGeneralAggregateArgs> = {
        [P in keyof T & keyof AggregateHashIndexGeneral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHashIndexGeneral[P]>
      : GetScalarType<T[P], AggregateHashIndexGeneral[P]>
  }




  export type HashIndexGeneralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HashIndexGeneralWhereInput
    orderBy?: HashIndexGeneralOrderByWithAggregationInput | HashIndexGeneralOrderByWithAggregationInput[]
    by: HashIndexGeneralScalarFieldEnum[] | HashIndexGeneralScalarFieldEnum
    having?: HashIndexGeneralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HashIndexGeneralCountAggregateInputType | true
    _avg?: HashIndexGeneralAvgAggregateInputType
    _sum?: HashIndexGeneralSumAggregateInputType
    _min?: HashIndexGeneralMinAggregateInputType
    _max?: HashIndexGeneralMaxAggregateInputType
  }

  export type HashIndexGeneralGroupByOutputType = {
    HashCode: number
    HashName: string | null
    _count: HashIndexGeneralCountAggregateOutputType | null
    _avg: HashIndexGeneralAvgAggregateOutputType | null
    _sum: HashIndexGeneralSumAggregateOutputType | null
    _min: HashIndexGeneralMinAggregateOutputType | null
    _max: HashIndexGeneralMaxAggregateOutputType | null
  }

  type GetHashIndexGeneralGroupByPayload<T extends HashIndexGeneralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HashIndexGeneralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HashIndexGeneralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HashIndexGeneralGroupByOutputType[P]>
            : GetScalarType<T[P], HashIndexGeneralGroupByOutputType[P]>
        }
      >
    >


  export type HashIndexGeneralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    HashCode?: boolean
    HashName?: boolean
  }, ExtArgs["result"]["hashIndexGeneral"]>


  export type HashIndexGeneralSelectScalar = {
    HashCode?: boolean
    HashName?: boolean
  }


  export type $HashIndexGeneralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HashIndexGeneral"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      HashCode: number
      HashName: string | null
    }, ExtArgs["result"]["hashIndexGeneral"]>
    composites: {}
  }

  type HashIndexGeneralGetPayload<S extends boolean | null | undefined | HashIndexGeneralDefaultArgs> = $Result.GetResult<Prisma.$HashIndexGeneralPayload, S>

  type HashIndexGeneralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HashIndexGeneralFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HashIndexGeneralCountAggregateInputType | true
    }

  export interface HashIndexGeneralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HashIndexGeneral'], meta: { name: 'HashIndexGeneral' } }
    /**
     * Find zero or one HashIndexGeneral that matches the filter.
     * @param {HashIndexGeneralFindUniqueArgs} args - Arguments to find a HashIndexGeneral
     * @example
     * // Get one HashIndexGeneral
     * const hashIndexGeneral = await prisma.hashIndexGeneral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HashIndexGeneralFindUniqueArgs>(args: SelectSubset<T, HashIndexGeneralFindUniqueArgs<ExtArgs>>): Prisma__HashIndexGeneralClient<$Result.GetResult<Prisma.$HashIndexGeneralPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HashIndexGeneral that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HashIndexGeneralFindUniqueOrThrowArgs} args - Arguments to find a HashIndexGeneral
     * @example
     * // Get one HashIndexGeneral
     * const hashIndexGeneral = await prisma.hashIndexGeneral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HashIndexGeneralFindUniqueOrThrowArgs>(args: SelectSubset<T, HashIndexGeneralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HashIndexGeneralClient<$Result.GetResult<Prisma.$HashIndexGeneralPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HashIndexGeneral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashIndexGeneralFindFirstArgs} args - Arguments to find a HashIndexGeneral
     * @example
     * // Get one HashIndexGeneral
     * const hashIndexGeneral = await prisma.hashIndexGeneral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HashIndexGeneralFindFirstArgs>(args?: SelectSubset<T, HashIndexGeneralFindFirstArgs<ExtArgs>>): Prisma__HashIndexGeneralClient<$Result.GetResult<Prisma.$HashIndexGeneralPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HashIndexGeneral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashIndexGeneralFindFirstOrThrowArgs} args - Arguments to find a HashIndexGeneral
     * @example
     * // Get one HashIndexGeneral
     * const hashIndexGeneral = await prisma.hashIndexGeneral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HashIndexGeneralFindFirstOrThrowArgs>(args?: SelectSubset<T, HashIndexGeneralFindFirstOrThrowArgs<ExtArgs>>): Prisma__HashIndexGeneralClient<$Result.GetResult<Prisma.$HashIndexGeneralPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HashIndexGenerals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashIndexGeneralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HashIndexGenerals
     * const hashIndexGenerals = await prisma.hashIndexGeneral.findMany()
     * 
     * // Get first 10 HashIndexGenerals
     * const hashIndexGenerals = await prisma.hashIndexGeneral.findMany({ take: 10 })
     * 
     * // Only select the `HashCode`
     * const hashIndexGeneralWithHashCodeOnly = await prisma.hashIndexGeneral.findMany({ select: { HashCode: true } })
     * 
     */
    findMany<T extends HashIndexGeneralFindManyArgs>(args?: SelectSubset<T, HashIndexGeneralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HashIndexGeneralPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HashIndexGeneral.
     * @param {HashIndexGeneralCreateArgs} args - Arguments to create a HashIndexGeneral.
     * @example
     * // Create one HashIndexGeneral
     * const HashIndexGeneral = await prisma.hashIndexGeneral.create({
     *   data: {
     *     // ... data to create a HashIndexGeneral
     *   }
     * })
     * 
     */
    create<T extends HashIndexGeneralCreateArgs>(args: SelectSubset<T, HashIndexGeneralCreateArgs<ExtArgs>>): Prisma__HashIndexGeneralClient<$Result.GetResult<Prisma.$HashIndexGeneralPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HashIndexGenerals.
     * @param {HashIndexGeneralCreateManyArgs} args - Arguments to create many HashIndexGenerals.
     * @example
     * // Create many HashIndexGenerals
     * const hashIndexGeneral = await prisma.hashIndexGeneral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HashIndexGeneralCreateManyArgs>(args?: SelectSubset<T, HashIndexGeneralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HashIndexGeneral.
     * @param {HashIndexGeneralDeleteArgs} args - Arguments to delete one HashIndexGeneral.
     * @example
     * // Delete one HashIndexGeneral
     * const HashIndexGeneral = await prisma.hashIndexGeneral.delete({
     *   where: {
     *     // ... filter to delete one HashIndexGeneral
     *   }
     * })
     * 
     */
    delete<T extends HashIndexGeneralDeleteArgs>(args: SelectSubset<T, HashIndexGeneralDeleteArgs<ExtArgs>>): Prisma__HashIndexGeneralClient<$Result.GetResult<Prisma.$HashIndexGeneralPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HashIndexGeneral.
     * @param {HashIndexGeneralUpdateArgs} args - Arguments to update one HashIndexGeneral.
     * @example
     * // Update one HashIndexGeneral
     * const hashIndexGeneral = await prisma.hashIndexGeneral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HashIndexGeneralUpdateArgs>(args: SelectSubset<T, HashIndexGeneralUpdateArgs<ExtArgs>>): Prisma__HashIndexGeneralClient<$Result.GetResult<Prisma.$HashIndexGeneralPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HashIndexGenerals.
     * @param {HashIndexGeneralDeleteManyArgs} args - Arguments to filter HashIndexGenerals to delete.
     * @example
     * // Delete a few HashIndexGenerals
     * const { count } = await prisma.hashIndexGeneral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HashIndexGeneralDeleteManyArgs>(args?: SelectSubset<T, HashIndexGeneralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HashIndexGenerals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashIndexGeneralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HashIndexGenerals
     * const hashIndexGeneral = await prisma.hashIndexGeneral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HashIndexGeneralUpdateManyArgs>(args: SelectSubset<T, HashIndexGeneralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HashIndexGeneral.
     * @param {HashIndexGeneralUpsertArgs} args - Arguments to update or create a HashIndexGeneral.
     * @example
     * // Update or create a HashIndexGeneral
     * const hashIndexGeneral = await prisma.hashIndexGeneral.upsert({
     *   create: {
     *     // ... data to create a HashIndexGeneral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HashIndexGeneral we want to update
     *   }
     * })
     */
    upsert<T extends HashIndexGeneralUpsertArgs>(args: SelectSubset<T, HashIndexGeneralUpsertArgs<ExtArgs>>): Prisma__HashIndexGeneralClient<$Result.GetResult<Prisma.$HashIndexGeneralPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HashIndexGenerals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashIndexGeneralCountArgs} args - Arguments to filter HashIndexGenerals to count.
     * @example
     * // Count the number of HashIndexGenerals
     * const count = await prisma.hashIndexGeneral.count({
     *   where: {
     *     // ... the filter for the HashIndexGenerals we want to count
     *   }
     * })
    **/
    count<T extends HashIndexGeneralCountArgs>(
      args?: Subset<T, HashIndexGeneralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HashIndexGeneralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HashIndexGeneral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashIndexGeneralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HashIndexGeneralAggregateArgs>(args: Subset<T, HashIndexGeneralAggregateArgs>): Prisma.PrismaPromise<GetHashIndexGeneralAggregateType<T>>

    /**
     * Group by HashIndexGeneral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashIndexGeneralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HashIndexGeneralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HashIndexGeneralGroupByArgs['orderBy'] }
        : { orderBy?: HashIndexGeneralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HashIndexGeneralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHashIndexGeneralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HashIndexGeneral model
   */
  readonly fields: HashIndexGeneralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HashIndexGeneral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HashIndexGeneralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HashIndexGeneral model
   */ 
  interface HashIndexGeneralFieldRefs {
    readonly HashCode: FieldRef<"HashIndexGeneral", 'Int'>
    readonly HashName: FieldRef<"HashIndexGeneral", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HashIndexGeneral findUnique
   */
  export type HashIndexGeneralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashIndexGeneral
     */
    select?: HashIndexGeneralSelect<ExtArgs> | null
    /**
     * Filter, which HashIndexGeneral to fetch.
     */
    where: HashIndexGeneralWhereUniqueInput
  }

  /**
   * HashIndexGeneral findUniqueOrThrow
   */
  export type HashIndexGeneralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashIndexGeneral
     */
    select?: HashIndexGeneralSelect<ExtArgs> | null
    /**
     * Filter, which HashIndexGeneral to fetch.
     */
    where: HashIndexGeneralWhereUniqueInput
  }

  /**
   * HashIndexGeneral findFirst
   */
  export type HashIndexGeneralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashIndexGeneral
     */
    select?: HashIndexGeneralSelect<ExtArgs> | null
    /**
     * Filter, which HashIndexGeneral to fetch.
     */
    where?: HashIndexGeneralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashIndexGenerals to fetch.
     */
    orderBy?: HashIndexGeneralOrderByWithRelationInput | HashIndexGeneralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HashIndexGenerals.
     */
    cursor?: HashIndexGeneralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashIndexGenerals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashIndexGenerals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HashIndexGenerals.
     */
    distinct?: HashIndexGeneralScalarFieldEnum | HashIndexGeneralScalarFieldEnum[]
  }

  /**
   * HashIndexGeneral findFirstOrThrow
   */
  export type HashIndexGeneralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashIndexGeneral
     */
    select?: HashIndexGeneralSelect<ExtArgs> | null
    /**
     * Filter, which HashIndexGeneral to fetch.
     */
    where?: HashIndexGeneralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashIndexGenerals to fetch.
     */
    orderBy?: HashIndexGeneralOrderByWithRelationInput | HashIndexGeneralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HashIndexGenerals.
     */
    cursor?: HashIndexGeneralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashIndexGenerals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashIndexGenerals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HashIndexGenerals.
     */
    distinct?: HashIndexGeneralScalarFieldEnum | HashIndexGeneralScalarFieldEnum[]
  }

  /**
   * HashIndexGeneral findMany
   */
  export type HashIndexGeneralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashIndexGeneral
     */
    select?: HashIndexGeneralSelect<ExtArgs> | null
    /**
     * Filter, which HashIndexGenerals to fetch.
     */
    where?: HashIndexGeneralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashIndexGenerals to fetch.
     */
    orderBy?: HashIndexGeneralOrderByWithRelationInput | HashIndexGeneralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HashIndexGenerals.
     */
    cursor?: HashIndexGeneralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashIndexGenerals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashIndexGenerals.
     */
    skip?: number
    distinct?: HashIndexGeneralScalarFieldEnum | HashIndexGeneralScalarFieldEnum[]
  }

  /**
   * HashIndexGeneral create
   */
  export type HashIndexGeneralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashIndexGeneral
     */
    select?: HashIndexGeneralSelect<ExtArgs> | null
    /**
     * The data needed to create a HashIndexGeneral.
     */
    data?: XOR<HashIndexGeneralCreateInput, HashIndexGeneralUncheckedCreateInput>
  }

  /**
   * HashIndexGeneral createMany
   */
  export type HashIndexGeneralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HashIndexGenerals.
     */
    data: HashIndexGeneralCreateManyInput | HashIndexGeneralCreateManyInput[]
  }

  /**
   * HashIndexGeneral update
   */
  export type HashIndexGeneralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashIndexGeneral
     */
    select?: HashIndexGeneralSelect<ExtArgs> | null
    /**
     * The data needed to update a HashIndexGeneral.
     */
    data: XOR<HashIndexGeneralUpdateInput, HashIndexGeneralUncheckedUpdateInput>
    /**
     * Choose, which HashIndexGeneral to update.
     */
    where: HashIndexGeneralWhereUniqueInput
  }

  /**
   * HashIndexGeneral updateMany
   */
  export type HashIndexGeneralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HashIndexGenerals.
     */
    data: XOR<HashIndexGeneralUpdateManyMutationInput, HashIndexGeneralUncheckedUpdateManyInput>
    /**
     * Filter which HashIndexGenerals to update
     */
    where?: HashIndexGeneralWhereInput
  }

  /**
   * HashIndexGeneral upsert
   */
  export type HashIndexGeneralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashIndexGeneral
     */
    select?: HashIndexGeneralSelect<ExtArgs> | null
    /**
     * The filter to search for the HashIndexGeneral to update in case it exists.
     */
    where: HashIndexGeneralWhereUniqueInput
    /**
     * In case the HashIndexGeneral found by the `where` argument doesn't exist, create a new HashIndexGeneral with this data.
     */
    create: XOR<HashIndexGeneralCreateInput, HashIndexGeneralUncheckedCreateInput>
    /**
     * In case the HashIndexGeneral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HashIndexGeneralUpdateInput, HashIndexGeneralUncheckedUpdateInput>
  }

  /**
   * HashIndexGeneral delete
   */
  export type HashIndexGeneralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashIndexGeneral
     */
    select?: HashIndexGeneralSelect<ExtArgs> | null
    /**
     * Filter which HashIndexGeneral to delete.
     */
    where: HashIndexGeneralWhereUniqueInput
  }

  /**
   * HashIndexGeneral deleteMany
   */
  export type HashIndexGeneralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HashIndexGenerals to delete
     */
    where?: HashIndexGeneralWhereInput
  }

  /**
   * HashIndexGeneral without action
   */
  export type HashIndexGeneralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashIndexGeneral
     */
    select?: HashIndexGeneralSelect<ExtArgs> | null
  }


  /**
   * Model HashSecurity
   */

  export type AggregateHashSecurity = {
    _count: HashSecurityCountAggregateOutputType | null
    _avg: HashSecurityAvgAggregateOutputType | null
    _sum: HashSecuritySumAggregateOutputType | null
    _min: HashSecurityMinAggregateOutputType | null
    _max: HashSecurityMaxAggregateOutputType | null
  }

  export type HashSecurityAvgAggregateOutputType = {
    HashCode: number | null
    IsUse: number | null
  }

  export type HashSecuritySumAggregateOutputType = {
    HashCode: bigint | null
    IsUse: number | null
  }

  export type HashSecurityMinAggregateOutputType = {
    HashID: string | null
    HashCode: bigint | null
    IsUse: number | null
  }

  export type HashSecurityMaxAggregateOutputType = {
    HashID: string | null
    HashCode: bigint | null
    IsUse: number | null
  }

  export type HashSecurityCountAggregateOutputType = {
    HashID: number
    HashCode: number
    IsUse: number
    _all: number
  }


  export type HashSecurityAvgAggregateInputType = {
    HashCode?: true
    IsUse?: true
  }

  export type HashSecuritySumAggregateInputType = {
    HashCode?: true
    IsUse?: true
  }

  export type HashSecurityMinAggregateInputType = {
    HashID?: true
    HashCode?: true
    IsUse?: true
  }

  export type HashSecurityMaxAggregateInputType = {
    HashID?: true
    HashCode?: true
    IsUse?: true
  }

  export type HashSecurityCountAggregateInputType = {
    HashID?: true
    HashCode?: true
    IsUse?: true
    _all?: true
  }

  export type HashSecurityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HashSecurity to aggregate.
     */
    where?: HashSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashSecurities to fetch.
     */
    orderBy?: HashSecurityOrderByWithRelationInput | HashSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HashSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashSecurities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HashSecurities
    **/
    _count?: true | HashSecurityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HashSecurityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HashSecuritySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HashSecurityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HashSecurityMaxAggregateInputType
  }

  export type GetHashSecurityAggregateType<T extends HashSecurityAggregateArgs> = {
        [P in keyof T & keyof AggregateHashSecurity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHashSecurity[P]>
      : GetScalarType<T[P], AggregateHashSecurity[P]>
  }




  export type HashSecurityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HashSecurityWhereInput
    orderBy?: HashSecurityOrderByWithAggregationInput | HashSecurityOrderByWithAggregationInput[]
    by: HashSecurityScalarFieldEnum[] | HashSecurityScalarFieldEnum
    having?: HashSecurityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HashSecurityCountAggregateInputType | true
    _avg?: HashSecurityAvgAggregateInputType
    _sum?: HashSecuritySumAggregateInputType
    _min?: HashSecurityMinAggregateInputType
    _max?: HashSecurityMaxAggregateInputType
  }

  export type HashSecurityGroupByOutputType = {
    HashID: string
    HashCode: bigint
    IsUse: number
    _count: HashSecurityCountAggregateOutputType | null
    _avg: HashSecurityAvgAggregateOutputType | null
    _sum: HashSecuritySumAggregateOutputType | null
    _min: HashSecurityMinAggregateOutputType | null
    _max: HashSecurityMaxAggregateOutputType | null
  }

  type GetHashSecurityGroupByPayload<T extends HashSecurityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HashSecurityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HashSecurityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HashSecurityGroupByOutputType[P]>
            : GetScalarType<T[P], HashSecurityGroupByOutputType[P]>
        }
      >
    >


  export type HashSecuritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    HashID?: boolean
    HashCode?: boolean
    IsUse?: boolean
  }, ExtArgs["result"]["hashSecurity"]>


  export type HashSecuritySelectScalar = {
    HashID?: boolean
    HashCode?: boolean
    IsUse?: boolean
  }


  export type $HashSecurityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HashSecurity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      HashID: string
      HashCode: bigint
      IsUse: number
    }, ExtArgs["result"]["hashSecurity"]>
    composites: {}
  }

  type HashSecurityGetPayload<S extends boolean | null | undefined | HashSecurityDefaultArgs> = $Result.GetResult<Prisma.$HashSecurityPayload, S>

  type HashSecurityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HashSecurityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HashSecurityCountAggregateInputType | true
    }

  export interface HashSecurityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HashSecurity'], meta: { name: 'HashSecurity' } }
    /**
     * Find zero or one HashSecurity that matches the filter.
     * @param {HashSecurityFindUniqueArgs} args - Arguments to find a HashSecurity
     * @example
     * // Get one HashSecurity
     * const hashSecurity = await prisma.hashSecurity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HashSecurityFindUniqueArgs>(args: SelectSubset<T, HashSecurityFindUniqueArgs<ExtArgs>>): Prisma__HashSecurityClient<$Result.GetResult<Prisma.$HashSecurityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HashSecurity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HashSecurityFindUniqueOrThrowArgs} args - Arguments to find a HashSecurity
     * @example
     * // Get one HashSecurity
     * const hashSecurity = await prisma.hashSecurity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HashSecurityFindUniqueOrThrowArgs>(args: SelectSubset<T, HashSecurityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HashSecurityClient<$Result.GetResult<Prisma.$HashSecurityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HashSecurity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashSecurityFindFirstArgs} args - Arguments to find a HashSecurity
     * @example
     * // Get one HashSecurity
     * const hashSecurity = await prisma.hashSecurity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HashSecurityFindFirstArgs>(args?: SelectSubset<T, HashSecurityFindFirstArgs<ExtArgs>>): Prisma__HashSecurityClient<$Result.GetResult<Prisma.$HashSecurityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HashSecurity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashSecurityFindFirstOrThrowArgs} args - Arguments to find a HashSecurity
     * @example
     * // Get one HashSecurity
     * const hashSecurity = await prisma.hashSecurity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HashSecurityFindFirstOrThrowArgs>(args?: SelectSubset<T, HashSecurityFindFirstOrThrowArgs<ExtArgs>>): Prisma__HashSecurityClient<$Result.GetResult<Prisma.$HashSecurityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HashSecurities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashSecurityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HashSecurities
     * const hashSecurities = await prisma.hashSecurity.findMany()
     * 
     * // Get first 10 HashSecurities
     * const hashSecurities = await prisma.hashSecurity.findMany({ take: 10 })
     * 
     * // Only select the `HashID`
     * const hashSecurityWithHashIDOnly = await prisma.hashSecurity.findMany({ select: { HashID: true } })
     * 
     */
    findMany<T extends HashSecurityFindManyArgs>(args?: SelectSubset<T, HashSecurityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HashSecurityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HashSecurity.
     * @param {HashSecurityCreateArgs} args - Arguments to create a HashSecurity.
     * @example
     * // Create one HashSecurity
     * const HashSecurity = await prisma.hashSecurity.create({
     *   data: {
     *     // ... data to create a HashSecurity
     *   }
     * })
     * 
     */
    create<T extends HashSecurityCreateArgs>(args: SelectSubset<T, HashSecurityCreateArgs<ExtArgs>>): Prisma__HashSecurityClient<$Result.GetResult<Prisma.$HashSecurityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HashSecurities.
     * @param {HashSecurityCreateManyArgs} args - Arguments to create many HashSecurities.
     * @example
     * // Create many HashSecurities
     * const hashSecurity = await prisma.hashSecurity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HashSecurityCreateManyArgs>(args?: SelectSubset<T, HashSecurityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HashSecurity.
     * @param {HashSecurityDeleteArgs} args - Arguments to delete one HashSecurity.
     * @example
     * // Delete one HashSecurity
     * const HashSecurity = await prisma.hashSecurity.delete({
     *   where: {
     *     // ... filter to delete one HashSecurity
     *   }
     * })
     * 
     */
    delete<T extends HashSecurityDeleteArgs>(args: SelectSubset<T, HashSecurityDeleteArgs<ExtArgs>>): Prisma__HashSecurityClient<$Result.GetResult<Prisma.$HashSecurityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HashSecurity.
     * @param {HashSecurityUpdateArgs} args - Arguments to update one HashSecurity.
     * @example
     * // Update one HashSecurity
     * const hashSecurity = await prisma.hashSecurity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HashSecurityUpdateArgs>(args: SelectSubset<T, HashSecurityUpdateArgs<ExtArgs>>): Prisma__HashSecurityClient<$Result.GetResult<Prisma.$HashSecurityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HashSecurities.
     * @param {HashSecurityDeleteManyArgs} args - Arguments to filter HashSecurities to delete.
     * @example
     * // Delete a few HashSecurities
     * const { count } = await prisma.hashSecurity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HashSecurityDeleteManyArgs>(args?: SelectSubset<T, HashSecurityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HashSecurities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashSecurityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HashSecurities
     * const hashSecurity = await prisma.hashSecurity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HashSecurityUpdateManyArgs>(args: SelectSubset<T, HashSecurityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HashSecurity.
     * @param {HashSecurityUpsertArgs} args - Arguments to update or create a HashSecurity.
     * @example
     * // Update or create a HashSecurity
     * const hashSecurity = await prisma.hashSecurity.upsert({
     *   create: {
     *     // ... data to create a HashSecurity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HashSecurity we want to update
     *   }
     * })
     */
    upsert<T extends HashSecurityUpsertArgs>(args: SelectSubset<T, HashSecurityUpsertArgs<ExtArgs>>): Prisma__HashSecurityClient<$Result.GetResult<Prisma.$HashSecurityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HashSecurities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashSecurityCountArgs} args - Arguments to filter HashSecurities to count.
     * @example
     * // Count the number of HashSecurities
     * const count = await prisma.hashSecurity.count({
     *   where: {
     *     // ... the filter for the HashSecurities we want to count
     *   }
     * })
    **/
    count<T extends HashSecurityCountArgs>(
      args?: Subset<T, HashSecurityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HashSecurityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HashSecurity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashSecurityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HashSecurityAggregateArgs>(args: Subset<T, HashSecurityAggregateArgs>): Prisma.PrismaPromise<GetHashSecurityAggregateType<T>>

    /**
     * Group by HashSecurity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashSecurityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HashSecurityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HashSecurityGroupByArgs['orderBy'] }
        : { orderBy?: HashSecurityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HashSecurityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHashSecurityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HashSecurity model
   */
  readonly fields: HashSecurityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HashSecurity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HashSecurityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HashSecurity model
   */ 
  interface HashSecurityFieldRefs {
    readonly HashID: FieldRef<"HashSecurity", 'String'>
    readonly HashCode: FieldRef<"HashSecurity", 'BigInt'>
    readonly IsUse: FieldRef<"HashSecurity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * HashSecurity findUnique
   */
  export type HashSecurityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashSecurity
     */
    select?: HashSecuritySelect<ExtArgs> | null
    /**
     * Filter, which HashSecurity to fetch.
     */
    where: HashSecurityWhereUniqueInput
  }

  /**
   * HashSecurity findUniqueOrThrow
   */
  export type HashSecurityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashSecurity
     */
    select?: HashSecuritySelect<ExtArgs> | null
    /**
     * Filter, which HashSecurity to fetch.
     */
    where: HashSecurityWhereUniqueInput
  }

  /**
   * HashSecurity findFirst
   */
  export type HashSecurityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashSecurity
     */
    select?: HashSecuritySelect<ExtArgs> | null
    /**
     * Filter, which HashSecurity to fetch.
     */
    where?: HashSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashSecurities to fetch.
     */
    orderBy?: HashSecurityOrderByWithRelationInput | HashSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HashSecurities.
     */
    cursor?: HashSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashSecurities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HashSecurities.
     */
    distinct?: HashSecurityScalarFieldEnum | HashSecurityScalarFieldEnum[]
  }

  /**
   * HashSecurity findFirstOrThrow
   */
  export type HashSecurityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashSecurity
     */
    select?: HashSecuritySelect<ExtArgs> | null
    /**
     * Filter, which HashSecurity to fetch.
     */
    where?: HashSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashSecurities to fetch.
     */
    orderBy?: HashSecurityOrderByWithRelationInput | HashSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HashSecurities.
     */
    cursor?: HashSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashSecurities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HashSecurities.
     */
    distinct?: HashSecurityScalarFieldEnum | HashSecurityScalarFieldEnum[]
  }

  /**
   * HashSecurity findMany
   */
  export type HashSecurityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashSecurity
     */
    select?: HashSecuritySelect<ExtArgs> | null
    /**
     * Filter, which HashSecurities to fetch.
     */
    where?: HashSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashSecurities to fetch.
     */
    orderBy?: HashSecurityOrderByWithRelationInput | HashSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HashSecurities.
     */
    cursor?: HashSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashSecurities.
     */
    skip?: number
    distinct?: HashSecurityScalarFieldEnum | HashSecurityScalarFieldEnum[]
  }

  /**
   * HashSecurity create
   */
  export type HashSecurityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashSecurity
     */
    select?: HashSecuritySelect<ExtArgs> | null
    /**
     * The data needed to create a HashSecurity.
     */
    data: XOR<HashSecurityCreateInput, HashSecurityUncheckedCreateInput>
  }

  /**
   * HashSecurity createMany
   */
  export type HashSecurityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HashSecurities.
     */
    data: HashSecurityCreateManyInput | HashSecurityCreateManyInput[]
  }

  /**
   * HashSecurity update
   */
  export type HashSecurityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashSecurity
     */
    select?: HashSecuritySelect<ExtArgs> | null
    /**
     * The data needed to update a HashSecurity.
     */
    data: XOR<HashSecurityUpdateInput, HashSecurityUncheckedUpdateInput>
    /**
     * Choose, which HashSecurity to update.
     */
    where: HashSecurityWhereUniqueInput
  }

  /**
   * HashSecurity updateMany
   */
  export type HashSecurityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HashSecurities.
     */
    data: XOR<HashSecurityUpdateManyMutationInput, HashSecurityUncheckedUpdateManyInput>
    /**
     * Filter which HashSecurities to update
     */
    where?: HashSecurityWhereInput
  }

  /**
   * HashSecurity upsert
   */
  export type HashSecurityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashSecurity
     */
    select?: HashSecuritySelect<ExtArgs> | null
    /**
     * The filter to search for the HashSecurity to update in case it exists.
     */
    where: HashSecurityWhereUniqueInput
    /**
     * In case the HashSecurity found by the `where` argument doesn't exist, create a new HashSecurity with this data.
     */
    create: XOR<HashSecurityCreateInput, HashSecurityUncheckedCreateInput>
    /**
     * In case the HashSecurity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HashSecurityUpdateInput, HashSecurityUncheckedUpdateInput>
  }

  /**
   * HashSecurity delete
   */
  export type HashSecurityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashSecurity
     */
    select?: HashSecuritySelect<ExtArgs> | null
    /**
     * Filter which HashSecurity to delete.
     */
    where: HashSecurityWhereUniqueInput
  }

  /**
   * HashSecurity deleteMany
   */
  export type HashSecurityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HashSecurities to delete
     */
    where?: HashSecurityWhereInput
  }

  /**
   * HashSecurity without action
   */
  export type HashSecurityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashSecurity
     */
    select?: HashSecuritySelect<ExtArgs> | null
  }


  /**
   * Model Jobs
   */

  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  export type JobsAvgAggregateOutputType = {
    JobsID: number | null
  }

  export type JobsSumAggregateOutputType = {
    JobsID: number | null
  }

  export type JobsMinAggregateOutputType = {
    JobsID: number | null
    JobTitle: string | null
  }

  export type JobsMaxAggregateOutputType = {
    JobsID: number | null
    JobTitle: string | null
  }

  export type JobsCountAggregateOutputType = {
    JobsID: number
    JobTitle: number
    _all: number
  }


  export type JobsAvgAggregateInputType = {
    JobsID?: true
  }

  export type JobsSumAggregateInputType = {
    JobsID?: true
  }

  export type JobsMinAggregateInputType = {
    JobsID?: true
    JobTitle?: true
  }

  export type JobsMaxAggregateInputType = {
    JobsID?: true
    JobTitle?: true
  }

  export type JobsCountAggregateInputType = {
    JobsID?: true
    JobTitle?: true
    _all?: true
  }

  export type JobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to aggregate.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsMaxAggregateInputType
  }

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>
  }




  export type JobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithAggregationInput | JobsOrderByWithAggregationInput[]
    by: JobsScalarFieldEnum[] | JobsScalarFieldEnum
    having?: JobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsCountAggregateInputType | true
    _avg?: JobsAvgAggregateInputType
    _sum?: JobsSumAggregateInputType
    _min?: JobsMinAggregateInputType
    _max?: JobsMaxAggregateInputType
  }

  export type JobsGroupByOutputType = {
    JobsID: number
    JobTitle: string
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  type GetJobsGroupByPayload<T extends JobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsGroupByOutputType[P]>
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
        }
      >
    >


  export type JobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    JobsID?: boolean
    JobTitle?: boolean
  }, ExtArgs["result"]["jobs"]>


  export type JobsSelectScalar = {
    JobsID?: boolean
    JobTitle?: boolean
  }


  export type $JobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Jobs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      JobsID: number
      JobTitle: string
    }, ExtArgs["result"]["jobs"]>
    composites: {}
  }

  type JobsGetPayload<S extends boolean | null | undefined | JobsDefaultArgs> = $Result.GetResult<Prisma.$JobsPayload, S>

  type JobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobsCountAggregateInputType | true
    }

  export interface JobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jobs'], meta: { name: 'Jobs' } }
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {JobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobsFindUniqueArgs>(args: SelectSubset<T, JobsFindUniqueArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Jobs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobsFindUniqueOrThrowArgs>(args: SelectSubset<T, JobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobsFindFirstArgs>(args?: SelectSubset<T, JobsFindFirstArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobsFindFirstOrThrowArgs>(args?: SelectSubset<T, JobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     * 
     * // Only select the `JobsID`
     * const jobsWithJobsIDOnly = await prisma.jobs.findMany({ select: { JobsID: true } })
     * 
     */
    findMany<T extends JobsFindManyArgs>(args?: SelectSubset<T, JobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Jobs.
     * @param {JobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     * 
     */
    create<T extends JobsCreateArgs>(args: SelectSubset<T, JobsCreateArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Jobs.
     * @param {JobsCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobsCreateManyArgs>(args?: SelectSubset<T, JobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jobs.
     * @param {JobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     * 
     */
    delete<T extends JobsDeleteArgs>(args: SelectSubset<T, JobsDeleteArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Jobs.
     * @param {JobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobsUpdateArgs>(args: SelectSubset<T, JobsUpdateArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Jobs.
     * @param {JobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobsDeleteManyArgs>(args?: SelectSubset<T, JobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobsUpdateManyArgs>(args: SelectSubset<T, JobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobs.
     * @param {JobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
     */
    upsert<T extends JobsUpsertArgs>(args: SelectSubset<T, JobsUpsertArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobsCountArgs>(
      args?: Subset<T, JobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsAggregateArgs>(args: Subset<T, JobsAggregateArgs>): Prisma.PrismaPromise<GetJobsAggregateType<T>>

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobsGroupByArgs['orderBy'] }
        : { orderBy?: JobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Jobs model
   */
  readonly fields: JobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Jobs model
   */ 
  interface JobsFieldRefs {
    readonly JobsID: FieldRef<"Jobs", 'Int'>
    readonly JobTitle: FieldRef<"Jobs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Jobs findUnique
   */
  export type JobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs findUniqueOrThrow
   */
  export type JobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs findFirst
   */
  export type JobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs findFirstOrThrow
   */
  export type JobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs findMany
   */
  export type JobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs create
   */
  export type JobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * The data needed to create a Jobs.
     */
    data: XOR<JobsCreateInput, JobsUncheckedCreateInput>
  }

  /**
   * Jobs createMany
   */
  export type JobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobsCreateManyInput | JobsCreateManyInput[]
  }

  /**
   * Jobs update
   */
  export type JobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * The data needed to update a Jobs.
     */
    data: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
    /**
     * Choose, which Jobs to update.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs updateMany
   */
  export type JobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobsWhereInput
  }

  /**
   * Jobs upsert
   */
  export type JobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * The filter to search for the Jobs to update in case it exists.
     */
    where: JobsWhereUniqueInput
    /**
     * In case the Jobs found by the `where` argument doesn't exist, create a new Jobs with this data.
     */
    create: XOR<JobsCreateInput, JobsUncheckedCreateInput>
    /**
     * In case the Jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
  }

  /**
   * Jobs delete
   */
  export type JobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Filter which Jobs to delete.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs deleteMany
   */
  export type JobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobsWhereInput
  }

  /**
   * Jobs without action
   */
  export type JobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
  }


  /**
   * Model KupaGemel
   */

  export type AggregateKupaGemel = {
    _count: KupaGemelCountAggregateOutputType | null
    _avg: KupaGemelAvgAggregateOutputType | null
    _sum: KupaGemelSumAggregateOutputType | null
    _min: KupaGemelMinAggregateOutputType | null
    _max: KupaGemelMaxAggregateOutputType | null
  }

  export type KupaGemelAvgAggregateOutputType = {
    KupaID: number | null
    AllowanceEmployeePercent: number | null
    AllowanceEmployerPercent: number | null
    AllowanceCompensationPercen: number | null
    EducationFundPercentEmp: number | null
    EducationFundPercentEmpoyer: number | null
  }

  export type KupaGemelSumAggregateOutputType = {
    KupaID: number | null
    AllowanceEmployeePercent: number | null
    AllowanceEmployerPercent: number | null
    AllowanceCompensationPercen: number | null
    EducationFundPercentEmp: number | null
    EducationFundPercentEmpoyer: number | null
  }

  export type KupaGemelMinAggregateOutputType = {
    KupaID: number | null
    KupaName: string | null
    AllowanceEmployeePercent: number | null
    AllowanceEmployerPercent: number | null
    AllowanceCompensationPercen: number | null
    IsAndromedaRecord: boolean | null
    EducationFundPercentEmp: number | null
    EducationFundPercentEmpoyer: number | null
  }

  export type KupaGemelMaxAggregateOutputType = {
    KupaID: number | null
    KupaName: string | null
    AllowanceEmployeePercent: number | null
    AllowanceEmployerPercent: number | null
    AllowanceCompensationPercen: number | null
    IsAndromedaRecord: boolean | null
    EducationFundPercentEmp: number | null
    EducationFundPercentEmpoyer: number | null
  }

  export type KupaGemelCountAggregateOutputType = {
    KupaID: number
    KupaName: number
    AllowanceEmployeePercent: number
    AllowanceEmployerPercent: number
    AllowanceCompensationPercen: number
    IsAndromedaRecord: number
    EducationFundPercentEmp: number
    EducationFundPercentEmpoyer: number
    _all: number
  }


  export type KupaGemelAvgAggregateInputType = {
    KupaID?: true
    AllowanceEmployeePercent?: true
    AllowanceEmployerPercent?: true
    AllowanceCompensationPercen?: true
    EducationFundPercentEmp?: true
    EducationFundPercentEmpoyer?: true
  }

  export type KupaGemelSumAggregateInputType = {
    KupaID?: true
    AllowanceEmployeePercent?: true
    AllowanceEmployerPercent?: true
    AllowanceCompensationPercen?: true
    EducationFundPercentEmp?: true
    EducationFundPercentEmpoyer?: true
  }

  export type KupaGemelMinAggregateInputType = {
    KupaID?: true
    KupaName?: true
    AllowanceEmployeePercent?: true
    AllowanceEmployerPercent?: true
    AllowanceCompensationPercen?: true
    IsAndromedaRecord?: true
    EducationFundPercentEmp?: true
    EducationFundPercentEmpoyer?: true
  }

  export type KupaGemelMaxAggregateInputType = {
    KupaID?: true
    KupaName?: true
    AllowanceEmployeePercent?: true
    AllowanceEmployerPercent?: true
    AllowanceCompensationPercen?: true
    IsAndromedaRecord?: true
    EducationFundPercentEmp?: true
    EducationFundPercentEmpoyer?: true
  }

  export type KupaGemelCountAggregateInputType = {
    KupaID?: true
    KupaName?: true
    AllowanceEmployeePercent?: true
    AllowanceEmployerPercent?: true
    AllowanceCompensationPercen?: true
    IsAndromedaRecord?: true
    EducationFundPercentEmp?: true
    EducationFundPercentEmpoyer?: true
    _all?: true
  }

  export type KupaGemelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KupaGemel to aggregate.
     */
    where?: KupaGemelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KupaGemels to fetch.
     */
    orderBy?: KupaGemelOrderByWithRelationInput | KupaGemelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KupaGemelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KupaGemels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KupaGemels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KupaGemels
    **/
    _count?: true | KupaGemelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KupaGemelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KupaGemelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KupaGemelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KupaGemelMaxAggregateInputType
  }

  export type GetKupaGemelAggregateType<T extends KupaGemelAggregateArgs> = {
        [P in keyof T & keyof AggregateKupaGemel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKupaGemel[P]>
      : GetScalarType<T[P], AggregateKupaGemel[P]>
  }




  export type KupaGemelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KupaGemelWhereInput
    orderBy?: KupaGemelOrderByWithAggregationInput | KupaGemelOrderByWithAggregationInput[]
    by: KupaGemelScalarFieldEnum[] | KupaGemelScalarFieldEnum
    having?: KupaGemelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KupaGemelCountAggregateInputType | true
    _avg?: KupaGemelAvgAggregateInputType
    _sum?: KupaGemelSumAggregateInputType
    _min?: KupaGemelMinAggregateInputType
    _max?: KupaGemelMaxAggregateInputType
  }

  export type KupaGemelGroupByOutputType = {
    KupaID: number
    KupaName: string | null
    AllowanceEmployeePercent: number | null
    AllowanceEmployerPercent: number | null
    AllowanceCompensationPercen: number | null
    IsAndromedaRecord: boolean
    EducationFundPercentEmp: number | null
    EducationFundPercentEmpoyer: number | null
    _count: KupaGemelCountAggregateOutputType | null
    _avg: KupaGemelAvgAggregateOutputType | null
    _sum: KupaGemelSumAggregateOutputType | null
    _min: KupaGemelMinAggregateOutputType | null
    _max: KupaGemelMaxAggregateOutputType | null
  }

  type GetKupaGemelGroupByPayload<T extends KupaGemelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KupaGemelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KupaGemelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KupaGemelGroupByOutputType[P]>
            : GetScalarType<T[P], KupaGemelGroupByOutputType[P]>
        }
      >
    >


  export type KupaGemelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    KupaID?: boolean
    KupaName?: boolean
    AllowanceEmployeePercent?: boolean
    AllowanceEmployerPercent?: boolean
    AllowanceCompensationPercen?: boolean
    IsAndromedaRecord?: boolean
    EducationFundPercentEmp?: boolean
    EducationFundPercentEmpoyer?: boolean
  }, ExtArgs["result"]["kupaGemel"]>


  export type KupaGemelSelectScalar = {
    KupaID?: boolean
    KupaName?: boolean
    AllowanceEmployeePercent?: boolean
    AllowanceEmployerPercent?: boolean
    AllowanceCompensationPercen?: boolean
    IsAndromedaRecord?: boolean
    EducationFundPercentEmp?: boolean
    EducationFundPercentEmpoyer?: boolean
  }


  export type $KupaGemelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KupaGemel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      KupaID: number
      KupaName: string | null
      AllowanceEmployeePercent: number | null
      AllowanceEmployerPercent: number | null
      AllowanceCompensationPercen: number | null
      IsAndromedaRecord: boolean
      EducationFundPercentEmp: number | null
      EducationFundPercentEmpoyer: number | null
    }, ExtArgs["result"]["kupaGemel"]>
    composites: {}
  }

  type KupaGemelGetPayload<S extends boolean | null | undefined | KupaGemelDefaultArgs> = $Result.GetResult<Prisma.$KupaGemelPayload, S>

  type KupaGemelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KupaGemelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KupaGemelCountAggregateInputType | true
    }

  export interface KupaGemelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KupaGemel'], meta: { name: 'KupaGemel' } }
    /**
     * Find zero or one KupaGemel that matches the filter.
     * @param {KupaGemelFindUniqueArgs} args - Arguments to find a KupaGemel
     * @example
     * // Get one KupaGemel
     * const kupaGemel = await prisma.kupaGemel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KupaGemelFindUniqueArgs>(args: SelectSubset<T, KupaGemelFindUniqueArgs<ExtArgs>>): Prisma__KupaGemelClient<$Result.GetResult<Prisma.$KupaGemelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KupaGemel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KupaGemelFindUniqueOrThrowArgs} args - Arguments to find a KupaGemel
     * @example
     * // Get one KupaGemel
     * const kupaGemel = await prisma.kupaGemel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KupaGemelFindUniqueOrThrowArgs>(args: SelectSubset<T, KupaGemelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KupaGemelClient<$Result.GetResult<Prisma.$KupaGemelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KupaGemel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KupaGemelFindFirstArgs} args - Arguments to find a KupaGemel
     * @example
     * // Get one KupaGemel
     * const kupaGemel = await prisma.kupaGemel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KupaGemelFindFirstArgs>(args?: SelectSubset<T, KupaGemelFindFirstArgs<ExtArgs>>): Prisma__KupaGemelClient<$Result.GetResult<Prisma.$KupaGemelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KupaGemel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KupaGemelFindFirstOrThrowArgs} args - Arguments to find a KupaGemel
     * @example
     * // Get one KupaGemel
     * const kupaGemel = await prisma.kupaGemel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KupaGemelFindFirstOrThrowArgs>(args?: SelectSubset<T, KupaGemelFindFirstOrThrowArgs<ExtArgs>>): Prisma__KupaGemelClient<$Result.GetResult<Prisma.$KupaGemelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KupaGemels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KupaGemelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KupaGemels
     * const kupaGemels = await prisma.kupaGemel.findMany()
     * 
     * // Get first 10 KupaGemels
     * const kupaGemels = await prisma.kupaGemel.findMany({ take: 10 })
     * 
     * // Only select the `KupaID`
     * const kupaGemelWithKupaIDOnly = await prisma.kupaGemel.findMany({ select: { KupaID: true } })
     * 
     */
    findMany<T extends KupaGemelFindManyArgs>(args?: SelectSubset<T, KupaGemelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KupaGemelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KupaGemel.
     * @param {KupaGemelCreateArgs} args - Arguments to create a KupaGemel.
     * @example
     * // Create one KupaGemel
     * const KupaGemel = await prisma.kupaGemel.create({
     *   data: {
     *     // ... data to create a KupaGemel
     *   }
     * })
     * 
     */
    create<T extends KupaGemelCreateArgs>(args: SelectSubset<T, KupaGemelCreateArgs<ExtArgs>>): Prisma__KupaGemelClient<$Result.GetResult<Prisma.$KupaGemelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KupaGemels.
     * @param {KupaGemelCreateManyArgs} args - Arguments to create many KupaGemels.
     * @example
     * // Create many KupaGemels
     * const kupaGemel = await prisma.kupaGemel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KupaGemelCreateManyArgs>(args?: SelectSubset<T, KupaGemelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KupaGemel.
     * @param {KupaGemelDeleteArgs} args - Arguments to delete one KupaGemel.
     * @example
     * // Delete one KupaGemel
     * const KupaGemel = await prisma.kupaGemel.delete({
     *   where: {
     *     // ... filter to delete one KupaGemel
     *   }
     * })
     * 
     */
    delete<T extends KupaGemelDeleteArgs>(args: SelectSubset<T, KupaGemelDeleteArgs<ExtArgs>>): Prisma__KupaGemelClient<$Result.GetResult<Prisma.$KupaGemelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KupaGemel.
     * @param {KupaGemelUpdateArgs} args - Arguments to update one KupaGemel.
     * @example
     * // Update one KupaGemel
     * const kupaGemel = await prisma.kupaGemel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KupaGemelUpdateArgs>(args: SelectSubset<T, KupaGemelUpdateArgs<ExtArgs>>): Prisma__KupaGemelClient<$Result.GetResult<Prisma.$KupaGemelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KupaGemels.
     * @param {KupaGemelDeleteManyArgs} args - Arguments to filter KupaGemels to delete.
     * @example
     * // Delete a few KupaGemels
     * const { count } = await prisma.kupaGemel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KupaGemelDeleteManyArgs>(args?: SelectSubset<T, KupaGemelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KupaGemels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KupaGemelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KupaGemels
     * const kupaGemel = await prisma.kupaGemel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KupaGemelUpdateManyArgs>(args: SelectSubset<T, KupaGemelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KupaGemel.
     * @param {KupaGemelUpsertArgs} args - Arguments to update or create a KupaGemel.
     * @example
     * // Update or create a KupaGemel
     * const kupaGemel = await prisma.kupaGemel.upsert({
     *   create: {
     *     // ... data to create a KupaGemel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KupaGemel we want to update
     *   }
     * })
     */
    upsert<T extends KupaGemelUpsertArgs>(args: SelectSubset<T, KupaGemelUpsertArgs<ExtArgs>>): Prisma__KupaGemelClient<$Result.GetResult<Prisma.$KupaGemelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KupaGemels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KupaGemelCountArgs} args - Arguments to filter KupaGemels to count.
     * @example
     * // Count the number of KupaGemels
     * const count = await prisma.kupaGemel.count({
     *   where: {
     *     // ... the filter for the KupaGemels we want to count
     *   }
     * })
    **/
    count<T extends KupaGemelCountArgs>(
      args?: Subset<T, KupaGemelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KupaGemelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KupaGemel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KupaGemelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KupaGemelAggregateArgs>(args: Subset<T, KupaGemelAggregateArgs>): Prisma.PrismaPromise<GetKupaGemelAggregateType<T>>

    /**
     * Group by KupaGemel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KupaGemelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KupaGemelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KupaGemelGroupByArgs['orderBy'] }
        : { orderBy?: KupaGemelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KupaGemelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKupaGemelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KupaGemel model
   */
  readonly fields: KupaGemelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KupaGemel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KupaGemelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KupaGemel model
   */ 
  interface KupaGemelFieldRefs {
    readonly KupaID: FieldRef<"KupaGemel", 'Int'>
    readonly KupaName: FieldRef<"KupaGemel", 'String'>
    readonly AllowanceEmployeePercent: FieldRef<"KupaGemel", 'Float'>
    readonly AllowanceEmployerPercent: FieldRef<"KupaGemel", 'Float'>
    readonly AllowanceCompensationPercen: FieldRef<"KupaGemel", 'Float'>
    readonly IsAndromedaRecord: FieldRef<"KupaGemel", 'Boolean'>
    readonly EducationFundPercentEmp: FieldRef<"KupaGemel", 'Float'>
    readonly EducationFundPercentEmpoyer: FieldRef<"KupaGemel", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * KupaGemel findUnique
   */
  export type KupaGemelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KupaGemel
     */
    select?: KupaGemelSelect<ExtArgs> | null
    /**
     * Filter, which KupaGemel to fetch.
     */
    where: KupaGemelWhereUniqueInput
  }

  /**
   * KupaGemel findUniqueOrThrow
   */
  export type KupaGemelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KupaGemel
     */
    select?: KupaGemelSelect<ExtArgs> | null
    /**
     * Filter, which KupaGemel to fetch.
     */
    where: KupaGemelWhereUniqueInput
  }

  /**
   * KupaGemel findFirst
   */
  export type KupaGemelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KupaGemel
     */
    select?: KupaGemelSelect<ExtArgs> | null
    /**
     * Filter, which KupaGemel to fetch.
     */
    where?: KupaGemelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KupaGemels to fetch.
     */
    orderBy?: KupaGemelOrderByWithRelationInput | KupaGemelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KupaGemels.
     */
    cursor?: KupaGemelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KupaGemels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KupaGemels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KupaGemels.
     */
    distinct?: KupaGemelScalarFieldEnum | KupaGemelScalarFieldEnum[]
  }

  /**
   * KupaGemel findFirstOrThrow
   */
  export type KupaGemelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KupaGemel
     */
    select?: KupaGemelSelect<ExtArgs> | null
    /**
     * Filter, which KupaGemel to fetch.
     */
    where?: KupaGemelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KupaGemels to fetch.
     */
    orderBy?: KupaGemelOrderByWithRelationInput | KupaGemelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KupaGemels.
     */
    cursor?: KupaGemelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KupaGemels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KupaGemels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KupaGemels.
     */
    distinct?: KupaGemelScalarFieldEnum | KupaGemelScalarFieldEnum[]
  }

  /**
   * KupaGemel findMany
   */
  export type KupaGemelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KupaGemel
     */
    select?: KupaGemelSelect<ExtArgs> | null
    /**
     * Filter, which KupaGemels to fetch.
     */
    where?: KupaGemelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KupaGemels to fetch.
     */
    orderBy?: KupaGemelOrderByWithRelationInput | KupaGemelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KupaGemels.
     */
    cursor?: KupaGemelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KupaGemels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KupaGemels.
     */
    skip?: number
    distinct?: KupaGemelScalarFieldEnum | KupaGemelScalarFieldEnum[]
  }

  /**
   * KupaGemel create
   */
  export type KupaGemelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KupaGemel
     */
    select?: KupaGemelSelect<ExtArgs> | null
    /**
     * The data needed to create a KupaGemel.
     */
    data: XOR<KupaGemelCreateInput, KupaGemelUncheckedCreateInput>
  }

  /**
   * KupaGemel createMany
   */
  export type KupaGemelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KupaGemels.
     */
    data: KupaGemelCreateManyInput | KupaGemelCreateManyInput[]
  }

  /**
   * KupaGemel update
   */
  export type KupaGemelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KupaGemel
     */
    select?: KupaGemelSelect<ExtArgs> | null
    /**
     * The data needed to update a KupaGemel.
     */
    data: XOR<KupaGemelUpdateInput, KupaGemelUncheckedUpdateInput>
    /**
     * Choose, which KupaGemel to update.
     */
    where: KupaGemelWhereUniqueInput
  }

  /**
   * KupaGemel updateMany
   */
  export type KupaGemelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KupaGemels.
     */
    data: XOR<KupaGemelUpdateManyMutationInput, KupaGemelUncheckedUpdateManyInput>
    /**
     * Filter which KupaGemels to update
     */
    where?: KupaGemelWhereInput
  }

  /**
   * KupaGemel upsert
   */
  export type KupaGemelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KupaGemel
     */
    select?: KupaGemelSelect<ExtArgs> | null
    /**
     * The filter to search for the KupaGemel to update in case it exists.
     */
    where: KupaGemelWhereUniqueInput
    /**
     * In case the KupaGemel found by the `where` argument doesn't exist, create a new KupaGemel with this data.
     */
    create: XOR<KupaGemelCreateInput, KupaGemelUncheckedCreateInput>
    /**
     * In case the KupaGemel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KupaGemelUpdateInput, KupaGemelUncheckedUpdateInput>
  }

  /**
   * KupaGemel delete
   */
  export type KupaGemelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KupaGemel
     */
    select?: KupaGemelSelect<ExtArgs> | null
    /**
     * Filter which KupaGemel to delete.
     */
    where: KupaGemelWhereUniqueInput
  }

  /**
   * KupaGemel deleteMany
   */
  export type KupaGemelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KupaGemels to delete
     */
    where?: KupaGemelWhereInput
  }

  /**
   * KupaGemel without action
   */
  export type KupaGemelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KupaGemel
     */
    select?: KupaGemelSelect<ExtArgs> | null
  }


  /**
   * Model LandPages
   */

  export type AggregateLandPages = {
    _count: LandPagesCountAggregateOutputType | null
    _min: LandPagesMinAggregateOutputType | null
    _max: LandPagesMaxAggregateOutputType | null
  }

  export type LandPagesMinAggregateOutputType = {
    LandPageRowId: string | null
    CompanyID: string | null
    CreatedAt: Date | null
    JsonData: string | null
    ViewDate: Date | null
    CompletedDate: Date | null
  }

  export type LandPagesMaxAggregateOutputType = {
    LandPageRowId: string | null
    CompanyID: string | null
    CreatedAt: Date | null
    JsonData: string | null
    ViewDate: Date | null
    CompletedDate: Date | null
  }

  export type LandPagesCountAggregateOutputType = {
    LandPageRowId: number
    CompanyID: number
    CreatedAt: number
    JsonData: number
    ViewDate: number
    CompletedDate: number
    _all: number
  }


  export type LandPagesMinAggregateInputType = {
    LandPageRowId?: true
    CompanyID?: true
    CreatedAt?: true
    JsonData?: true
    ViewDate?: true
    CompletedDate?: true
  }

  export type LandPagesMaxAggregateInputType = {
    LandPageRowId?: true
    CompanyID?: true
    CreatedAt?: true
    JsonData?: true
    ViewDate?: true
    CompletedDate?: true
  }

  export type LandPagesCountAggregateInputType = {
    LandPageRowId?: true
    CompanyID?: true
    CreatedAt?: true
    JsonData?: true
    ViewDate?: true
    CompletedDate?: true
    _all?: true
  }

  export type LandPagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LandPages to aggregate.
     */
    where?: LandPagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandPages to fetch.
     */
    orderBy?: LandPagesOrderByWithRelationInput | LandPagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LandPagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LandPages
    **/
    _count?: true | LandPagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandPagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandPagesMaxAggregateInputType
  }

  export type GetLandPagesAggregateType<T extends LandPagesAggregateArgs> = {
        [P in keyof T & keyof AggregateLandPages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLandPages[P]>
      : GetScalarType<T[P], AggregateLandPages[P]>
  }




  export type LandPagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandPagesWhereInput
    orderBy?: LandPagesOrderByWithAggregationInput | LandPagesOrderByWithAggregationInput[]
    by: LandPagesScalarFieldEnum[] | LandPagesScalarFieldEnum
    having?: LandPagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandPagesCountAggregateInputType | true
    _min?: LandPagesMinAggregateInputType
    _max?: LandPagesMaxAggregateInputType
  }

  export type LandPagesGroupByOutputType = {
    LandPageRowId: string
    CompanyID: string
    CreatedAt: Date | null
    JsonData: string | null
    ViewDate: Date | null
    CompletedDate: Date | null
    _count: LandPagesCountAggregateOutputType | null
    _min: LandPagesMinAggregateOutputType | null
    _max: LandPagesMaxAggregateOutputType | null
  }

  type GetLandPagesGroupByPayload<T extends LandPagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandPagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandPagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandPagesGroupByOutputType[P]>
            : GetScalarType<T[P], LandPagesGroupByOutputType[P]>
        }
      >
    >


  export type LandPagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LandPageRowId?: boolean
    CompanyID?: boolean
    CreatedAt?: boolean
    JsonData?: boolean
    ViewDate?: boolean
    CompletedDate?: boolean
    Companies?: boolean | CompaniesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landPages"]>


  export type LandPagesSelectScalar = {
    LandPageRowId?: boolean
    CompanyID?: boolean
    CreatedAt?: boolean
    JsonData?: boolean
    ViewDate?: boolean
    CompletedDate?: boolean
  }

  export type LandPagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Companies?: boolean | CompaniesDefaultArgs<ExtArgs>
  }

  export type $LandPagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LandPages"
    objects: {
      Companies: Prisma.$CompaniesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      LandPageRowId: string
      CompanyID: string
      CreatedAt: Date | null
      JsonData: string | null
      ViewDate: Date | null
      CompletedDate: Date | null
    }, ExtArgs["result"]["landPages"]>
    composites: {}
  }

  type LandPagesGetPayload<S extends boolean | null | undefined | LandPagesDefaultArgs> = $Result.GetResult<Prisma.$LandPagesPayload, S>

  type LandPagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LandPagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LandPagesCountAggregateInputType | true
    }

  export interface LandPagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LandPages'], meta: { name: 'LandPages' } }
    /**
     * Find zero or one LandPages that matches the filter.
     * @param {LandPagesFindUniqueArgs} args - Arguments to find a LandPages
     * @example
     * // Get one LandPages
     * const landPages = await prisma.landPages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LandPagesFindUniqueArgs>(args: SelectSubset<T, LandPagesFindUniqueArgs<ExtArgs>>): Prisma__LandPagesClient<$Result.GetResult<Prisma.$LandPagesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LandPages that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LandPagesFindUniqueOrThrowArgs} args - Arguments to find a LandPages
     * @example
     * // Get one LandPages
     * const landPages = await prisma.landPages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LandPagesFindUniqueOrThrowArgs>(args: SelectSubset<T, LandPagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LandPagesClient<$Result.GetResult<Prisma.$LandPagesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LandPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandPagesFindFirstArgs} args - Arguments to find a LandPages
     * @example
     * // Get one LandPages
     * const landPages = await prisma.landPages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LandPagesFindFirstArgs>(args?: SelectSubset<T, LandPagesFindFirstArgs<ExtArgs>>): Prisma__LandPagesClient<$Result.GetResult<Prisma.$LandPagesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LandPages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandPagesFindFirstOrThrowArgs} args - Arguments to find a LandPages
     * @example
     * // Get one LandPages
     * const landPages = await prisma.landPages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LandPagesFindFirstOrThrowArgs>(args?: SelectSubset<T, LandPagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__LandPagesClient<$Result.GetResult<Prisma.$LandPagesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LandPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandPagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LandPages
     * const landPages = await prisma.landPages.findMany()
     * 
     * // Get first 10 LandPages
     * const landPages = await prisma.landPages.findMany({ take: 10 })
     * 
     * // Only select the `LandPageRowId`
     * const landPagesWithLandPageRowIdOnly = await prisma.landPages.findMany({ select: { LandPageRowId: true } })
     * 
     */
    findMany<T extends LandPagesFindManyArgs>(args?: SelectSubset<T, LandPagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandPagesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LandPages.
     * @param {LandPagesCreateArgs} args - Arguments to create a LandPages.
     * @example
     * // Create one LandPages
     * const LandPages = await prisma.landPages.create({
     *   data: {
     *     // ... data to create a LandPages
     *   }
     * })
     * 
     */
    create<T extends LandPagesCreateArgs>(args: SelectSubset<T, LandPagesCreateArgs<ExtArgs>>): Prisma__LandPagesClient<$Result.GetResult<Prisma.$LandPagesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LandPages.
     * @param {LandPagesCreateManyArgs} args - Arguments to create many LandPages.
     * @example
     * // Create many LandPages
     * const landPages = await prisma.landPages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LandPagesCreateManyArgs>(args?: SelectSubset<T, LandPagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LandPages.
     * @param {LandPagesDeleteArgs} args - Arguments to delete one LandPages.
     * @example
     * // Delete one LandPages
     * const LandPages = await prisma.landPages.delete({
     *   where: {
     *     // ... filter to delete one LandPages
     *   }
     * })
     * 
     */
    delete<T extends LandPagesDeleteArgs>(args: SelectSubset<T, LandPagesDeleteArgs<ExtArgs>>): Prisma__LandPagesClient<$Result.GetResult<Prisma.$LandPagesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LandPages.
     * @param {LandPagesUpdateArgs} args - Arguments to update one LandPages.
     * @example
     * // Update one LandPages
     * const landPages = await prisma.landPages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LandPagesUpdateArgs>(args: SelectSubset<T, LandPagesUpdateArgs<ExtArgs>>): Prisma__LandPagesClient<$Result.GetResult<Prisma.$LandPagesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LandPages.
     * @param {LandPagesDeleteManyArgs} args - Arguments to filter LandPages to delete.
     * @example
     * // Delete a few LandPages
     * const { count } = await prisma.landPages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LandPagesDeleteManyArgs>(args?: SelectSubset<T, LandPagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LandPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandPagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LandPages
     * const landPages = await prisma.landPages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LandPagesUpdateManyArgs>(args: SelectSubset<T, LandPagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LandPages.
     * @param {LandPagesUpsertArgs} args - Arguments to update or create a LandPages.
     * @example
     * // Update or create a LandPages
     * const landPages = await prisma.landPages.upsert({
     *   create: {
     *     // ... data to create a LandPages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LandPages we want to update
     *   }
     * })
     */
    upsert<T extends LandPagesUpsertArgs>(args: SelectSubset<T, LandPagesUpsertArgs<ExtArgs>>): Prisma__LandPagesClient<$Result.GetResult<Prisma.$LandPagesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LandPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandPagesCountArgs} args - Arguments to filter LandPages to count.
     * @example
     * // Count the number of LandPages
     * const count = await prisma.landPages.count({
     *   where: {
     *     // ... the filter for the LandPages we want to count
     *   }
     * })
    **/
    count<T extends LandPagesCountArgs>(
      args?: Subset<T, LandPagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandPagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LandPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandPagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandPagesAggregateArgs>(args: Subset<T, LandPagesAggregateArgs>): Prisma.PrismaPromise<GetLandPagesAggregateType<T>>

    /**
     * Group by LandPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandPagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LandPagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LandPagesGroupByArgs['orderBy'] }
        : { orderBy?: LandPagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LandPagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandPagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LandPages model
   */
  readonly fields: LandPagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LandPages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LandPagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Companies<T extends CompaniesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesDefaultArgs<ExtArgs>>): Prisma__CompaniesClient<$Result.GetResult<Prisma.$CompaniesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LandPages model
   */ 
  interface LandPagesFieldRefs {
    readonly LandPageRowId: FieldRef<"LandPages", 'String'>
    readonly CompanyID: FieldRef<"LandPages", 'String'>
    readonly CreatedAt: FieldRef<"LandPages", 'DateTime'>
    readonly JsonData: FieldRef<"LandPages", 'String'>
    readonly ViewDate: FieldRef<"LandPages", 'DateTime'>
    readonly CompletedDate: FieldRef<"LandPages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LandPages findUnique
   */
  export type LandPagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandPages
     */
    select?: LandPagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandPagesInclude<ExtArgs> | null
    /**
     * Filter, which LandPages to fetch.
     */
    where: LandPagesWhereUniqueInput
  }

  /**
   * LandPages findUniqueOrThrow
   */
  export type LandPagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandPages
     */
    select?: LandPagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandPagesInclude<ExtArgs> | null
    /**
     * Filter, which LandPages to fetch.
     */
    where: LandPagesWhereUniqueInput
  }

  /**
   * LandPages findFirst
   */
  export type LandPagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandPages
     */
    select?: LandPagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandPagesInclude<ExtArgs> | null
    /**
     * Filter, which LandPages to fetch.
     */
    where?: LandPagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandPages to fetch.
     */
    orderBy?: LandPagesOrderByWithRelationInput | LandPagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LandPages.
     */
    cursor?: LandPagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LandPages.
     */
    distinct?: LandPagesScalarFieldEnum | LandPagesScalarFieldEnum[]
  }

  /**
   * LandPages findFirstOrThrow
   */
  export type LandPagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandPages
     */
    select?: LandPagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandPagesInclude<ExtArgs> | null
    /**
     * Filter, which LandPages to fetch.
     */
    where?: LandPagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandPages to fetch.
     */
    orderBy?: LandPagesOrderByWithRelationInput | LandPagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LandPages.
     */
    cursor?: LandPagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LandPages.
     */
    distinct?: LandPagesScalarFieldEnum | LandPagesScalarFieldEnum[]
  }

  /**
   * LandPages findMany
   */
  export type LandPagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandPages
     */
    select?: LandPagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandPagesInclude<ExtArgs> | null
    /**
     * Filter, which LandPages to fetch.
     */
    where?: LandPagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandPages to fetch.
     */
    orderBy?: LandPagesOrderByWithRelationInput | LandPagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LandPages.
     */
    cursor?: LandPagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandPages.
     */
    skip?: number
    distinct?: LandPagesScalarFieldEnum | LandPagesScalarFieldEnum[]
  }

  /**
   * LandPages create
   */
  export type LandPagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandPages
     */
    select?: LandPagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandPagesInclude<ExtArgs> | null
    /**
     * The data needed to create a LandPages.
     */
    data: XOR<LandPagesCreateInput, LandPagesUncheckedCreateInput>
  }

  /**
   * LandPages createMany
   */
  export type LandPagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LandPages.
     */
    data: LandPagesCreateManyInput | LandPagesCreateManyInput[]
  }

  /**
   * LandPages update
   */
  export type LandPagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandPages
     */
    select?: LandPagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandPagesInclude<ExtArgs> | null
    /**
     * The data needed to update a LandPages.
     */
    data: XOR<LandPagesUpdateInput, LandPagesUncheckedUpdateInput>
    /**
     * Choose, which LandPages to update.
     */
    where: LandPagesWhereUniqueInput
  }

  /**
   * LandPages updateMany
   */
  export type LandPagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LandPages.
     */
    data: XOR<LandPagesUpdateManyMutationInput, LandPagesUncheckedUpdateManyInput>
    /**
     * Filter which LandPages to update
     */
    where?: LandPagesWhereInput
  }

  /**
   * LandPages upsert
   */
  export type LandPagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandPages
     */
    select?: LandPagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandPagesInclude<ExtArgs> | null
    /**
     * The filter to search for the LandPages to update in case it exists.
     */
    where: LandPagesWhereUniqueInput
    /**
     * In case the LandPages found by the `where` argument doesn't exist, create a new LandPages with this data.
     */
    create: XOR<LandPagesCreateInput, LandPagesUncheckedCreateInput>
    /**
     * In case the LandPages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LandPagesUpdateInput, LandPagesUncheckedUpdateInput>
  }

  /**
   * LandPages delete
   */
  export type LandPagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandPages
     */
    select?: LandPagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandPagesInclude<ExtArgs> | null
    /**
     * Filter which LandPages to delete.
     */
    where: LandPagesWhereUniqueInput
  }

  /**
   * LandPages deleteMany
   */
  export type LandPagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LandPages to delete
     */
    where?: LandPagesWhereInput
  }

  /**
   * LandPages without action
   */
  export type LandPagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandPages
     */
    select?: LandPagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LandPagesInclude<ExtArgs> | null
  }


  /**
   * Model LanguageDefinition
   */

  export type AggregateLanguageDefinition = {
    _count: LanguageDefinitionCountAggregateOutputType | null
    _avg: LanguageDefinitionAvgAggregateOutputType | null
    _sum: LanguageDefinitionSumAggregateOutputType | null
    _min: LanguageDefinitionMinAggregateOutputType | null
    _max: LanguageDefinitionMaxAggregateOutputType | null
  }

  export type LanguageDefinitionAvgAggregateOutputType = {
    LanguageDefinitionID: number | null
    ControlTypeID: number | null
  }

  export type LanguageDefinitionSumAggregateOutputType = {
    LanguageDefinitionID: number | null
    ControlTypeID: number | null
  }

  export type LanguageDefinitionMinAggregateOutputType = {
    LanguageDefinitionID: number | null
    ObjectName: string | null
    ControlTypeID: number | null
    ControlName: string | null
    CaptionEnglish: string | null
    CaptionHebrow: string | null
    CaptionRomanian: string | null
    CaptionRussian: string | null
    CaptionChinese: string | null
    CaptionTurkish: string | null
  }

  export type LanguageDefinitionMaxAggregateOutputType = {
    LanguageDefinitionID: number | null
    ObjectName: string | null
    ControlTypeID: number | null
    ControlName: string | null
    CaptionEnglish: string | null
    CaptionHebrow: string | null
    CaptionRomanian: string | null
    CaptionRussian: string | null
    CaptionChinese: string | null
    CaptionTurkish: string | null
  }

  export type LanguageDefinitionCountAggregateOutputType = {
    LanguageDefinitionID: number
    ObjectName: number
    ControlTypeID: number
    ControlName: number
    CaptionEnglish: number
    CaptionHebrow: number
    CaptionRomanian: number
    CaptionRussian: number
    CaptionChinese: number
    CaptionTurkish: number
    _all: number
  }


  export type LanguageDefinitionAvgAggregateInputType = {
    LanguageDefinitionID?: true
    ControlTypeID?: true
  }

  export type LanguageDefinitionSumAggregateInputType = {
    LanguageDefinitionID?: true
    ControlTypeID?: true
  }

  export type LanguageDefinitionMinAggregateInputType = {
    LanguageDefinitionID?: true
    ObjectName?: true
    ControlTypeID?: true
    ControlName?: true
    CaptionEnglish?: true
    CaptionHebrow?: true
    CaptionRomanian?: true
    CaptionRussian?: true
    CaptionChinese?: true
    CaptionTurkish?: true
  }

  export type LanguageDefinitionMaxAggregateInputType = {
    LanguageDefinitionID?: true
    ObjectName?: true
    ControlTypeID?: true
    ControlName?: true
    CaptionEnglish?: true
    CaptionHebrow?: true
    CaptionRomanian?: true
    CaptionRussian?: true
    CaptionChinese?: true
    CaptionTurkish?: true
  }

  export type LanguageDefinitionCountAggregateInputType = {
    LanguageDefinitionID?: true
    ObjectName?: true
    ControlTypeID?: true
    ControlName?: true
    CaptionEnglish?: true
    CaptionHebrow?: true
    CaptionRomanian?: true
    CaptionRussian?: true
    CaptionChinese?: true
    CaptionTurkish?: true
    _all?: true
  }

  export type LanguageDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LanguageDefinition to aggregate.
     */
    where?: LanguageDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageDefinitions to fetch.
     */
    orderBy?: LanguageDefinitionOrderByWithRelationInput | LanguageDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LanguageDefinitions
    **/
    _count?: true | LanguageDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageDefinitionMaxAggregateInputType
  }

  export type GetLanguageDefinitionAggregateType<T extends LanguageDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguageDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguageDefinition[P]>
      : GetScalarType<T[P], AggregateLanguageDefinition[P]>
  }




  export type LanguageDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageDefinitionWhereInput
    orderBy?: LanguageDefinitionOrderByWithAggregationInput | LanguageDefinitionOrderByWithAggregationInput[]
    by: LanguageDefinitionScalarFieldEnum[] | LanguageDefinitionScalarFieldEnum
    having?: LanguageDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageDefinitionCountAggregateInputType | true
    _avg?: LanguageDefinitionAvgAggregateInputType
    _sum?: LanguageDefinitionSumAggregateInputType
    _min?: LanguageDefinitionMinAggregateInputType
    _max?: LanguageDefinitionMaxAggregateInputType
  }

  export type LanguageDefinitionGroupByOutputType = {
    LanguageDefinitionID: number
    ObjectName: string
    ControlTypeID: number
    ControlName: string
    CaptionEnglish: string | null
    CaptionHebrow: string | null
    CaptionRomanian: string | null
    CaptionRussian: string | null
    CaptionChinese: string | null
    CaptionTurkish: string | null
    _count: LanguageDefinitionCountAggregateOutputType | null
    _avg: LanguageDefinitionAvgAggregateOutputType | null
    _sum: LanguageDefinitionSumAggregateOutputType | null
    _min: LanguageDefinitionMinAggregateOutputType | null
    _max: LanguageDefinitionMaxAggregateOutputType | null
  }

  type GetLanguageDefinitionGroupByPayload<T extends LanguageDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type LanguageDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LanguageDefinitionID?: boolean
    ObjectName?: boolean
    ControlTypeID?: boolean
    ControlName?: boolean
    CaptionEnglish?: boolean
    CaptionHebrow?: boolean
    CaptionRomanian?: boolean
    CaptionRussian?: boolean
    CaptionChinese?: boolean
    CaptionTurkish?: boolean
  }, ExtArgs["result"]["languageDefinition"]>


  export type LanguageDefinitionSelectScalar = {
    LanguageDefinitionID?: boolean
    ObjectName?: boolean
    ControlTypeID?: boolean
    ControlName?: boolean
    CaptionEnglish?: boolean
    CaptionHebrow?: boolean
    CaptionRomanian?: boolean
    CaptionRussian?: boolean
    CaptionChinese?: boolean
    CaptionTurkish?: boolean
  }


  export type $LanguageDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LanguageDefinition"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      LanguageDefinitionID: number
      ObjectName: string
      ControlTypeID: number
      ControlName: string
      CaptionEnglish: string | null
      CaptionHebrow: string | null
      CaptionRomanian: string | null
      CaptionRussian: string | null
      CaptionChinese: string | null
      CaptionTurkish: string | null
    }, ExtArgs["result"]["languageDefinition"]>
    composites: {}
  }

  type LanguageDefinitionGetPayload<S extends boolean | null | undefined | LanguageDefinitionDefaultArgs> = $Result.GetResult<Prisma.$LanguageDefinitionPayload, S>

  type LanguageDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LanguageDefinitionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LanguageDefinitionCountAggregateInputType | true
    }

  export interface LanguageDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LanguageDefinition'], meta: { name: 'LanguageDefinition' } }
    /**
     * Find zero or one LanguageDefinition that matches the filter.
     * @param {LanguageDefinitionFindUniqueArgs} args - Arguments to find a LanguageDefinition
     * @example
     * // Get one LanguageDefinition
     * const languageDefinition = await prisma.languageDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageDefinitionFindUniqueArgs>(args: SelectSubset<T, LanguageDefinitionFindUniqueArgs<ExtArgs>>): Prisma__LanguageDefinitionClient<$Result.GetResult<Prisma.$LanguageDefinitionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LanguageDefinition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LanguageDefinitionFindUniqueOrThrowArgs} args - Arguments to find a LanguageDefinition
     * @example
     * // Get one LanguageDefinition
     * const languageDefinition = await prisma.languageDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageDefinitionClient<$Result.GetResult<Prisma.$LanguageDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LanguageDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageDefinitionFindFirstArgs} args - Arguments to find a LanguageDefinition
     * @example
     * // Get one LanguageDefinition
     * const languageDefinition = await prisma.languageDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageDefinitionFindFirstArgs>(args?: SelectSubset<T, LanguageDefinitionFindFirstArgs<ExtArgs>>): Prisma__LanguageDefinitionClient<$Result.GetResult<Prisma.$LanguageDefinitionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LanguageDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageDefinitionFindFirstOrThrowArgs} args - Arguments to find a LanguageDefinition
     * @example
     * // Get one LanguageDefinition
     * const languageDefinition = await prisma.languageDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageDefinitionClient<$Result.GetResult<Prisma.$LanguageDefinitionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LanguageDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LanguageDefinitions
     * const languageDefinitions = await prisma.languageDefinition.findMany()
     * 
     * // Get first 10 LanguageDefinitions
     * const languageDefinitions = await prisma.languageDefinition.findMany({ take: 10 })
     * 
     * // Only select the `LanguageDefinitionID`
     * const languageDefinitionWithLanguageDefinitionIDOnly = await prisma.languageDefinition.findMany({ select: { LanguageDefinitionID: true } })
     * 
     */
    findMany<T extends LanguageDefinitionFindManyArgs>(args?: SelectSubset<T, LanguageDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageDefinitionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LanguageDefinition.
     * @param {LanguageDefinitionCreateArgs} args - Arguments to create a LanguageDefinition.
     * @example
     * // Create one LanguageDefinition
     * const LanguageDefinition = await prisma.languageDefinition.create({
     *   data: {
     *     // ... data to create a LanguageDefinition
     *   }
     * })
     * 
     */
    create<T extends LanguageDefinitionCreateArgs>(args: SelectSubset<T, LanguageDefinitionCreateArgs<ExtArgs>>): Prisma__LanguageDefinitionClient<$Result.GetResult<Prisma.$LanguageDefinitionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LanguageDefinitions.
     * @param {LanguageDefinitionCreateManyArgs} args - Arguments to create many LanguageDefinitions.
     * @example
     * // Create many LanguageDefinitions
     * const languageDefinition = await prisma.languageDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageDefinitionCreateManyArgs>(args?: SelectSubset<T, LanguageDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LanguageDefinition.
     * @param {LanguageDefinitionDeleteArgs} args - Arguments to delete one LanguageDefinition.
     * @example
     * // Delete one LanguageDefinition
     * const LanguageDefinition = await prisma.languageDefinition.delete({
     *   where: {
     *     // ... filter to delete one LanguageDefinition
     *   }
     * })
     * 
     */
    delete<T extends LanguageDefinitionDeleteArgs>(args: SelectSubset<T, LanguageDefinitionDeleteArgs<ExtArgs>>): Prisma__LanguageDefinitionClient<$Result.GetResult<Prisma.$LanguageDefinitionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LanguageDefinition.
     * @param {LanguageDefinitionUpdateArgs} args - Arguments to update one LanguageDefinition.
     * @example
     * // Update one LanguageDefinition
     * const languageDefinition = await prisma.languageDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageDefinitionUpdateArgs>(args: SelectSubset<T, LanguageDefinitionUpdateArgs<ExtArgs>>): Prisma__LanguageDefinitionClient<$Result.GetResult<Prisma.$LanguageDefinitionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LanguageDefinitions.
     * @param {LanguageDefinitionDeleteManyArgs} args - Arguments to filter LanguageDefinitions to delete.
     * @example
     * // Delete a few LanguageDefinitions
     * const { count } = await prisma.languageDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDefinitionDeleteManyArgs>(args?: SelectSubset<T, LanguageDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LanguageDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LanguageDefinitions
     * const languageDefinition = await prisma.languageDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageDefinitionUpdateManyArgs>(args: SelectSubset<T, LanguageDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LanguageDefinition.
     * @param {LanguageDefinitionUpsertArgs} args - Arguments to update or create a LanguageDefinition.
     * @example
     * // Update or create a LanguageDefinition
     * const languageDefinition = await prisma.languageDefinition.upsert({
     *   create: {
     *     // ... data to create a LanguageDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LanguageDefinition we want to update
     *   }
     * })
     */
    upsert<T extends LanguageDefinitionUpsertArgs>(args: SelectSubset<T, LanguageDefinitionUpsertArgs<ExtArgs>>): Prisma__LanguageDefinitionClient<$Result.GetResult<Prisma.$LanguageDefinitionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LanguageDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageDefinitionCountArgs} args - Arguments to filter LanguageDefinitions to count.
     * @example
     * // Count the number of LanguageDefinitions
     * const count = await prisma.languageDefinition.count({
     *   where: {
     *     // ... the filter for the LanguageDefinitions we want to count
     *   }
     * })
    **/
    count<T extends LanguageDefinitionCountArgs>(
      args?: Subset<T, LanguageDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LanguageDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageDefinitionAggregateArgs>(args: Subset<T, LanguageDefinitionAggregateArgs>): Prisma.PrismaPromise<GetLanguageDefinitionAggregateType<T>>

    /**
     * Group by LanguageDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: LanguageDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LanguageDefinition model
   */
  readonly fields: LanguageDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LanguageDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LanguageDefinition model
   */ 
  interface LanguageDefinitionFieldRefs {
    readonly LanguageDefinitionID: FieldRef<"LanguageDefinition", 'Int'>
    readonly ObjectName: FieldRef<"LanguageDefinition", 'String'>
    readonly ControlTypeID: FieldRef<"LanguageDefinition", 'Int'>
    readonly ControlName: FieldRef<"LanguageDefinition", 'String'>
    readonly CaptionEnglish: FieldRef<"LanguageDefinition", 'String'>
    readonly CaptionHebrow: FieldRef<"LanguageDefinition", 'String'>
    readonly CaptionRomanian: FieldRef<"LanguageDefinition", 'String'>
    readonly CaptionRussian: FieldRef<"LanguageDefinition", 'String'>
    readonly CaptionChinese: FieldRef<"LanguageDefinition", 'String'>
    readonly CaptionTurkish: FieldRef<"LanguageDefinition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LanguageDefinition findUnique
   */
  export type LanguageDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageDefinition
     */
    select?: LanguageDefinitionSelect<ExtArgs> | null
    /**
     * Filter, which LanguageDefinition to fetch.
     */
    where: LanguageDefinitionWhereUniqueInput
  }

  /**
   * LanguageDefinition findUniqueOrThrow
   */
  export type LanguageDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageDefinition
     */
    select?: LanguageDefinitionSelect<ExtArgs> | null
    /**
     * Filter, which LanguageDefinition to fetch.
     */
    where: LanguageDefinitionWhereUniqueInput
  }

  /**
   * LanguageDefinition findFirst
   */
  export type LanguageDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageDefinition
     */
    select?: LanguageDefinitionSelect<ExtArgs> | null
    /**
     * Filter, which LanguageDefinition to fetch.
     */
    where?: LanguageDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageDefinitions to fetch.
     */
    orderBy?: LanguageDefinitionOrderByWithRelationInput | LanguageDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LanguageDefinitions.
     */
    cursor?: LanguageDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LanguageDefinitions.
     */
    distinct?: LanguageDefinitionScalarFieldEnum | LanguageDefinitionScalarFieldEnum[]
  }

  /**
   * LanguageDefinition findFirstOrThrow
   */
  export type LanguageDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageDefinition
     */
    select?: LanguageDefinitionSelect<ExtArgs> | null
    /**
     * Filter, which LanguageDefinition to fetch.
     */
    where?: LanguageDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageDefinitions to fetch.
     */
    orderBy?: LanguageDefinitionOrderByWithRelationInput | LanguageDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LanguageDefinitions.
     */
    cursor?: LanguageDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LanguageDefinitions.
     */
    distinct?: LanguageDefinitionScalarFieldEnum | LanguageDefinitionScalarFieldEnum[]
  }

  /**
   * LanguageDefinition findMany
   */
  export type LanguageDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageDefinition
     */
    select?: LanguageDefinitionSelect<ExtArgs> | null
    /**
     * Filter, which LanguageDefinitions to fetch.
     */
    where?: LanguageDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageDefinitions to fetch.
     */
    orderBy?: LanguageDefinitionOrderByWithRelationInput | LanguageDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LanguageDefinitions.
     */
    cursor?: LanguageDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageDefinitions.
     */
    skip?: number
    distinct?: LanguageDefinitionScalarFieldEnum | LanguageDefinitionScalarFieldEnum[]
  }

  /**
   * LanguageDefinition create
   */
  export type LanguageDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageDefinition
     */
    select?: LanguageDefinitionSelect<ExtArgs> | null
    /**
     * The data needed to create a LanguageDefinition.
     */
    data: XOR<LanguageDefinitionCreateInput, LanguageDefinitionUncheckedCreateInput>
  }

  /**
   * LanguageDefinition createMany
   */
  export type LanguageDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LanguageDefinitions.
     */
    data: LanguageDefinitionCreateManyInput | LanguageDefinitionCreateManyInput[]
  }

  /**
   * LanguageDefinition update
   */
  export type LanguageDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageDefinition
     */
    select?: LanguageDefinitionSelect<ExtArgs> | null
    /**
     * The data needed to update a LanguageDefinition.
     */
    data: XOR<LanguageDefinitionUpdateInput, LanguageDefinitionUncheckedUpdateInput>
    /**
     * Choose, which LanguageDefinition to update.
     */
    where: LanguageDefinitionWhereUniqueInput
  }

  /**
   * LanguageDefinition updateMany
   */
  export type LanguageDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LanguageDefinitions.
     */
    data: XOR<LanguageDefinitionUpdateManyMutationInput, LanguageDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which LanguageDefinitions to update
     */
    where?: LanguageDefinitionWhereInput
  }

  /**
   * LanguageDefinition upsert
   */
  export type LanguageDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageDefinition
     */
    select?: LanguageDefinitionSelect<ExtArgs> | null
    /**
     * The filter to search for the LanguageDefinition to update in case it exists.
     */
    where: LanguageDefinitionWhereUniqueInput
    /**
     * In case the LanguageDefinition found by the `where` argument doesn't exist, create a new LanguageDefinition with this data.
     */
    create: XOR<LanguageDefinitionCreateInput, LanguageDefinitionUncheckedCreateInput>
    /**
     * In case the LanguageDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageDefinitionUpdateInput, LanguageDefinitionUncheckedUpdateInput>
  }

  /**
   * LanguageDefinition delete
   */
  export type LanguageDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageDefinition
     */
    select?: LanguageDefinitionSelect<ExtArgs> | null
    /**
     * Filter which LanguageDefinition to delete.
     */
    where: LanguageDefinitionWhereUniqueInput
  }

  /**
   * LanguageDefinition deleteMany
   */
  export type LanguageDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LanguageDefinitions to delete
     */
    where?: LanguageDefinitionWhereInput
  }

  /**
   * LanguageDefinition without action
   */
  export type LanguageDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageDefinition
     */
    select?: LanguageDefinitionSelect<ExtArgs> | null
  }


  /**
   * Model Lkup_Area
   */

  export type AggregateLkup_Area = {
    _count: Lkup_AreaCountAggregateOutputType | null
    _avg: Lkup_AreaAvgAggregateOutputType | null
    _sum: Lkup_AreaSumAggregateOutputType | null
    _min: Lkup_AreaMinAggregateOutputType | null
    _max: Lkup_AreaMaxAggregateOutputType | null
  }

  export type Lkup_AreaAvgAggregateOutputType = {
    AreaID: number | null
    AreaCode: number | null
    Amount: number | null
  }

  export type Lkup_AreaSumAggregateOutputType = {
    AreaID: number | null
    AreaCode: number | null
    Amount: number | null
  }

  export type Lkup_AreaMinAggregateOutputType = {
    AreaID: number | null
    AreaCode: number | null
    AreaName: string | null
    Amount: number | null
  }

  export type Lkup_AreaMaxAggregateOutputType = {
    AreaID: number | null
    AreaCode: number | null
    AreaName: string | null
    Amount: number | null
  }

  export type Lkup_AreaCountAggregateOutputType = {
    AreaID: number
    AreaCode: number
    AreaName: number
    Amount: number
    _all: number
  }


  export type Lkup_AreaAvgAggregateInputType = {
    AreaID?: true
    AreaCode?: true
    Amount?: true
  }

  export type Lkup_AreaSumAggregateInputType = {
    AreaID?: true
    AreaCode?: true
    Amount?: true
  }

  export type Lkup_AreaMinAggregateInputType = {
    AreaID?: true
    AreaCode?: true
    AreaName?: true
    Amount?: true
  }

  export type Lkup_AreaMaxAggregateInputType = {
    AreaID?: true
    AreaCode?: true
    AreaName?: true
    Amount?: true
  }

  export type Lkup_AreaCountAggregateInputType = {
    AreaID?: true
    AreaCode?: true
    AreaName?: true
    Amount?: true
    _all?: true
  }

  export type Lkup_AreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Area to aggregate.
     */
    where?: Lkup_AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Areas to fetch.
     */
    orderBy?: Lkup_AreaOrderByWithRelationInput | Lkup_AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_Areas
    **/
    _count?: true | Lkup_AreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_AreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_AreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_AreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_AreaMaxAggregateInputType
  }

  export type GetLkup_AreaAggregateType<T extends Lkup_AreaAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_Area]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_Area[P]>
      : GetScalarType<T[P], AggregateLkup_Area[P]>
  }




  export type Lkup_AreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_AreaWhereInput
    orderBy?: Lkup_AreaOrderByWithAggregationInput | Lkup_AreaOrderByWithAggregationInput[]
    by: Lkup_AreaScalarFieldEnum[] | Lkup_AreaScalarFieldEnum
    having?: Lkup_AreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_AreaCountAggregateInputType | true
    _avg?: Lkup_AreaAvgAggregateInputType
    _sum?: Lkup_AreaSumAggregateInputType
    _min?: Lkup_AreaMinAggregateInputType
    _max?: Lkup_AreaMaxAggregateInputType
  }

  export type Lkup_AreaGroupByOutputType = {
    AreaID: number
    AreaCode: number
    AreaName: string
    Amount: number
    _count: Lkup_AreaCountAggregateOutputType | null
    _avg: Lkup_AreaAvgAggregateOutputType | null
    _sum: Lkup_AreaSumAggregateOutputType | null
    _min: Lkup_AreaMinAggregateOutputType | null
    _max: Lkup_AreaMaxAggregateOutputType | null
  }

  type GetLkup_AreaGroupByPayload<T extends Lkup_AreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_AreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_AreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_AreaGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_AreaGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_AreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AreaID?: boolean
    AreaCode?: boolean
    AreaName?: boolean
    Amount?: boolean
  }, ExtArgs["result"]["lkup_Area"]>


  export type Lkup_AreaSelectScalar = {
    AreaID?: boolean
    AreaCode?: boolean
    AreaName?: boolean
    Amount?: boolean
  }


  export type $Lkup_AreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_Area"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      AreaID: number
      AreaCode: number
      AreaName: string
      Amount: number
    }, ExtArgs["result"]["lkup_Area"]>
    composites: {}
  }

  type Lkup_AreaGetPayload<S extends boolean | null | undefined | Lkup_AreaDefaultArgs> = $Result.GetResult<Prisma.$Lkup_AreaPayload, S>

  type Lkup_AreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_AreaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_AreaCountAggregateInputType | true
    }

  export interface Lkup_AreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_Area'], meta: { name: 'Lkup_Area' } }
    /**
     * Find zero or one Lkup_Area that matches the filter.
     * @param {Lkup_AreaFindUniqueArgs} args - Arguments to find a Lkup_Area
     * @example
     * // Get one Lkup_Area
     * const lkup_Area = await prisma.lkup_Area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_AreaFindUniqueArgs>(args: SelectSubset<T, Lkup_AreaFindUniqueArgs<ExtArgs>>): Prisma__Lkup_AreaClient<$Result.GetResult<Prisma.$Lkup_AreaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_Area that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_AreaFindUniqueOrThrowArgs} args - Arguments to find a Lkup_Area
     * @example
     * // Get one Lkup_Area
     * const lkup_Area = await prisma.lkup_Area.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_AreaFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_AreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_AreaClient<$Result.GetResult<Prisma.$Lkup_AreaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_Area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_AreaFindFirstArgs} args - Arguments to find a Lkup_Area
     * @example
     * // Get one Lkup_Area
     * const lkup_Area = await prisma.lkup_Area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_AreaFindFirstArgs>(args?: SelectSubset<T, Lkup_AreaFindFirstArgs<ExtArgs>>): Prisma__Lkup_AreaClient<$Result.GetResult<Prisma.$Lkup_AreaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_Area that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_AreaFindFirstOrThrowArgs} args - Arguments to find a Lkup_Area
     * @example
     * // Get one Lkup_Area
     * const lkup_Area = await prisma.lkup_Area.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_AreaFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_AreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_AreaClient<$Result.GetResult<Prisma.$Lkup_AreaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_AreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_Areas
     * const lkup_Areas = await prisma.lkup_Area.findMany()
     * 
     * // Get first 10 Lkup_Areas
     * const lkup_Areas = await prisma.lkup_Area.findMany({ take: 10 })
     * 
     * // Only select the `AreaID`
     * const lkup_AreaWithAreaIDOnly = await prisma.lkup_Area.findMany({ select: { AreaID: true } })
     * 
     */
    findMany<T extends Lkup_AreaFindManyArgs>(args?: SelectSubset<T, Lkup_AreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_AreaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_Area.
     * @param {Lkup_AreaCreateArgs} args - Arguments to create a Lkup_Area.
     * @example
     * // Create one Lkup_Area
     * const Lkup_Area = await prisma.lkup_Area.create({
     *   data: {
     *     // ... data to create a Lkup_Area
     *   }
     * })
     * 
     */
    create<T extends Lkup_AreaCreateArgs>(args: SelectSubset<T, Lkup_AreaCreateArgs<ExtArgs>>): Prisma__Lkup_AreaClient<$Result.GetResult<Prisma.$Lkup_AreaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_Areas.
     * @param {Lkup_AreaCreateManyArgs} args - Arguments to create many Lkup_Areas.
     * @example
     * // Create many Lkup_Areas
     * const lkup_Area = await prisma.lkup_Area.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_AreaCreateManyArgs>(args?: SelectSubset<T, Lkup_AreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_Area.
     * @param {Lkup_AreaDeleteArgs} args - Arguments to delete one Lkup_Area.
     * @example
     * // Delete one Lkup_Area
     * const Lkup_Area = await prisma.lkup_Area.delete({
     *   where: {
     *     // ... filter to delete one Lkup_Area
     *   }
     * })
     * 
     */
    delete<T extends Lkup_AreaDeleteArgs>(args: SelectSubset<T, Lkup_AreaDeleteArgs<ExtArgs>>): Prisma__Lkup_AreaClient<$Result.GetResult<Prisma.$Lkup_AreaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_Area.
     * @param {Lkup_AreaUpdateArgs} args - Arguments to update one Lkup_Area.
     * @example
     * // Update one Lkup_Area
     * const lkup_Area = await prisma.lkup_Area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_AreaUpdateArgs>(args: SelectSubset<T, Lkup_AreaUpdateArgs<ExtArgs>>): Prisma__Lkup_AreaClient<$Result.GetResult<Prisma.$Lkup_AreaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_Areas.
     * @param {Lkup_AreaDeleteManyArgs} args - Arguments to filter Lkup_Areas to delete.
     * @example
     * // Delete a few Lkup_Areas
     * const { count } = await prisma.lkup_Area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_AreaDeleteManyArgs>(args?: SelectSubset<T, Lkup_AreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_AreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_Areas
     * const lkup_Area = await prisma.lkup_Area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_AreaUpdateManyArgs>(args: SelectSubset<T, Lkup_AreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_Area.
     * @param {Lkup_AreaUpsertArgs} args - Arguments to update or create a Lkup_Area.
     * @example
     * // Update or create a Lkup_Area
     * const lkup_Area = await prisma.lkup_Area.upsert({
     *   create: {
     *     // ... data to create a Lkup_Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_Area we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_AreaUpsertArgs>(args: SelectSubset<T, Lkup_AreaUpsertArgs<ExtArgs>>): Prisma__Lkup_AreaClient<$Result.GetResult<Prisma.$Lkup_AreaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_AreaCountArgs} args - Arguments to filter Lkup_Areas to count.
     * @example
     * // Count the number of Lkup_Areas
     * const count = await prisma.lkup_Area.count({
     *   where: {
     *     // ... the filter for the Lkup_Areas we want to count
     *   }
     * })
    **/
    count<T extends Lkup_AreaCountArgs>(
      args?: Subset<T, Lkup_AreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_AreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_AreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_AreaAggregateArgs>(args: Subset<T, Lkup_AreaAggregateArgs>): Prisma.PrismaPromise<GetLkup_AreaAggregateType<T>>

    /**
     * Group by Lkup_Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_AreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_AreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_AreaGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_AreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_AreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_AreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_Area model
   */
  readonly fields: Lkup_AreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_Area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_AreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_Area model
   */ 
  interface Lkup_AreaFieldRefs {
    readonly AreaID: FieldRef<"Lkup_Area", 'Int'>
    readonly AreaCode: FieldRef<"Lkup_Area", 'Int'>
    readonly AreaName: FieldRef<"Lkup_Area", 'String'>
    readonly Amount: FieldRef<"Lkup_Area", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_Area findUnique
   */
  export type Lkup_AreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Area
     */
    select?: Lkup_AreaSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Area to fetch.
     */
    where: Lkup_AreaWhereUniqueInput
  }

  /**
   * Lkup_Area findUniqueOrThrow
   */
  export type Lkup_AreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Area
     */
    select?: Lkup_AreaSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Area to fetch.
     */
    where: Lkup_AreaWhereUniqueInput
  }

  /**
   * Lkup_Area findFirst
   */
  export type Lkup_AreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Area
     */
    select?: Lkup_AreaSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Area to fetch.
     */
    where?: Lkup_AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Areas to fetch.
     */
    orderBy?: Lkup_AreaOrderByWithRelationInput | Lkup_AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Areas.
     */
    cursor?: Lkup_AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Areas.
     */
    distinct?: Lkup_AreaScalarFieldEnum | Lkup_AreaScalarFieldEnum[]
  }

  /**
   * Lkup_Area findFirstOrThrow
   */
  export type Lkup_AreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Area
     */
    select?: Lkup_AreaSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Area to fetch.
     */
    where?: Lkup_AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Areas to fetch.
     */
    orderBy?: Lkup_AreaOrderByWithRelationInput | Lkup_AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Areas.
     */
    cursor?: Lkup_AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Areas.
     */
    distinct?: Lkup_AreaScalarFieldEnum | Lkup_AreaScalarFieldEnum[]
  }

  /**
   * Lkup_Area findMany
   */
  export type Lkup_AreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Area
     */
    select?: Lkup_AreaSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Areas to fetch.
     */
    where?: Lkup_AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Areas to fetch.
     */
    orderBy?: Lkup_AreaOrderByWithRelationInput | Lkup_AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_Areas.
     */
    cursor?: Lkup_AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Areas.
     */
    skip?: number
    distinct?: Lkup_AreaScalarFieldEnum | Lkup_AreaScalarFieldEnum[]
  }

  /**
   * Lkup_Area create
   */
  export type Lkup_AreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Area
     */
    select?: Lkup_AreaSelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_Area.
     */
    data: XOR<Lkup_AreaCreateInput, Lkup_AreaUncheckedCreateInput>
  }

  /**
   * Lkup_Area createMany
   */
  export type Lkup_AreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_Areas.
     */
    data: Lkup_AreaCreateManyInput | Lkup_AreaCreateManyInput[]
  }

  /**
   * Lkup_Area update
   */
  export type Lkup_AreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Area
     */
    select?: Lkup_AreaSelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_Area.
     */
    data: XOR<Lkup_AreaUpdateInput, Lkup_AreaUncheckedUpdateInput>
    /**
     * Choose, which Lkup_Area to update.
     */
    where: Lkup_AreaWhereUniqueInput
  }

  /**
   * Lkup_Area updateMany
   */
  export type Lkup_AreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_Areas.
     */
    data: XOR<Lkup_AreaUpdateManyMutationInput, Lkup_AreaUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_Areas to update
     */
    where?: Lkup_AreaWhereInput
  }

  /**
   * Lkup_Area upsert
   */
  export type Lkup_AreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Area
     */
    select?: Lkup_AreaSelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_Area to update in case it exists.
     */
    where: Lkup_AreaWhereUniqueInput
    /**
     * In case the Lkup_Area found by the `where` argument doesn't exist, create a new Lkup_Area with this data.
     */
    create: XOR<Lkup_AreaCreateInput, Lkup_AreaUncheckedCreateInput>
    /**
     * In case the Lkup_Area was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_AreaUpdateInput, Lkup_AreaUncheckedUpdateInput>
  }

  /**
   * Lkup_Area delete
   */
  export type Lkup_AreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Area
     */
    select?: Lkup_AreaSelect<ExtArgs> | null
    /**
     * Filter which Lkup_Area to delete.
     */
    where: Lkup_AreaWhereUniqueInput
  }

  /**
   * Lkup_Area deleteMany
   */
  export type Lkup_AreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Areas to delete
     */
    where?: Lkup_AreaWhereInput
  }

  /**
   * Lkup_Area without action
   */
  export type Lkup_AreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Area
     */
    select?: Lkup_AreaSelect<ExtArgs> | null
  }


  /**
   * Model Lkup_Banks
   */

  export type AggregateLkup_Banks = {
    _count: Lkup_BanksCountAggregateOutputType | null
    _avg: Lkup_BanksAvgAggregateOutputType | null
    _sum: Lkup_BanksSumAggregateOutputType | null
    _min: Lkup_BanksMinAggregateOutputType | null
    _max: Lkup_BanksMaxAggregateOutputType | null
  }

  export type Lkup_BanksAvgAggregateOutputType = {
    BankID: number | null
    BankNumber: number | null
    CountryID: number | null
  }

  export type Lkup_BanksSumAggregateOutputType = {
    BankID: number | null
    BankNumber: number | null
    CountryID: number | null
  }

  export type Lkup_BanksMinAggregateOutputType = {
    BankID: number | null
    BankName: string | null
    BankNumber: number | null
    CountryID: number | null
  }

  export type Lkup_BanksMaxAggregateOutputType = {
    BankID: number | null
    BankName: string | null
    BankNumber: number | null
    CountryID: number | null
  }

  export type Lkup_BanksCountAggregateOutputType = {
    BankID: number
    BankName: number
    BankNumber: number
    CountryID: number
    _all: number
  }


  export type Lkup_BanksAvgAggregateInputType = {
    BankID?: true
    BankNumber?: true
    CountryID?: true
  }

  export type Lkup_BanksSumAggregateInputType = {
    BankID?: true
    BankNumber?: true
    CountryID?: true
  }

  export type Lkup_BanksMinAggregateInputType = {
    BankID?: true
    BankName?: true
    BankNumber?: true
    CountryID?: true
  }

  export type Lkup_BanksMaxAggregateInputType = {
    BankID?: true
    BankName?: true
    BankNumber?: true
    CountryID?: true
  }

  export type Lkup_BanksCountAggregateInputType = {
    BankID?: true
    BankName?: true
    BankNumber?: true
    CountryID?: true
    _all?: true
  }

  export type Lkup_BanksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Banks to aggregate.
     */
    where?: Lkup_BanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Banks to fetch.
     */
    orderBy?: Lkup_BanksOrderByWithRelationInput | Lkup_BanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_BanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_Banks
    **/
    _count?: true | Lkup_BanksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_BanksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_BanksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_BanksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_BanksMaxAggregateInputType
  }

  export type GetLkup_BanksAggregateType<T extends Lkup_BanksAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_Banks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_Banks[P]>
      : GetScalarType<T[P], AggregateLkup_Banks[P]>
  }




  export type Lkup_BanksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_BanksWhereInput
    orderBy?: Lkup_BanksOrderByWithAggregationInput | Lkup_BanksOrderByWithAggregationInput[]
    by: Lkup_BanksScalarFieldEnum[] | Lkup_BanksScalarFieldEnum
    having?: Lkup_BanksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_BanksCountAggregateInputType | true
    _avg?: Lkup_BanksAvgAggregateInputType
    _sum?: Lkup_BanksSumAggregateInputType
    _min?: Lkup_BanksMinAggregateInputType
    _max?: Lkup_BanksMaxAggregateInputType
  }

  export type Lkup_BanksGroupByOutputType = {
    BankID: number
    BankName: string
    BankNumber: number
    CountryID: number | null
    _count: Lkup_BanksCountAggregateOutputType | null
    _avg: Lkup_BanksAvgAggregateOutputType | null
    _sum: Lkup_BanksSumAggregateOutputType | null
    _min: Lkup_BanksMinAggregateOutputType | null
    _max: Lkup_BanksMaxAggregateOutputType | null
  }

  type GetLkup_BanksGroupByPayload<T extends Lkup_BanksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_BanksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_BanksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_BanksGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_BanksGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_BanksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BankID?: boolean
    BankName?: boolean
    BankNumber?: boolean
    CountryID?: boolean
  }, ExtArgs["result"]["lkup_Banks"]>


  export type Lkup_BanksSelectScalar = {
    BankID?: boolean
    BankName?: boolean
    BankNumber?: boolean
    CountryID?: boolean
  }


  export type $Lkup_BanksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_Banks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      BankID: number
      BankName: string
      BankNumber: number
      CountryID: number | null
    }, ExtArgs["result"]["lkup_Banks"]>
    composites: {}
  }

  type Lkup_BanksGetPayload<S extends boolean | null | undefined | Lkup_BanksDefaultArgs> = $Result.GetResult<Prisma.$Lkup_BanksPayload, S>

  type Lkup_BanksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_BanksFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_BanksCountAggregateInputType | true
    }

  export interface Lkup_BanksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_Banks'], meta: { name: 'Lkup_Banks' } }
    /**
     * Find zero or one Lkup_Banks that matches the filter.
     * @param {Lkup_BanksFindUniqueArgs} args - Arguments to find a Lkup_Banks
     * @example
     * // Get one Lkup_Banks
     * const lkup_Banks = await prisma.lkup_Banks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_BanksFindUniqueArgs>(args: SelectSubset<T, Lkup_BanksFindUniqueArgs<ExtArgs>>): Prisma__Lkup_BanksClient<$Result.GetResult<Prisma.$Lkup_BanksPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_Banks that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_BanksFindUniqueOrThrowArgs} args - Arguments to find a Lkup_Banks
     * @example
     * // Get one Lkup_Banks
     * const lkup_Banks = await prisma.lkup_Banks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_BanksFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_BanksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_BanksClient<$Result.GetResult<Prisma.$Lkup_BanksPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksFindFirstArgs} args - Arguments to find a Lkup_Banks
     * @example
     * // Get one Lkup_Banks
     * const lkup_Banks = await prisma.lkup_Banks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_BanksFindFirstArgs>(args?: SelectSubset<T, Lkup_BanksFindFirstArgs<ExtArgs>>): Prisma__Lkup_BanksClient<$Result.GetResult<Prisma.$Lkup_BanksPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_Banks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksFindFirstOrThrowArgs} args - Arguments to find a Lkup_Banks
     * @example
     * // Get one Lkup_Banks
     * const lkup_Banks = await prisma.lkup_Banks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_BanksFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_BanksFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_BanksClient<$Result.GetResult<Prisma.$Lkup_BanksPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_Banks
     * const lkup_Banks = await prisma.lkup_Banks.findMany()
     * 
     * // Get first 10 Lkup_Banks
     * const lkup_Banks = await prisma.lkup_Banks.findMany({ take: 10 })
     * 
     * // Only select the `BankID`
     * const lkup_BanksWithBankIDOnly = await prisma.lkup_Banks.findMany({ select: { BankID: true } })
     * 
     */
    findMany<T extends Lkup_BanksFindManyArgs>(args?: SelectSubset<T, Lkup_BanksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_BanksPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_Banks.
     * @param {Lkup_BanksCreateArgs} args - Arguments to create a Lkup_Banks.
     * @example
     * // Create one Lkup_Banks
     * const Lkup_Banks = await prisma.lkup_Banks.create({
     *   data: {
     *     // ... data to create a Lkup_Banks
     *   }
     * })
     * 
     */
    create<T extends Lkup_BanksCreateArgs>(args: SelectSubset<T, Lkup_BanksCreateArgs<ExtArgs>>): Prisma__Lkup_BanksClient<$Result.GetResult<Prisma.$Lkup_BanksPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_Banks.
     * @param {Lkup_BanksCreateManyArgs} args - Arguments to create many Lkup_Banks.
     * @example
     * // Create many Lkup_Banks
     * const lkup_Banks = await prisma.lkup_Banks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_BanksCreateManyArgs>(args?: SelectSubset<T, Lkup_BanksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_Banks.
     * @param {Lkup_BanksDeleteArgs} args - Arguments to delete one Lkup_Banks.
     * @example
     * // Delete one Lkup_Banks
     * const Lkup_Banks = await prisma.lkup_Banks.delete({
     *   where: {
     *     // ... filter to delete one Lkup_Banks
     *   }
     * })
     * 
     */
    delete<T extends Lkup_BanksDeleteArgs>(args: SelectSubset<T, Lkup_BanksDeleteArgs<ExtArgs>>): Prisma__Lkup_BanksClient<$Result.GetResult<Prisma.$Lkup_BanksPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_Banks.
     * @param {Lkup_BanksUpdateArgs} args - Arguments to update one Lkup_Banks.
     * @example
     * // Update one Lkup_Banks
     * const lkup_Banks = await prisma.lkup_Banks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_BanksUpdateArgs>(args: SelectSubset<T, Lkup_BanksUpdateArgs<ExtArgs>>): Prisma__Lkup_BanksClient<$Result.GetResult<Prisma.$Lkup_BanksPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_Banks.
     * @param {Lkup_BanksDeleteManyArgs} args - Arguments to filter Lkup_Banks to delete.
     * @example
     * // Delete a few Lkup_Banks
     * const { count } = await prisma.lkup_Banks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_BanksDeleteManyArgs>(args?: SelectSubset<T, Lkup_BanksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_Banks
     * const lkup_Banks = await prisma.lkup_Banks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_BanksUpdateManyArgs>(args: SelectSubset<T, Lkup_BanksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_Banks.
     * @param {Lkup_BanksUpsertArgs} args - Arguments to update or create a Lkup_Banks.
     * @example
     * // Update or create a Lkup_Banks
     * const lkup_Banks = await prisma.lkup_Banks.upsert({
     *   create: {
     *     // ... data to create a Lkup_Banks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_Banks we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_BanksUpsertArgs>(args: SelectSubset<T, Lkup_BanksUpsertArgs<ExtArgs>>): Prisma__Lkup_BanksClient<$Result.GetResult<Prisma.$Lkup_BanksPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksCountArgs} args - Arguments to filter Lkup_Banks to count.
     * @example
     * // Count the number of Lkup_Banks
     * const count = await prisma.lkup_Banks.count({
     *   where: {
     *     // ... the filter for the Lkup_Banks we want to count
     *   }
     * })
    **/
    count<T extends Lkup_BanksCountArgs>(
      args?: Subset<T, Lkup_BanksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_BanksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_BanksAggregateArgs>(args: Subset<T, Lkup_BanksAggregateArgs>): Prisma.PrismaPromise<GetLkup_BanksAggregateType<T>>

    /**
     * Group by Lkup_Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_BanksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_BanksGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_BanksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_BanksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_BanksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_Banks model
   */
  readonly fields: Lkup_BanksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_Banks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_BanksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_Banks model
   */ 
  interface Lkup_BanksFieldRefs {
    readonly BankID: FieldRef<"Lkup_Banks", 'Int'>
    readonly BankName: FieldRef<"Lkup_Banks", 'String'>
    readonly BankNumber: FieldRef<"Lkup_Banks", 'Int'>
    readonly CountryID: FieldRef<"Lkup_Banks", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_Banks findUnique
   */
  export type Lkup_BanksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Banks
     */
    select?: Lkup_BanksSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Banks to fetch.
     */
    where: Lkup_BanksWhereUniqueInput
  }

  /**
   * Lkup_Banks findUniqueOrThrow
   */
  export type Lkup_BanksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Banks
     */
    select?: Lkup_BanksSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Banks to fetch.
     */
    where: Lkup_BanksWhereUniqueInput
  }

  /**
   * Lkup_Banks findFirst
   */
  export type Lkup_BanksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Banks
     */
    select?: Lkup_BanksSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Banks to fetch.
     */
    where?: Lkup_BanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Banks to fetch.
     */
    orderBy?: Lkup_BanksOrderByWithRelationInput | Lkup_BanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Banks.
     */
    cursor?: Lkup_BanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Banks.
     */
    distinct?: Lkup_BanksScalarFieldEnum | Lkup_BanksScalarFieldEnum[]
  }

  /**
   * Lkup_Banks findFirstOrThrow
   */
  export type Lkup_BanksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Banks
     */
    select?: Lkup_BanksSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Banks to fetch.
     */
    where?: Lkup_BanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Banks to fetch.
     */
    orderBy?: Lkup_BanksOrderByWithRelationInput | Lkup_BanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Banks.
     */
    cursor?: Lkup_BanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Banks.
     */
    distinct?: Lkup_BanksScalarFieldEnum | Lkup_BanksScalarFieldEnum[]
  }

  /**
   * Lkup_Banks findMany
   */
  export type Lkup_BanksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Banks
     */
    select?: Lkup_BanksSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Banks to fetch.
     */
    where?: Lkup_BanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Banks to fetch.
     */
    orderBy?: Lkup_BanksOrderByWithRelationInput | Lkup_BanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_Banks.
     */
    cursor?: Lkup_BanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Banks.
     */
    skip?: number
    distinct?: Lkup_BanksScalarFieldEnum | Lkup_BanksScalarFieldEnum[]
  }

  /**
   * Lkup_Banks create
   */
  export type Lkup_BanksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Banks
     */
    select?: Lkup_BanksSelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_Banks.
     */
    data: XOR<Lkup_BanksCreateInput, Lkup_BanksUncheckedCreateInput>
  }

  /**
   * Lkup_Banks createMany
   */
  export type Lkup_BanksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_Banks.
     */
    data: Lkup_BanksCreateManyInput | Lkup_BanksCreateManyInput[]
  }

  /**
   * Lkup_Banks update
   */
  export type Lkup_BanksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Banks
     */
    select?: Lkup_BanksSelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_Banks.
     */
    data: XOR<Lkup_BanksUpdateInput, Lkup_BanksUncheckedUpdateInput>
    /**
     * Choose, which Lkup_Banks to update.
     */
    where: Lkup_BanksWhereUniqueInput
  }

  /**
   * Lkup_Banks updateMany
   */
  export type Lkup_BanksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_Banks.
     */
    data: XOR<Lkup_BanksUpdateManyMutationInput, Lkup_BanksUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_Banks to update
     */
    where?: Lkup_BanksWhereInput
  }

  /**
   * Lkup_Banks upsert
   */
  export type Lkup_BanksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Banks
     */
    select?: Lkup_BanksSelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_Banks to update in case it exists.
     */
    where: Lkup_BanksWhereUniqueInput
    /**
     * In case the Lkup_Banks found by the `where` argument doesn't exist, create a new Lkup_Banks with this data.
     */
    create: XOR<Lkup_BanksCreateInput, Lkup_BanksUncheckedCreateInput>
    /**
     * In case the Lkup_Banks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_BanksUpdateInput, Lkup_BanksUncheckedUpdateInput>
  }

  /**
   * Lkup_Banks delete
   */
  export type Lkup_BanksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Banks
     */
    select?: Lkup_BanksSelect<ExtArgs> | null
    /**
     * Filter which Lkup_Banks to delete.
     */
    where: Lkup_BanksWhereUniqueInput
  }

  /**
   * Lkup_Banks deleteMany
   */
  export type Lkup_BanksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Banks to delete
     */
    where?: Lkup_BanksWhereInput
  }

  /**
   * Lkup_Banks without action
   */
  export type Lkup_BanksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Banks
     */
    select?: Lkup_BanksSelect<ExtArgs> | null
  }


  /**
   * Model Lkup_BanksVerBranch
   */

  export type AggregateLkup_BanksVerBranch = {
    _count: Lkup_BanksVerBranchCountAggregateOutputType | null
    _avg: Lkup_BanksVerBranchAvgAggregateOutputType | null
    _sum: Lkup_BanksVerBranchSumAggregateOutputType | null
    _min: Lkup_BanksVerBranchMinAggregateOutputType | null
    _max: Lkup_BanksVerBranchMaxAggregateOutputType | null
  }

  export type Lkup_BanksVerBranchAvgAggregateOutputType = {
    BranchID: number | null
    BankID: number | null
  }

  export type Lkup_BanksVerBranchSumAggregateOutputType = {
    BranchID: number | null
    BankID: number | null
  }

  export type Lkup_BanksVerBranchMinAggregateOutputType = {
    BranchID: number | null
    BankID: number | null
    BranchName: string | null
    BranchCode: string | null
    Address: string | null
    SortCode: string | null
    Phone_1: string | null
    Phone_2: string | null
    FaxNumber: string | null
    EMail: string | null
    Comment: string | null
  }

  export type Lkup_BanksVerBranchMaxAggregateOutputType = {
    BranchID: number | null
    BankID: number | null
    BranchName: string | null
    BranchCode: string | null
    Address: string | null
    SortCode: string | null
    Phone_1: string | null
    Phone_2: string | null
    FaxNumber: string | null
    EMail: string | null
    Comment: string | null
  }

  export type Lkup_BanksVerBranchCountAggregateOutputType = {
    BranchID: number
    BankID: number
    BranchName: number
    BranchCode: number
    Address: number
    SortCode: number
    Phone_1: number
    Phone_2: number
    FaxNumber: number
    EMail: number
    Comment: number
    _all: number
  }


  export type Lkup_BanksVerBranchAvgAggregateInputType = {
    BranchID?: true
    BankID?: true
  }

  export type Lkup_BanksVerBranchSumAggregateInputType = {
    BranchID?: true
    BankID?: true
  }

  export type Lkup_BanksVerBranchMinAggregateInputType = {
    BranchID?: true
    BankID?: true
    BranchName?: true
    BranchCode?: true
    Address?: true
    SortCode?: true
    Phone_1?: true
    Phone_2?: true
    FaxNumber?: true
    EMail?: true
    Comment?: true
  }

  export type Lkup_BanksVerBranchMaxAggregateInputType = {
    BranchID?: true
    BankID?: true
    BranchName?: true
    BranchCode?: true
    Address?: true
    SortCode?: true
    Phone_1?: true
    Phone_2?: true
    FaxNumber?: true
    EMail?: true
    Comment?: true
  }

  export type Lkup_BanksVerBranchCountAggregateInputType = {
    BranchID?: true
    BankID?: true
    BranchName?: true
    BranchCode?: true
    Address?: true
    SortCode?: true
    Phone_1?: true
    Phone_2?: true
    FaxNumber?: true
    EMail?: true
    Comment?: true
    _all?: true
  }

  export type Lkup_BanksVerBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_BanksVerBranch to aggregate.
     */
    where?: Lkup_BanksVerBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_BanksVerBranches to fetch.
     */
    orderBy?: Lkup_BanksVerBranchOrderByWithRelationInput | Lkup_BanksVerBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_BanksVerBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_BanksVerBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_BanksVerBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_BanksVerBranches
    **/
    _count?: true | Lkup_BanksVerBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_BanksVerBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_BanksVerBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_BanksVerBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_BanksVerBranchMaxAggregateInputType
  }

  export type GetLkup_BanksVerBranchAggregateType<T extends Lkup_BanksVerBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_BanksVerBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_BanksVerBranch[P]>
      : GetScalarType<T[P], AggregateLkup_BanksVerBranch[P]>
  }




  export type Lkup_BanksVerBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_BanksVerBranchWhereInput
    orderBy?: Lkup_BanksVerBranchOrderByWithAggregationInput | Lkup_BanksVerBranchOrderByWithAggregationInput[]
    by: Lkup_BanksVerBranchScalarFieldEnum[] | Lkup_BanksVerBranchScalarFieldEnum
    having?: Lkup_BanksVerBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_BanksVerBranchCountAggregateInputType | true
    _avg?: Lkup_BanksVerBranchAvgAggregateInputType
    _sum?: Lkup_BanksVerBranchSumAggregateInputType
    _min?: Lkup_BanksVerBranchMinAggregateInputType
    _max?: Lkup_BanksVerBranchMaxAggregateInputType
  }

  export type Lkup_BanksVerBranchGroupByOutputType = {
    BranchID: number
    BankID: number | null
    BranchName: string | null
    BranchCode: string | null
    Address: string | null
    SortCode: string | null
    Phone_1: string | null
    Phone_2: string | null
    FaxNumber: string | null
    EMail: string | null
    Comment: string | null
    _count: Lkup_BanksVerBranchCountAggregateOutputType | null
    _avg: Lkup_BanksVerBranchAvgAggregateOutputType | null
    _sum: Lkup_BanksVerBranchSumAggregateOutputType | null
    _min: Lkup_BanksVerBranchMinAggregateOutputType | null
    _max: Lkup_BanksVerBranchMaxAggregateOutputType | null
  }

  type GetLkup_BanksVerBranchGroupByPayload<T extends Lkup_BanksVerBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_BanksVerBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_BanksVerBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_BanksVerBranchGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_BanksVerBranchGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_BanksVerBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BranchID?: boolean
    BankID?: boolean
    BranchName?: boolean
    BranchCode?: boolean
    Address?: boolean
    SortCode?: boolean
    Phone_1?: boolean
    Phone_2?: boolean
    FaxNumber?: boolean
    EMail?: boolean
    Comment?: boolean
  }, ExtArgs["result"]["lkup_BanksVerBranch"]>


  export type Lkup_BanksVerBranchSelectScalar = {
    BranchID?: boolean
    BankID?: boolean
    BranchName?: boolean
    BranchCode?: boolean
    Address?: boolean
    SortCode?: boolean
    Phone_1?: boolean
    Phone_2?: boolean
    FaxNumber?: boolean
    EMail?: boolean
    Comment?: boolean
  }


  export type $Lkup_BanksVerBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_BanksVerBranch"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      BranchID: number
      BankID: number | null
      BranchName: string | null
      BranchCode: string | null
      Address: string | null
      SortCode: string | null
      Phone_1: string | null
      Phone_2: string | null
      FaxNumber: string | null
      EMail: string | null
      Comment: string | null
    }, ExtArgs["result"]["lkup_BanksVerBranch"]>
    composites: {}
  }

  type Lkup_BanksVerBranchGetPayload<S extends boolean | null | undefined | Lkup_BanksVerBranchDefaultArgs> = $Result.GetResult<Prisma.$Lkup_BanksVerBranchPayload, S>

  type Lkup_BanksVerBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_BanksVerBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_BanksVerBranchCountAggregateInputType | true
    }

  export interface Lkup_BanksVerBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_BanksVerBranch'], meta: { name: 'Lkup_BanksVerBranch' } }
    /**
     * Find zero or one Lkup_BanksVerBranch that matches the filter.
     * @param {Lkup_BanksVerBranchFindUniqueArgs} args - Arguments to find a Lkup_BanksVerBranch
     * @example
     * // Get one Lkup_BanksVerBranch
     * const lkup_BanksVerBranch = await prisma.lkup_BanksVerBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_BanksVerBranchFindUniqueArgs>(args: SelectSubset<T, Lkup_BanksVerBranchFindUniqueArgs<ExtArgs>>): Prisma__Lkup_BanksVerBranchClient<$Result.GetResult<Prisma.$Lkup_BanksVerBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_BanksVerBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_BanksVerBranchFindUniqueOrThrowArgs} args - Arguments to find a Lkup_BanksVerBranch
     * @example
     * // Get one Lkup_BanksVerBranch
     * const lkup_BanksVerBranch = await prisma.lkup_BanksVerBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_BanksVerBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_BanksVerBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_BanksVerBranchClient<$Result.GetResult<Prisma.$Lkup_BanksVerBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_BanksVerBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksVerBranchFindFirstArgs} args - Arguments to find a Lkup_BanksVerBranch
     * @example
     * // Get one Lkup_BanksVerBranch
     * const lkup_BanksVerBranch = await prisma.lkup_BanksVerBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_BanksVerBranchFindFirstArgs>(args?: SelectSubset<T, Lkup_BanksVerBranchFindFirstArgs<ExtArgs>>): Prisma__Lkup_BanksVerBranchClient<$Result.GetResult<Prisma.$Lkup_BanksVerBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_BanksVerBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksVerBranchFindFirstOrThrowArgs} args - Arguments to find a Lkup_BanksVerBranch
     * @example
     * // Get one Lkup_BanksVerBranch
     * const lkup_BanksVerBranch = await prisma.lkup_BanksVerBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_BanksVerBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_BanksVerBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_BanksVerBranchClient<$Result.GetResult<Prisma.$Lkup_BanksVerBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_BanksVerBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksVerBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_BanksVerBranches
     * const lkup_BanksVerBranches = await prisma.lkup_BanksVerBranch.findMany()
     * 
     * // Get first 10 Lkup_BanksVerBranches
     * const lkup_BanksVerBranches = await prisma.lkup_BanksVerBranch.findMany({ take: 10 })
     * 
     * // Only select the `BranchID`
     * const lkup_BanksVerBranchWithBranchIDOnly = await prisma.lkup_BanksVerBranch.findMany({ select: { BranchID: true } })
     * 
     */
    findMany<T extends Lkup_BanksVerBranchFindManyArgs>(args?: SelectSubset<T, Lkup_BanksVerBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_BanksVerBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_BanksVerBranch.
     * @param {Lkup_BanksVerBranchCreateArgs} args - Arguments to create a Lkup_BanksVerBranch.
     * @example
     * // Create one Lkup_BanksVerBranch
     * const Lkup_BanksVerBranch = await prisma.lkup_BanksVerBranch.create({
     *   data: {
     *     // ... data to create a Lkup_BanksVerBranch
     *   }
     * })
     * 
     */
    create<T extends Lkup_BanksVerBranchCreateArgs>(args: SelectSubset<T, Lkup_BanksVerBranchCreateArgs<ExtArgs>>): Prisma__Lkup_BanksVerBranchClient<$Result.GetResult<Prisma.$Lkup_BanksVerBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_BanksVerBranches.
     * @param {Lkup_BanksVerBranchCreateManyArgs} args - Arguments to create many Lkup_BanksVerBranches.
     * @example
     * // Create many Lkup_BanksVerBranches
     * const lkup_BanksVerBranch = await prisma.lkup_BanksVerBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_BanksVerBranchCreateManyArgs>(args?: SelectSubset<T, Lkup_BanksVerBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_BanksVerBranch.
     * @param {Lkup_BanksVerBranchDeleteArgs} args - Arguments to delete one Lkup_BanksVerBranch.
     * @example
     * // Delete one Lkup_BanksVerBranch
     * const Lkup_BanksVerBranch = await prisma.lkup_BanksVerBranch.delete({
     *   where: {
     *     // ... filter to delete one Lkup_BanksVerBranch
     *   }
     * })
     * 
     */
    delete<T extends Lkup_BanksVerBranchDeleteArgs>(args: SelectSubset<T, Lkup_BanksVerBranchDeleteArgs<ExtArgs>>): Prisma__Lkup_BanksVerBranchClient<$Result.GetResult<Prisma.$Lkup_BanksVerBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_BanksVerBranch.
     * @param {Lkup_BanksVerBranchUpdateArgs} args - Arguments to update one Lkup_BanksVerBranch.
     * @example
     * // Update one Lkup_BanksVerBranch
     * const lkup_BanksVerBranch = await prisma.lkup_BanksVerBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_BanksVerBranchUpdateArgs>(args: SelectSubset<T, Lkup_BanksVerBranchUpdateArgs<ExtArgs>>): Prisma__Lkup_BanksVerBranchClient<$Result.GetResult<Prisma.$Lkup_BanksVerBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_BanksVerBranches.
     * @param {Lkup_BanksVerBranchDeleteManyArgs} args - Arguments to filter Lkup_BanksVerBranches to delete.
     * @example
     * // Delete a few Lkup_BanksVerBranches
     * const { count } = await prisma.lkup_BanksVerBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_BanksVerBranchDeleteManyArgs>(args?: SelectSubset<T, Lkup_BanksVerBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_BanksVerBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksVerBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_BanksVerBranches
     * const lkup_BanksVerBranch = await prisma.lkup_BanksVerBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_BanksVerBranchUpdateManyArgs>(args: SelectSubset<T, Lkup_BanksVerBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_BanksVerBranch.
     * @param {Lkup_BanksVerBranchUpsertArgs} args - Arguments to update or create a Lkup_BanksVerBranch.
     * @example
     * // Update or create a Lkup_BanksVerBranch
     * const lkup_BanksVerBranch = await prisma.lkup_BanksVerBranch.upsert({
     *   create: {
     *     // ... data to create a Lkup_BanksVerBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_BanksVerBranch we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_BanksVerBranchUpsertArgs>(args: SelectSubset<T, Lkup_BanksVerBranchUpsertArgs<ExtArgs>>): Prisma__Lkup_BanksVerBranchClient<$Result.GetResult<Prisma.$Lkup_BanksVerBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_BanksVerBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksVerBranchCountArgs} args - Arguments to filter Lkup_BanksVerBranches to count.
     * @example
     * // Count the number of Lkup_BanksVerBranches
     * const count = await prisma.lkup_BanksVerBranch.count({
     *   where: {
     *     // ... the filter for the Lkup_BanksVerBranches we want to count
     *   }
     * })
    **/
    count<T extends Lkup_BanksVerBranchCountArgs>(
      args?: Subset<T, Lkup_BanksVerBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_BanksVerBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_BanksVerBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksVerBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_BanksVerBranchAggregateArgs>(args: Subset<T, Lkup_BanksVerBranchAggregateArgs>): Prisma.PrismaPromise<GetLkup_BanksVerBranchAggregateType<T>>

    /**
     * Group by Lkup_BanksVerBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_BanksVerBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_BanksVerBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_BanksVerBranchGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_BanksVerBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_BanksVerBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_BanksVerBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_BanksVerBranch model
   */
  readonly fields: Lkup_BanksVerBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_BanksVerBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_BanksVerBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_BanksVerBranch model
   */ 
  interface Lkup_BanksVerBranchFieldRefs {
    readonly BranchID: FieldRef<"Lkup_BanksVerBranch", 'Int'>
    readonly BankID: FieldRef<"Lkup_BanksVerBranch", 'Int'>
    readonly BranchName: FieldRef<"Lkup_BanksVerBranch", 'String'>
    readonly BranchCode: FieldRef<"Lkup_BanksVerBranch", 'String'>
    readonly Address: FieldRef<"Lkup_BanksVerBranch", 'String'>
    readonly SortCode: FieldRef<"Lkup_BanksVerBranch", 'String'>
    readonly Phone_1: FieldRef<"Lkup_BanksVerBranch", 'String'>
    readonly Phone_2: FieldRef<"Lkup_BanksVerBranch", 'String'>
    readonly FaxNumber: FieldRef<"Lkup_BanksVerBranch", 'String'>
    readonly EMail: FieldRef<"Lkup_BanksVerBranch", 'String'>
    readonly Comment: FieldRef<"Lkup_BanksVerBranch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_BanksVerBranch findUnique
   */
  export type Lkup_BanksVerBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_BanksVerBranch
     */
    select?: Lkup_BanksVerBranchSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_BanksVerBranch to fetch.
     */
    where: Lkup_BanksVerBranchWhereUniqueInput
  }

  /**
   * Lkup_BanksVerBranch findUniqueOrThrow
   */
  export type Lkup_BanksVerBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_BanksVerBranch
     */
    select?: Lkup_BanksVerBranchSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_BanksVerBranch to fetch.
     */
    where: Lkup_BanksVerBranchWhereUniqueInput
  }

  /**
   * Lkup_BanksVerBranch findFirst
   */
  export type Lkup_BanksVerBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_BanksVerBranch
     */
    select?: Lkup_BanksVerBranchSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_BanksVerBranch to fetch.
     */
    where?: Lkup_BanksVerBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_BanksVerBranches to fetch.
     */
    orderBy?: Lkup_BanksVerBranchOrderByWithRelationInput | Lkup_BanksVerBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_BanksVerBranches.
     */
    cursor?: Lkup_BanksVerBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_BanksVerBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_BanksVerBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_BanksVerBranches.
     */
    distinct?: Lkup_BanksVerBranchScalarFieldEnum | Lkup_BanksVerBranchScalarFieldEnum[]
  }

  /**
   * Lkup_BanksVerBranch findFirstOrThrow
   */
  export type Lkup_BanksVerBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_BanksVerBranch
     */
    select?: Lkup_BanksVerBranchSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_BanksVerBranch to fetch.
     */
    where?: Lkup_BanksVerBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_BanksVerBranches to fetch.
     */
    orderBy?: Lkup_BanksVerBranchOrderByWithRelationInput | Lkup_BanksVerBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_BanksVerBranches.
     */
    cursor?: Lkup_BanksVerBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_BanksVerBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_BanksVerBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_BanksVerBranches.
     */
    distinct?: Lkup_BanksVerBranchScalarFieldEnum | Lkup_BanksVerBranchScalarFieldEnum[]
  }

  /**
   * Lkup_BanksVerBranch findMany
   */
  export type Lkup_BanksVerBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_BanksVerBranch
     */
    select?: Lkup_BanksVerBranchSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_BanksVerBranches to fetch.
     */
    where?: Lkup_BanksVerBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_BanksVerBranches to fetch.
     */
    orderBy?: Lkup_BanksVerBranchOrderByWithRelationInput | Lkup_BanksVerBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_BanksVerBranches.
     */
    cursor?: Lkup_BanksVerBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_BanksVerBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_BanksVerBranches.
     */
    skip?: number
    distinct?: Lkup_BanksVerBranchScalarFieldEnum | Lkup_BanksVerBranchScalarFieldEnum[]
  }

  /**
   * Lkup_BanksVerBranch create
   */
  export type Lkup_BanksVerBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_BanksVerBranch
     */
    select?: Lkup_BanksVerBranchSelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_BanksVerBranch.
     */
    data?: XOR<Lkup_BanksVerBranchCreateInput, Lkup_BanksVerBranchUncheckedCreateInput>
  }

  /**
   * Lkup_BanksVerBranch createMany
   */
  export type Lkup_BanksVerBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_BanksVerBranches.
     */
    data: Lkup_BanksVerBranchCreateManyInput | Lkup_BanksVerBranchCreateManyInput[]
  }

  /**
   * Lkup_BanksVerBranch update
   */
  export type Lkup_BanksVerBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_BanksVerBranch
     */
    select?: Lkup_BanksVerBranchSelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_BanksVerBranch.
     */
    data: XOR<Lkup_BanksVerBranchUpdateInput, Lkup_BanksVerBranchUncheckedUpdateInput>
    /**
     * Choose, which Lkup_BanksVerBranch to update.
     */
    where: Lkup_BanksVerBranchWhereUniqueInput
  }

  /**
   * Lkup_BanksVerBranch updateMany
   */
  export type Lkup_BanksVerBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_BanksVerBranches.
     */
    data: XOR<Lkup_BanksVerBranchUpdateManyMutationInput, Lkup_BanksVerBranchUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_BanksVerBranches to update
     */
    where?: Lkup_BanksVerBranchWhereInput
  }

  /**
   * Lkup_BanksVerBranch upsert
   */
  export type Lkup_BanksVerBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_BanksVerBranch
     */
    select?: Lkup_BanksVerBranchSelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_BanksVerBranch to update in case it exists.
     */
    where: Lkup_BanksVerBranchWhereUniqueInput
    /**
     * In case the Lkup_BanksVerBranch found by the `where` argument doesn't exist, create a new Lkup_BanksVerBranch with this data.
     */
    create: XOR<Lkup_BanksVerBranchCreateInput, Lkup_BanksVerBranchUncheckedCreateInput>
    /**
     * In case the Lkup_BanksVerBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_BanksVerBranchUpdateInput, Lkup_BanksVerBranchUncheckedUpdateInput>
  }

  /**
   * Lkup_BanksVerBranch delete
   */
  export type Lkup_BanksVerBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_BanksVerBranch
     */
    select?: Lkup_BanksVerBranchSelect<ExtArgs> | null
    /**
     * Filter which Lkup_BanksVerBranch to delete.
     */
    where: Lkup_BanksVerBranchWhereUniqueInput
  }

  /**
   * Lkup_BanksVerBranch deleteMany
   */
  export type Lkup_BanksVerBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_BanksVerBranches to delete
     */
    where?: Lkup_BanksVerBranchWhereInput
  }

  /**
   * Lkup_BanksVerBranch without action
   */
  export type Lkup_BanksVerBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_BanksVerBranch
     */
    select?: Lkup_BanksVerBranchSelect<ExtArgs> | null
  }


  /**
   * Model Lkup_City
   */

  export type AggregateLkup_City = {
    _count: Lkup_CityCountAggregateOutputType | null
    _avg: Lkup_CityAvgAggregateOutputType | null
    _sum: Lkup_CitySumAggregateOutputType | null
    _min: Lkup_CityMinAggregateOutputType | null
    _max: Lkup_CityMaxAggregateOutputType | null
  }

  export type Lkup_CityAvgAggregateOutputType = {
    CityID: number | null
    CityCode: number | null
  }

  export type Lkup_CitySumAggregateOutputType = {
    CityID: number | null
    CityCode: number | null
  }

  export type Lkup_CityMinAggregateOutputType = {
    CityID: number | null
    CityCode: number | null
    CityName: string | null
    CityNameEng: string | null
  }

  export type Lkup_CityMaxAggregateOutputType = {
    CityID: number | null
    CityCode: number | null
    CityName: string | null
    CityNameEng: string | null
  }

  export type Lkup_CityCountAggregateOutputType = {
    CityID: number
    CityCode: number
    CityName: number
    CityNameEng: number
    _all: number
  }


  export type Lkup_CityAvgAggregateInputType = {
    CityID?: true
    CityCode?: true
  }

  export type Lkup_CitySumAggregateInputType = {
    CityID?: true
    CityCode?: true
  }

  export type Lkup_CityMinAggregateInputType = {
    CityID?: true
    CityCode?: true
    CityName?: true
    CityNameEng?: true
  }

  export type Lkup_CityMaxAggregateInputType = {
    CityID?: true
    CityCode?: true
    CityName?: true
    CityNameEng?: true
  }

  export type Lkup_CityCountAggregateInputType = {
    CityID?: true
    CityCode?: true
    CityName?: true
    CityNameEng?: true
    _all?: true
  }

  export type Lkup_CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_City to aggregate.
     */
    where?: Lkup_CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Cities to fetch.
     */
    orderBy?: Lkup_CityOrderByWithRelationInput | Lkup_CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_Cities
    **/
    _count?: true | Lkup_CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_CityMaxAggregateInputType
  }

  export type GetLkup_CityAggregateType<T extends Lkup_CityAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_City]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_City[P]>
      : GetScalarType<T[P], AggregateLkup_City[P]>
  }




  export type Lkup_CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_CityWhereInput
    orderBy?: Lkup_CityOrderByWithAggregationInput | Lkup_CityOrderByWithAggregationInput[]
    by: Lkup_CityScalarFieldEnum[] | Lkup_CityScalarFieldEnum
    having?: Lkup_CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_CityCountAggregateInputType | true
    _avg?: Lkup_CityAvgAggregateInputType
    _sum?: Lkup_CitySumAggregateInputType
    _min?: Lkup_CityMinAggregateInputType
    _max?: Lkup_CityMaxAggregateInputType
  }

  export type Lkup_CityGroupByOutputType = {
    CityID: number
    CityCode: number
    CityName: string
    CityNameEng: string
    _count: Lkup_CityCountAggregateOutputType | null
    _avg: Lkup_CityAvgAggregateOutputType | null
    _sum: Lkup_CitySumAggregateOutputType | null
    _min: Lkup_CityMinAggregateOutputType | null
    _max: Lkup_CityMaxAggregateOutputType | null
  }

  type GetLkup_CityGroupByPayload<T extends Lkup_CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_CityGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_CityGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CityID?: boolean
    CityCode?: boolean
    CityName?: boolean
    CityNameEng?: boolean
  }, ExtArgs["result"]["lkup_City"]>


  export type Lkup_CitySelectScalar = {
    CityID?: boolean
    CityCode?: boolean
    CityName?: boolean
    CityNameEng?: boolean
  }


  export type $Lkup_CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_City"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CityID: number
      CityCode: number
      CityName: string
      CityNameEng: string
    }, ExtArgs["result"]["lkup_City"]>
    composites: {}
  }

  type Lkup_CityGetPayload<S extends boolean | null | undefined | Lkup_CityDefaultArgs> = $Result.GetResult<Prisma.$Lkup_CityPayload, S>

  type Lkup_CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_CityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_CityCountAggregateInputType | true
    }

  export interface Lkup_CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_City'], meta: { name: 'Lkup_City' } }
    /**
     * Find zero or one Lkup_City that matches the filter.
     * @param {Lkup_CityFindUniqueArgs} args - Arguments to find a Lkup_City
     * @example
     * // Get one Lkup_City
     * const lkup_City = await prisma.lkup_City.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_CityFindUniqueArgs>(args: SelectSubset<T, Lkup_CityFindUniqueArgs<ExtArgs>>): Prisma__Lkup_CityClient<$Result.GetResult<Prisma.$Lkup_CityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_City that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_CityFindUniqueOrThrowArgs} args - Arguments to find a Lkup_City
     * @example
     * // Get one Lkup_City
     * const lkup_City = await prisma.lkup_City.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_CityFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_CityClient<$Result.GetResult<Prisma.$Lkup_CityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CityFindFirstArgs} args - Arguments to find a Lkup_City
     * @example
     * // Get one Lkup_City
     * const lkup_City = await prisma.lkup_City.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_CityFindFirstArgs>(args?: SelectSubset<T, Lkup_CityFindFirstArgs<ExtArgs>>): Prisma__Lkup_CityClient<$Result.GetResult<Prisma.$Lkup_CityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CityFindFirstOrThrowArgs} args - Arguments to find a Lkup_City
     * @example
     * // Get one Lkup_City
     * const lkup_City = await prisma.lkup_City.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_CityFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_CityClient<$Result.GetResult<Prisma.$Lkup_CityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_Cities
     * const lkup_Cities = await prisma.lkup_City.findMany()
     * 
     * // Get first 10 Lkup_Cities
     * const lkup_Cities = await prisma.lkup_City.findMany({ take: 10 })
     * 
     * // Only select the `CityID`
     * const lkup_CityWithCityIDOnly = await prisma.lkup_City.findMany({ select: { CityID: true } })
     * 
     */
    findMany<T extends Lkup_CityFindManyArgs>(args?: SelectSubset<T, Lkup_CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_CityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_City.
     * @param {Lkup_CityCreateArgs} args - Arguments to create a Lkup_City.
     * @example
     * // Create one Lkup_City
     * const Lkup_City = await prisma.lkup_City.create({
     *   data: {
     *     // ... data to create a Lkup_City
     *   }
     * })
     * 
     */
    create<T extends Lkup_CityCreateArgs>(args: SelectSubset<T, Lkup_CityCreateArgs<ExtArgs>>): Prisma__Lkup_CityClient<$Result.GetResult<Prisma.$Lkup_CityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_Cities.
     * @param {Lkup_CityCreateManyArgs} args - Arguments to create many Lkup_Cities.
     * @example
     * // Create many Lkup_Cities
     * const lkup_City = await prisma.lkup_City.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_CityCreateManyArgs>(args?: SelectSubset<T, Lkup_CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_City.
     * @param {Lkup_CityDeleteArgs} args - Arguments to delete one Lkup_City.
     * @example
     * // Delete one Lkup_City
     * const Lkup_City = await prisma.lkup_City.delete({
     *   where: {
     *     // ... filter to delete one Lkup_City
     *   }
     * })
     * 
     */
    delete<T extends Lkup_CityDeleteArgs>(args: SelectSubset<T, Lkup_CityDeleteArgs<ExtArgs>>): Prisma__Lkup_CityClient<$Result.GetResult<Prisma.$Lkup_CityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_City.
     * @param {Lkup_CityUpdateArgs} args - Arguments to update one Lkup_City.
     * @example
     * // Update one Lkup_City
     * const lkup_City = await prisma.lkup_City.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_CityUpdateArgs>(args: SelectSubset<T, Lkup_CityUpdateArgs<ExtArgs>>): Prisma__Lkup_CityClient<$Result.GetResult<Prisma.$Lkup_CityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_Cities.
     * @param {Lkup_CityDeleteManyArgs} args - Arguments to filter Lkup_Cities to delete.
     * @example
     * // Delete a few Lkup_Cities
     * const { count } = await prisma.lkup_City.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_CityDeleteManyArgs>(args?: SelectSubset<T, Lkup_CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_Cities
     * const lkup_City = await prisma.lkup_City.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_CityUpdateManyArgs>(args: SelectSubset<T, Lkup_CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_City.
     * @param {Lkup_CityUpsertArgs} args - Arguments to update or create a Lkup_City.
     * @example
     * // Update or create a Lkup_City
     * const lkup_City = await prisma.lkup_City.upsert({
     *   create: {
     *     // ... data to create a Lkup_City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_City we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_CityUpsertArgs>(args: SelectSubset<T, Lkup_CityUpsertArgs<ExtArgs>>): Prisma__Lkup_CityClient<$Result.GetResult<Prisma.$Lkup_CityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CityCountArgs} args - Arguments to filter Lkup_Cities to count.
     * @example
     * // Count the number of Lkup_Cities
     * const count = await prisma.lkup_City.count({
     *   where: {
     *     // ... the filter for the Lkup_Cities we want to count
     *   }
     * })
    **/
    count<T extends Lkup_CityCountArgs>(
      args?: Subset<T, Lkup_CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_CityAggregateArgs>(args: Subset<T, Lkup_CityAggregateArgs>): Prisma.PrismaPromise<GetLkup_CityAggregateType<T>>

    /**
     * Group by Lkup_City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_CityGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_CityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_City model
   */
  readonly fields: Lkup_CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_City model
   */ 
  interface Lkup_CityFieldRefs {
    readonly CityID: FieldRef<"Lkup_City", 'Int'>
    readonly CityCode: FieldRef<"Lkup_City", 'Int'>
    readonly CityName: FieldRef<"Lkup_City", 'String'>
    readonly CityNameEng: FieldRef<"Lkup_City", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_City findUnique
   */
  export type Lkup_CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_City
     */
    select?: Lkup_CitySelect<ExtArgs> | null
    /**
     * Filter, which Lkup_City to fetch.
     */
    where: Lkup_CityWhereUniqueInput
  }

  /**
   * Lkup_City findUniqueOrThrow
   */
  export type Lkup_CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_City
     */
    select?: Lkup_CitySelect<ExtArgs> | null
    /**
     * Filter, which Lkup_City to fetch.
     */
    where: Lkup_CityWhereUniqueInput
  }

  /**
   * Lkup_City findFirst
   */
  export type Lkup_CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_City
     */
    select?: Lkup_CitySelect<ExtArgs> | null
    /**
     * Filter, which Lkup_City to fetch.
     */
    where?: Lkup_CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Cities to fetch.
     */
    orderBy?: Lkup_CityOrderByWithRelationInput | Lkup_CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Cities.
     */
    cursor?: Lkup_CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Cities.
     */
    distinct?: Lkup_CityScalarFieldEnum | Lkup_CityScalarFieldEnum[]
  }

  /**
   * Lkup_City findFirstOrThrow
   */
  export type Lkup_CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_City
     */
    select?: Lkup_CitySelect<ExtArgs> | null
    /**
     * Filter, which Lkup_City to fetch.
     */
    where?: Lkup_CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Cities to fetch.
     */
    orderBy?: Lkup_CityOrderByWithRelationInput | Lkup_CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Cities.
     */
    cursor?: Lkup_CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Cities.
     */
    distinct?: Lkup_CityScalarFieldEnum | Lkup_CityScalarFieldEnum[]
  }

  /**
   * Lkup_City findMany
   */
  export type Lkup_CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_City
     */
    select?: Lkup_CitySelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Cities to fetch.
     */
    where?: Lkup_CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Cities to fetch.
     */
    orderBy?: Lkup_CityOrderByWithRelationInput | Lkup_CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_Cities.
     */
    cursor?: Lkup_CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Cities.
     */
    skip?: number
    distinct?: Lkup_CityScalarFieldEnum | Lkup_CityScalarFieldEnum[]
  }

  /**
   * Lkup_City create
   */
  export type Lkup_CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_City
     */
    select?: Lkup_CitySelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_City.
     */
    data: XOR<Lkup_CityCreateInput, Lkup_CityUncheckedCreateInput>
  }

  /**
   * Lkup_City createMany
   */
  export type Lkup_CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_Cities.
     */
    data: Lkup_CityCreateManyInput | Lkup_CityCreateManyInput[]
  }

  /**
   * Lkup_City update
   */
  export type Lkup_CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_City
     */
    select?: Lkup_CitySelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_City.
     */
    data: XOR<Lkup_CityUpdateInput, Lkup_CityUncheckedUpdateInput>
    /**
     * Choose, which Lkup_City to update.
     */
    where: Lkup_CityWhereUniqueInput
  }

  /**
   * Lkup_City updateMany
   */
  export type Lkup_CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_Cities.
     */
    data: XOR<Lkup_CityUpdateManyMutationInput, Lkup_CityUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_Cities to update
     */
    where?: Lkup_CityWhereInput
  }

  /**
   * Lkup_City upsert
   */
  export type Lkup_CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_City
     */
    select?: Lkup_CitySelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_City to update in case it exists.
     */
    where: Lkup_CityWhereUniqueInput
    /**
     * In case the Lkup_City found by the `where` argument doesn't exist, create a new Lkup_City with this data.
     */
    create: XOR<Lkup_CityCreateInput, Lkup_CityUncheckedCreateInput>
    /**
     * In case the Lkup_City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_CityUpdateInput, Lkup_CityUncheckedUpdateInput>
  }

  /**
   * Lkup_City delete
   */
  export type Lkup_CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_City
     */
    select?: Lkup_CitySelect<ExtArgs> | null
    /**
     * Filter which Lkup_City to delete.
     */
    where: Lkup_CityWhereUniqueInput
  }

  /**
   * Lkup_City deleteMany
   */
  export type Lkup_CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Cities to delete
     */
    where?: Lkup_CityWhereInput
  }

  /**
   * Lkup_City without action
   */
  export type Lkup_CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_City
     */
    select?: Lkup_CitySelect<ExtArgs> | null
  }


  /**
   * Model Lkup_Corporation
   */

  export type AggregateLkup_Corporation = {
    _count: Lkup_CorporationCountAggregateOutputType | null
    _avg: Lkup_CorporationAvgAggregateOutputType | null
    _sum: Lkup_CorporationSumAggregateOutputType | null
    _min: Lkup_CorporationMinAggregateOutputType | null
    _max: Lkup_CorporationMaxAggregateOutputType | null
  }

  export type Lkup_CorporationAvgAggregateOutputType = {
    CorporationID: number | null
    IsActive: number | null
    CorporationNumber: number | null
  }

  export type Lkup_CorporationSumAggregateOutputType = {
    CorporationID: number | null
    IsActive: number | null
    CorporationNumber: number | null
  }

  export type Lkup_CorporationMinAggregateOutputType = {
    CorporationID: number | null
    CorporationName: string | null
    IsActive: number | null
    CorporationNumber: number | null
    Address: string | null
    Email: string | null
    Phone: string | null
    Cfo_email: string | null
    Contact_name: string | null
    Contact_phone: string | null
    Ops_email: string | null
    SoftTalkTaxToken: string | null
    CorporationAutoLink: string | null
  }

  export type Lkup_CorporationMaxAggregateOutputType = {
    CorporationID: number | null
    CorporationName: string | null
    IsActive: number | null
    CorporationNumber: number | null
    Address: string | null
    Email: string | null
    Phone: string | null
    Cfo_email: string | null
    Contact_name: string | null
    Contact_phone: string | null
    Ops_email: string | null
    SoftTalkTaxToken: string | null
    CorporationAutoLink: string | null
  }

  export type Lkup_CorporationCountAggregateOutputType = {
    CorporationID: number
    CorporationName: number
    IsActive: number
    CorporationNumber: number
    Address: number
    Email: number
    Phone: number
    Cfo_email: number
    Contact_name: number
    Contact_phone: number
    Ops_email: number
    SoftTalkTaxToken: number
    CorporationAutoLink: number
    _all: number
  }


  export type Lkup_CorporationAvgAggregateInputType = {
    CorporationID?: true
    IsActive?: true
    CorporationNumber?: true
  }

  export type Lkup_CorporationSumAggregateInputType = {
    CorporationID?: true
    IsActive?: true
    CorporationNumber?: true
  }

  export type Lkup_CorporationMinAggregateInputType = {
    CorporationID?: true
    CorporationName?: true
    IsActive?: true
    CorporationNumber?: true
    Address?: true
    Email?: true
    Phone?: true
    Cfo_email?: true
    Contact_name?: true
    Contact_phone?: true
    Ops_email?: true
    SoftTalkTaxToken?: true
    CorporationAutoLink?: true
  }

  export type Lkup_CorporationMaxAggregateInputType = {
    CorporationID?: true
    CorporationName?: true
    IsActive?: true
    CorporationNumber?: true
    Address?: true
    Email?: true
    Phone?: true
    Cfo_email?: true
    Contact_name?: true
    Contact_phone?: true
    Ops_email?: true
    SoftTalkTaxToken?: true
    CorporationAutoLink?: true
  }

  export type Lkup_CorporationCountAggregateInputType = {
    CorporationID?: true
    CorporationName?: true
    IsActive?: true
    CorporationNumber?: true
    Address?: true
    Email?: true
    Phone?: true
    Cfo_email?: true
    Contact_name?: true
    Contact_phone?: true
    Ops_email?: true
    SoftTalkTaxToken?: true
    CorporationAutoLink?: true
    _all?: true
  }

  export type Lkup_CorporationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Corporation to aggregate.
     */
    where?: Lkup_CorporationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Corporations to fetch.
     */
    orderBy?: Lkup_CorporationOrderByWithRelationInput | Lkup_CorporationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_CorporationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Corporations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Corporations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_Corporations
    **/
    _count?: true | Lkup_CorporationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_CorporationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_CorporationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_CorporationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_CorporationMaxAggregateInputType
  }

  export type GetLkup_CorporationAggregateType<T extends Lkup_CorporationAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_Corporation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_Corporation[P]>
      : GetScalarType<T[P], AggregateLkup_Corporation[P]>
  }




  export type Lkup_CorporationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_CorporationWhereInput
    orderBy?: Lkup_CorporationOrderByWithAggregationInput | Lkup_CorporationOrderByWithAggregationInput[]
    by: Lkup_CorporationScalarFieldEnum[] | Lkup_CorporationScalarFieldEnum
    having?: Lkup_CorporationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_CorporationCountAggregateInputType | true
    _avg?: Lkup_CorporationAvgAggregateInputType
    _sum?: Lkup_CorporationSumAggregateInputType
    _min?: Lkup_CorporationMinAggregateInputType
    _max?: Lkup_CorporationMaxAggregateInputType
  }

  export type Lkup_CorporationGroupByOutputType = {
    CorporationID: number
    CorporationName: string
    IsActive: number
    CorporationNumber: number
    Address: string | null
    Email: string | null
    Phone: string | null
    Cfo_email: string | null
    Contact_name: string | null
    Contact_phone: string | null
    Ops_email: string | null
    SoftTalkTaxToken: string | null
    CorporationAutoLink: string | null
    _count: Lkup_CorporationCountAggregateOutputType | null
    _avg: Lkup_CorporationAvgAggregateOutputType | null
    _sum: Lkup_CorporationSumAggregateOutputType | null
    _min: Lkup_CorporationMinAggregateOutputType | null
    _max: Lkup_CorporationMaxAggregateOutputType | null
  }

  type GetLkup_CorporationGroupByPayload<T extends Lkup_CorporationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_CorporationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_CorporationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_CorporationGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_CorporationGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_CorporationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CorporationID?: boolean
    CorporationName?: boolean
    IsActive?: boolean
    CorporationNumber?: boolean
    Address?: boolean
    Email?: boolean
    Phone?: boolean
    Cfo_email?: boolean
    Contact_name?: boolean
    Contact_phone?: boolean
    Ops_email?: boolean
    SoftTalkTaxToken?: boolean
    CorporationAutoLink?: boolean
  }, ExtArgs["result"]["lkup_Corporation"]>


  export type Lkup_CorporationSelectScalar = {
    CorporationID?: boolean
    CorporationName?: boolean
    IsActive?: boolean
    CorporationNumber?: boolean
    Address?: boolean
    Email?: boolean
    Phone?: boolean
    Cfo_email?: boolean
    Contact_name?: boolean
    Contact_phone?: boolean
    Ops_email?: boolean
    SoftTalkTaxToken?: boolean
    CorporationAutoLink?: boolean
  }


  export type $Lkup_CorporationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_Corporation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CorporationID: number
      CorporationName: string
      IsActive: number
      CorporationNumber: number
      Address: string | null
      Email: string | null
      Phone: string | null
      Cfo_email: string | null
      Contact_name: string | null
      Contact_phone: string | null
      Ops_email: string | null
      SoftTalkTaxToken: string | null
      CorporationAutoLink: string | null
    }, ExtArgs["result"]["lkup_Corporation"]>
    composites: {}
  }

  type Lkup_CorporationGetPayload<S extends boolean | null | undefined | Lkup_CorporationDefaultArgs> = $Result.GetResult<Prisma.$Lkup_CorporationPayload, S>

  type Lkup_CorporationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_CorporationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_CorporationCountAggregateInputType | true
    }

  export interface Lkup_CorporationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_Corporation'], meta: { name: 'Lkup_Corporation' } }
    /**
     * Find zero or one Lkup_Corporation that matches the filter.
     * @param {Lkup_CorporationFindUniqueArgs} args - Arguments to find a Lkup_Corporation
     * @example
     * // Get one Lkup_Corporation
     * const lkup_Corporation = await prisma.lkup_Corporation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_CorporationFindUniqueArgs>(args: SelectSubset<T, Lkup_CorporationFindUniqueArgs<ExtArgs>>): Prisma__Lkup_CorporationClient<$Result.GetResult<Prisma.$Lkup_CorporationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_Corporation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_CorporationFindUniqueOrThrowArgs} args - Arguments to find a Lkup_Corporation
     * @example
     * // Get one Lkup_Corporation
     * const lkup_Corporation = await prisma.lkup_Corporation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_CorporationFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_CorporationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_CorporationClient<$Result.GetResult<Prisma.$Lkup_CorporationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_Corporation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CorporationFindFirstArgs} args - Arguments to find a Lkup_Corporation
     * @example
     * // Get one Lkup_Corporation
     * const lkup_Corporation = await prisma.lkup_Corporation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_CorporationFindFirstArgs>(args?: SelectSubset<T, Lkup_CorporationFindFirstArgs<ExtArgs>>): Prisma__Lkup_CorporationClient<$Result.GetResult<Prisma.$Lkup_CorporationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_Corporation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CorporationFindFirstOrThrowArgs} args - Arguments to find a Lkup_Corporation
     * @example
     * // Get one Lkup_Corporation
     * const lkup_Corporation = await prisma.lkup_Corporation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_CorporationFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_CorporationFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_CorporationClient<$Result.GetResult<Prisma.$Lkup_CorporationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_Corporations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CorporationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_Corporations
     * const lkup_Corporations = await prisma.lkup_Corporation.findMany()
     * 
     * // Get first 10 Lkup_Corporations
     * const lkup_Corporations = await prisma.lkup_Corporation.findMany({ take: 10 })
     * 
     * // Only select the `CorporationID`
     * const lkup_CorporationWithCorporationIDOnly = await prisma.lkup_Corporation.findMany({ select: { CorporationID: true } })
     * 
     */
    findMany<T extends Lkup_CorporationFindManyArgs>(args?: SelectSubset<T, Lkup_CorporationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_CorporationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_Corporation.
     * @param {Lkup_CorporationCreateArgs} args - Arguments to create a Lkup_Corporation.
     * @example
     * // Create one Lkup_Corporation
     * const Lkup_Corporation = await prisma.lkup_Corporation.create({
     *   data: {
     *     // ... data to create a Lkup_Corporation
     *   }
     * })
     * 
     */
    create<T extends Lkup_CorporationCreateArgs>(args: SelectSubset<T, Lkup_CorporationCreateArgs<ExtArgs>>): Prisma__Lkup_CorporationClient<$Result.GetResult<Prisma.$Lkup_CorporationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_Corporations.
     * @param {Lkup_CorporationCreateManyArgs} args - Arguments to create many Lkup_Corporations.
     * @example
     * // Create many Lkup_Corporations
     * const lkup_Corporation = await prisma.lkup_Corporation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_CorporationCreateManyArgs>(args?: SelectSubset<T, Lkup_CorporationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_Corporation.
     * @param {Lkup_CorporationDeleteArgs} args - Arguments to delete one Lkup_Corporation.
     * @example
     * // Delete one Lkup_Corporation
     * const Lkup_Corporation = await prisma.lkup_Corporation.delete({
     *   where: {
     *     // ... filter to delete one Lkup_Corporation
     *   }
     * })
     * 
     */
    delete<T extends Lkup_CorporationDeleteArgs>(args: SelectSubset<T, Lkup_CorporationDeleteArgs<ExtArgs>>): Prisma__Lkup_CorporationClient<$Result.GetResult<Prisma.$Lkup_CorporationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_Corporation.
     * @param {Lkup_CorporationUpdateArgs} args - Arguments to update one Lkup_Corporation.
     * @example
     * // Update one Lkup_Corporation
     * const lkup_Corporation = await prisma.lkup_Corporation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_CorporationUpdateArgs>(args: SelectSubset<T, Lkup_CorporationUpdateArgs<ExtArgs>>): Prisma__Lkup_CorporationClient<$Result.GetResult<Prisma.$Lkup_CorporationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_Corporations.
     * @param {Lkup_CorporationDeleteManyArgs} args - Arguments to filter Lkup_Corporations to delete.
     * @example
     * // Delete a few Lkup_Corporations
     * const { count } = await prisma.lkup_Corporation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_CorporationDeleteManyArgs>(args?: SelectSubset<T, Lkup_CorporationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_Corporations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CorporationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_Corporations
     * const lkup_Corporation = await prisma.lkup_Corporation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_CorporationUpdateManyArgs>(args: SelectSubset<T, Lkup_CorporationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_Corporation.
     * @param {Lkup_CorporationUpsertArgs} args - Arguments to update or create a Lkup_Corporation.
     * @example
     * // Update or create a Lkup_Corporation
     * const lkup_Corporation = await prisma.lkup_Corporation.upsert({
     *   create: {
     *     // ... data to create a Lkup_Corporation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_Corporation we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_CorporationUpsertArgs>(args: SelectSubset<T, Lkup_CorporationUpsertArgs<ExtArgs>>): Prisma__Lkup_CorporationClient<$Result.GetResult<Prisma.$Lkup_CorporationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_Corporations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CorporationCountArgs} args - Arguments to filter Lkup_Corporations to count.
     * @example
     * // Count the number of Lkup_Corporations
     * const count = await prisma.lkup_Corporation.count({
     *   where: {
     *     // ... the filter for the Lkup_Corporations we want to count
     *   }
     * })
    **/
    count<T extends Lkup_CorporationCountArgs>(
      args?: Subset<T, Lkup_CorporationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_CorporationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_Corporation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CorporationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_CorporationAggregateArgs>(args: Subset<T, Lkup_CorporationAggregateArgs>): Prisma.PrismaPromise<GetLkup_CorporationAggregateType<T>>

    /**
     * Group by Lkup_Corporation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CorporationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_CorporationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_CorporationGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_CorporationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_CorporationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_CorporationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_Corporation model
   */
  readonly fields: Lkup_CorporationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_Corporation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_CorporationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_Corporation model
   */ 
  interface Lkup_CorporationFieldRefs {
    readonly CorporationID: FieldRef<"Lkup_Corporation", 'Int'>
    readonly CorporationName: FieldRef<"Lkup_Corporation", 'String'>
    readonly IsActive: FieldRef<"Lkup_Corporation", 'Int'>
    readonly CorporationNumber: FieldRef<"Lkup_Corporation", 'Int'>
    readonly Address: FieldRef<"Lkup_Corporation", 'String'>
    readonly Email: FieldRef<"Lkup_Corporation", 'String'>
    readonly Phone: FieldRef<"Lkup_Corporation", 'String'>
    readonly Cfo_email: FieldRef<"Lkup_Corporation", 'String'>
    readonly Contact_name: FieldRef<"Lkup_Corporation", 'String'>
    readonly Contact_phone: FieldRef<"Lkup_Corporation", 'String'>
    readonly Ops_email: FieldRef<"Lkup_Corporation", 'String'>
    readonly SoftTalkTaxToken: FieldRef<"Lkup_Corporation", 'String'>
    readonly CorporationAutoLink: FieldRef<"Lkup_Corporation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_Corporation findUnique
   */
  export type Lkup_CorporationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Corporation
     */
    select?: Lkup_CorporationSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Corporation to fetch.
     */
    where: Lkup_CorporationWhereUniqueInput
  }

  /**
   * Lkup_Corporation findUniqueOrThrow
   */
  export type Lkup_CorporationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Corporation
     */
    select?: Lkup_CorporationSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Corporation to fetch.
     */
    where: Lkup_CorporationWhereUniqueInput
  }

  /**
   * Lkup_Corporation findFirst
   */
  export type Lkup_CorporationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Corporation
     */
    select?: Lkup_CorporationSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Corporation to fetch.
     */
    where?: Lkup_CorporationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Corporations to fetch.
     */
    orderBy?: Lkup_CorporationOrderByWithRelationInput | Lkup_CorporationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Corporations.
     */
    cursor?: Lkup_CorporationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Corporations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Corporations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Corporations.
     */
    distinct?: Lkup_CorporationScalarFieldEnum | Lkup_CorporationScalarFieldEnum[]
  }

  /**
   * Lkup_Corporation findFirstOrThrow
   */
  export type Lkup_CorporationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Corporation
     */
    select?: Lkup_CorporationSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Corporation to fetch.
     */
    where?: Lkup_CorporationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Corporations to fetch.
     */
    orderBy?: Lkup_CorporationOrderByWithRelationInput | Lkup_CorporationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Corporations.
     */
    cursor?: Lkup_CorporationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Corporations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Corporations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Corporations.
     */
    distinct?: Lkup_CorporationScalarFieldEnum | Lkup_CorporationScalarFieldEnum[]
  }

  /**
   * Lkup_Corporation findMany
   */
  export type Lkup_CorporationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Corporation
     */
    select?: Lkup_CorporationSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Corporations to fetch.
     */
    where?: Lkup_CorporationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Corporations to fetch.
     */
    orderBy?: Lkup_CorporationOrderByWithRelationInput | Lkup_CorporationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_Corporations.
     */
    cursor?: Lkup_CorporationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Corporations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Corporations.
     */
    skip?: number
    distinct?: Lkup_CorporationScalarFieldEnum | Lkup_CorporationScalarFieldEnum[]
  }

  /**
   * Lkup_Corporation create
   */
  export type Lkup_CorporationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Corporation
     */
    select?: Lkup_CorporationSelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_Corporation.
     */
    data: XOR<Lkup_CorporationCreateInput, Lkup_CorporationUncheckedCreateInput>
  }

  /**
   * Lkup_Corporation createMany
   */
  export type Lkup_CorporationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_Corporations.
     */
    data: Lkup_CorporationCreateManyInput | Lkup_CorporationCreateManyInput[]
  }

  /**
   * Lkup_Corporation update
   */
  export type Lkup_CorporationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Corporation
     */
    select?: Lkup_CorporationSelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_Corporation.
     */
    data: XOR<Lkup_CorporationUpdateInput, Lkup_CorporationUncheckedUpdateInput>
    /**
     * Choose, which Lkup_Corporation to update.
     */
    where: Lkup_CorporationWhereUniqueInput
  }

  /**
   * Lkup_Corporation updateMany
   */
  export type Lkup_CorporationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_Corporations.
     */
    data: XOR<Lkup_CorporationUpdateManyMutationInput, Lkup_CorporationUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_Corporations to update
     */
    where?: Lkup_CorporationWhereInput
  }

  /**
   * Lkup_Corporation upsert
   */
  export type Lkup_CorporationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Corporation
     */
    select?: Lkup_CorporationSelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_Corporation to update in case it exists.
     */
    where: Lkup_CorporationWhereUniqueInput
    /**
     * In case the Lkup_Corporation found by the `where` argument doesn't exist, create a new Lkup_Corporation with this data.
     */
    create: XOR<Lkup_CorporationCreateInput, Lkup_CorporationUncheckedCreateInput>
    /**
     * In case the Lkup_Corporation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_CorporationUpdateInput, Lkup_CorporationUncheckedUpdateInput>
  }

  /**
   * Lkup_Corporation delete
   */
  export type Lkup_CorporationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Corporation
     */
    select?: Lkup_CorporationSelect<ExtArgs> | null
    /**
     * Filter which Lkup_Corporation to delete.
     */
    where: Lkup_CorporationWhereUniqueInput
  }

  /**
   * Lkup_Corporation deleteMany
   */
  export type Lkup_CorporationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Corporations to delete
     */
    where?: Lkup_CorporationWhereInput
  }

  /**
   * Lkup_Corporation without action
   */
  export type Lkup_CorporationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Corporation
     */
    select?: Lkup_CorporationSelect<ExtArgs> | null
  }


  /**
   * Model Lkup_Country
   */

  export type AggregateLkup_Country = {
    _count: Lkup_CountryCountAggregateOutputType | null
    _avg: Lkup_CountryAvgAggregateOutputType | null
    _sum: Lkup_CountrySumAggregateOutputType | null
    _min: Lkup_CountryMinAggregateOutputType | null
    _max: Lkup_CountryMaxAggregateOutputType | null
  }

  export type Lkup_CountryAvgAggregateOutputType = {
    CountryID: number | null
    MultipleSelect: number | null
  }

  export type Lkup_CountrySumAggregateOutputType = {
    CountryID: number | null
    MultipleSelect: number | null
  }

  export type Lkup_CountryMinAggregateOutputType = {
    CountryID: number | null
    CountryCode: string | null
    CountryName: string | null
    CountryNameEnglish: string | null
    MultipleSelect: number | null
  }

  export type Lkup_CountryMaxAggregateOutputType = {
    CountryID: number | null
    CountryCode: string | null
    CountryName: string | null
    CountryNameEnglish: string | null
    MultipleSelect: number | null
  }

  export type Lkup_CountryCountAggregateOutputType = {
    CountryID: number
    CountryCode: number
    CountryName: number
    CountryNameEnglish: number
    MultipleSelect: number
    _all: number
  }


  export type Lkup_CountryAvgAggregateInputType = {
    CountryID?: true
    MultipleSelect?: true
  }

  export type Lkup_CountrySumAggregateInputType = {
    CountryID?: true
    MultipleSelect?: true
  }

  export type Lkup_CountryMinAggregateInputType = {
    CountryID?: true
    CountryCode?: true
    CountryName?: true
    CountryNameEnglish?: true
    MultipleSelect?: true
  }

  export type Lkup_CountryMaxAggregateInputType = {
    CountryID?: true
    CountryCode?: true
    CountryName?: true
    CountryNameEnglish?: true
    MultipleSelect?: true
  }

  export type Lkup_CountryCountAggregateInputType = {
    CountryID?: true
    CountryCode?: true
    CountryName?: true
    CountryNameEnglish?: true
    MultipleSelect?: true
    _all?: true
  }

  export type Lkup_CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Country to aggregate.
     */
    where?: Lkup_CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Countries to fetch.
     */
    orderBy?: Lkup_CountryOrderByWithRelationInput | Lkup_CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_Countries
    **/
    _count?: true | Lkup_CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_CountryMaxAggregateInputType
  }

  export type GetLkup_CountryAggregateType<T extends Lkup_CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_Country]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_Country[P]>
      : GetScalarType<T[P], AggregateLkup_Country[P]>
  }




  export type Lkup_CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_CountryWhereInput
    orderBy?: Lkup_CountryOrderByWithAggregationInput | Lkup_CountryOrderByWithAggregationInput[]
    by: Lkup_CountryScalarFieldEnum[] | Lkup_CountryScalarFieldEnum
    having?: Lkup_CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_CountryCountAggregateInputType | true
    _avg?: Lkup_CountryAvgAggregateInputType
    _sum?: Lkup_CountrySumAggregateInputType
    _min?: Lkup_CountryMinAggregateInputType
    _max?: Lkup_CountryMaxAggregateInputType
  }

  export type Lkup_CountryGroupByOutputType = {
    CountryID: number
    CountryCode: string
    CountryName: string
    CountryNameEnglish: string | null
    MultipleSelect: number
    _count: Lkup_CountryCountAggregateOutputType | null
    _avg: Lkup_CountryAvgAggregateOutputType | null
    _sum: Lkup_CountrySumAggregateOutputType | null
    _min: Lkup_CountryMinAggregateOutputType | null
    _max: Lkup_CountryMaxAggregateOutputType | null
  }

  type GetLkup_CountryGroupByPayload<T extends Lkup_CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_CountryGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_CountryGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CountryID?: boolean
    CountryCode?: boolean
    CountryName?: boolean
    CountryNameEnglish?: boolean
    MultipleSelect?: boolean
  }, ExtArgs["result"]["lkup_Country"]>


  export type Lkup_CountrySelectScalar = {
    CountryID?: boolean
    CountryCode?: boolean
    CountryName?: boolean
    CountryNameEnglish?: boolean
    MultipleSelect?: boolean
  }


  export type $Lkup_CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_Country"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CountryID: number
      CountryCode: string
      CountryName: string
      CountryNameEnglish: string | null
      MultipleSelect: number
    }, ExtArgs["result"]["lkup_Country"]>
    composites: {}
  }

  type Lkup_CountryGetPayload<S extends boolean | null | undefined | Lkup_CountryDefaultArgs> = $Result.GetResult<Prisma.$Lkup_CountryPayload, S>

  type Lkup_CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_CountryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_CountryCountAggregateInputType | true
    }

  export interface Lkup_CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_Country'], meta: { name: 'Lkup_Country' } }
    /**
     * Find zero or one Lkup_Country that matches the filter.
     * @param {Lkup_CountryFindUniqueArgs} args - Arguments to find a Lkup_Country
     * @example
     * // Get one Lkup_Country
     * const lkup_Country = await prisma.lkup_Country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_CountryFindUniqueArgs>(args: SelectSubset<T, Lkup_CountryFindUniqueArgs<ExtArgs>>): Prisma__Lkup_CountryClient<$Result.GetResult<Prisma.$Lkup_CountryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_Country that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_CountryFindUniqueOrThrowArgs} args - Arguments to find a Lkup_Country
     * @example
     * // Get one Lkup_Country
     * const lkup_Country = await prisma.lkup_Country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_CountryClient<$Result.GetResult<Prisma.$Lkup_CountryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CountryFindFirstArgs} args - Arguments to find a Lkup_Country
     * @example
     * // Get one Lkup_Country
     * const lkup_Country = await prisma.lkup_Country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_CountryFindFirstArgs>(args?: SelectSubset<T, Lkup_CountryFindFirstArgs<ExtArgs>>): Prisma__Lkup_CountryClient<$Result.GetResult<Prisma.$Lkup_CountryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CountryFindFirstOrThrowArgs} args - Arguments to find a Lkup_Country
     * @example
     * // Get one Lkup_Country
     * const lkup_Country = await prisma.lkup_Country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_CountryClient<$Result.GetResult<Prisma.$Lkup_CountryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_Countries
     * const lkup_Countries = await prisma.lkup_Country.findMany()
     * 
     * // Get first 10 Lkup_Countries
     * const lkup_Countries = await prisma.lkup_Country.findMany({ take: 10 })
     * 
     * // Only select the `CountryID`
     * const lkup_CountryWithCountryIDOnly = await prisma.lkup_Country.findMany({ select: { CountryID: true } })
     * 
     */
    findMany<T extends Lkup_CountryFindManyArgs>(args?: SelectSubset<T, Lkup_CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_CountryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_Country.
     * @param {Lkup_CountryCreateArgs} args - Arguments to create a Lkup_Country.
     * @example
     * // Create one Lkup_Country
     * const Lkup_Country = await prisma.lkup_Country.create({
     *   data: {
     *     // ... data to create a Lkup_Country
     *   }
     * })
     * 
     */
    create<T extends Lkup_CountryCreateArgs>(args: SelectSubset<T, Lkup_CountryCreateArgs<ExtArgs>>): Prisma__Lkup_CountryClient<$Result.GetResult<Prisma.$Lkup_CountryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_Countries.
     * @param {Lkup_CountryCreateManyArgs} args - Arguments to create many Lkup_Countries.
     * @example
     * // Create many Lkup_Countries
     * const lkup_Country = await prisma.lkup_Country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_CountryCreateManyArgs>(args?: SelectSubset<T, Lkup_CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_Country.
     * @param {Lkup_CountryDeleteArgs} args - Arguments to delete one Lkup_Country.
     * @example
     * // Delete one Lkup_Country
     * const Lkup_Country = await prisma.lkup_Country.delete({
     *   where: {
     *     // ... filter to delete one Lkup_Country
     *   }
     * })
     * 
     */
    delete<T extends Lkup_CountryDeleteArgs>(args: SelectSubset<T, Lkup_CountryDeleteArgs<ExtArgs>>): Prisma__Lkup_CountryClient<$Result.GetResult<Prisma.$Lkup_CountryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_Country.
     * @param {Lkup_CountryUpdateArgs} args - Arguments to update one Lkup_Country.
     * @example
     * // Update one Lkup_Country
     * const lkup_Country = await prisma.lkup_Country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_CountryUpdateArgs>(args: SelectSubset<T, Lkup_CountryUpdateArgs<ExtArgs>>): Prisma__Lkup_CountryClient<$Result.GetResult<Prisma.$Lkup_CountryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_Countries.
     * @param {Lkup_CountryDeleteManyArgs} args - Arguments to filter Lkup_Countries to delete.
     * @example
     * // Delete a few Lkup_Countries
     * const { count } = await prisma.lkup_Country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_CountryDeleteManyArgs>(args?: SelectSubset<T, Lkup_CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_Countries
     * const lkup_Country = await prisma.lkup_Country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_CountryUpdateManyArgs>(args: SelectSubset<T, Lkup_CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_Country.
     * @param {Lkup_CountryUpsertArgs} args - Arguments to update or create a Lkup_Country.
     * @example
     * // Update or create a Lkup_Country
     * const lkup_Country = await prisma.lkup_Country.upsert({
     *   create: {
     *     // ... data to create a Lkup_Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_Country we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_CountryUpsertArgs>(args: SelectSubset<T, Lkup_CountryUpsertArgs<ExtArgs>>): Prisma__Lkup_CountryClient<$Result.GetResult<Prisma.$Lkup_CountryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CountryCountArgs} args - Arguments to filter Lkup_Countries to count.
     * @example
     * // Count the number of Lkup_Countries
     * const count = await prisma.lkup_Country.count({
     *   where: {
     *     // ... the filter for the Lkup_Countries we want to count
     *   }
     * })
    **/
    count<T extends Lkup_CountryCountArgs>(
      args?: Subset<T, Lkup_CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_CountryAggregateArgs>(args: Subset<T, Lkup_CountryAggregateArgs>): Prisma.PrismaPromise<GetLkup_CountryAggregateType<T>>

    /**
     * Group by Lkup_Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_CountryGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_CountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_Country model
   */
  readonly fields: Lkup_CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_Country model
   */ 
  interface Lkup_CountryFieldRefs {
    readonly CountryID: FieldRef<"Lkup_Country", 'Int'>
    readonly CountryCode: FieldRef<"Lkup_Country", 'String'>
    readonly CountryName: FieldRef<"Lkup_Country", 'String'>
    readonly CountryNameEnglish: FieldRef<"Lkup_Country", 'String'>
    readonly MultipleSelect: FieldRef<"Lkup_Country", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_Country findUnique
   */
  export type Lkup_CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Country
     */
    select?: Lkup_CountrySelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Country to fetch.
     */
    where: Lkup_CountryWhereUniqueInput
  }

  /**
   * Lkup_Country findUniqueOrThrow
   */
  export type Lkup_CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Country
     */
    select?: Lkup_CountrySelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Country to fetch.
     */
    where: Lkup_CountryWhereUniqueInput
  }

  /**
   * Lkup_Country findFirst
   */
  export type Lkup_CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Country
     */
    select?: Lkup_CountrySelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Country to fetch.
     */
    where?: Lkup_CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Countries to fetch.
     */
    orderBy?: Lkup_CountryOrderByWithRelationInput | Lkup_CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Countries.
     */
    cursor?: Lkup_CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Countries.
     */
    distinct?: Lkup_CountryScalarFieldEnum | Lkup_CountryScalarFieldEnum[]
  }

  /**
   * Lkup_Country findFirstOrThrow
   */
  export type Lkup_CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Country
     */
    select?: Lkup_CountrySelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Country to fetch.
     */
    where?: Lkup_CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Countries to fetch.
     */
    orderBy?: Lkup_CountryOrderByWithRelationInput | Lkup_CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Countries.
     */
    cursor?: Lkup_CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Countries.
     */
    distinct?: Lkup_CountryScalarFieldEnum | Lkup_CountryScalarFieldEnum[]
  }

  /**
   * Lkup_Country findMany
   */
  export type Lkup_CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Country
     */
    select?: Lkup_CountrySelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Countries to fetch.
     */
    where?: Lkup_CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Countries to fetch.
     */
    orderBy?: Lkup_CountryOrderByWithRelationInput | Lkup_CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_Countries.
     */
    cursor?: Lkup_CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Countries.
     */
    skip?: number
    distinct?: Lkup_CountryScalarFieldEnum | Lkup_CountryScalarFieldEnum[]
  }

  /**
   * Lkup_Country create
   */
  export type Lkup_CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Country
     */
    select?: Lkup_CountrySelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_Country.
     */
    data: XOR<Lkup_CountryCreateInput, Lkup_CountryUncheckedCreateInput>
  }

  /**
   * Lkup_Country createMany
   */
  export type Lkup_CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_Countries.
     */
    data: Lkup_CountryCreateManyInput | Lkup_CountryCreateManyInput[]
  }

  /**
   * Lkup_Country update
   */
  export type Lkup_CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Country
     */
    select?: Lkup_CountrySelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_Country.
     */
    data: XOR<Lkup_CountryUpdateInput, Lkup_CountryUncheckedUpdateInput>
    /**
     * Choose, which Lkup_Country to update.
     */
    where: Lkup_CountryWhereUniqueInput
  }

  /**
   * Lkup_Country updateMany
   */
  export type Lkup_CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_Countries.
     */
    data: XOR<Lkup_CountryUpdateManyMutationInput, Lkup_CountryUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_Countries to update
     */
    where?: Lkup_CountryWhereInput
  }

  /**
   * Lkup_Country upsert
   */
  export type Lkup_CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Country
     */
    select?: Lkup_CountrySelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_Country to update in case it exists.
     */
    where: Lkup_CountryWhereUniqueInput
    /**
     * In case the Lkup_Country found by the `where` argument doesn't exist, create a new Lkup_Country with this data.
     */
    create: XOR<Lkup_CountryCreateInput, Lkup_CountryUncheckedCreateInput>
    /**
     * In case the Lkup_Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_CountryUpdateInput, Lkup_CountryUncheckedUpdateInput>
  }

  /**
   * Lkup_Country delete
   */
  export type Lkup_CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Country
     */
    select?: Lkup_CountrySelect<ExtArgs> | null
    /**
     * Filter which Lkup_Country to delete.
     */
    where: Lkup_CountryWhereUniqueInput
  }

  /**
   * Lkup_Country deleteMany
   */
  export type Lkup_CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Countries to delete
     */
    where?: Lkup_CountryWhereInput
  }

  /**
   * Lkup_Country without action
   */
  export type Lkup_CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Country
     */
    select?: Lkup_CountrySelect<ExtArgs> | null
  }


  /**
   * Model Lkup_CreaditCard
   */

  export type AggregateLkup_CreaditCard = {
    _count: Lkup_CreaditCardCountAggregateOutputType | null
    _avg: Lkup_CreaditCardAvgAggregateOutputType | null
    _sum: Lkup_CreaditCardSumAggregateOutputType | null
    _min: Lkup_CreaditCardMinAggregateOutputType | null
    _max: Lkup_CreaditCardMaxAggregateOutputType | null
  }

  export type Lkup_CreaditCardAvgAggregateOutputType = {
    CardID: number | null
    CardCode: number | null
  }

  export type Lkup_CreaditCardSumAggregateOutputType = {
    CardID: number | null
    CardCode: number | null
  }

  export type Lkup_CreaditCardMinAggregateOutputType = {
    CardID: number | null
    CardName: string | null
    CardCode: number | null
  }

  export type Lkup_CreaditCardMaxAggregateOutputType = {
    CardID: number | null
    CardName: string | null
    CardCode: number | null
  }

  export type Lkup_CreaditCardCountAggregateOutputType = {
    CardID: number
    CardName: number
    CardCode: number
    _all: number
  }


  export type Lkup_CreaditCardAvgAggregateInputType = {
    CardID?: true
    CardCode?: true
  }

  export type Lkup_CreaditCardSumAggregateInputType = {
    CardID?: true
    CardCode?: true
  }

  export type Lkup_CreaditCardMinAggregateInputType = {
    CardID?: true
    CardName?: true
    CardCode?: true
  }

  export type Lkup_CreaditCardMaxAggregateInputType = {
    CardID?: true
    CardName?: true
    CardCode?: true
  }

  export type Lkup_CreaditCardCountAggregateInputType = {
    CardID?: true
    CardName?: true
    CardCode?: true
    _all?: true
  }

  export type Lkup_CreaditCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_CreaditCard to aggregate.
     */
    where?: Lkup_CreaditCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_CreaditCards to fetch.
     */
    orderBy?: Lkup_CreaditCardOrderByWithRelationInput | Lkup_CreaditCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_CreaditCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_CreaditCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_CreaditCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_CreaditCards
    **/
    _count?: true | Lkup_CreaditCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_CreaditCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_CreaditCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_CreaditCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_CreaditCardMaxAggregateInputType
  }

  export type GetLkup_CreaditCardAggregateType<T extends Lkup_CreaditCardAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_CreaditCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_CreaditCard[P]>
      : GetScalarType<T[P], AggregateLkup_CreaditCard[P]>
  }




  export type Lkup_CreaditCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_CreaditCardWhereInput
    orderBy?: Lkup_CreaditCardOrderByWithAggregationInput | Lkup_CreaditCardOrderByWithAggregationInput[]
    by: Lkup_CreaditCardScalarFieldEnum[] | Lkup_CreaditCardScalarFieldEnum
    having?: Lkup_CreaditCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_CreaditCardCountAggregateInputType | true
    _avg?: Lkup_CreaditCardAvgAggregateInputType
    _sum?: Lkup_CreaditCardSumAggregateInputType
    _min?: Lkup_CreaditCardMinAggregateInputType
    _max?: Lkup_CreaditCardMaxAggregateInputType
  }

  export type Lkup_CreaditCardGroupByOutputType = {
    CardID: number
    CardName: string
    CardCode: number
    _count: Lkup_CreaditCardCountAggregateOutputType | null
    _avg: Lkup_CreaditCardAvgAggregateOutputType | null
    _sum: Lkup_CreaditCardSumAggregateOutputType | null
    _min: Lkup_CreaditCardMinAggregateOutputType | null
    _max: Lkup_CreaditCardMaxAggregateOutputType | null
  }

  type GetLkup_CreaditCardGroupByPayload<T extends Lkup_CreaditCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_CreaditCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_CreaditCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_CreaditCardGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_CreaditCardGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_CreaditCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CardID?: boolean
    CardName?: boolean
    CardCode?: boolean
  }, ExtArgs["result"]["lkup_CreaditCard"]>


  export type Lkup_CreaditCardSelectScalar = {
    CardID?: boolean
    CardName?: boolean
    CardCode?: boolean
  }


  export type $Lkup_CreaditCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_CreaditCard"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CardID: number
      CardName: string
      CardCode: number
    }, ExtArgs["result"]["lkup_CreaditCard"]>
    composites: {}
  }

  type Lkup_CreaditCardGetPayload<S extends boolean | null | undefined | Lkup_CreaditCardDefaultArgs> = $Result.GetResult<Prisma.$Lkup_CreaditCardPayload, S>

  type Lkup_CreaditCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_CreaditCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_CreaditCardCountAggregateInputType | true
    }

  export interface Lkup_CreaditCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_CreaditCard'], meta: { name: 'Lkup_CreaditCard' } }
    /**
     * Find zero or one Lkup_CreaditCard that matches the filter.
     * @param {Lkup_CreaditCardFindUniqueArgs} args - Arguments to find a Lkup_CreaditCard
     * @example
     * // Get one Lkup_CreaditCard
     * const lkup_CreaditCard = await prisma.lkup_CreaditCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_CreaditCardFindUniqueArgs>(args: SelectSubset<T, Lkup_CreaditCardFindUniqueArgs<ExtArgs>>): Prisma__Lkup_CreaditCardClient<$Result.GetResult<Prisma.$Lkup_CreaditCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_CreaditCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_CreaditCardFindUniqueOrThrowArgs} args - Arguments to find a Lkup_CreaditCard
     * @example
     * // Get one Lkup_CreaditCard
     * const lkup_CreaditCard = await prisma.lkup_CreaditCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_CreaditCardFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_CreaditCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_CreaditCardClient<$Result.GetResult<Prisma.$Lkup_CreaditCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_CreaditCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CreaditCardFindFirstArgs} args - Arguments to find a Lkup_CreaditCard
     * @example
     * // Get one Lkup_CreaditCard
     * const lkup_CreaditCard = await prisma.lkup_CreaditCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_CreaditCardFindFirstArgs>(args?: SelectSubset<T, Lkup_CreaditCardFindFirstArgs<ExtArgs>>): Prisma__Lkup_CreaditCardClient<$Result.GetResult<Prisma.$Lkup_CreaditCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_CreaditCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CreaditCardFindFirstOrThrowArgs} args - Arguments to find a Lkup_CreaditCard
     * @example
     * // Get one Lkup_CreaditCard
     * const lkup_CreaditCard = await prisma.lkup_CreaditCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_CreaditCardFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_CreaditCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_CreaditCardClient<$Result.GetResult<Prisma.$Lkup_CreaditCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_CreaditCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CreaditCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_CreaditCards
     * const lkup_CreaditCards = await prisma.lkup_CreaditCard.findMany()
     * 
     * // Get first 10 Lkup_CreaditCards
     * const lkup_CreaditCards = await prisma.lkup_CreaditCard.findMany({ take: 10 })
     * 
     * // Only select the `CardID`
     * const lkup_CreaditCardWithCardIDOnly = await prisma.lkup_CreaditCard.findMany({ select: { CardID: true } })
     * 
     */
    findMany<T extends Lkup_CreaditCardFindManyArgs>(args?: SelectSubset<T, Lkup_CreaditCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_CreaditCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_CreaditCard.
     * @param {Lkup_CreaditCardCreateArgs} args - Arguments to create a Lkup_CreaditCard.
     * @example
     * // Create one Lkup_CreaditCard
     * const Lkup_CreaditCard = await prisma.lkup_CreaditCard.create({
     *   data: {
     *     // ... data to create a Lkup_CreaditCard
     *   }
     * })
     * 
     */
    create<T extends Lkup_CreaditCardCreateArgs>(args: SelectSubset<T, Lkup_CreaditCardCreateArgs<ExtArgs>>): Prisma__Lkup_CreaditCardClient<$Result.GetResult<Prisma.$Lkup_CreaditCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_CreaditCards.
     * @param {Lkup_CreaditCardCreateManyArgs} args - Arguments to create many Lkup_CreaditCards.
     * @example
     * // Create many Lkup_CreaditCards
     * const lkup_CreaditCard = await prisma.lkup_CreaditCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_CreaditCardCreateManyArgs>(args?: SelectSubset<T, Lkup_CreaditCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_CreaditCard.
     * @param {Lkup_CreaditCardDeleteArgs} args - Arguments to delete one Lkup_CreaditCard.
     * @example
     * // Delete one Lkup_CreaditCard
     * const Lkup_CreaditCard = await prisma.lkup_CreaditCard.delete({
     *   where: {
     *     // ... filter to delete one Lkup_CreaditCard
     *   }
     * })
     * 
     */
    delete<T extends Lkup_CreaditCardDeleteArgs>(args: SelectSubset<T, Lkup_CreaditCardDeleteArgs<ExtArgs>>): Prisma__Lkup_CreaditCardClient<$Result.GetResult<Prisma.$Lkup_CreaditCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_CreaditCard.
     * @param {Lkup_CreaditCardUpdateArgs} args - Arguments to update one Lkup_CreaditCard.
     * @example
     * // Update one Lkup_CreaditCard
     * const lkup_CreaditCard = await prisma.lkup_CreaditCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_CreaditCardUpdateArgs>(args: SelectSubset<T, Lkup_CreaditCardUpdateArgs<ExtArgs>>): Prisma__Lkup_CreaditCardClient<$Result.GetResult<Prisma.$Lkup_CreaditCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_CreaditCards.
     * @param {Lkup_CreaditCardDeleteManyArgs} args - Arguments to filter Lkup_CreaditCards to delete.
     * @example
     * // Delete a few Lkup_CreaditCards
     * const { count } = await prisma.lkup_CreaditCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_CreaditCardDeleteManyArgs>(args?: SelectSubset<T, Lkup_CreaditCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_CreaditCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CreaditCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_CreaditCards
     * const lkup_CreaditCard = await prisma.lkup_CreaditCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_CreaditCardUpdateManyArgs>(args: SelectSubset<T, Lkup_CreaditCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_CreaditCard.
     * @param {Lkup_CreaditCardUpsertArgs} args - Arguments to update or create a Lkup_CreaditCard.
     * @example
     * // Update or create a Lkup_CreaditCard
     * const lkup_CreaditCard = await prisma.lkup_CreaditCard.upsert({
     *   create: {
     *     // ... data to create a Lkup_CreaditCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_CreaditCard we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_CreaditCardUpsertArgs>(args: SelectSubset<T, Lkup_CreaditCardUpsertArgs<ExtArgs>>): Prisma__Lkup_CreaditCardClient<$Result.GetResult<Prisma.$Lkup_CreaditCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_CreaditCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CreaditCardCountArgs} args - Arguments to filter Lkup_CreaditCards to count.
     * @example
     * // Count the number of Lkup_CreaditCards
     * const count = await prisma.lkup_CreaditCard.count({
     *   where: {
     *     // ... the filter for the Lkup_CreaditCards we want to count
     *   }
     * })
    **/
    count<T extends Lkup_CreaditCardCountArgs>(
      args?: Subset<T, Lkup_CreaditCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_CreaditCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_CreaditCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CreaditCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_CreaditCardAggregateArgs>(args: Subset<T, Lkup_CreaditCardAggregateArgs>): Prisma.PrismaPromise<GetLkup_CreaditCardAggregateType<T>>

    /**
     * Group by Lkup_CreaditCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_CreaditCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_CreaditCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_CreaditCardGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_CreaditCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_CreaditCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_CreaditCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_CreaditCard model
   */
  readonly fields: Lkup_CreaditCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_CreaditCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_CreaditCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_CreaditCard model
   */ 
  interface Lkup_CreaditCardFieldRefs {
    readonly CardID: FieldRef<"Lkup_CreaditCard", 'Int'>
    readonly CardName: FieldRef<"Lkup_CreaditCard", 'String'>
    readonly CardCode: FieldRef<"Lkup_CreaditCard", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_CreaditCard findUnique
   */
  export type Lkup_CreaditCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_CreaditCard
     */
    select?: Lkup_CreaditCardSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_CreaditCard to fetch.
     */
    where: Lkup_CreaditCardWhereUniqueInput
  }

  /**
   * Lkup_CreaditCard findUniqueOrThrow
   */
  export type Lkup_CreaditCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_CreaditCard
     */
    select?: Lkup_CreaditCardSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_CreaditCard to fetch.
     */
    where: Lkup_CreaditCardWhereUniqueInput
  }

  /**
   * Lkup_CreaditCard findFirst
   */
  export type Lkup_CreaditCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_CreaditCard
     */
    select?: Lkup_CreaditCardSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_CreaditCard to fetch.
     */
    where?: Lkup_CreaditCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_CreaditCards to fetch.
     */
    orderBy?: Lkup_CreaditCardOrderByWithRelationInput | Lkup_CreaditCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_CreaditCards.
     */
    cursor?: Lkup_CreaditCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_CreaditCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_CreaditCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_CreaditCards.
     */
    distinct?: Lkup_CreaditCardScalarFieldEnum | Lkup_CreaditCardScalarFieldEnum[]
  }

  /**
   * Lkup_CreaditCard findFirstOrThrow
   */
  export type Lkup_CreaditCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_CreaditCard
     */
    select?: Lkup_CreaditCardSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_CreaditCard to fetch.
     */
    where?: Lkup_CreaditCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_CreaditCards to fetch.
     */
    orderBy?: Lkup_CreaditCardOrderByWithRelationInput | Lkup_CreaditCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_CreaditCards.
     */
    cursor?: Lkup_CreaditCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_CreaditCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_CreaditCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_CreaditCards.
     */
    distinct?: Lkup_CreaditCardScalarFieldEnum | Lkup_CreaditCardScalarFieldEnum[]
  }

  /**
   * Lkup_CreaditCard findMany
   */
  export type Lkup_CreaditCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_CreaditCard
     */
    select?: Lkup_CreaditCardSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_CreaditCards to fetch.
     */
    where?: Lkup_CreaditCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_CreaditCards to fetch.
     */
    orderBy?: Lkup_CreaditCardOrderByWithRelationInput | Lkup_CreaditCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_CreaditCards.
     */
    cursor?: Lkup_CreaditCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_CreaditCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_CreaditCards.
     */
    skip?: number
    distinct?: Lkup_CreaditCardScalarFieldEnum | Lkup_CreaditCardScalarFieldEnum[]
  }

  /**
   * Lkup_CreaditCard create
   */
  export type Lkup_CreaditCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_CreaditCard
     */
    select?: Lkup_CreaditCardSelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_CreaditCard.
     */
    data: XOR<Lkup_CreaditCardCreateInput, Lkup_CreaditCardUncheckedCreateInput>
  }

  /**
   * Lkup_CreaditCard createMany
   */
  export type Lkup_CreaditCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_CreaditCards.
     */
    data: Lkup_CreaditCardCreateManyInput | Lkup_CreaditCardCreateManyInput[]
  }

  /**
   * Lkup_CreaditCard update
   */
  export type Lkup_CreaditCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_CreaditCard
     */
    select?: Lkup_CreaditCardSelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_CreaditCard.
     */
    data: XOR<Lkup_CreaditCardUpdateInput, Lkup_CreaditCardUncheckedUpdateInput>
    /**
     * Choose, which Lkup_CreaditCard to update.
     */
    where: Lkup_CreaditCardWhereUniqueInput
  }

  /**
   * Lkup_CreaditCard updateMany
   */
  export type Lkup_CreaditCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_CreaditCards.
     */
    data: XOR<Lkup_CreaditCardUpdateManyMutationInput, Lkup_CreaditCardUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_CreaditCards to update
     */
    where?: Lkup_CreaditCardWhereInput
  }

  /**
   * Lkup_CreaditCard upsert
   */
  export type Lkup_CreaditCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_CreaditCard
     */
    select?: Lkup_CreaditCardSelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_CreaditCard to update in case it exists.
     */
    where: Lkup_CreaditCardWhereUniqueInput
    /**
     * In case the Lkup_CreaditCard found by the `where` argument doesn't exist, create a new Lkup_CreaditCard with this data.
     */
    create: XOR<Lkup_CreaditCardCreateInput, Lkup_CreaditCardUncheckedCreateInput>
    /**
     * In case the Lkup_CreaditCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_CreaditCardUpdateInput, Lkup_CreaditCardUncheckedUpdateInput>
  }

  /**
   * Lkup_CreaditCard delete
   */
  export type Lkup_CreaditCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_CreaditCard
     */
    select?: Lkup_CreaditCardSelect<ExtArgs> | null
    /**
     * Filter which Lkup_CreaditCard to delete.
     */
    where: Lkup_CreaditCardWhereUniqueInput
  }

  /**
   * Lkup_CreaditCard deleteMany
   */
  export type Lkup_CreaditCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_CreaditCards to delete
     */
    where?: Lkup_CreaditCardWhereInput
  }

  /**
   * Lkup_CreaditCard without action
   */
  export type Lkup_CreaditCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_CreaditCard
     */
    select?: Lkup_CreaditCardSelect<ExtArgs> | null
  }


  /**
   * Model Lkup_EmployeesType
   */

  export type AggregateLkup_EmployeesType = {
    _count: Lkup_EmployeesTypeCountAggregateOutputType | null
    _avg: Lkup_EmployeesTypeAvgAggregateOutputType | null
    _sum: Lkup_EmployeesTypeSumAggregateOutputType | null
    _min: Lkup_EmployeesTypeMinAggregateOutputType | null
    _max: Lkup_EmployeesTypeMaxAggregateOutputType | null
  }

  export type Lkup_EmployeesTypeAvgAggregateOutputType = {
    TypeID: number | null
  }

  export type Lkup_EmployeesTypeSumAggregateOutputType = {
    TypeID: number | null
  }

  export type Lkup_EmployeesTypeMinAggregateOutputType = {
    TypeID: number | null
    TypeName: string | null
  }

  export type Lkup_EmployeesTypeMaxAggregateOutputType = {
    TypeID: number | null
    TypeName: string | null
  }

  export type Lkup_EmployeesTypeCountAggregateOutputType = {
    TypeID: number
    TypeName: number
    _all: number
  }


  export type Lkup_EmployeesTypeAvgAggregateInputType = {
    TypeID?: true
  }

  export type Lkup_EmployeesTypeSumAggregateInputType = {
    TypeID?: true
  }

  export type Lkup_EmployeesTypeMinAggregateInputType = {
    TypeID?: true
    TypeName?: true
  }

  export type Lkup_EmployeesTypeMaxAggregateInputType = {
    TypeID?: true
    TypeName?: true
  }

  export type Lkup_EmployeesTypeCountAggregateInputType = {
    TypeID?: true
    TypeName?: true
    _all?: true
  }

  export type Lkup_EmployeesTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_EmployeesType to aggregate.
     */
    where?: Lkup_EmployeesTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_EmployeesTypes to fetch.
     */
    orderBy?: Lkup_EmployeesTypeOrderByWithRelationInput | Lkup_EmployeesTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_EmployeesTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_EmployeesTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_EmployeesTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_EmployeesTypes
    **/
    _count?: true | Lkup_EmployeesTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_EmployeesTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_EmployeesTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_EmployeesTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_EmployeesTypeMaxAggregateInputType
  }

  export type GetLkup_EmployeesTypeAggregateType<T extends Lkup_EmployeesTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_EmployeesType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_EmployeesType[P]>
      : GetScalarType<T[P], AggregateLkup_EmployeesType[P]>
  }




  export type Lkup_EmployeesTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_EmployeesTypeWhereInput
    orderBy?: Lkup_EmployeesTypeOrderByWithAggregationInput | Lkup_EmployeesTypeOrderByWithAggregationInput[]
    by: Lkup_EmployeesTypeScalarFieldEnum[] | Lkup_EmployeesTypeScalarFieldEnum
    having?: Lkup_EmployeesTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_EmployeesTypeCountAggregateInputType | true
    _avg?: Lkup_EmployeesTypeAvgAggregateInputType
    _sum?: Lkup_EmployeesTypeSumAggregateInputType
    _min?: Lkup_EmployeesTypeMinAggregateInputType
    _max?: Lkup_EmployeesTypeMaxAggregateInputType
  }

  export type Lkup_EmployeesTypeGroupByOutputType = {
    TypeID: number
    TypeName: string
    _count: Lkup_EmployeesTypeCountAggregateOutputType | null
    _avg: Lkup_EmployeesTypeAvgAggregateOutputType | null
    _sum: Lkup_EmployeesTypeSumAggregateOutputType | null
    _min: Lkup_EmployeesTypeMinAggregateOutputType | null
    _max: Lkup_EmployeesTypeMaxAggregateOutputType | null
  }

  type GetLkup_EmployeesTypeGroupByPayload<T extends Lkup_EmployeesTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_EmployeesTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_EmployeesTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_EmployeesTypeGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_EmployeesTypeGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_EmployeesTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TypeID?: boolean
    TypeName?: boolean
  }, ExtArgs["result"]["lkup_EmployeesType"]>


  export type Lkup_EmployeesTypeSelectScalar = {
    TypeID?: boolean
    TypeName?: boolean
  }


  export type $Lkup_EmployeesTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_EmployeesType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      TypeID: number
      TypeName: string
    }, ExtArgs["result"]["lkup_EmployeesType"]>
    composites: {}
  }

  type Lkup_EmployeesTypeGetPayload<S extends boolean | null | undefined | Lkup_EmployeesTypeDefaultArgs> = $Result.GetResult<Prisma.$Lkup_EmployeesTypePayload, S>

  type Lkup_EmployeesTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_EmployeesTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_EmployeesTypeCountAggregateInputType | true
    }

  export interface Lkup_EmployeesTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_EmployeesType'], meta: { name: 'Lkup_EmployeesType' } }
    /**
     * Find zero or one Lkup_EmployeesType that matches the filter.
     * @param {Lkup_EmployeesTypeFindUniqueArgs} args - Arguments to find a Lkup_EmployeesType
     * @example
     * // Get one Lkup_EmployeesType
     * const lkup_EmployeesType = await prisma.lkup_EmployeesType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_EmployeesTypeFindUniqueArgs>(args: SelectSubset<T, Lkup_EmployeesTypeFindUniqueArgs<ExtArgs>>): Prisma__Lkup_EmployeesTypeClient<$Result.GetResult<Prisma.$Lkup_EmployeesTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_EmployeesType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_EmployeesTypeFindUniqueOrThrowArgs} args - Arguments to find a Lkup_EmployeesType
     * @example
     * // Get one Lkup_EmployeesType
     * const lkup_EmployeesType = await prisma.lkup_EmployeesType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_EmployeesTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_EmployeesTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_EmployeesTypeClient<$Result.GetResult<Prisma.$Lkup_EmployeesTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_EmployeesType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_EmployeesTypeFindFirstArgs} args - Arguments to find a Lkup_EmployeesType
     * @example
     * // Get one Lkup_EmployeesType
     * const lkup_EmployeesType = await prisma.lkup_EmployeesType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_EmployeesTypeFindFirstArgs>(args?: SelectSubset<T, Lkup_EmployeesTypeFindFirstArgs<ExtArgs>>): Prisma__Lkup_EmployeesTypeClient<$Result.GetResult<Prisma.$Lkup_EmployeesTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_EmployeesType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_EmployeesTypeFindFirstOrThrowArgs} args - Arguments to find a Lkup_EmployeesType
     * @example
     * // Get one Lkup_EmployeesType
     * const lkup_EmployeesType = await prisma.lkup_EmployeesType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_EmployeesTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_EmployeesTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_EmployeesTypeClient<$Result.GetResult<Prisma.$Lkup_EmployeesTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_EmployeesTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_EmployeesTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_EmployeesTypes
     * const lkup_EmployeesTypes = await prisma.lkup_EmployeesType.findMany()
     * 
     * // Get first 10 Lkup_EmployeesTypes
     * const lkup_EmployeesTypes = await prisma.lkup_EmployeesType.findMany({ take: 10 })
     * 
     * // Only select the `TypeID`
     * const lkup_EmployeesTypeWithTypeIDOnly = await prisma.lkup_EmployeesType.findMany({ select: { TypeID: true } })
     * 
     */
    findMany<T extends Lkup_EmployeesTypeFindManyArgs>(args?: SelectSubset<T, Lkup_EmployeesTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_EmployeesTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_EmployeesType.
     * @param {Lkup_EmployeesTypeCreateArgs} args - Arguments to create a Lkup_EmployeesType.
     * @example
     * // Create one Lkup_EmployeesType
     * const Lkup_EmployeesType = await prisma.lkup_EmployeesType.create({
     *   data: {
     *     // ... data to create a Lkup_EmployeesType
     *   }
     * })
     * 
     */
    create<T extends Lkup_EmployeesTypeCreateArgs>(args: SelectSubset<T, Lkup_EmployeesTypeCreateArgs<ExtArgs>>): Prisma__Lkup_EmployeesTypeClient<$Result.GetResult<Prisma.$Lkup_EmployeesTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_EmployeesTypes.
     * @param {Lkup_EmployeesTypeCreateManyArgs} args - Arguments to create many Lkup_EmployeesTypes.
     * @example
     * // Create many Lkup_EmployeesTypes
     * const lkup_EmployeesType = await prisma.lkup_EmployeesType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_EmployeesTypeCreateManyArgs>(args?: SelectSubset<T, Lkup_EmployeesTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_EmployeesType.
     * @param {Lkup_EmployeesTypeDeleteArgs} args - Arguments to delete one Lkup_EmployeesType.
     * @example
     * // Delete one Lkup_EmployeesType
     * const Lkup_EmployeesType = await prisma.lkup_EmployeesType.delete({
     *   where: {
     *     // ... filter to delete one Lkup_EmployeesType
     *   }
     * })
     * 
     */
    delete<T extends Lkup_EmployeesTypeDeleteArgs>(args: SelectSubset<T, Lkup_EmployeesTypeDeleteArgs<ExtArgs>>): Prisma__Lkup_EmployeesTypeClient<$Result.GetResult<Prisma.$Lkup_EmployeesTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_EmployeesType.
     * @param {Lkup_EmployeesTypeUpdateArgs} args - Arguments to update one Lkup_EmployeesType.
     * @example
     * // Update one Lkup_EmployeesType
     * const lkup_EmployeesType = await prisma.lkup_EmployeesType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_EmployeesTypeUpdateArgs>(args: SelectSubset<T, Lkup_EmployeesTypeUpdateArgs<ExtArgs>>): Prisma__Lkup_EmployeesTypeClient<$Result.GetResult<Prisma.$Lkup_EmployeesTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_EmployeesTypes.
     * @param {Lkup_EmployeesTypeDeleteManyArgs} args - Arguments to filter Lkup_EmployeesTypes to delete.
     * @example
     * // Delete a few Lkup_EmployeesTypes
     * const { count } = await prisma.lkup_EmployeesType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_EmployeesTypeDeleteManyArgs>(args?: SelectSubset<T, Lkup_EmployeesTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_EmployeesTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_EmployeesTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_EmployeesTypes
     * const lkup_EmployeesType = await prisma.lkup_EmployeesType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_EmployeesTypeUpdateManyArgs>(args: SelectSubset<T, Lkup_EmployeesTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_EmployeesType.
     * @param {Lkup_EmployeesTypeUpsertArgs} args - Arguments to update or create a Lkup_EmployeesType.
     * @example
     * // Update or create a Lkup_EmployeesType
     * const lkup_EmployeesType = await prisma.lkup_EmployeesType.upsert({
     *   create: {
     *     // ... data to create a Lkup_EmployeesType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_EmployeesType we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_EmployeesTypeUpsertArgs>(args: SelectSubset<T, Lkup_EmployeesTypeUpsertArgs<ExtArgs>>): Prisma__Lkup_EmployeesTypeClient<$Result.GetResult<Prisma.$Lkup_EmployeesTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_EmployeesTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_EmployeesTypeCountArgs} args - Arguments to filter Lkup_EmployeesTypes to count.
     * @example
     * // Count the number of Lkup_EmployeesTypes
     * const count = await prisma.lkup_EmployeesType.count({
     *   where: {
     *     // ... the filter for the Lkup_EmployeesTypes we want to count
     *   }
     * })
    **/
    count<T extends Lkup_EmployeesTypeCountArgs>(
      args?: Subset<T, Lkup_EmployeesTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_EmployeesTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_EmployeesType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_EmployeesTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_EmployeesTypeAggregateArgs>(args: Subset<T, Lkup_EmployeesTypeAggregateArgs>): Prisma.PrismaPromise<GetLkup_EmployeesTypeAggregateType<T>>

    /**
     * Group by Lkup_EmployeesType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_EmployeesTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_EmployeesTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_EmployeesTypeGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_EmployeesTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_EmployeesTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_EmployeesTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_EmployeesType model
   */
  readonly fields: Lkup_EmployeesTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_EmployeesType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_EmployeesTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_EmployeesType model
   */ 
  interface Lkup_EmployeesTypeFieldRefs {
    readonly TypeID: FieldRef<"Lkup_EmployeesType", 'Int'>
    readonly TypeName: FieldRef<"Lkup_EmployeesType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_EmployeesType findUnique
   */
  export type Lkup_EmployeesTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_EmployeesType
     */
    select?: Lkup_EmployeesTypeSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_EmployeesType to fetch.
     */
    where: Lkup_EmployeesTypeWhereUniqueInput
  }

  /**
   * Lkup_EmployeesType findUniqueOrThrow
   */
  export type Lkup_EmployeesTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_EmployeesType
     */
    select?: Lkup_EmployeesTypeSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_EmployeesType to fetch.
     */
    where: Lkup_EmployeesTypeWhereUniqueInput
  }

  /**
   * Lkup_EmployeesType findFirst
   */
  export type Lkup_EmployeesTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_EmployeesType
     */
    select?: Lkup_EmployeesTypeSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_EmployeesType to fetch.
     */
    where?: Lkup_EmployeesTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_EmployeesTypes to fetch.
     */
    orderBy?: Lkup_EmployeesTypeOrderByWithRelationInput | Lkup_EmployeesTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_EmployeesTypes.
     */
    cursor?: Lkup_EmployeesTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_EmployeesTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_EmployeesTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_EmployeesTypes.
     */
    distinct?: Lkup_EmployeesTypeScalarFieldEnum | Lkup_EmployeesTypeScalarFieldEnum[]
  }

  /**
   * Lkup_EmployeesType findFirstOrThrow
   */
  export type Lkup_EmployeesTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_EmployeesType
     */
    select?: Lkup_EmployeesTypeSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_EmployeesType to fetch.
     */
    where?: Lkup_EmployeesTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_EmployeesTypes to fetch.
     */
    orderBy?: Lkup_EmployeesTypeOrderByWithRelationInput | Lkup_EmployeesTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_EmployeesTypes.
     */
    cursor?: Lkup_EmployeesTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_EmployeesTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_EmployeesTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_EmployeesTypes.
     */
    distinct?: Lkup_EmployeesTypeScalarFieldEnum | Lkup_EmployeesTypeScalarFieldEnum[]
  }

  /**
   * Lkup_EmployeesType findMany
   */
  export type Lkup_EmployeesTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_EmployeesType
     */
    select?: Lkup_EmployeesTypeSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_EmployeesTypes to fetch.
     */
    where?: Lkup_EmployeesTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_EmployeesTypes to fetch.
     */
    orderBy?: Lkup_EmployeesTypeOrderByWithRelationInput | Lkup_EmployeesTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_EmployeesTypes.
     */
    cursor?: Lkup_EmployeesTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_EmployeesTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_EmployeesTypes.
     */
    skip?: number
    distinct?: Lkup_EmployeesTypeScalarFieldEnum | Lkup_EmployeesTypeScalarFieldEnum[]
  }

  /**
   * Lkup_EmployeesType create
   */
  export type Lkup_EmployeesTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_EmployeesType
     */
    select?: Lkup_EmployeesTypeSelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_EmployeesType.
     */
    data: XOR<Lkup_EmployeesTypeCreateInput, Lkup_EmployeesTypeUncheckedCreateInput>
  }

  /**
   * Lkup_EmployeesType createMany
   */
  export type Lkup_EmployeesTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_EmployeesTypes.
     */
    data: Lkup_EmployeesTypeCreateManyInput | Lkup_EmployeesTypeCreateManyInput[]
  }

  /**
   * Lkup_EmployeesType update
   */
  export type Lkup_EmployeesTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_EmployeesType
     */
    select?: Lkup_EmployeesTypeSelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_EmployeesType.
     */
    data: XOR<Lkup_EmployeesTypeUpdateInput, Lkup_EmployeesTypeUncheckedUpdateInput>
    /**
     * Choose, which Lkup_EmployeesType to update.
     */
    where: Lkup_EmployeesTypeWhereUniqueInput
  }

  /**
   * Lkup_EmployeesType updateMany
   */
  export type Lkup_EmployeesTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_EmployeesTypes.
     */
    data: XOR<Lkup_EmployeesTypeUpdateManyMutationInput, Lkup_EmployeesTypeUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_EmployeesTypes to update
     */
    where?: Lkup_EmployeesTypeWhereInput
  }

  /**
   * Lkup_EmployeesType upsert
   */
  export type Lkup_EmployeesTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_EmployeesType
     */
    select?: Lkup_EmployeesTypeSelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_EmployeesType to update in case it exists.
     */
    where: Lkup_EmployeesTypeWhereUniqueInput
    /**
     * In case the Lkup_EmployeesType found by the `where` argument doesn't exist, create a new Lkup_EmployeesType with this data.
     */
    create: XOR<Lkup_EmployeesTypeCreateInput, Lkup_EmployeesTypeUncheckedCreateInput>
    /**
     * In case the Lkup_EmployeesType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_EmployeesTypeUpdateInput, Lkup_EmployeesTypeUncheckedUpdateInput>
  }

  /**
   * Lkup_EmployeesType delete
   */
  export type Lkup_EmployeesTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_EmployeesType
     */
    select?: Lkup_EmployeesTypeSelect<ExtArgs> | null
    /**
     * Filter which Lkup_EmployeesType to delete.
     */
    where: Lkup_EmployeesTypeWhereUniqueInput
  }

  /**
   * Lkup_EmployeesType deleteMany
   */
  export type Lkup_EmployeesTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_EmployeesTypes to delete
     */
    where?: Lkup_EmployeesTypeWhereInput
  }

  /**
   * Lkup_EmployeesType without action
   */
  export type Lkup_EmployeesTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_EmployeesType
     */
    select?: Lkup_EmployeesTypeSelect<ExtArgs> | null
  }


  /**
   * Model Lkup_Language
   */

  export type AggregateLkup_Language = {
    _count: Lkup_LanguageCountAggregateOutputType | null
    _avg: Lkup_LanguageAvgAggregateOutputType | null
    _sum: Lkup_LanguageSumAggregateOutputType | null
    _min: Lkup_LanguageMinAggregateOutputType | null
    _max: Lkup_LanguageMaxAggregateOutputType | null
  }

  export type Lkup_LanguageAvgAggregateOutputType = {
    LanguageID: number | null
  }

  export type Lkup_LanguageSumAggregateOutputType = {
    LanguageID: number | null
  }

  export type Lkup_LanguageMinAggregateOutputType = {
    LanguageID: number | null
    LanguageName: string | null
  }

  export type Lkup_LanguageMaxAggregateOutputType = {
    LanguageID: number | null
    LanguageName: string | null
  }

  export type Lkup_LanguageCountAggregateOutputType = {
    LanguageID: number
    LanguageName: number
    _all: number
  }


  export type Lkup_LanguageAvgAggregateInputType = {
    LanguageID?: true
  }

  export type Lkup_LanguageSumAggregateInputType = {
    LanguageID?: true
  }

  export type Lkup_LanguageMinAggregateInputType = {
    LanguageID?: true
    LanguageName?: true
  }

  export type Lkup_LanguageMaxAggregateInputType = {
    LanguageID?: true
    LanguageName?: true
  }

  export type Lkup_LanguageCountAggregateInputType = {
    LanguageID?: true
    LanguageName?: true
    _all?: true
  }

  export type Lkup_LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Language to aggregate.
     */
    where?: Lkup_LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Languages to fetch.
     */
    orderBy?: Lkup_LanguageOrderByWithRelationInput | Lkup_LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_Languages
    **/
    _count?: true | Lkup_LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_LanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_LanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_LanguageMaxAggregateInputType
  }

  export type GetLkup_LanguageAggregateType<T extends Lkup_LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_Language]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_Language[P]>
      : GetScalarType<T[P], AggregateLkup_Language[P]>
  }




  export type Lkup_LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_LanguageWhereInput
    orderBy?: Lkup_LanguageOrderByWithAggregationInput | Lkup_LanguageOrderByWithAggregationInput[]
    by: Lkup_LanguageScalarFieldEnum[] | Lkup_LanguageScalarFieldEnum
    having?: Lkup_LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_LanguageCountAggregateInputType | true
    _avg?: Lkup_LanguageAvgAggregateInputType
    _sum?: Lkup_LanguageSumAggregateInputType
    _min?: Lkup_LanguageMinAggregateInputType
    _max?: Lkup_LanguageMaxAggregateInputType
  }

  export type Lkup_LanguageGroupByOutputType = {
    LanguageID: number
    LanguageName: string
    _count: Lkup_LanguageCountAggregateOutputType | null
    _avg: Lkup_LanguageAvgAggregateOutputType | null
    _sum: Lkup_LanguageSumAggregateOutputType | null
    _min: Lkup_LanguageMinAggregateOutputType | null
    _max: Lkup_LanguageMaxAggregateOutputType | null
  }

  type GetLkup_LanguageGroupByPayload<T extends Lkup_LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_LanguageGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LanguageID?: boolean
    LanguageName?: boolean
  }, ExtArgs["result"]["lkup_Language"]>


  export type Lkup_LanguageSelectScalar = {
    LanguageID?: boolean
    LanguageName?: boolean
  }


  export type $Lkup_LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_Language"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      LanguageID: number
      LanguageName: string
    }, ExtArgs["result"]["lkup_Language"]>
    composites: {}
  }

  type Lkup_LanguageGetPayload<S extends boolean | null | undefined | Lkup_LanguageDefaultArgs> = $Result.GetResult<Prisma.$Lkup_LanguagePayload, S>

  type Lkup_LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_LanguageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_LanguageCountAggregateInputType | true
    }

  export interface Lkup_LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_Language'], meta: { name: 'Lkup_Language' } }
    /**
     * Find zero or one Lkup_Language that matches the filter.
     * @param {Lkup_LanguageFindUniqueArgs} args - Arguments to find a Lkup_Language
     * @example
     * // Get one Lkup_Language
     * const lkup_Language = await prisma.lkup_Language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_LanguageFindUniqueArgs>(args: SelectSubset<T, Lkup_LanguageFindUniqueArgs<ExtArgs>>): Prisma__Lkup_LanguageClient<$Result.GetResult<Prisma.$Lkup_LanguagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_Language that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_LanguageFindUniqueOrThrowArgs} args - Arguments to find a Lkup_Language
     * @example
     * // Get one Lkup_Language
     * const lkup_Language = await prisma.lkup_Language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_LanguageClient<$Result.GetResult<Prisma.$Lkup_LanguagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_LanguageFindFirstArgs} args - Arguments to find a Lkup_Language
     * @example
     * // Get one Lkup_Language
     * const lkup_Language = await prisma.lkup_Language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_LanguageFindFirstArgs>(args?: SelectSubset<T, Lkup_LanguageFindFirstArgs<ExtArgs>>): Prisma__Lkup_LanguageClient<$Result.GetResult<Prisma.$Lkup_LanguagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_LanguageFindFirstOrThrowArgs} args - Arguments to find a Lkup_Language
     * @example
     * // Get one Lkup_Language
     * const lkup_Language = await prisma.lkup_Language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_LanguageClient<$Result.GetResult<Prisma.$Lkup_LanguagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_Languages
     * const lkup_Languages = await prisma.lkup_Language.findMany()
     * 
     * // Get first 10 Lkup_Languages
     * const lkup_Languages = await prisma.lkup_Language.findMany({ take: 10 })
     * 
     * // Only select the `LanguageID`
     * const lkup_LanguageWithLanguageIDOnly = await prisma.lkup_Language.findMany({ select: { LanguageID: true } })
     * 
     */
    findMany<T extends Lkup_LanguageFindManyArgs>(args?: SelectSubset<T, Lkup_LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_LanguagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_Language.
     * @param {Lkup_LanguageCreateArgs} args - Arguments to create a Lkup_Language.
     * @example
     * // Create one Lkup_Language
     * const Lkup_Language = await prisma.lkup_Language.create({
     *   data: {
     *     // ... data to create a Lkup_Language
     *   }
     * })
     * 
     */
    create<T extends Lkup_LanguageCreateArgs>(args: SelectSubset<T, Lkup_LanguageCreateArgs<ExtArgs>>): Prisma__Lkup_LanguageClient<$Result.GetResult<Prisma.$Lkup_LanguagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_Languages.
     * @param {Lkup_LanguageCreateManyArgs} args - Arguments to create many Lkup_Languages.
     * @example
     * // Create many Lkup_Languages
     * const lkup_Language = await prisma.lkup_Language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_LanguageCreateManyArgs>(args?: SelectSubset<T, Lkup_LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_Language.
     * @param {Lkup_LanguageDeleteArgs} args - Arguments to delete one Lkup_Language.
     * @example
     * // Delete one Lkup_Language
     * const Lkup_Language = await prisma.lkup_Language.delete({
     *   where: {
     *     // ... filter to delete one Lkup_Language
     *   }
     * })
     * 
     */
    delete<T extends Lkup_LanguageDeleteArgs>(args: SelectSubset<T, Lkup_LanguageDeleteArgs<ExtArgs>>): Prisma__Lkup_LanguageClient<$Result.GetResult<Prisma.$Lkup_LanguagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_Language.
     * @param {Lkup_LanguageUpdateArgs} args - Arguments to update one Lkup_Language.
     * @example
     * // Update one Lkup_Language
     * const lkup_Language = await prisma.lkup_Language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_LanguageUpdateArgs>(args: SelectSubset<T, Lkup_LanguageUpdateArgs<ExtArgs>>): Prisma__Lkup_LanguageClient<$Result.GetResult<Prisma.$Lkup_LanguagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_Languages.
     * @param {Lkup_LanguageDeleteManyArgs} args - Arguments to filter Lkup_Languages to delete.
     * @example
     * // Delete a few Lkup_Languages
     * const { count } = await prisma.lkup_Language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_LanguageDeleteManyArgs>(args?: SelectSubset<T, Lkup_LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_Languages
     * const lkup_Language = await prisma.lkup_Language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_LanguageUpdateManyArgs>(args: SelectSubset<T, Lkup_LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_Language.
     * @param {Lkup_LanguageUpsertArgs} args - Arguments to update or create a Lkup_Language.
     * @example
     * // Update or create a Lkup_Language
     * const lkup_Language = await prisma.lkup_Language.upsert({
     *   create: {
     *     // ... data to create a Lkup_Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_Language we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_LanguageUpsertArgs>(args: SelectSubset<T, Lkup_LanguageUpsertArgs<ExtArgs>>): Prisma__Lkup_LanguageClient<$Result.GetResult<Prisma.$Lkup_LanguagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_LanguageCountArgs} args - Arguments to filter Lkup_Languages to count.
     * @example
     * // Count the number of Lkup_Languages
     * const count = await prisma.lkup_Language.count({
     *   where: {
     *     // ... the filter for the Lkup_Languages we want to count
     *   }
     * })
    **/
    count<T extends Lkup_LanguageCountArgs>(
      args?: Subset<T, Lkup_LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_LanguageAggregateArgs>(args: Subset<T, Lkup_LanguageAggregateArgs>): Prisma.PrismaPromise<GetLkup_LanguageAggregateType<T>>

    /**
     * Group by Lkup_Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_LanguageGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_LanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_Language model
   */
  readonly fields: Lkup_LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_Language model
   */ 
  interface Lkup_LanguageFieldRefs {
    readonly LanguageID: FieldRef<"Lkup_Language", 'Int'>
    readonly LanguageName: FieldRef<"Lkup_Language", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_Language findUnique
   */
  export type Lkup_LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Language
     */
    select?: Lkup_LanguageSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Language to fetch.
     */
    where: Lkup_LanguageWhereUniqueInput
  }

  /**
   * Lkup_Language findUniqueOrThrow
   */
  export type Lkup_LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Language
     */
    select?: Lkup_LanguageSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Language to fetch.
     */
    where: Lkup_LanguageWhereUniqueInput
  }

  /**
   * Lkup_Language findFirst
   */
  export type Lkup_LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Language
     */
    select?: Lkup_LanguageSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Language to fetch.
     */
    where?: Lkup_LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Languages to fetch.
     */
    orderBy?: Lkup_LanguageOrderByWithRelationInput | Lkup_LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Languages.
     */
    cursor?: Lkup_LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Languages.
     */
    distinct?: Lkup_LanguageScalarFieldEnum | Lkup_LanguageScalarFieldEnum[]
  }

  /**
   * Lkup_Language findFirstOrThrow
   */
  export type Lkup_LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Language
     */
    select?: Lkup_LanguageSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Language to fetch.
     */
    where?: Lkup_LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Languages to fetch.
     */
    orderBy?: Lkup_LanguageOrderByWithRelationInput | Lkup_LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Languages.
     */
    cursor?: Lkup_LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Languages.
     */
    distinct?: Lkup_LanguageScalarFieldEnum | Lkup_LanguageScalarFieldEnum[]
  }

  /**
   * Lkup_Language findMany
   */
  export type Lkup_LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Language
     */
    select?: Lkup_LanguageSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Languages to fetch.
     */
    where?: Lkup_LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Languages to fetch.
     */
    orderBy?: Lkup_LanguageOrderByWithRelationInput | Lkup_LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_Languages.
     */
    cursor?: Lkup_LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Languages.
     */
    skip?: number
    distinct?: Lkup_LanguageScalarFieldEnum | Lkup_LanguageScalarFieldEnum[]
  }

  /**
   * Lkup_Language create
   */
  export type Lkup_LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Language
     */
    select?: Lkup_LanguageSelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_Language.
     */
    data: XOR<Lkup_LanguageCreateInput, Lkup_LanguageUncheckedCreateInput>
  }

  /**
   * Lkup_Language createMany
   */
  export type Lkup_LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_Languages.
     */
    data: Lkup_LanguageCreateManyInput | Lkup_LanguageCreateManyInput[]
  }

  /**
   * Lkup_Language update
   */
  export type Lkup_LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Language
     */
    select?: Lkup_LanguageSelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_Language.
     */
    data: XOR<Lkup_LanguageUpdateInput, Lkup_LanguageUncheckedUpdateInput>
    /**
     * Choose, which Lkup_Language to update.
     */
    where: Lkup_LanguageWhereUniqueInput
  }

  /**
   * Lkup_Language updateMany
   */
  export type Lkup_LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_Languages.
     */
    data: XOR<Lkup_LanguageUpdateManyMutationInput, Lkup_LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_Languages to update
     */
    where?: Lkup_LanguageWhereInput
  }

  /**
   * Lkup_Language upsert
   */
  export type Lkup_LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Language
     */
    select?: Lkup_LanguageSelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_Language to update in case it exists.
     */
    where: Lkup_LanguageWhereUniqueInput
    /**
     * In case the Lkup_Language found by the `where` argument doesn't exist, create a new Lkup_Language with this data.
     */
    create: XOR<Lkup_LanguageCreateInput, Lkup_LanguageUncheckedCreateInput>
    /**
     * In case the Lkup_Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_LanguageUpdateInput, Lkup_LanguageUncheckedUpdateInput>
  }

  /**
   * Lkup_Language delete
   */
  export type Lkup_LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Language
     */
    select?: Lkup_LanguageSelect<ExtArgs> | null
    /**
     * Filter which Lkup_Language to delete.
     */
    where: Lkup_LanguageWhereUniqueInput
  }

  /**
   * Lkup_Language deleteMany
   */
  export type Lkup_LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Languages to delete
     */
    where?: Lkup_LanguageWhereInput
  }

  /**
   * Lkup_Language without action
   */
  export type Lkup_LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Language
     */
    select?: Lkup_LanguageSelect<ExtArgs> | null
  }


  /**
   * Model Lkup_PaySlip
   */

  export type AggregateLkup_PaySlip = {
    _count: Lkup_PaySlipCountAggregateOutputType | null
    _avg: Lkup_PaySlipAvgAggregateOutputType | null
    _sum: Lkup_PaySlipSumAggregateOutputType | null
    _min: Lkup_PaySlipMinAggregateOutputType | null
    _max: Lkup_PaySlipMaxAggregateOutputType | null
  }

  export type Lkup_PaySlipAvgAggregateOutputType = {
    PaySlipCode: number | null
  }

  export type Lkup_PaySlipSumAggregateOutputType = {
    PaySlipCode: number | null
  }

  export type Lkup_PaySlipMinAggregateOutputType = {
    PaySlipCode: number | null
    PaySlipName: string | null
    PaySlipNameSource: string | null
    IsTytle: boolean | null
  }

  export type Lkup_PaySlipMaxAggregateOutputType = {
    PaySlipCode: number | null
    PaySlipName: string | null
    PaySlipNameSource: string | null
    IsTytle: boolean | null
  }

  export type Lkup_PaySlipCountAggregateOutputType = {
    PaySlipCode: number
    PaySlipName: number
    PaySlipNameSource: number
    IsTytle: number
    _all: number
  }


  export type Lkup_PaySlipAvgAggregateInputType = {
    PaySlipCode?: true
  }

  export type Lkup_PaySlipSumAggregateInputType = {
    PaySlipCode?: true
  }

  export type Lkup_PaySlipMinAggregateInputType = {
    PaySlipCode?: true
    PaySlipName?: true
    PaySlipNameSource?: true
    IsTytle?: true
  }

  export type Lkup_PaySlipMaxAggregateInputType = {
    PaySlipCode?: true
    PaySlipName?: true
    PaySlipNameSource?: true
    IsTytle?: true
  }

  export type Lkup_PaySlipCountAggregateInputType = {
    PaySlipCode?: true
    PaySlipName?: true
    PaySlipNameSource?: true
    IsTytle?: true
    _all?: true
  }

  export type Lkup_PaySlipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_PaySlip to aggregate.
     */
    where?: Lkup_PaySlipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_PaySlips to fetch.
     */
    orderBy?: Lkup_PaySlipOrderByWithRelationInput | Lkup_PaySlipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_PaySlipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_PaySlips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_PaySlips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_PaySlips
    **/
    _count?: true | Lkup_PaySlipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_PaySlipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_PaySlipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_PaySlipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_PaySlipMaxAggregateInputType
  }

  export type GetLkup_PaySlipAggregateType<T extends Lkup_PaySlipAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_PaySlip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_PaySlip[P]>
      : GetScalarType<T[P], AggregateLkup_PaySlip[P]>
  }




  export type Lkup_PaySlipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_PaySlipWhereInput
    orderBy?: Lkup_PaySlipOrderByWithAggregationInput | Lkup_PaySlipOrderByWithAggregationInput[]
    by: Lkup_PaySlipScalarFieldEnum[] | Lkup_PaySlipScalarFieldEnum
    having?: Lkup_PaySlipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_PaySlipCountAggregateInputType | true
    _avg?: Lkup_PaySlipAvgAggregateInputType
    _sum?: Lkup_PaySlipSumAggregateInputType
    _min?: Lkup_PaySlipMinAggregateInputType
    _max?: Lkup_PaySlipMaxAggregateInputType
  }

  export type Lkup_PaySlipGroupByOutputType = {
    PaySlipCode: number
    PaySlipName: string | null
    PaySlipNameSource: string | null
    IsTytle: boolean
    _count: Lkup_PaySlipCountAggregateOutputType | null
    _avg: Lkup_PaySlipAvgAggregateOutputType | null
    _sum: Lkup_PaySlipSumAggregateOutputType | null
    _min: Lkup_PaySlipMinAggregateOutputType | null
    _max: Lkup_PaySlipMaxAggregateOutputType | null
  }

  type GetLkup_PaySlipGroupByPayload<T extends Lkup_PaySlipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_PaySlipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_PaySlipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_PaySlipGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_PaySlipGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_PaySlipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PaySlipCode?: boolean
    PaySlipName?: boolean
    PaySlipNameSource?: boolean
    IsTytle?: boolean
  }, ExtArgs["result"]["lkup_PaySlip"]>


  export type Lkup_PaySlipSelectScalar = {
    PaySlipCode?: boolean
    PaySlipName?: boolean
    PaySlipNameSource?: boolean
    IsTytle?: boolean
  }


  export type $Lkup_PaySlipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_PaySlip"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      PaySlipCode: number
      PaySlipName: string | null
      PaySlipNameSource: string | null
      IsTytle: boolean
    }, ExtArgs["result"]["lkup_PaySlip"]>
    composites: {}
  }

  type Lkup_PaySlipGetPayload<S extends boolean | null | undefined | Lkup_PaySlipDefaultArgs> = $Result.GetResult<Prisma.$Lkup_PaySlipPayload, S>

  type Lkup_PaySlipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_PaySlipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_PaySlipCountAggregateInputType | true
    }

  export interface Lkup_PaySlipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_PaySlip'], meta: { name: 'Lkup_PaySlip' } }
    /**
     * Find zero or one Lkup_PaySlip that matches the filter.
     * @param {Lkup_PaySlipFindUniqueArgs} args - Arguments to find a Lkup_PaySlip
     * @example
     * // Get one Lkup_PaySlip
     * const lkup_PaySlip = await prisma.lkup_PaySlip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_PaySlipFindUniqueArgs>(args: SelectSubset<T, Lkup_PaySlipFindUniqueArgs<ExtArgs>>): Prisma__Lkup_PaySlipClient<$Result.GetResult<Prisma.$Lkup_PaySlipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_PaySlip that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_PaySlipFindUniqueOrThrowArgs} args - Arguments to find a Lkup_PaySlip
     * @example
     * // Get one Lkup_PaySlip
     * const lkup_PaySlip = await prisma.lkup_PaySlip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_PaySlipFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_PaySlipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_PaySlipClient<$Result.GetResult<Prisma.$Lkup_PaySlipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_PaySlip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_PaySlipFindFirstArgs} args - Arguments to find a Lkup_PaySlip
     * @example
     * // Get one Lkup_PaySlip
     * const lkup_PaySlip = await prisma.lkup_PaySlip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_PaySlipFindFirstArgs>(args?: SelectSubset<T, Lkup_PaySlipFindFirstArgs<ExtArgs>>): Prisma__Lkup_PaySlipClient<$Result.GetResult<Prisma.$Lkup_PaySlipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_PaySlip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_PaySlipFindFirstOrThrowArgs} args - Arguments to find a Lkup_PaySlip
     * @example
     * // Get one Lkup_PaySlip
     * const lkup_PaySlip = await prisma.lkup_PaySlip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_PaySlipFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_PaySlipFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_PaySlipClient<$Result.GetResult<Prisma.$Lkup_PaySlipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_PaySlips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_PaySlipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_PaySlips
     * const lkup_PaySlips = await prisma.lkup_PaySlip.findMany()
     * 
     * // Get first 10 Lkup_PaySlips
     * const lkup_PaySlips = await prisma.lkup_PaySlip.findMany({ take: 10 })
     * 
     * // Only select the `PaySlipCode`
     * const lkup_PaySlipWithPaySlipCodeOnly = await prisma.lkup_PaySlip.findMany({ select: { PaySlipCode: true } })
     * 
     */
    findMany<T extends Lkup_PaySlipFindManyArgs>(args?: SelectSubset<T, Lkup_PaySlipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_PaySlipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_PaySlip.
     * @param {Lkup_PaySlipCreateArgs} args - Arguments to create a Lkup_PaySlip.
     * @example
     * // Create one Lkup_PaySlip
     * const Lkup_PaySlip = await prisma.lkup_PaySlip.create({
     *   data: {
     *     // ... data to create a Lkup_PaySlip
     *   }
     * })
     * 
     */
    create<T extends Lkup_PaySlipCreateArgs>(args: SelectSubset<T, Lkup_PaySlipCreateArgs<ExtArgs>>): Prisma__Lkup_PaySlipClient<$Result.GetResult<Prisma.$Lkup_PaySlipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_PaySlips.
     * @param {Lkup_PaySlipCreateManyArgs} args - Arguments to create many Lkup_PaySlips.
     * @example
     * // Create many Lkup_PaySlips
     * const lkup_PaySlip = await prisma.lkup_PaySlip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_PaySlipCreateManyArgs>(args?: SelectSubset<T, Lkup_PaySlipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_PaySlip.
     * @param {Lkup_PaySlipDeleteArgs} args - Arguments to delete one Lkup_PaySlip.
     * @example
     * // Delete one Lkup_PaySlip
     * const Lkup_PaySlip = await prisma.lkup_PaySlip.delete({
     *   where: {
     *     // ... filter to delete one Lkup_PaySlip
     *   }
     * })
     * 
     */
    delete<T extends Lkup_PaySlipDeleteArgs>(args: SelectSubset<T, Lkup_PaySlipDeleteArgs<ExtArgs>>): Prisma__Lkup_PaySlipClient<$Result.GetResult<Prisma.$Lkup_PaySlipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_PaySlip.
     * @param {Lkup_PaySlipUpdateArgs} args - Arguments to update one Lkup_PaySlip.
     * @example
     * // Update one Lkup_PaySlip
     * const lkup_PaySlip = await prisma.lkup_PaySlip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_PaySlipUpdateArgs>(args: SelectSubset<T, Lkup_PaySlipUpdateArgs<ExtArgs>>): Prisma__Lkup_PaySlipClient<$Result.GetResult<Prisma.$Lkup_PaySlipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_PaySlips.
     * @param {Lkup_PaySlipDeleteManyArgs} args - Arguments to filter Lkup_PaySlips to delete.
     * @example
     * // Delete a few Lkup_PaySlips
     * const { count } = await prisma.lkup_PaySlip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_PaySlipDeleteManyArgs>(args?: SelectSubset<T, Lkup_PaySlipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_PaySlips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_PaySlipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_PaySlips
     * const lkup_PaySlip = await prisma.lkup_PaySlip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_PaySlipUpdateManyArgs>(args: SelectSubset<T, Lkup_PaySlipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_PaySlip.
     * @param {Lkup_PaySlipUpsertArgs} args - Arguments to update or create a Lkup_PaySlip.
     * @example
     * // Update or create a Lkup_PaySlip
     * const lkup_PaySlip = await prisma.lkup_PaySlip.upsert({
     *   create: {
     *     // ... data to create a Lkup_PaySlip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_PaySlip we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_PaySlipUpsertArgs>(args: SelectSubset<T, Lkup_PaySlipUpsertArgs<ExtArgs>>): Prisma__Lkup_PaySlipClient<$Result.GetResult<Prisma.$Lkup_PaySlipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_PaySlips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_PaySlipCountArgs} args - Arguments to filter Lkup_PaySlips to count.
     * @example
     * // Count the number of Lkup_PaySlips
     * const count = await prisma.lkup_PaySlip.count({
     *   where: {
     *     // ... the filter for the Lkup_PaySlips we want to count
     *   }
     * })
    **/
    count<T extends Lkup_PaySlipCountArgs>(
      args?: Subset<T, Lkup_PaySlipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_PaySlipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_PaySlip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_PaySlipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_PaySlipAggregateArgs>(args: Subset<T, Lkup_PaySlipAggregateArgs>): Prisma.PrismaPromise<GetLkup_PaySlipAggregateType<T>>

    /**
     * Group by Lkup_PaySlip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_PaySlipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_PaySlipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_PaySlipGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_PaySlipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_PaySlipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_PaySlipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_PaySlip model
   */
  readonly fields: Lkup_PaySlipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_PaySlip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_PaySlipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_PaySlip model
   */ 
  interface Lkup_PaySlipFieldRefs {
    readonly PaySlipCode: FieldRef<"Lkup_PaySlip", 'Int'>
    readonly PaySlipName: FieldRef<"Lkup_PaySlip", 'String'>
    readonly PaySlipNameSource: FieldRef<"Lkup_PaySlip", 'String'>
    readonly IsTytle: FieldRef<"Lkup_PaySlip", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_PaySlip findUnique
   */
  export type Lkup_PaySlipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_PaySlip
     */
    select?: Lkup_PaySlipSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_PaySlip to fetch.
     */
    where: Lkup_PaySlipWhereUniqueInput
  }

  /**
   * Lkup_PaySlip findUniqueOrThrow
   */
  export type Lkup_PaySlipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_PaySlip
     */
    select?: Lkup_PaySlipSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_PaySlip to fetch.
     */
    where: Lkup_PaySlipWhereUniqueInput
  }

  /**
   * Lkup_PaySlip findFirst
   */
  export type Lkup_PaySlipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_PaySlip
     */
    select?: Lkup_PaySlipSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_PaySlip to fetch.
     */
    where?: Lkup_PaySlipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_PaySlips to fetch.
     */
    orderBy?: Lkup_PaySlipOrderByWithRelationInput | Lkup_PaySlipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_PaySlips.
     */
    cursor?: Lkup_PaySlipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_PaySlips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_PaySlips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_PaySlips.
     */
    distinct?: Lkup_PaySlipScalarFieldEnum | Lkup_PaySlipScalarFieldEnum[]
  }

  /**
   * Lkup_PaySlip findFirstOrThrow
   */
  export type Lkup_PaySlipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_PaySlip
     */
    select?: Lkup_PaySlipSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_PaySlip to fetch.
     */
    where?: Lkup_PaySlipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_PaySlips to fetch.
     */
    orderBy?: Lkup_PaySlipOrderByWithRelationInput | Lkup_PaySlipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_PaySlips.
     */
    cursor?: Lkup_PaySlipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_PaySlips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_PaySlips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_PaySlips.
     */
    distinct?: Lkup_PaySlipScalarFieldEnum | Lkup_PaySlipScalarFieldEnum[]
  }

  /**
   * Lkup_PaySlip findMany
   */
  export type Lkup_PaySlipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_PaySlip
     */
    select?: Lkup_PaySlipSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_PaySlips to fetch.
     */
    where?: Lkup_PaySlipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_PaySlips to fetch.
     */
    orderBy?: Lkup_PaySlipOrderByWithRelationInput | Lkup_PaySlipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_PaySlips.
     */
    cursor?: Lkup_PaySlipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_PaySlips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_PaySlips.
     */
    skip?: number
    distinct?: Lkup_PaySlipScalarFieldEnum | Lkup_PaySlipScalarFieldEnum[]
  }

  /**
   * Lkup_PaySlip create
   */
  export type Lkup_PaySlipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_PaySlip
     */
    select?: Lkup_PaySlipSelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_PaySlip.
     */
    data: XOR<Lkup_PaySlipCreateInput, Lkup_PaySlipUncheckedCreateInput>
  }

  /**
   * Lkup_PaySlip createMany
   */
  export type Lkup_PaySlipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_PaySlips.
     */
    data: Lkup_PaySlipCreateManyInput | Lkup_PaySlipCreateManyInput[]
  }

  /**
   * Lkup_PaySlip update
   */
  export type Lkup_PaySlipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_PaySlip
     */
    select?: Lkup_PaySlipSelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_PaySlip.
     */
    data: XOR<Lkup_PaySlipUpdateInput, Lkup_PaySlipUncheckedUpdateInput>
    /**
     * Choose, which Lkup_PaySlip to update.
     */
    where: Lkup_PaySlipWhereUniqueInput
  }

  /**
   * Lkup_PaySlip updateMany
   */
  export type Lkup_PaySlipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_PaySlips.
     */
    data: XOR<Lkup_PaySlipUpdateManyMutationInput, Lkup_PaySlipUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_PaySlips to update
     */
    where?: Lkup_PaySlipWhereInput
  }

  /**
   * Lkup_PaySlip upsert
   */
  export type Lkup_PaySlipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_PaySlip
     */
    select?: Lkup_PaySlipSelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_PaySlip to update in case it exists.
     */
    where: Lkup_PaySlipWhereUniqueInput
    /**
     * In case the Lkup_PaySlip found by the `where` argument doesn't exist, create a new Lkup_PaySlip with this data.
     */
    create: XOR<Lkup_PaySlipCreateInput, Lkup_PaySlipUncheckedCreateInput>
    /**
     * In case the Lkup_PaySlip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_PaySlipUpdateInput, Lkup_PaySlipUncheckedUpdateInput>
  }

  /**
   * Lkup_PaySlip delete
   */
  export type Lkup_PaySlipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_PaySlip
     */
    select?: Lkup_PaySlipSelect<ExtArgs> | null
    /**
     * Filter which Lkup_PaySlip to delete.
     */
    where: Lkup_PaySlipWhereUniqueInput
  }

  /**
   * Lkup_PaySlip deleteMany
   */
  export type Lkup_PaySlipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_PaySlips to delete
     */
    where?: Lkup_PaySlipWhereInput
  }

  /**
   * Lkup_PaySlip without action
   */
  export type Lkup_PaySlipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_PaySlip
     */
    select?: Lkup_PaySlipSelect<ExtArgs> | null
  }


  /**
   * Model Lkup_Sector
   */

  export type AggregateLkup_Sector = {
    _count: Lkup_SectorCountAggregateOutputType | null
    _avg: Lkup_SectorAvgAggregateOutputType | null
    _sum: Lkup_SectorSumAggregateOutputType | null
    _min: Lkup_SectorMinAggregateOutputType | null
    _max: Lkup_SectorMaxAggregateOutputType | null
  }

  export type Lkup_SectorAvgAggregateOutputType = {
    SectorID: number | null
    SectorCode: number | null
  }

  export type Lkup_SectorSumAggregateOutputType = {
    SectorID: number | null
    SectorCode: number | null
  }

  export type Lkup_SectorMinAggregateOutputType = {
    SectorID: number | null
    SectorCode: number | null
    SectorName: string | null
  }

  export type Lkup_SectorMaxAggregateOutputType = {
    SectorID: number | null
    SectorCode: number | null
    SectorName: string | null
  }

  export type Lkup_SectorCountAggregateOutputType = {
    SectorID: number
    SectorCode: number
    SectorName: number
    _all: number
  }


  export type Lkup_SectorAvgAggregateInputType = {
    SectorID?: true
    SectorCode?: true
  }

  export type Lkup_SectorSumAggregateInputType = {
    SectorID?: true
    SectorCode?: true
  }

  export type Lkup_SectorMinAggregateInputType = {
    SectorID?: true
    SectorCode?: true
    SectorName?: true
  }

  export type Lkup_SectorMaxAggregateInputType = {
    SectorID?: true
    SectorCode?: true
    SectorName?: true
  }

  export type Lkup_SectorCountAggregateInputType = {
    SectorID?: true
    SectorCode?: true
    SectorName?: true
    _all?: true
  }

  export type Lkup_SectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Sector to aggregate.
     */
    where?: Lkup_SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Sectors to fetch.
     */
    orderBy?: Lkup_SectorOrderByWithRelationInput | Lkup_SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_Sectors
    **/
    _count?: true | Lkup_SectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_SectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_SectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_SectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_SectorMaxAggregateInputType
  }

  export type GetLkup_SectorAggregateType<T extends Lkup_SectorAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_Sector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_Sector[P]>
      : GetScalarType<T[P], AggregateLkup_Sector[P]>
  }




  export type Lkup_SectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_SectorWhereInput
    orderBy?: Lkup_SectorOrderByWithAggregationInput | Lkup_SectorOrderByWithAggregationInput[]
    by: Lkup_SectorScalarFieldEnum[] | Lkup_SectorScalarFieldEnum
    having?: Lkup_SectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_SectorCountAggregateInputType | true
    _avg?: Lkup_SectorAvgAggregateInputType
    _sum?: Lkup_SectorSumAggregateInputType
    _min?: Lkup_SectorMinAggregateInputType
    _max?: Lkup_SectorMaxAggregateInputType
  }

  export type Lkup_SectorGroupByOutputType = {
    SectorID: number
    SectorCode: number | null
    SectorName: string | null
    _count: Lkup_SectorCountAggregateOutputType | null
    _avg: Lkup_SectorAvgAggregateOutputType | null
    _sum: Lkup_SectorSumAggregateOutputType | null
    _min: Lkup_SectorMinAggregateOutputType | null
    _max: Lkup_SectorMaxAggregateOutputType | null
  }

  type GetLkup_SectorGroupByPayload<T extends Lkup_SectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_SectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_SectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_SectorGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_SectorGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_SectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SectorID?: boolean
    SectorCode?: boolean
    SectorName?: boolean
  }, ExtArgs["result"]["lkup_Sector"]>


  export type Lkup_SectorSelectScalar = {
    SectorID?: boolean
    SectorCode?: boolean
    SectorName?: boolean
  }


  export type $Lkup_SectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_Sector"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SectorID: number
      SectorCode: number | null
      SectorName: string | null
    }, ExtArgs["result"]["lkup_Sector"]>
    composites: {}
  }

  type Lkup_SectorGetPayload<S extends boolean | null | undefined | Lkup_SectorDefaultArgs> = $Result.GetResult<Prisma.$Lkup_SectorPayload, S>

  type Lkup_SectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_SectorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_SectorCountAggregateInputType | true
    }

  export interface Lkup_SectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_Sector'], meta: { name: 'Lkup_Sector' } }
    /**
     * Find zero or one Lkup_Sector that matches the filter.
     * @param {Lkup_SectorFindUniqueArgs} args - Arguments to find a Lkup_Sector
     * @example
     * // Get one Lkup_Sector
     * const lkup_Sector = await prisma.lkup_Sector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_SectorFindUniqueArgs>(args: SelectSubset<T, Lkup_SectorFindUniqueArgs<ExtArgs>>): Prisma__Lkup_SectorClient<$Result.GetResult<Prisma.$Lkup_SectorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_Sector that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_SectorFindUniqueOrThrowArgs} args - Arguments to find a Lkup_Sector
     * @example
     * // Get one Lkup_Sector
     * const lkup_Sector = await prisma.lkup_Sector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_SectorFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_SectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_SectorClient<$Result.GetResult<Prisma.$Lkup_SectorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_Sector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SectorFindFirstArgs} args - Arguments to find a Lkup_Sector
     * @example
     * // Get one Lkup_Sector
     * const lkup_Sector = await prisma.lkup_Sector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_SectorFindFirstArgs>(args?: SelectSubset<T, Lkup_SectorFindFirstArgs<ExtArgs>>): Prisma__Lkup_SectorClient<$Result.GetResult<Prisma.$Lkup_SectorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_Sector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SectorFindFirstOrThrowArgs} args - Arguments to find a Lkup_Sector
     * @example
     * // Get one Lkup_Sector
     * const lkup_Sector = await prisma.lkup_Sector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_SectorFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_SectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_SectorClient<$Result.GetResult<Prisma.$Lkup_SectorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_Sectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_Sectors
     * const lkup_Sectors = await prisma.lkup_Sector.findMany()
     * 
     * // Get first 10 Lkup_Sectors
     * const lkup_Sectors = await prisma.lkup_Sector.findMany({ take: 10 })
     * 
     * // Only select the `SectorID`
     * const lkup_SectorWithSectorIDOnly = await prisma.lkup_Sector.findMany({ select: { SectorID: true } })
     * 
     */
    findMany<T extends Lkup_SectorFindManyArgs>(args?: SelectSubset<T, Lkup_SectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_SectorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_Sector.
     * @param {Lkup_SectorCreateArgs} args - Arguments to create a Lkup_Sector.
     * @example
     * // Create one Lkup_Sector
     * const Lkup_Sector = await prisma.lkup_Sector.create({
     *   data: {
     *     // ... data to create a Lkup_Sector
     *   }
     * })
     * 
     */
    create<T extends Lkup_SectorCreateArgs>(args: SelectSubset<T, Lkup_SectorCreateArgs<ExtArgs>>): Prisma__Lkup_SectorClient<$Result.GetResult<Prisma.$Lkup_SectorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_Sectors.
     * @param {Lkup_SectorCreateManyArgs} args - Arguments to create many Lkup_Sectors.
     * @example
     * // Create many Lkup_Sectors
     * const lkup_Sector = await prisma.lkup_Sector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_SectorCreateManyArgs>(args?: SelectSubset<T, Lkup_SectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_Sector.
     * @param {Lkup_SectorDeleteArgs} args - Arguments to delete one Lkup_Sector.
     * @example
     * // Delete one Lkup_Sector
     * const Lkup_Sector = await prisma.lkup_Sector.delete({
     *   where: {
     *     // ... filter to delete one Lkup_Sector
     *   }
     * })
     * 
     */
    delete<T extends Lkup_SectorDeleteArgs>(args: SelectSubset<T, Lkup_SectorDeleteArgs<ExtArgs>>): Prisma__Lkup_SectorClient<$Result.GetResult<Prisma.$Lkup_SectorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_Sector.
     * @param {Lkup_SectorUpdateArgs} args - Arguments to update one Lkup_Sector.
     * @example
     * // Update one Lkup_Sector
     * const lkup_Sector = await prisma.lkup_Sector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_SectorUpdateArgs>(args: SelectSubset<T, Lkup_SectorUpdateArgs<ExtArgs>>): Prisma__Lkup_SectorClient<$Result.GetResult<Prisma.$Lkup_SectorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_Sectors.
     * @param {Lkup_SectorDeleteManyArgs} args - Arguments to filter Lkup_Sectors to delete.
     * @example
     * // Delete a few Lkup_Sectors
     * const { count } = await prisma.lkup_Sector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_SectorDeleteManyArgs>(args?: SelectSubset<T, Lkup_SectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_Sectors
     * const lkup_Sector = await prisma.lkup_Sector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_SectorUpdateManyArgs>(args: SelectSubset<T, Lkup_SectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_Sector.
     * @param {Lkup_SectorUpsertArgs} args - Arguments to update or create a Lkup_Sector.
     * @example
     * // Update or create a Lkup_Sector
     * const lkup_Sector = await prisma.lkup_Sector.upsert({
     *   create: {
     *     // ... data to create a Lkup_Sector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_Sector we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_SectorUpsertArgs>(args: SelectSubset<T, Lkup_SectorUpsertArgs<ExtArgs>>): Prisma__Lkup_SectorClient<$Result.GetResult<Prisma.$Lkup_SectorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SectorCountArgs} args - Arguments to filter Lkup_Sectors to count.
     * @example
     * // Count the number of Lkup_Sectors
     * const count = await prisma.lkup_Sector.count({
     *   where: {
     *     // ... the filter for the Lkup_Sectors we want to count
     *   }
     * })
    **/
    count<T extends Lkup_SectorCountArgs>(
      args?: Subset<T, Lkup_SectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_SectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_Sector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_SectorAggregateArgs>(args: Subset<T, Lkup_SectorAggregateArgs>): Prisma.PrismaPromise<GetLkup_SectorAggregateType<T>>

    /**
     * Group by Lkup_Sector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_SectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_SectorGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_SectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_SectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_SectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_Sector model
   */
  readonly fields: Lkup_SectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_Sector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_SectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_Sector model
   */ 
  interface Lkup_SectorFieldRefs {
    readonly SectorID: FieldRef<"Lkup_Sector", 'Int'>
    readonly SectorCode: FieldRef<"Lkup_Sector", 'Int'>
    readonly SectorName: FieldRef<"Lkup_Sector", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_Sector findUnique
   */
  export type Lkup_SectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Sector
     */
    select?: Lkup_SectorSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Sector to fetch.
     */
    where: Lkup_SectorWhereUniqueInput
  }

  /**
   * Lkup_Sector findUniqueOrThrow
   */
  export type Lkup_SectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Sector
     */
    select?: Lkup_SectorSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Sector to fetch.
     */
    where: Lkup_SectorWhereUniqueInput
  }

  /**
   * Lkup_Sector findFirst
   */
  export type Lkup_SectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Sector
     */
    select?: Lkup_SectorSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Sector to fetch.
     */
    where?: Lkup_SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Sectors to fetch.
     */
    orderBy?: Lkup_SectorOrderByWithRelationInput | Lkup_SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Sectors.
     */
    cursor?: Lkup_SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Sectors.
     */
    distinct?: Lkup_SectorScalarFieldEnum | Lkup_SectorScalarFieldEnum[]
  }

  /**
   * Lkup_Sector findFirstOrThrow
   */
  export type Lkup_SectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Sector
     */
    select?: Lkup_SectorSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Sector to fetch.
     */
    where?: Lkup_SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Sectors to fetch.
     */
    orderBy?: Lkup_SectorOrderByWithRelationInput | Lkup_SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_Sectors.
     */
    cursor?: Lkup_SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_Sectors.
     */
    distinct?: Lkup_SectorScalarFieldEnum | Lkup_SectorScalarFieldEnum[]
  }

  /**
   * Lkup_Sector findMany
   */
  export type Lkup_SectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Sector
     */
    select?: Lkup_SectorSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_Sectors to fetch.
     */
    where?: Lkup_SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_Sectors to fetch.
     */
    orderBy?: Lkup_SectorOrderByWithRelationInput | Lkup_SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_Sectors.
     */
    cursor?: Lkup_SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_Sectors.
     */
    skip?: number
    distinct?: Lkup_SectorScalarFieldEnum | Lkup_SectorScalarFieldEnum[]
  }

  /**
   * Lkup_Sector create
   */
  export type Lkup_SectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Sector
     */
    select?: Lkup_SectorSelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_Sector.
     */
    data?: XOR<Lkup_SectorCreateInput, Lkup_SectorUncheckedCreateInput>
  }

  /**
   * Lkup_Sector createMany
   */
  export type Lkup_SectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_Sectors.
     */
    data: Lkup_SectorCreateManyInput | Lkup_SectorCreateManyInput[]
  }

  /**
   * Lkup_Sector update
   */
  export type Lkup_SectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Sector
     */
    select?: Lkup_SectorSelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_Sector.
     */
    data: XOR<Lkup_SectorUpdateInput, Lkup_SectorUncheckedUpdateInput>
    /**
     * Choose, which Lkup_Sector to update.
     */
    where: Lkup_SectorWhereUniqueInput
  }

  /**
   * Lkup_Sector updateMany
   */
  export type Lkup_SectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_Sectors.
     */
    data: XOR<Lkup_SectorUpdateManyMutationInput, Lkup_SectorUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_Sectors to update
     */
    where?: Lkup_SectorWhereInput
  }

  /**
   * Lkup_Sector upsert
   */
  export type Lkup_SectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Sector
     */
    select?: Lkup_SectorSelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_Sector to update in case it exists.
     */
    where: Lkup_SectorWhereUniqueInput
    /**
     * In case the Lkup_Sector found by the `where` argument doesn't exist, create a new Lkup_Sector with this data.
     */
    create: XOR<Lkup_SectorCreateInput, Lkup_SectorUncheckedCreateInput>
    /**
     * In case the Lkup_Sector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_SectorUpdateInput, Lkup_SectorUncheckedUpdateInput>
  }

  /**
   * Lkup_Sector delete
   */
  export type Lkup_SectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Sector
     */
    select?: Lkup_SectorSelect<ExtArgs> | null
    /**
     * Filter which Lkup_Sector to delete.
     */
    where: Lkup_SectorWhereUniqueInput
  }

  /**
   * Lkup_Sector deleteMany
   */
  export type Lkup_SectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_Sectors to delete
     */
    where?: Lkup_SectorWhereInput
  }

  /**
   * Lkup_Sector without action
   */
  export type Lkup_SectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_Sector
     */
    select?: Lkup_SectorSelect<ExtArgs> | null
  }


  /**
   * Model Lkup_SocialSecuritySector
   */

  export type AggregateLkup_SocialSecuritySector = {
    _count: Lkup_SocialSecuritySectorCountAggregateOutputType | null
    _avg: Lkup_SocialSecuritySectorAvgAggregateOutputType | null
    _sum: Lkup_SocialSecuritySectorSumAggregateOutputType | null
    _min: Lkup_SocialSecuritySectorMinAggregateOutputType | null
    _max: Lkup_SocialSecuritySectorMaxAggregateOutputType | null
  }

  export type Lkup_SocialSecuritySectorAvgAggregateOutputType = {
    SocialSecurityID: number | null
    SocialSecurityCode: number | null
  }

  export type Lkup_SocialSecuritySectorSumAggregateOutputType = {
    SocialSecurityID: number | null
    SocialSecurityCode: number | null
  }

  export type Lkup_SocialSecuritySectorMinAggregateOutputType = {
    SocialSecurityID: number | null
    SocialSecurityCode: number | null
    SocialSecurityName: string | null
  }

  export type Lkup_SocialSecuritySectorMaxAggregateOutputType = {
    SocialSecurityID: number | null
    SocialSecurityCode: number | null
    SocialSecurityName: string | null
  }

  export type Lkup_SocialSecuritySectorCountAggregateOutputType = {
    SocialSecurityID: number
    SocialSecurityCode: number
    SocialSecurityName: number
    _all: number
  }


  export type Lkup_SocialSecuritySectorAvgAggregateInputType = {
    SocialSecurityID?: true
    SocialSecurityCode?: true
  }

  export type Lkup_SocialSecuritySectorSumAggregateInputType = {
    SocialSecurityID?: true
    SocialSecurityCode?: true
  }

  export type Lkup_SocialSecuritySectorMinAggregateInputType = {
    SocialSecurityID?: true
    SocialSecurityCode?: true
    SocialSecurityName?: true
  }

  export type Lkup_SocialSecuritySectorMaxAggregateInputType = {
    SocialSecurityID?: true
    SocialSecurityCode?: true
    SocialSecurityName?: true
  }

  export type Lkup_SocialSecuritySectorCountAggregateInputType = {
    SocialSecurityID?: true
    SocialSecurityCode?: true
    SocialSecurityName?: true
    _all?: true
  }

  export type Lkup_SocialSecuritySectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_SocialSecuritySector to aggregate.
     */
    where?: Lkup_SocialSecuritySectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_SocialSecuritySectors to fetch.
     */
    orderBy?: Lkup_SocialSecuritySectorOrderByWithRelationInput | Lkup_SocialSecuritySectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_SocialSecuritySectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_SocialSecuritySectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_SocialSecuritySectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_SocialSecuritySectors
    **/
    _count?: true | Lkup_SocialSecuritySectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_SocialSecuritySectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_SocialSecuritySectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_SocialSecuritySectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_SocialSecuritySectorMaxAggregateInputType
  }

  export type GetLkup_SocialSecuritySectorAggregateType<T extends Lkup_SocialSecuritySectorAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_SocialSecuritySector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_SocialSecuritySector[P]>
      : GetScalarType<T[P], AggregateLkup_SocialSecuritySector[P]>
  }




  export type Lkup_SocialSecuritySectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_SocialSecuritySectorWhereInput
    orderBy?: Lkup_SocialSecuritySectorOrderByWithAggregationInput | Lkup_SocialSecuritySectorOrderByWithAggregationInput[]
    by: Lkup_SocialSecuritySectorScalarFieldEnum[] | Lkup_SocialSecuritySectorScalarFieldEnum
    having?: Lkup_SocialSecuritySectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_SocialSecuritySectorCountAggregateInputType | true
    _avg?: Lkup_SocialSecuritySectorAvgAggregateInputType
    _sum?: Lkup_SocialSecuritySectorSumAggregateInputType
    _min?: Lkup_SocialSecuritySectorMinAggregateInputType
    _max?: Lkup_SocialSecuritySectorMaxAggregateInputType
  }

  export type Lkup_SocialSecuritySectorGroupByOutputType = {
    SocialSecurityID: number
    SocialSecurityCode: number
    SocialSecurityName: string
    _count: Lkup_SocialSecuritySectorCountAggregateOutputType | null
    _avg: Lkup_SocialSecuritySectorAvgAggregateOutputType | null
    _sum: Lkup_SocialSecuritySectorSumAggregateOutputType | null
    _min: Lkup_SocialSecuritySectorMinAggregateOutputType | null
    _max: Lkup_SocialSecuritySectorMaxAggregateOutputType | null
  }

  type GetLkup_SocialSecuritySectorGroupByPayload<T extends Lkup_SocialSecuritySectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_SocialSecuritySectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_SocialSecuritySectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_SocialSecuritySectorGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_SocialSecuritySectorGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_SocialSecuritySectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SocialSecurityID?: boolean
    SocialSecurityCode?: boolean
    SocialSecurityName?: boolean
  }, ExtArgs["result"]["lkup_SocialSecuritySector"]>


  export type Lkup_SocialSecuritySectorSelectScalar = {
    SocialSecurityID?: boolean
    SocialSecurityCode?: boolean
    SocialSecurityName?: boolean
  }


  export type $Lkup_SocialSecuritySectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_SocialSecuritySector"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SocialSecurityID: number
      SocialSecurityCode: number
      SocialSecurityName: string
    }, ExtArgs["result"]["lkup_SocialSecuritySector"]>
    composites: {}
  }

  type Lkup_SocialSecuritySectorGetPayload<S extends boolean | null | undefined | Lkup_SocialSecuritySectorDefaultArgs> = $Result.GetResult<Prisma.$Lkup_SocialSecuritySectorPayload, S>

  type Lkup_SocialSecuritySectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_SocialSecuritySectorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_SocialSecuritySectorCountAggregateInputType | true
    }

  export interface Lkup_SocialSecuritySectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_SocialSecuritySector'], meta: { name: 'Lkup_SocialSecuritySector' } }
    /**
     * Find zero or one Lkup_SocialSecuritySector that matches the filter.
     * @param {Lkup_SocialSecuritySectorFindUniqueArgs} args - Arguments to find a Lkup_SocialSecuritySector
     * @example
     * // Get one Lkup_SocialSecuritySector
     * const lkup_SocialSecuritySector = await prisma.lkup_SocialSecuritySector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_SocialSecuritySectorFindUniqueArgs>(args: SelectSubset<T, Lkup_SocialSecuritySectorFindUniqueArgs<ExtArgs>>): Prisma__Lkup_SocialSecuritySectorClient<$Result.GetResult<Prisma.$Lkup_SocialSecuritySectorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_SocialSecuritySector that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_SocialSecuritySectorFindUniqueOrThrowArgs} args - Arguments to find a Lkup_SocialSecuritySector
     * @example
     * // Get one Lkup_SocialSecuritySector
     * const lkup_SocialSecuritySector = await prisma.lkup_SocialSecuritySector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_SocialSecuritySectorFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_SocialSecuritySectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_SocialSecuritySectorClient<$Result.GetResult<Prisma.$Lkup_SocialSecuritySectorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_SocialSecuritySector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SocialSecuritySectorFindFirstArgs} args - Arguments to find a Lkup_SocialSecuritySector
     * @example
     * // Get one Lkup_SocialSecuritySector
     * const lkup_SocialSecuritySector = await prisma.lkup_SocialSecuritySector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_SocialSecuritySectorFindFirstArgs>(args?: SelectSubset<T, Lkup_SocialSecuritySectorFindFirstArgs<ExtArgs>>): Prisma__Lkup_SocialSecuritySectorClient<$Result.GetResult<Prisma.$Lkup_SocialSecuritySectorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_SocialSecuritySector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SocialSecuritySectorFindFirstOrThrowArgs} args - Arguments to find a Lkup_SocialSecuritySector
     * @example
     * // Get one Lkup_SocialSecuritySector
     * const lkup_SocialSecuritySector = await prisma.lkup_SocialSecuritySector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_SocialSecuritySectorFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_SocialSecuritySectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_SocialSecuritySectorClient<$Result.GetResult<Prisma.$Lkup_SocialSecuritySectorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_SocialSecuritySectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SocialSecuritySectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_SocialSecuritySectors
     * const lkup_SocialSecuritySectors = await prisma.lkup_SocialSecuritySector.findMany()
     * 
     * // Get first 10 Lkup_SocialSecuritySectors
     * const lkup_SocialSecuritySectors = await prisma.lkup_SocialSecuritySector.findMany({ take: 10 })
     * 
     * // Only select the `SocialSecurityID`
     * const lkup_SocialSecuritySectorWithSocialSecurityIDOnly = await prisma.lkup_SocialSecuritySector.findMany({ select: { SocialSecurityID: true } })
     * 
     */
    findMany<T extends Lkup_SocialSecuritySectorFindManyArgs>(args?: SelectSubset<T, Lkup_SocialSecuritySectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_SocialSecuritySectorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_SocialSecuritySector.
     * @param {Lkup_SocialSecuritySectorCreateArgs} args - Arguments to create a Lkup_SocialSecuritySector.
     * @example
     * // Create one Lkup_SocialSecuritySector
     * const Lkup_SocialSecuritySector = await prisma.lkup_SocialSecuritySector.create({
     *   data: {
     *     // ... data to create a Lkup_SocialSecuritySector
     *   }
     * })
     * 
     */
    create<T extends Lkup_SocialSecuritySectorCreateArgs>(args: SelectSubset<T, Lkup_SocialSecuritySectorCreateArgs<ExtArgs>>): Prisma__Lkup_SocialSecuritySectorClient<$Result.GetResult<Prisma.$Lkup_SocialSecuritySectorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_SocialSecuritySectors.
     * @param {Lkup_SocialSecuritySectorCreateManyArgs} args - Arguments to create many Lkup_SocialSecuritySectors.
     * @example
     * // Create many Lkup_SocialSecuritySectors
     * const lkup_SocialSecuritySector = await prisma.lkup_SocialSecuritySector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_SocialSecuritySectorCreateManyArgs>(args?: SelectSubset<T, Lkup_SocialSecuritySectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_SocialSecuritySector.
     * @param {Lkup_SocialSecuritySectorDeleteArgs} args - Arguments to delete one Lkup_SocialSecuritySector.
     * @example
     * // Delete one Lkup_SocialSecuritySector
     * const Lkup_SocialSecuritySector = await prisma.lkup_SocialSecuritySector.delete({
     *   where: {
     *     // ... filter to delete one Lkup_SocialSecuritySector
     *   }
     * })
     * 
     */
    delete<T extends Lkup_SocialSecuritySectorDeleteArgs>(args: SelectSubset<T, Lkup_SocialSecuritySectorDeleteArgs<ExtArgs>>): Prisma__Lkup_SocialSecuritySectorClient<$Result.GetResult<Prisma.$Lkup_SocialSecuritySectorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_SocialSecuritySector.
     * @param {Lkup_SocialSecuritySectorUpdateArgs} args - Arguments to update one Lkup_SocialSecuritySector.
     * @example
     * // Update one Lkup_SocialSecuritySector
     * const lkup_SocialSecuritySector = await prisma.lkup_SocialSecuritySector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_SocialSecuritySectorUpdateArgs>(args: SelectSubset<T, Lkup_SocialSecuritySectorUpdateArgs<ExtArgs>>): Prisma__Lkup_SocialSecuritySectorClient<$Result.GetResult<Prisma.$Lkup_SocialSecuritySectorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_SocialSecuritySectors.
     * @param {Lkup_SocialSecuritySectorDeleteManyArgs} args - Arguments to filter Lkup_SocialSecuritySectors to delete.
     * @example
     * // Delete a few Lkup_SocialSecuritySectors
     * const { count } = await prisma.lkup_SocialSecuritySector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_SocialSecuritySectorDeleteManyArgs>(args?: SelectSubset<T, Lkup_SocialSecuritySectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_SocialSecuritySectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SocialSecuritySectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_SocialSecuritySectors
     * const lkup_SocialSecuritySector = await prisma.lkup_SocialSecuritySector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_SocialSecuritySectorUpdateManyArgs>(args: SelectSubset<T, Lkup_SocialSecuritySectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_SocialSecuritySector.
     * @param {Lkup_SocialSecuritySectorUpsertArgs} args - Arguments to update or create a Lkup_SocialSecuritySector.
     * @example
     * // Update or create a Lkup_SocialSecuritySector
     * const lkup_SocialSecuritySector = await prisma.lkup_SocialSecuritySector.upsert({
     *   create: {
     *     // ... data to create a Lkup_SocialSecuritySector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_SocialSecuritySector we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_SocialSecuritySectorUpsertArgs>(args: SelectSubset<T, Lkup_SocialSecuritySectorUpsertArgs<ExtArgs>>): Prisma__Lkup_SocialSecuritySectorClient<$Result.GetResult<Prisma.$Lkup_SocialSecuritySectorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_SocialSecuritySectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SocialSecuritySectorCountArgs} args - Arguments to filter Lkup_SocialSecuritySectors to count.
     * @example
     * // Count the number of Lkup_SocialSecuritySectors
     * const count = await prisma.lkup_SocialSecuritySector.count({
     *   where: {
     *     // ... the filter for the Lkup_SocialSecuritySectors we want to count
     *   }
     * })
    **/
    count<T extends Lkup_SocialSecuritySectorCountArgs>(
      args?: Subset<T, Lkup_SocialSecuritySectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_SocialSecuritySectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_SocialSecuritySector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SocialSecuritySectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_SocialSecuritySectorAggregateArgs>(args: Subset<T, Lkup_SocialSecuritySectorAggregateArgs>): Prisma.PrismaPromise<GetLkup_SocialSecuritySectorAggregateType<T>>

    /**
     * Group by Lkup_SocialSecuritySector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_SocialSecuritySectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_SocialSecuritySectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_SocialSecuritySectorGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_SocialSecuritySectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_SocialSecuritySectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_SocialSecuritySectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_SocialSecuritySector model
   */
  readonly fields: Lkup_SocialSecuritySectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_SocialSecuritySector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_SocialSecuritySectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_SocialSecuritySector model
   */ 
  interface Lkup_SocialSecuritySectorFieldRefs {
    readonly SocialSecurityID: FieldRef<"Lkup_SocialSecuritySector", 'Int'>
    readonly SocialSecurityCode: FieldRef<"Lkup_SocialSecuritySector", 'Int'>
    readonly SocialSecurityName: FieldRef<"Lkup_SocialSecuritySector", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_SocialSecuritySector findUnique
   */
  export type Lkup_SocialSecuritySectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_SocialSecuritySector
     */
    select?: Lkup_SocialSecuritySectorSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_SocialSecuritySector to fetch.
     */
    where: Lkup_SocialSecuritySectorWhereUniqueInput
  }

  /**
   * Lkup_SocialSecuritySector findUniqueOrThrow
   */
  export type Lkup_SocialSecuritySectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_SocialSecuritySector
     */
    select?: Lkup_SocialSecuritySectorSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_SocialSecuritySector to fetch.
     */
    where: Lkup_SocialSecuritySectorWhereUniqueInput
  }

  /**
   * Lkup_SocialSecuritySector findFirst
   */
  export type Lkup_SocialSecuritySectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_SocialSecuritySector
     */
    select?: Lkup_SocialSecuritySectorSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_SocialSecuritySector to fetch.
     */
    where?: Lkup_SocialSecuritySectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_SocialSecuritySectors to fetch.
     */
    orderBy?: Lkup_SocialSecuritySectorOrderByWithRelationInput | Lkup_SocialSecuritySectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_SocialSecuritySectors.
     */
    cursor?: Lkup_SocialSecuritySectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_SocialSecuritySectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_SocialSecuritySectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_SocialSecuritySectors.
     */
    distinct?: Lkup_SocialSecuritySectorScalarFieldEnum | Lkup_SocialSecuritySectorScalarFieldEnum[]
  }

  /**
   * Lkup_SocialSecuritySector findFirstOrThrow
   */
  export type Lkup_SocialSecuritySectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_SocialSecuritySector
     */
    select?: Lkup_SocialSecuritySectorSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_SocialSecuritySector to fetch.
     */
    where?: Lkup_SocialSecuritySectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_SocialSecuritySectors to fetch.
     */
    orderBy?: Lkup_SocialSecuritySectorOrderByWithRelationInput | Lkup_SocialSecuritySectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_SocialSecuritySectors.
     */
    cursor?: Lkup_SocialSecuritySectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_SocialSecuritySectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_SocialSecuritySectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_SocialSecuritySectors.
     */
    distinct?: Lkup_SocialSecuritySectorScalarFieldEnum | Lkup_SocialSecuritySectorScalarFieldEnum[]
  }

  /**
   * Lkup_SocialSecuritySector findMany
   */
  export type Lkup_SocialSecuritySectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_SocialSecuritySector
     */
    select?: Lkup_SocialSecuritySectorSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_SocialSecuritySectors to fetch.
     */
    where?: Lkup_SocialSecuritySectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_SocialSecuritySectors to fetch.
     */
    orderBy?: Lkup_SocialSecuritySectorOrderByWithRelationInput | Lkup_SocialSecuritySectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_SocialSecuritySectors.
     */
    cursor?: Lkup_SocialSecuritySectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_SocialSecuritySectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_SocialSecuritySectors.
     */
    skip?: number
    distinct?: Lkup_SocialSecuritySectorScalarFieldEnum | Lkup_SocialSecuritySectorScalarFieldEnum[]
  }

  /**
   * Lkup_SocialSecuritySector create
   */
  export type Lkup_SocialSecuritySectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_SocialSecuritySector
     */
    select?: Lkup_SocialSecuritySectorSelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_SocialSecuritySector.
     */
    data: XOR<Lkup_SocialSecuritySectorCreateInput, Lkup_SocialSecuritySectorUncheckedCreateInput>
  }

  /**
   * Lkup_SocialSecuritySector createMany
   */
  export type Lkup_SocialSecuritySectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_SocialSecuritySectors.
     */
    data: Lkup_SocialSecuritySectorCreateManyInput | Lkup_SocialSecuritySectorCreateManyInput[]
  }

  /**
   * Lkup_SocialSecuritySector update
   */
  export type Lkup_SocialSecuritySectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_SocialSecuritySector
     */
    select?: Lkup_SocialSecuritySectorSelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_SocialSecuritySector.
     */
    data: XOR<Lkup_SocialSecuritySectorUpdateInput, Lkup_SocialSecuritySectorUncheckedUpdateInput>
    /**
     * Choose, which Lkup_SocialSecuritySector to update.
     */
    where: Lkup_SocialSecuritySectorWhereUniqueInput
  }

  /**
   * Lkup_SocialSecuritySector updateMany
   */
  export type Lkup_SocialSecuritySectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_SocialSecuritySectors.
     */
    data: XOR<Lkup_SocialSecuritySectorUpdateManyMutationInput, Lkup_SocialSecuritySectorUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_SocialSecuritySectors to update
     */
    where?: Lkup_SocialSecuritySectorWhereInput
  }

  /**
   * Lkup_SocialSecuritySector upsert
   */
  export type Lkup_SocialSecuritySectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_SocialSecuritySector
     */
    select?: Lkup_SocialSecuritySectorSelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_SocialSecuritySector to update in case it exists.
     */
    where: Lkup_SocialSecuritySectorWhereUniqueInput
    /**
     * In case the Lkup_SocialSecuritySector found by the `where` argument doesn't exist, create a new Lkup_SocialSecuritySector with this data.
     */
    create: XOR<Lkup_SocialSecuritySectorCreateInput, Lkup_SocialSecuritySectorUncheckedCreateInput>
    /**
     * In case the Lkup_SocialSecuritySector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_SocialSecuritySectorUpdateInput, Lkup_SocialSecuritySectorUncheckedUpdateInput>
  }

  /**
   * Lkup_SocialSecuritySector delete
   */
  export type Lkup_SocialSecuritySectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_SocialSecuritySector
     */
    select?: Lkup_SocialSecuritySectorSelect<ExtArgs> | null
    /**
     * Filter which Lkup_SocialSecuritySector to delete.
     */
    where: Lkup_SocialSecuritySectorWhereUniqueInput
  }

  /**
   * Lkup_SocialSecuritySector deleteMany
   */
  export type Lkup_SocialSecuritySectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_SocialSecuritySectors to delete
     */
    where?: Lkup_SocialSecuritySectorWhereInput
  }

  /**
   * Lkup_SocialSecuritySector without action
   */
  export type Lkup_SocialSecuritySectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_SocialSecuritySector
     */
    select?: Lkup_SocialSecuritySectorSelect<ExtArgs> | null
  }


  /**
   * Model Lkup_street
   */

  export type AggregateLkup_street = {
    _count: Lkup_streetCountAggregateOutputType | null
    _avg: Lkup_streetAvgAggregateOutputType | null
    _sum: Lkup_streetSumAggregateOutputType | null
    _min: Lkup_streetMinAggregateOutputType | null
    _max: Lkup_streetMaxAggregateOutputType | null
  }

  export type Lkup_streetAvgAggregateOutputType = {
    StrretID: number | null
    StreetCode: number | null
    Citycode: number | null
  }

  export type Lkup_streetSumAggregateOutputType = {
    StrretID: number | null
    StreetCode: number | null
    Citycode: number | null
  }

  export type Lkup_streetMinAggregateOutputType = {
    StrretID: number | null
    StreetName: string | null
    StreetCode: number | null
    Citycode: number | null
    StreetNameEng: string | null
  }

  export type Lkup_streetMaxAggregateOutputType = {
    StrretID: number | null
    StreetName: string | null
    StreetCode: number | null
    Citycode: number | null
    StreetNameEng: string | null
  }

  export type Lkup_streetCountAggregateOutputType = {
    StrretID: number
    StreetName: number
    StreetCode: number
    Citycode: number
    StreetNameEng: number
    _all: number
  }


  export type Lkup_streetAvgAggregateInputType = {
    StrretID?: true
    StreetCode?: true
    Citycode?: true
  }

  export type Lkup_streetSumAggregateInputType = {
    StrretID?: true
    StreetCode?: true
    Citycode?: true
  }

  export type Lkup_streetMinAggregateInputType = {
    StrretID?: true
    StreetName?: true
    StreetCode?: true
    Citycode?: true
    StreetNameEng?: true
  }

  export type Lkup_streetMaxAggregateInputType = {
    StrretID?: true
    StreetName?: true
    StreetCode?: true
    Citycode?: true
    StreetNameEng?: true
  }

  export type Lkup_streetCountAggregateInputType = {
    StrretID?: true
    StreetName?: true
    StreetCode?: true
    Citycode?: true
    StreetNameEng?: true
    _all?: true
  }

  export type Lkup_streetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_street to aggregate.
     */
    where?: Lkup_streetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_streets to fetch.
     */
    orderBy?: Lkup_streetOrderByWithRelationInput | Lkup_streetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_streetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_streets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_streets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_streets
    **/
    _count?: true | Lkup_streetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_streetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_streetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_streetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_streetMaxAggregateInputType
  }

  export type GetLkup_streetAggregateType<T extends Lkup_streetAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_street]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_street[P]>
      : GetScalarType<T[P], AggregateLkup_street[P]>
  }




  export type Lkup_streetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_streetWhereInput
    orderBy?: Lkup_streetOrderByWithAggregationInput | Lkup_streetOrderByWithAggregationInput[]
    by: Lkup_streetScalarFieldEnum[] | Lkup_streetScalarFieldEnum
    having?: Lkup_streetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_streetCountAggregateInputType | true
    _avg?: Lkup_streetAvgAggregateInputType
    _sum?: Lkup_streetSumAggregateInputType
    _min?: Lkup_streetMinAggregateInputType
    _max?: Lkup_streetMaxAggregateInputType
  }

  export type Lkup_streetGroupByOutputType = {
    StrretID: number
    StreetName: string | null
    StreetCode: number | null
    Citycode: number | null
    StreetNameEng: string | null
    _count: Lkup_streetCountAggregateOutputType | null
    _avg: Lkup_streetAvgAggregateOutputType | null
    _sum: Lkup_streetSumAggregateOutputType | null
    _min: Lkup_streetMinAggregateOutputType | null
    _max: Lkup_streetMaxAggregateOutputType | null
  }

  type GetLkup_streetGroupByPayload<T extends Lkup_streetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_streetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_streetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_streetGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_streetGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_streetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    StrretID?: boolean
    StreetName?: boolean
    StreetCode?: boolean
    Citycode?: boolean
    StreetNameEng?: boolean
  }, ExtArgs["result"]["lkup_street"]>


  export type Lkup_streetSelectScalar = {
    StrretID?: boolean
    StreetName?: boolean
    StreetCode?: boolean
    Citycode?: boolean
    StreetNameEng?: boolean
  }


  export type $Lkup_streetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_street"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      StrretID: number
      StreetName: string | null
      StreetCode: number | null
      Citycode: number | null
      StreetNameEng: string | null
    }, ExtArgs["result"]["lkup_street"]>
    composites: {}
  }

  type Lkup_streetGetPayload<S extends boolean | null | undefined | Lkup_streetDefaultArgs> = $Result.GetResult<Prisma.$Lkup_streetPayload, S>

  type Lkup_streetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_streetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_streetCountAggregateInputType | true
    }

  export interface Lkup_streetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_street'], meta: { name: 'Lkup_street' } }
    /**
     * Find zero or one Lkup_street that matches the filter.
     * @param {Lkup_streetFindUniqueArgs} args - Arguments to find a Lkup_street
     * @example
     * // Get one Lkup_street
     * const lkup_street = await prisma.lkup_street.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_streetFindUniqueArgs>(args: SelectSubset<T, Lkup_streetFindUniqueArgs<ExtArgs>>): Prisma__Lkup_streetClient<$Result.GetResult<Prisma.$Lkup_streetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_street that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_streetFindUniqueOrThrowArgs} args - Arguments to find a Lkup_street
     * @example
     * // Get one Lkup_street
     * const lkup_street = await prisma.lkup_street.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_streetFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_streetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_streetClient<$Result.GetResult<Prisma.$Lkup_streetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_street that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_streetFindFirstArgs} args - Arguments to find a Lkup_street
     * @example
     * // Get one Lkup_street
     * const lkup_street = await prisma.lkup_street.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_streetFindFirstArgs>(args?: SelectSubset<T, Lkup_streetFindFirstArgs<ExtArgs>>): Prisma__Lkup_streetClient<$Result.GetResult<Prisma.$Lkup_streetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_street that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_streetFindFirstOrThrowArgs} args - Arguments to find a Lkup_street
     * @example
     * // Get one Lkup_street
     * const lkup_street = await prisma.lkup_street.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_streetFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_streetFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_streetClient<$Result.GetResult<Prisma.$Lkup_streetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_streets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_streetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_streets
     * const lkup_streets = await prisma.lkup_street.findMany()
     * 
     * // Get first 10 Lkup_streets
     * const lkup_streets = await prisma.lkup_street.findMany({ take: 10 })
     * 
     * // Only select the `StrretID`
     * const lkup_streetWithStrretIDOnly = await prisma.lkup_street.findMany({ select: { StrretID: true } })
     * 
     */
    findMany<T extends Lkup_streetFindManyArgs>(args?: SelectSubset<T, Lkup_streetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_streetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_street.
     * @param {Lkup_streetCreateArgs} args - Arguments to create a Lkup_street.
     * @example
     * // Create one Lkup_street
     * const Lkup_street = await prisma.lkup_street.create({
     *   data: {
     *     // ... data to create a Lkup_street
     *   }
     * })
     * 
     */
    create<T extends Lkup_streetCreateArgs>(args: SelectSubset<T, Lkup_streetCreateArgs<ExtArgs>>): Prisma__Lkup_streetClient<$Result.GetResult<Prisma.$Lkup_streetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_streets.
     * @param {Lkup_streetCreateManyArgs} args - Arguments to create many Lkup_streets.
     * @example
     * // Create many Lkup_streets
     * const lkup_street = await prisma.lkup_street.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_streetCreateManyArgs>(args?: SelectSubset<T, Lkup_streetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_street.
     * @param {Lkup_streetDeleteArgs} args - Arguments to delete one Lkup_street.
     * @example
     * // Delete one Lkup_street
     * const Lkup_street = await prisma.lkup_street.delete({
     *   where: {
     *     // ... filter to delete one Lkup_street
     *   }
     * })
     * 
     */
    delete<T extends Lkup_streetDeleteArgs>(args: SelectSubset<T, Lkup_streetDeleteArgs<ExtArgs>>): Prisma__Lkup_streetClient<$Result.GetResult<Prisma.$Lkup_streetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_street.
     * @param {Lkup_streetUpdateArgs} args - Arguments to update one Lkup_street.
     * @example
     * // Update one Lkup_street
     * const lkup_street = await prisma.lkup_street.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_streetUpdateArgs>(args: SelectSubset<T, Lkup_streetUpdateArgs<ExtArgs>>): Prisma__Lkup_streetClient<$Result.GetResult<Prisma.$Lkup_streetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_streets.
     * @param {Lkup_streetDeleteManyArgs} args - Arguments to filter Lkup_streets to delete.
     * @example
     * // Delete a few Lkup_streets
     * const { count } = await prisma.lkup_street.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_streetDeleteManyArgs>(args?: SelectSubset<T, Lkup_streetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_streets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_streetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_streets
     * const lkup_street = await prisma.lkup_street.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_streetUpdateManyArgs>(args: SelectSubset<T, Lkup_streetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_street.
     * @param {Lkup_streetUpsertArgs} args - Arguments to update or create a Lkup_street.
     * @example
     * // Update or create a Lkup_street
     * const lkup_street = await prisma.lkup_street.upsert({
     *   create: {
     *     // ... data to create a Lkup_street
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_street we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_streetUpsertArgs>(args: SelectSubset<T, Lkup_streetUpsertArgs<ExtArgs>>): Prisma__Lkup_streetClient<$Result.GetResult<Prisma.$Lkup_streetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_streets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_streetCountArgs} args - Arguments to filter Lkup_streets to count.
     * @example
     * // Count the number of Lkup_streets
     * const count = await prisma.lkup_street.count({
     *   where: {
     *     // ... the filter for the Lkup_streets we want to count
     *   }
     * })
    **/
    count<T extends Lkup_streetCountArgs>(
      args?: Subset<T, Lkup_streetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_streetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_street.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_streetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_streetAggregateArgs>(args: Subset<T, Lkup_streetAggregateArgs>): Prisma.PrismaPromise<GetLkup_streetAggregateType<T>>

    /**
     * Group by Lkup_street.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_streetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_streetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_streetGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_streetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_streetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_streetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_street model
   */
  readonly fields: Lkup_streetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_street.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_streetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_street model
   */ 
  interface Lkup_streetFieldRefs {
    readonly StrretID: FieldRef<"Lkup_street", 'Int'>
    readonly StreetName: FieldRef<"Lkup_street", 'String'>
    readonly StreetCode: FieldRef<"Lkup_street", 'Int'>
    readonly Citycode: FieldRef<"Lkup_street", 'Int'>
    readonly StreetNameEng: FieldRef<"Lkup_street", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_street findUnique
   */
  export type Lkup_streetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_street
     */
    select?: Lkup_streetSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_street to fetch.
     */
    where: Lkup_streetWhereUniqueInput
  }

  /**
   * Lkup_street findUniqueOrThrow
   */
  export type Lkup_streetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_street
     */
    select?: Lkup_streetSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_street to fetch.
     */
    where: Lkup_streetWhereUniqueInput
  }

  /**
   * Lkup_street findFirst
   */
  export type Lkup_streetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_street
     */
    select?: Lkup_streetSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_street to fetch.
     */
    where?: Lkup_streetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_streets to fetch.
     */
    orderBy?: Lkup_streetOrderByWithRelationInput | Lkup_streetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_streets.
     */
    cursor?: Lkup_streetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_streets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_streets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_streets.
     */
    distinct?: Lkup_streetScalarFieldEnum | Lkup_streetScalarFieldEnum[]
  }

  /**
   * Lkup_street findFirstOrThrow
   */
  export type Lkup_streetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_street
     */
    select?: Lkup_streetSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_street to fetch.
     */
    where?: Lkup_streetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_streets to fetch.
     */
    orderBy?: Lkup_streetOrderByWithRelationInput | Lkup_streetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_streets.
     */
    cursor?: Lkup_streetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_streets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_streets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_streets.
     */
    distinct?: Lkup_streetScalarFieldEnum | Lkup_streetScalarFieldEnum[]
  }

  /**
   * Lkup_street findMany
   */
  export type Lkup_streetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_street
     */
    select?: Lkup_streetSelect<ExtArgs> | null
    /**
     * Filter, which Lkup_streets to fetch.
     */
    where?: Lkup_streetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_streets to fetch.
     */
    orderBy?: Lkup_streetOrderByWithRelationInput | Lkup_streetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_streets.
     */
    cursor?: Lkup_streetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_streets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_streets.
     */
    skip?: number
    distinct?: Lkup_streetScalarFieldEnum | Lkup_streetScalarFieldEnum[]
  }

  /**
   * Lkup_street create
   */
  export type Lkup_streetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_street
     */
    select?: Lkup_streetSelect<ExtArgs> | null
    /**
     * The data needed to create a Lkup_street.
     */
    data?: XOR<Lkup_streetCreateInput, Lkup_streetUncheckedCreateInput>
  }

  /**
   * Lkup_street createMany
   */
  export type Lkup_streetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_streets.
     */
    data: Lkup_streetCreateManyInput | Lkup_streetCreateManyInput[]
  }

  /**
   * Lkup_street update
   */
  export type Lkup_streetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_street
     */
    select?: Lkup_streetSelect<ExtArgs> | null
    /**
     * The data needed to update a Lkup_street.
     */
    data: XOR<Lkup_streetUpdateInput, Lkup_streetUncheckedUpdateInput>
    /**
     * Choose, which Lkup_street to update.
     */
    where: Lkup_streetWhereUniqueInput
  }

  /**
   * Lkup_street updateMany
   */
  export type Lkup_streetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_streets.
     */
    data: XOR<Lkup_streetUpdateManyMutationInput, Lkup_streetUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_streets to update
     */
    where?: Lkup_streetWhereInput
  }

  /**
   * Lkup_street upsert
   */
  export type Lkup_streetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_street
     */
    select?: Lkup_streetSelect<ExtArgs> | null
    /**
     * The filter to search for the Lkup_street to update in case it exists.
     */
    where: Lkup_streetWhereUniqueInput
    /**
     * In case the Lkup_street found by the `where` argument doesn't exist, create a new Lkup_street with this data.
     */
    create: XOR<Lkup_streetCreateInput, Lkup_streetUncheckedCreateInput>
    /**
     * In case the Lkup_street was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_streetUpdateInput, Lkup_streetUncheckedUpdateInput>
  }

  /**
   * Lkup_street delete
   */
  export type Lkup_streetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_street
     */
    select?: Lkup_streetSelect<ExtArgs> | null
    /**
     * Filter which Lkup_street to delete.
     */
    where: Lkup_streetWhereUniqueInput
  }

  /**
   * Lkup_street deleteMany
   */
  export type Lkup_streetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_streets to delete
     */
    where?: Lkup_streetWhereInput
  }

  /**
   * Lkup_street without action
   */
  export type Lkup_streetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_street
     */
    select?: Lkup_streetSelect<ExtArgs> | null
  }


  /**
   * Model PensionDetail
   */

  export type AggregatePensionDetail = {
    _count: PensionDetailCountAggregateOutputType | null
    _avg: PensionDetailAvgAggregateOutputType | null
    _sum: PensionDetailSumAggregateOutputType | null
    _min: PensionDetailMinAggregateOutputType | null
    _max: PensionDetailMaxAggregateOutputType | null
  }

  export type PensionDetailAvgAggregateOutputType = {
    PensionDetailID: number | null
    TypePension: number | null
    StartYearPension: number | null
    EmployerRate: number | null
    EmployeeRate: number | null
    EmployerCompensationRate: number | null
    TotalPensionRate: number | null
    AvarageSalaryPension: number | null
    Deposit: number | null
  }

  export type PensionDetailSumAggregateOutputType = {
    PensionDetailID: number | null
    TypePension: number | null
    StartYearPension: number | null
    EmployerRate: number | null
    EmployeeRate: number | null
    EmployerCompensationRate: number | null
    TotalPensionRate: number | null
    AvarageSalaryPension: number | null
    Deposit: number | null
  }

  export type PensionDetailMinAggregateOutputType = {
    PensionDetailID: number | null
    TypePension: number | null
    StartYearPension: number | null
    EmployerRate: number | null
    EmployeeRate: number | null
    EmployerCompensationRate: number | null
    TotalPensionRate: number | null
    AvarageSalaryPension: number | null
    Deposit: number | null
  }

  export type PensionDetailMaxAggregateOutputType = {
    PensionDetailID: number | null
    TypePension: number | null
    StartYearPension: number | null
    EmployerRate: number | null
    EmployeeRate: number | null
    EmployerCompensationRate: number | null
    TotalPensionRate: number | null
    AvarageSalaryPension: number | null
    Deposit: number | null
  }

  export type PensionDetailCountAggregateOutputType = {
    PensionDetailID: number
    TypePension: number
    StartYearPension: number
    EmployerRate: number
    EmployeeRate: number
    EmployerCompensationRate: number
    TotalPensionRate: number
    AvarageSalaryPension: number
    Deposit: number
    _all: number
  }


  export type PensionDetailAvgAggregateInputType = {
    PensionDetailID?: true
    TypePension?: true
    StartYearPension?: true
    EmployerRate?: true
    EmployeeRate?: true
    EmployerCompensationRate?: true
    TotalPensionRate?: true
    AvarageSalaryPension?: true
    Deposit?: true
  }

  export type PensionDetailSumAggregateInputType = {
    PensionDetailID?: true
    TypePension?: true
    StartYearPension?: true
    EmployerRate?: true
    EmployeeRate?: true
    EmployerCompensationRate?: true
    TotalPensionRate?: true
    AvarageSalaryPension?: true
    Deposit?: true
  }

  export type PensionDetailMinAggregateInputType = {
    PensionDetailID?: true
    TypePension?: true
    StartYearPension?: true
    EmployerRate?: true
    EmployeeRate?: true
    EmployerCompensationRate?: true
    TotalPensionRate?: true
    AvarageSalaryPension?: true
    Deposit?: true
  }

  export type PensionDetailMaxAggregateInputType = {
    PensionDetailID?: true
    TypePension?: true
    StartYearPension?: true
    EmployerRate?: true
    EmployeeRate?: true
    EmployerCompensationRate?: true
    TotalPensionRate?: true
    AvarageSalaryPension?: true
    Deposit?: true
  }

  export type PensionDetailCountAggregateInputType = {
    PensionDetailID?: true
    TypePension?: true
    StartYearPension?: true
    EmployerRate?: true
    EmployeeRate?: true
    EmployerCompensationRate?: true
    TotalPensionRate?: true
    AvarageSalaryPension?: true
    Deposit?: true
    _all?: true
  }

  export type PensionDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PensionDetail to aggregate.
     */
    where?: PensionDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PensionDetails to fetch.
     */
    orderBy?: PensionDetailOrderByWithRelationInput | PensionDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PensionDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PensionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PensionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PensionDetails
    **/
    _count?: true | PensionDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PensionDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PensionDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PensionDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PensionDetailMaxAggregateInputType
  }

  export type GetPensionDetailAggregateType<T extends PensionDetailAggregateArgs> = {
        [P in keyof T & keyof AggregatePensionDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePensionDetail[P]>
      : GetScalarType<T[P], AggregatePensionDetail[P]>
  }




  export type PensionDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PensionDetailWhereInput
    orderBy?: PensionDetailOrderByWithAggregationInput | PensionDetailOrderByWithAggregationInput[]
    by: PensionDetailScalarFieldEnum[] | PensionDetailScalarFieldEnum
    having?: PensionDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PensionDetailCountAggregateInputType | true
    _avg?: PensionDetailAvgAggregateInputType
    _sum?: PensionDetailSumAggregateInputType
    _min?: PensionDetailMinAggregateInputType
    _max?: PensionDetailMaxAggregateInputType
  }

  export type PensionDetailGroupByOutputType = {
    PensionDetailID: number
    TypePension: number | null
    StartYearPension: number | null
    EmployerRate: number | null
    EmployeeRate: number | null
    EmployerCompensationRate: number | null
    TotalPensionRate: number | null
    AvarageSalaryPension: number | null
    Deposit: number | null
    _count: PensionDetailCountAggregateOutputType | null
    _avg: PensionDetailAvgAggregateOutputType | null
    _sum: PensionDetailSumAggregateOutputType | null
    _min: PensionDetailMinAggregateOutputType | null
    _max: PensionDetailMaxAggregateOutputType | null
  }

  type GetPensionDetailGroupByPayload<T extends PensionDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PensionDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PensionDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PensionDetailGroupByOutputType[P]>
            : GetScalarType<T[P], PensionDetailGroupByOutputType[P]>
        }
      >
    >


  export type PensionDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PensionDetailID?: boolean
    TypePension?: boolean
    StartYearPension?: boolean
    EmployerRate?: boolean
    EmployeeRate?: boolean
    EmployerCompensationRate?: boolean
    TotalPensionRate?: boolean
    AvarageSalaryPension?: boolean
    Deposit?: boolean
  }, ExtArgs["result"]["pensionDetail"]>


  export type PensionDetailSelectScalar = {
    PensionDetailID?: boolean
    TypePension?: boolean
    StartYearPension?: boolean
    EmployerRate?: boolean
    EmployeeRate?: boolean
    EmployerCompensationRate?: boolean
    TotalPensionRate?: boolean
    AvarageSalaryPension?: boolean
    Deposit?: boolean
  }


  export type $PensionDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PensionDetail"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      PensionDetailID: number
      TypePension: number | null
      StartYearPension: number | null
      EmployerRate: number | null
      EmployeeRate: number | null
      EmployerCompensationRate: number | null
      TotalPensionRate: number | null
      AvarageSalaryPension: number | null
      Deposit: number | null
    }, ExtArgs["result"]["pensionDetail"]>
    composites: {}
  }

  type PensionDetailGetPayload<S extends boolean | null | undefined | PensionDetailDefaultArgs> = $Result.GetResult<Prisma.$PensionDetailPayload, S>

  type PensionDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PensionDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PensionDetailCountAggregateInputType | true
    }

  export interface PensionDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PensionDetail'], meta: { name: 'PensionDetail' } }
    /**
     * Find zero or one PensionDetail that matches the filter.
     * @param {PensionDetailFindUniqueArgs} args - Arguments to find a PensionDetail
     * @example
     * // Get one PensionDetail
     * const pensionDetail = await prisma.pensionDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PensionDetailFindUniqueArgs>(args: SelectSubset<T, PensionDetailFindUniqueArgs<ExtArgs>>): Prisma__PensionDetailClient<$Result.GetResult<Prisma.$PensionDetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PensionDetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PensionDetailFindUniqueOrThrowArgs} args - Arguments to find a PensionDetail
     * @example
     * // Get one PensionDetail
     * const pensionDetail = await prisma.pensionDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PensionDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, PensionDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PensionDetailClient<$Result.GetResult<Prisma.$PensionDetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PensionDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PensionDetailFindFirstArgs} args - Arguments to find a PensionDetail
     * @example
     * // Get one PensionDetail
     * const pensionDetail = await prisma.pensionDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PensionDetailFindFirstArgs>(args?: SelectSubset<T, PensionDetailFindFirstArgs<ExtArgs>>): Prisma__PensionDetailClient<$Result.GetResult<Prisma.$PensionDetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PensionDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PensionDetailFindFirstOrThrowArgs} args - Arguments to find a PensionDetail
     * @example
     * // Get one PensionDetail
     * const pensionDetail = await prisma.pensionDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PensionDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, PensionDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__PensionDetailClient<$Result.GetResult<Prisma.$PensionDetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PensionDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PensionDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PensionDetails
     * const pensionDetails = await prisma.pensionDetail.findMany()
     * 
     * // Get first 10 PensionDetails
     * const pensionDetails = await prisma.pensionDetail.findMany({ take: 10 })
     * 
     * // Only select the `PensionDetailID`
     * const pensionDetailWithPensionDetailIDOnly = await prisma.pensionDetail.findMany({ select: { PensionDetailID: true } })
     * 
     */
    findMany<T extends PensionDetailFindManyArgs>(args?: SelectSubset<T, PensionDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PensionDetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PensionDetail.
     * @param {PensionDetailCreateArgs} args - Arguments to create a PensionDetail.
     * @example
     * // Create one PensionDetail
     * const PensionDetail = await prisma.pensionDetail.create({
     *   data: {
     *     // ... data to create a PensionDetail
     *   }
     * })
     * 
     */
    create<T extends PensionDetailCreateArgs>(args: SelectSubset<T, PensionDetailCreateArgs<ExtArgs>>): Prisma__PensionDetailClient<$Result.GetResult<Prisma.$PensionDetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PensionDetails.
     * @param {PensionDetailCreateManyArgs} args - Arguments to create many PensionDetails.
     * @example
     * // Create many PensionDetails
     * const pensionDetail = await prisma.pensionDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PensionDetailCreateManyArgs>(args?: SelectSubset<T, PensionDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PensionDetail.
     * @param {PensionDetailDeleteArgs} args - Arguments to delete one PensionDetail.
     * @example
     * // Delete one PensionDetail
     * const PensionDetail = await prisma.pensionDetail.delete({
     *   where: {
     *     // ... filter to delete one PensionDetail
     *   }
     * })
     * 
     */
    delete<T extends PensionDetailDeleteArgs>(args: SelectSubset<T, PensionDetailDeleteArgs<ExtArgs>>): Prisma__PensionDetailClient<$Result.GetResult<Prisma.$PensionDetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PensionDetail.
     * @param {PensionDetailUpdateArgs} args - Arguments to update one PensionDetail.
     * @example
     * // Update one PensionDetail
     * const pensionDetail = await prisma.pensionDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PensionDetailUpdateArgs>(args: SelectSubset<T, PensionDetailUpdateArgs<ExtArgs>>): Prisma__PensionDetailClient<$Result.GetResult<Prisma.$PensionDetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PensionDetails.
     * @param {PensionDetailDeleteManyArgs} args - Arguments to filter PensionDetails to delete.
     * @example
     * // Delete a few PensionDetails
     * const { count } = await prisma.pensionDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PensionDetailDeleteManyArgs>(args?: SelectSubset<T, PensionDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PensionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PensionDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PensionDetails
     * const pensionDetail = await prisma.pensionDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PensionDetailUpdateManyArgs>(args: SelectSubset<T, PensionDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PensionDetail.
     * @param {PensionDetailUpsertArgs} args - Arguments to update or create a PensionDetail.
     * @example
     * // Update or create a PensionDetail
     * const pensionDetail = await prisma.pensionDetail.upsert({
     *   create: {
     *     // ... data to create a PensionDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PensionDetail we want to update
     *   }
     * })
     */
    upsert<T extends PensionDetailUpsertArgs>(args: SelectSubset<T, PensionDetailUpsertArgs<ExtArgs>>): Prisma__PensionDetailClient<$Result.GetResult<Prisma.$PensionDetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PensionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PensionDetailCountArgs} args - Arguments to filter PensionDetails to count.
     * @example
     * // Count the number of PensionDetails
     * const count = await prisma.pensionDetail.count({
     *   where: {
     *     // ... the filter for the PensionDetails we want to count
     *   }
     * })
    **/
    count<T extends PensionDetailCountArgs>(
      args?: Subset<T, PensionDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PensionDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PensionDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PensionDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PensionDetailAggregateArgs>(args: Subset<T, PensionDetailAggregateArgs>): Prisma.PrismaPromise<GetPensionDetailAggregateType<T>>

    /**
     * Group by PensionDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PensionDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PensionDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PensionDetailGroupByArgs['orderBy'] }
        : { orderBy?: PensionDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PensionDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPensionDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PensionDetail model
   */
  readonly fields: PensionDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PensionDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PensionDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PensionDetail model
   */ 
  interface PensionDetailFieldRefs {
    readonly PensionDetailID: FieldRef<"PensionDetail", 'Int'>
    readonly TypePension: FieldRef<"PensionDetail", 'Int'>
    readonly StartYearPension: FieldRef<"PensionDetail", 'Int'>
    readonly EmployerRate: FieldRef<"PensionDetail", 'Float'>
    readonly EmployeeRate: FieldRef<"PensionDetail", 'Float'>
    readonly EmployerCompensationRate: FieldRef<"PensionDetail", 'Float'>
    readonly TotalPensionRate: FieldRef<"PensionDetail", 'Float'>
    readonly AvarageSalaryPension: FieldRef<"PensionDetail", 'Float'>
    readonly Deposit: FieldRef<"PensionDetail", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * PensionDetail findUnique
   */
  export type PensionDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PensionDetail
     */
    select?: PensionDetailSelect<ExtArgs> | null
    /**
     * Filter, which PensionDetail to fetch.
     */
    where: PensionDetailWhereUniqueInput
  }

  /**
   * PensionDetail findUniqueOrThrow
   */
  export type PensionDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PensionDetail
     */
    select?: PensionDetailSelect<ExtArgs> | null
    /**
     * Filter, which PensionDetail to fetch.
     */
    where: PensionDetailWhereUniqueInput
  }

  /**
   * PensionDetail findFirst
   */
  export type PensionDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PensionDetail
     */
    select?: PensionDetailSelect<ExtArgs> | null
    /**
     * Filter, which PensionDetail to fetch.
     */
    where?: PensionDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PensionDetails to fetch.
     */
    orderBy?: PensionDetailOrderByWithRelationInput | PensionDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PensionDetails.
     */
    cursor?: PensionDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PensionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PensionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PensionDetails.
     */
    distinct?: PensionDetailScalarFieldEnum | PensionDetailScalarFieldEnum[]
  }

  /**
   * PensionDetail findFirstOrThrow
   */
  export type PensionDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PensionDetail
     */
    select?: PensionDetailSelect<ExtArgs> | null
    /**
     * Filter, which PensionDetail to fetch.
     */
    where?: PensionDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PensionDetails to fetch.
     */
    orderBy?: PensionDetailOrderByWithRelationInput | PensionDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PensionDetails.
     */
    cursor?: PensionDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PensionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PensionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PensionDetails.
     */
    distinct?: PensionDetailScalarFieldEnum | PensionDetailScalarFieldEnum[]
  }

  /**
   * PensionDetail findMany
   */
  export type PensionDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PensionDetail
     */
    select?: PensionDetailSelect<ExtArgs> | null
    /**
     * Filter, which PensionDetails to fetch.
     */
    where?: PensionDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PensionDetails to fetch.
     */
    orderBy?: PensionDetailOrderByWithRelationInput | PensionDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PensionDetails.
     */
    cursor?: PensionDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PensionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PensionDetails.
     */
    skip?: number
    distinct?: PensionDetailScalarFieldEnum | PensionDetailScalarFieldEnum[]
  }

  /**
   * PensionDetail create
   */
  export type PensionDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PensionDetail
     */
    select?: PensionDetailSelect<ExtArgs> | null
    /**
     * The data needed to create a PensionDetail.
     */
    data?: XOR<PensionDetailCreateInput, PensionDetailUncheckedCreateInput>
  }

  /**
   * PensionDetail createMany
   */
  export type PensionDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PensionDetails.
     */
    data: PensionDetailCreateManyInput | PensionDetailCreateManyInput[]
  }

  /**
   * PensionDetail update
   */
  export type PensionDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PensionDetail
     */
    select?: PensionDetailSelect<ExtArgs> | null
    /**
     * The data needed to update a PensionDetail.
     */
    data: XOR<PensionDetailUpdateInput, PensionDetailUncheckedUpdateInput>
    /**
     * Choose, which PensionDetail to update.
     */
    where: PensionDetailWhereUniqueInput
  }

  /**
   * PensionDetail updateMany
   */
  export type PensionDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PensionDetails.
     */
    data: XOR<PensionDetailUpdateManyMutationInput, PensionDetailUncheckedUpdateManyInput>
    /**
     * Filter which PensionDetails to update
     */
    where?: PensionDetailWhereInput
  }

  /**
   * PensionDetail upsert
   */
  export type PensionDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PensionDetail
     */
    select?: PensionDetailSelect<ExtArgs> | null
    /**
     * The filter to search for the PensionDetail to update in case it exists.
     */
    where: PensionDetailWhereUniqueInput
    /**
     * In case the PensionDetail found by the `where` argument doesn't exist, create a new PensionDetail with this data.
     */
    create: XOR<PensionDetailCreateInput, PensionDetailUncheckedCreateInput>
    /**
     * In case the PensionDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PensionDetailUpdateInput, PensionDetailUncheckedUpdateInput>
  }

  /**
   * PensionDetail delete
   */
  export type PensionDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PensionDetail
     */
    select?: PensionDetailSelect<ExtArgs> | null
    /**
     * Filter which PensionDetail to delete.
     */
    where: PensionDetailWhereUniqueInput
  }

  /**
   * PensionDetail deleteMany
   */
  export type PensionDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PensionDetails to delete
     */
    where?: PensionDetailWhereInput
  }

  /**
   * PensionDetail without action
   */
  export type PensionDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PensionDetail
     */
    select?: PensionDetailSelect<ExtArgs> | null
  }


  /**
   * Model Products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsMinAggregateOutputType = {
    ProductsId: string | null
    ProductName: string | null
    ProductDescription: string | null
  }

  export type ProductsMaxAggregateOutputType = {
    ProductsId: string | null
    ProductName: string | null
    ProductDescription: string | null
  }

  export type ProductsCountAggregateOutputType = {
    ProductsId: number
    ProductName: number
    ProductDescription: number
    _all: number
  }


  export type ProductsMinAggregateInputType = {
    ProductsId?: true
    ProductName?: true
    ProductDescription?: true
  }

  export type ProductsMaxAggregateInputType = {
    ProductsId?: true
    ProductName?: true
    ProductDescription?: true
  }

  export type ProductsCountAggregateInputType = {
    ProductsId?: true
    ProductName?: true
    ProductDescription?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to aggregate.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type ProductsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithAggregationInput | ProductsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: ProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    ProductsId: string
    ProductName: string
    ProductDescription: string | null
    _count: ProductsCountAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends ProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type ProductsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ProductsId?: boolean
    ProductName?: boolean
    ProductDescription?: boolean
    CompaniesProducts?: boolean | Products$CompaniesProductsArgs<ExtArgs>
    CompaniesProductsExpireDates?: boolean | Products$CompaniesProductsExpireDatesArgs<ExtArgs>
    CompaniesUsersProductsExpireDates?: boolean | Products$CompaniesUsersProductsExpireDatesArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>


  export type ProductsSelectScalar = {
    ProductsId?: boolean
    ProductName?: boolean
    ProductDescription?: boolean
  }

  export type ProductsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CompaniesProducts?: boolean | Products$CompaniesProductsArgs<ExtArgs>
    CompaniesProductsExpireDates?: boolean | Products$CompaniesProductsExpireDatesArgs<ExtArgs>
    CompaniesUsersProductsExpireDates?: boolean | Products$CompaniesUsersProductsExpireDatesArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Products"
    objects: {
      CompaniesProducts: Prisma.$CompaniesProductsPayload<ExtArgs>[]
      CompaniesProductsExpireDates: Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>[]
      CompaniesUsersProductsExpireDates: Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ProductsId: string
      ProductName: string
      ProductDescription: string | null
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type ProductsGetPayload<S extends boolean | null | undefined | ProductsDefaultArgs> = $Result.GetResult<Prisma.$ProductsPayload, S>

  type ProductsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface ProductsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Products'], meta: { name: 'Products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {ProductsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductsFindUniqueArgs>(args: SelectSubset<T, ProductsFindUniqueArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductsFindFirstArgs>(args?: SelectSubset<T, ProductsFindFirstArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `ProductsId`
     * const productsWithProductsIdOnly = await prisma.products.findMany({ select: { ProductsId: true } })
     * 
     */
    findMany<T extends ProductsFindManyArgs>(args?: SelectSubset<T, ProductsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Products.
     * @param {ProductsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends ProductsCreateArgs>(args: SelectSubset<T, ProductsCreateArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductsCreateManyArgs>(args?: SelectSubset<T, ProductsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Products.
     * @param {ProductsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends ProductsDeleteArgs>(args: SelectSubset<T, ProductsDeleteArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Products.
     * @param {ProductsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductsUpdateArgs>(args: SelectSubset<T, ProductsUpdateArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductsDeleteManyArgs>(args?: SelectSubset<T, ProductsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductsUpdateManyArgs>(args: SelectSubset<T, ProductsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Products.
     * @param {ProductsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends ProductsUpsertArgs>(args: SelectSubset<T, ProductsUpsertArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductsCountArgs>(
      args?: Subset<T, ProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductsGroupByArgs['orderBy'] }
        : { orderBy?: ProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Products model
   */
  readonly fields: ProductsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CompaniesProducts<T extends Products$CompaniesProductsArgs<ExtArgs> = {}>(args?: Subset<T, Products$CompaniesProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesProductsPayload<ExtArgs>, T, "findMany"> | Null>
    CompaniesProductsExpireDates<T extends Products$CompaniesProductsExpireDatesArgs<ExtArgs> = {}>(args?: Subset<T, Products$CompaniesProductsExpireDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesProductsExpireDatesPayload<ExtArgs>, T, "findMany"> | Null>
    CompaniesUsersProductsExpireDates<T extends Products$CompaniesUsersProductsExpireDatesArgs<ExtArgs> = {}>(args?: Subset<T, Products$CompaniesUsersProductsExpireDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUsersProductsExpireDatesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Products model
   */ 
  interface ProductsFieldRefs {
    readonly ProductsId: FieldRef<"Products", 'String'>
    readonly ProductName: FieldRef<"Products", 'String'>
    readonly ProductDescription: FieldRef<"Products", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Products findUnique
   */
  export type ProductsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findUniqueOrThrow
   */
  export type ProductsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findFirst
   */
  export type ProductsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products findFirstOrThrow
   */
  export type ProductsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products findMany
   */
  export type ProductsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products create
   */
  export type ProductsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The data needed to create a Products.
     */
    data: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
  }

  /**
   * Products createMany
   */
  export type ProductsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductsCreateManyInput | ProductsCreateManyInput[]
  }

  /**
   * Products update
   */
  export type ProductsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The data needed to update a Products.
     */
    data: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
    /**
     * Choose, which Products to update.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products updateMany
   */
  export type ProductsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductsWhereInput
  }

  /**
   * Products upsert
   */
  export type ProductsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The filter to search for the Products to update in case it exists.
     */
    where: ProductsWhereUniqueInput
    /**
     * In case the Products found by the `where` argument doesn't exist, create a new Products with this data.
     */
    create: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
    /**
     * In case the Products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
  }

  /**
   * Products delete
   */
  export type ProductsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter which Products to delete.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products deleteMany
   */
  export type ProductsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductsWhereInput
  }

  /**
   * Products.CompaniesProducts
   */
  export type Products$CompaniesProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProducts
     */
    select?: CompaniesProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsInclude<ExtArgs> | null
    where?: CompaniesProductsWhereInput
    orderBy?: CompaniesProductsOrderByWithRelationInput | CompaniesProductsOrderByWithRelationInput[]
    cursor?: CompaniesProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesProductsScalarFieldEnum | CompaniesProductsScalarFieldEnum[]
  }

  /**
   * Products.CompaniesProductsExpireDates
   */
  export type Products$CompaniesProductsExpireDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesProductsExpireDates
     */
    select?: CompaniesProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesProductsExpireDatesInclude<ExtArgs> | null
    where?: CompaniesProductsExpireDatesWhereInput
    orderBy?: CompaniesProductsExpireDatesOrderByWithRelationInput | CompaniesProductsExpireDatesOrderByWithRelationInput[]
    cursor?: CompaniesProductsExpireDatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesProductsExpireDatesScalarFieldEnum | CompaniesProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * Products.CompaniesUsersProductsExpireDates
   */
  export type Products$CompaniesUsersProductsExpireDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUsersProductsExpireDates
     */
    select?: CompaniesUsersProductsExpireDatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUsersProductsExpireDatesInclude<ExtArgs> | null
    where?: CompaniesUsersProductsExpireDatesWhereInput
    orderBy?: CompaniesUsersProductsExpireDatesOrderByWithRelationInput | CompaniesUsersProductsExpireDatesOrderByWithRelationInput[]
    cursor?: CompaniesUsersProductsExpireDatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesUsersProductsExpireDatesScalarFieldEnum | CompaniesUsersProductsExpireDatesScalarFieldEnum[]
  }

  /**
   * Products without action
   */
  export type ProductsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
  }


  /**
   * Model Rank
   */

  export type AggregateRank = {
    _count: RankCountAggregateOutputType | null
    _avg: RankAvgAggregateOutputType | null
    _sum: RankSumAggregateOutputType | null
    _min: RankMinAggregateOutputType | null
    _max: RankMaxAggregateOutputType | null
  }

  export type RankAvgAggregateOutputType = {
    RankID: number | null
    SectorCode: number | null
    RankYear: number | null
    RankMonth: number | null
    RankCode: number | null
    Salary: number | null
    RankNumber: number | null
  }

  export type RankSumAggregateOutputType = {
    RankID: number | null
    SectorCode: number | null
    RankYear: number | null
    RankMonth: number | null
    RankCode: number | null
    Salary: number | null
    RankNumber: number | null
  }

  export type RankMinAggregateOutputType = {
    RankID: number | null
    SectorCode: number | null
    RankYear: number | null
    RankMonth: number | null
    RankCode: number | null
    RankName: string | null
    Salary: number | null
    RankNumber: number | null
  }

  export type RankMaxAggregateOutputType = {
    RankID: number | null
    SectorCode: number | null
    RankYear: number | null
    RankMonth: number | null
    RankCode: number | null
    RankName: string | null
    Salary: number | null
    RankNumber: number | null
  }

  export type RankCountAggregateOutputType = {
    RankID: number
    SectorCode: number
    RankYear: number
    RankMonth: number
    RankCode: number
    RankName: number
    Salary: number
    RankNumber: number
    _all: number
  }


  export type RankAvgAggregateInputType = {
    RankID?: true
    SectorCode?: true
    RankYear?: true
    RankMonth?: true
    RankCode?: true
    Salary?: true
    RankNumber?: true
  }

  export type RankSumAggregateInputType = {
    RankID?: true
    SectorCode?: true
    RankYear?: true
    RankMonth?: true
    RankCode?: true
    Salary?: true
    RankNumber?: true
  }

  export type RankMinAggregateInputType = {
    RankID?: true
    SectorCode?: true
    RankYear?: true
    RankMonth?: true
    RankCode?: true
    RankName?: true
    Salary?: true
    RankNumber?: true
  }

  export type RankMaxAggregateInputType = {
    RankID?: true
    SectorCode?: true
    RankYear?: true
    RankMonth?: true
    RankCode?: true
    RankName?: true
    Salary?: true
    RankNumber?: true
  }

  export type RankCountAggregateInputType = {
    RankID?: true
    SectorCode?: true
    RankYear?: true
    RankMonth?: true
    RankCode?: true
    RankName?: true
    Salary?: true
    RankNumber?: true
    _all?: true
  }

  export type RankAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rank to aggregate.
     */
    where?: RankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RankOrderByWithRelationInput | RankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ranks
    **/
    _count?: true | RankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RankAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RankSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankMaxAggregateInputType
  }

  export type GetRankAggregateType<T extends RankAggregateArgs> = {
        [P in keyof T & keyof AggregateRank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRank[P]>
      : GetScalarType<T[P], AggregateRank[P]>
  }




  export type RankGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RankWhereInput
    orderBy?: RankOrderByWithAggregationInput | RankOrderByWithAggregationInput[]
    by: RankScalarFieldEnum[] | RankScalarFieldEnum
    having?: RankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankCountAggregateInputType | true
    _avg?: RankAvgAggregateInputType
    _sum?: RankSumAggregateInputType
    _min?: RankMinAggregateInputType
    _max?: RankMaxAggregateInputType
  }

  export type RankGroupByOutputType = {
    RankID: number
    SectorCode: number | null
    RankYear: number | null
    RankMonth: number | null
    RankCode: number | null
    RankName: string | null
    Salary: number | null
    RankNumber: number | null
    _count: RankCountAggregateOutputType | null
    _avg: RankAvgAggregateOutputType | null
    _sum: RankSumAggregateOutputType | null
    _min: RankMinAggregateOutputType | null
    _max: RankMaxAggregateOutputType | null
  }

  type GetRankGroupByPayload<T extends RankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankGroupByOutputType[P]>
            : GetScalarType<T[P], RankGroupByOutputType[P]>
        }
      >
    >


  export type RankSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    RankID?: boolean
    SectorCode?: boolean
    RankYear?: boolean
    RankMonth?: boolean
    RankCode?: boolean
    RankName?: boolean
    Salary?: boolean
    RankNumber?: boolean
  }, ExtArgs["result"]["rank"]>


  export type RankSelectScalar = {
    RankID?: boolean
    SectorCode?: boolean
    RankYear?: boolean
    RankMonth?: boolean
    RankCode?: boolean
    RankName?: boolean
    Salary?: boolean
    RankNumber?: boolean
  }


  export type $RankPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rank"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      RankID: number
      SectorCode: number | null
      RankYear: number | null
      RankMonth: number | null
      RankCode: number | null
      RankName: string | null
      Salary: number | null
      RankNumber: number | null
    }, ExtArgs["result"]["rank"]>
    composites: {}
  }

  type RankGetPayload<S extends boolean | null | undefined | RankDefaultArgs> = $Result.GetResult<Prisma.$RankPayload, S>

  type RankCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RankFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RankCountAggregateInputType | true
    }

  export interface RankDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rank'], meta: { name: 'Rank' } }
    /**
     * Find zero or one Rank that matches the filter.
     * @param {RankFindUniqueArgs} args - Arguments to find a Rank
     * @example
     * // Get one Rank
     * const rank = await prisma.rank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RankFindUniqueArgs>(args: SelectSubset<T, RankFindUniqueArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rank that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RankFindUniqueOrThrowArgs} args - Arguments to find a Rank
     * @example
     * // Get one Rank
     * const rank = await prisma.rank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RankFindUniqueOrThrowArgs>(args: SelectSubset<T, RankFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankFindFirstArgs} args - Arguments to find a Rank
     * @example
     * // Get one Rank
     * const rank = await prisma.rank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RankFindFirstArgs>(args?: SelectSubset<T, RankFindFirstArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rank that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankFindFirstOrThrowArgs} args - Arguments to find a Rank
     * @example
     * // Get one Rank
     * const rank = await prisma.rank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RankFindFirstOrThrowArgs>(args?: SelectSubset<T, RankFindFirstOrThrowArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ranks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ranks
     * const ranks = await prisma.rank.findMany()
     * 
     * // Get first 10 Ranks
     * const ranks = await prisma.rank.findMany({ take: 10 })
     * 
     * // Only select the `RankID`
     * const rankWithRankIDOnly = await prisma.rank.findMany({ select: { RankID: true } })
     * 
     */
    findMany<T extends RankFindManyArgs>(args?: SelectSubset<T, RankFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rank.
     * @param {RankCreateArgs} args - Arguments to create a Rank.
     * @example
     * // Create one Rank
     * const Rank = await prisma.rank.create({
     *   data: {
     *     // ... data to create a Rank
     *   }
     * })
     * 
     */
    create<T extends RankCreateArgs>(args: SelectSubset<T, RankCreateArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ranks.
     * @param {RankCreateManyArgs} args - Arguments to create many Ranks.
     * @example
     * // Create many Ranks
     * const rank = await prisma.rank.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RankCreateManyArgs>(args?: SelectSubset<T, RankCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rank.
     * @param {RankDeleteArgs} args - Arguments to delete one Rank.
     * @example
     * // Delete one Rank
     * const Rank = await prisma.rank.delete({
     *   where: {
     *     // ... filter to delete one Rank
     *   }
     * })
     * 
     */
    delete<T extends RankDeleteArgs>(args: SelectSubset<T, RankDeleteArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rank.
     * @param {RankUpdateArgs} args - Arguments to update one Rank.
     * @example
     * // Update one Rank
     * const rank = await prisma.rank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RankUpdateArgs>(args: SelectSubset<T, RankUpdateArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ranks.
     * @param {RankDeleteManyArgs} args - Arguments to filter Ranks to delete.
     * @example
     * // Delete a few Ranks
     * const { count } = await prisma.rank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RankDeleteManyArgs>(args?: SelectSubset<T, RankDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ranks
     * const rank = await prisma.rank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RankUpdateManyArgs>(args: SelectSubset<T, RankUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rank.
     * @param {RankUpsertArgs} args - Arguments to update or create a Rank.
     * @example
     * // Update or create a Rank
     * const rank = await prisma.rank.upsert({
     *   create: {
     *     // ... data to create a Rank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rank we want to update
     *   }
     * })
     */
    upsert<T extends RankUpsertArgs>(args: SelectSubset<T, RankUpsertArgs<ExtArgs>>): Prisma__RankClient<$Result.GetResult<Prisma.$RankPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankCountArgs} args - Arguments to filter Ranks to count.
     * @example
     * // Count the number of Ranks
     * const count = await prisma.rank.count({
     *   where: {
     *     // ... the filter for the Ranks we want to count
     *   }
     * })
    **/
    count<T extends RankCountArgs>(
      args?: Subset<T, RankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankAggregateArgs>(args: Subset<T, RankAggregateArgs>): Prisma.PrismaPromise<GetRankAggregateType<T>>

    /**
     * Group by Rank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RankGroupByArgs['orderBy'] }
        : { orderBy?: RankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rank model
   */
  readonly fields: RankFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RankClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rank model
   */ 
  interface RankFieldRefs {
    readonly RankID: FieldRef<"Rank", 'Int'>
    readonly SectorCode: FieldRef<"Rank", 'Int'>
    readonly RankYear: FieldRef<"Rank", 'Int'>
    readonly RankMonth: FieldRef<"Rank", 'Int'>
    readonly RankCode: FieldRef<"Rank", 'Int'>
    readonly RankName: FieldRef<"Rank", 'String'>
    readonly Salary: FieldRef<"Rank", 'Float'>
    readonly RankNumber: FieldRef<"Rank", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Rank findUnique
   */
  export type RankFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Filter, which Rank to fetch.
     */
    where: RankWhereUniqueInput
  }

  /**
   * Rank findUniqueOrThrow
   */
  export type RankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Filter, which Rank to fetch.
     */
    where: RankWhereUniqueInput
  }

  /**
   * Rank findFirst
   */
  export type RankFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Filter, which Rank to fetch.
     */
    where?: RankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RankOrderByWithRelationInput | RankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ranks.
     */
    cursor?: RankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ranks.
     */
    distinct?: RankScalarFieldEnum | RankScalarFieldEnum[]
  }

  /**
   * Rank findFirstOrThrow
   */
  export type RankFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Filter, which Rank to fetch.
     */
    where?: RankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RankOrderByWithRelationInput | RankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ranks.
     */
    cursor?: RankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ranks.
     */
    distinct?: RankScalarFieldEnum | RankScalarFieldEnum[]
  }

  /**
   * Rank findMany
   */
  export type RankFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Filter, which Ranks to fetch.
     */
    where?: RankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RankOrderByWithRelationInput | RankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ranks.
     */
    cursor?: RankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    distinct?: RankScalarFieldEnum | RankScalarFieldEnum[]
  }

  /**
   * Rank create
   */
  export type RankCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * The data needed to create a Rank.
     */
    data?: XOR<RankCreateInput, RankUncheckedCreateInput>
  }

  /**
   * Rank createMany
   */
  export type RankCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ranks.
     */
    data: RankCreateManyInput | RankCreateManyInput[]
  }

  /**
   * Rank update
   */
  export type RankUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * The data needed to update a Rank.
     */
    data: XOR<RankUpdateInput, RankUncheckedUpdateInput>
    /**
     * Choose, which Rank to update.
     */
    where: RankWhereUniqueInput
  }

  /**
   * Rank updateMany
   */
  export type RankUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ranks.
     */
    data: XOR<RankUpdateManyMutationInput, RankUncheckedUpdateManyInput>
    /**
     * Filter which Ranks to update
     */
    where?: RankWhereInput
  }

  /**
   * Rank upsert
   */
  export type RankUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * The filter to search for the Rank to update in case it exists.
     */
    where: RankWhereUniqueInput
    /**
     * In case the Rank found by the `where` argument doesn't exist, create a new Rank with this data.
     */
    create: XOR<RankCreateInput, RankUncheckedCreateInput>
    /**
     * In case the Rank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RankUpdateInput, RankUncheckedUpdateInput>
  }

  /**
   * Rank delete
   */
  export type RankDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
    /**
     * Filter which Rank to delete.
     */
    where: RankWhereUniqueInput
  }

  /**
   * Rank deleteMany
   */
  export type RankDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ranks to delete
     */
    where?: RankWhereInput
  }

  /**
   * Rank without action
   */
  export type RankDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rank
     */
    select?: RankSelect<ExtArgs> | null
  }


  /**
   * Model RecoveryDefinition
   */

  export type AggregateRecoveryDefinition = {
    _count: RecoveryDefinitionCountAggregateOutputType | null
    _avg: RecoveryDefinitionAvgAggregateOutputType | null
    _sum: RecoveryDefinitionSumAggregateOutputType | null
    _min: RecoveryDefinitionMinAggregateOutputType | null
    _max: RecoveryDefinitionMaxAggregateOutputType | null
  }

  export type RecoveryDefinitionAvgAggregateOutputType = {
    RecoveryDefinitionID: number | null
  }

  export type RecoveryDefinitionSumAggregateOutputType = {
    RecoveryDefinitionID: number | null
  }

  export type RecoveryDefinitionMinAggregateOutputType = {
    RecoveryDefinitionID: number | null
    RecoveryDefinitionName: string | null
    RecoveryYear: string | null
  }

  export type RecoveryDefinitionMaxAggregateOutputType = {
    RecoveryDefinitionID: number | null
    RecoveryDefinitionName: string | null
    RecoveryYear: string | null
  }

  export type RecoveryDefinitionCountAggregateOutputType = {
    RecoveryDefinitionID: number
    RecoveryDefinitionName: number
    RecoveryYear: number
    _all: number
  }


  export type RecoveryDefinitionAvgAggregateInputType = {
    RecoveryDefinitionID?: true
  }

  export type RecoveryDefinitionSumAggregateInputType = {
    RecoveryDefinitionID?: true
  }

  export type RecoveryDefinitionMinAggregateInputType = {
    RecoveryDefinitionID?: true
    RecoveryDefinitionName?: true
    RecoveryYear?: true
  }

  export type RecoveryDefinitionMaxAggregateInputType = {
    RecoveryDefinitionID?: true
    RecoveryDefinitionName?: true
    RecoveryYear?: true
  }

  export type RecoveryDefinitionCountAggregateInputType = {
    RecoveryDefinitionID?: true
    RecoveryDefinitionName?: true
    RecoveryYear?: true
    _all?: true
  }

  export type RecoveryDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryDefinition to aggregate.
     */
    where?: RecoveryDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryDefinitions to fetch.
     */
    orderBy?: RecoveryDefinitionOrderByWithRelationInput | RecoveryDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecoveryDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecoveryDefinitions
    **/
    _count?: true | RecoveryDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecoveryDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecoveryDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecoveryDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecoveryDefinitionMaxAggregateInputType
  }

  export type GetRecoveryDefinitionAggregateType<T extends RecoveryDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateRecoveryDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecoveryDefinition[P]>
      : GetScalarType<T[P], AggregateRecoveryDefinition[P]>
  }




  export type RecoveryDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryDefinitionWhereInput
    orderBy?: RecoveryDefinitionOrderByWithAggregationInput | RecoveryDefinitionOrderByWithAggregationInput[]
    by: RecoveryDefinitionScalarFieldEnum[] | RecoveryDefinitionScalarFieldEnum
    having?: RecoveryDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecoveryDefinitionCountAggregateInputType | true
    _avg?: RecoveryDefinitionAvgAggregateInputType
    _sum?: RecoveryDefinitionSumAggregateInputType
    _min?: RecoveryDefinitionMinAggregateInputType
    _max?: RecoveryDefinitionMaxAggregateInputType
  }

  export type RecoveryDefinitionGroupByOutputType = {
    RecoveryDefinitionID: number
    RecoveryDefinitionName: string | null
    RecoveryYear: string | null
    _count: RecoveryDefinitionCountAggregateOutputType | null
    _avg: RecoveryDefinitionAvgAggregateOutputType | null
    _sum: RecoveryDefinitionSumAggregateOutputType | null
    _min: RecoveryDefinitionMinAggregateOutputType | null
    _max: RecoveryDefinitionMaxAggregateOutputType | null
  }

  type GetRecoveryDefinitionGroupByPayload<T extends RecoveryDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecoveryDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecoveryDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecoveryDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], RecoveryDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type RecoveryDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    RecoveryDefinitionID?: boolean
    RecoveryDefinitionName?: boolean
    RecoveryYear?: boolean
    RecoveryDefinitionDetails?: boolean | RecoveryDefinition$RecoveryDefinitionDetailsArgs<ExtArgs>
    RecoveryDefinitionRateDetails?: boolean | RecoveryDefinition$RecoveryDefinitionRateDetailsArgs<ExtArgs>
    _count?: boolean | RecoveryDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryDefinition"]>


  export type RecoveryDefinitionSelectScalar = {
    RecoveryDefinitionID?: boolean
    RecoveryDefinitionName?: boolean
    RecoveryYear?: boolean
  }

  export type RecoveryDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RecoveryDefinitionDetails?: boolean | RecoveryDefinition$RecoveryDefinitionDetailsArgs<ExtArgs>
    RecoveryDefinitionRateDetails?: boolean | RecoveryDefinition$RecoveryDefinitionRateDetailsArgs<ExtArgs>
    _count?: boolean | RecoveryDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RecoveryDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecoveryDefinition"
    objects: {
      RecoveryDefinitionDetails: Prisma.$RecoveryDefinitionDetailsPayload<ExtArgs>[]
      RecoveryDefinitionRateDetails: Prisma.$RecoveryDefinitionRateDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      RecoveryDefinitionID: number
      RecoveryDefinitionName: string | null
      RecoveryYear: string | null
    }, ExtArgs["result"]["recoveryDefinition"]>
    composites: {}
  }

  type RecoveryDefinitionGetPayload<S extends boolean | null | undefined | RecoveryDefinitionDefaultArgs> = $Result.GetResult<Prisma.$RecoveryDefinitionPayload, S>

  type RecoveryDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecoveryDefinitionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecoveryDefinitionCountAggregateInputType | true
    }

  export interface RecoveryDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecoveryDefinition'], meta: { name: 'RecoveryDefinition' } }
    /**
     * Find zero or one RecoveryDefinition that matches the filter.
     * @param {RecoveryDefinitionFindUniqueArgs} args - Arguments to find a RecoveryDefinition
     * @example
     * // Get one RecoveryDefinition
     * const recoveryDefinition = await prisma.recoveryDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecoveryDefinitionFindUniqueArgs>(args: SelectSubset<T, RecoveryDefinitionFindUniqueArgs<ExtArgs>>): Prisma__RecoveryDefinitionClient<$Result.GetResult<Prisma.$RecoveryDefinitionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RecoveryDefinition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecoveryDefinitionFindUniqueOrThrowArgs} args - Arguments to find a RecoveryDefinition
     * @example
     * // Get one RecoveryDefinition
     * const recoveryDefinition = await prisma.recoveryDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecoveryDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, RecoveryDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecoveryDefinitionClient<$Result.GetResult<Prisma.$RecoveryDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RecoveryDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionFindFirstArgs} args - Arguments to find a RecoveryDefinition
     * @example
     * // Get one RecoveryDefinition
     * const recoveryDefinition = await prisma.recoveryDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecoveryDefinitionFindFirstArgs>(args?: SelectSubset<T, RecoveryDefinitionFindFirstArgs<ExtArgs>>): Prisma__RecoveryDefinitionClient<$Result.GetResult<Prisma.$RecoveryDefinitionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RecoveryDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionFindFirstOrThrowArgs} args - Arguments to find a RecoveryDefinition
     * @example
     * // Get one RecoveryDefinition
     * const recoveryDefinition = await prisma.recoveryDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecoveryDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, RecoveryDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecoveryDefinitionClient<$Result.GetResult<Prisma.$RecoveryDefinitionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RecoveryDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecoveryDefinitions
     * const recoveryDefinitions = await prisma.recoveryDefinition.findMany()
     * 
     * // Get first 10 RecoveryDefinitions
     * const recoveryDefinitions = await prisma.recoveryDefinition.findMany({ take: 10 })
     * 
     * // Only select the `RecoveryDefinitionID`
     * const recoveryDefinitionWithRecoveryDefinitionIDOnly = await prisma.recoveryDefinition.findMany({ select: { RecoveryDefinitionID: true } })
     * 
     */
    findMany<T extends RecoveryDefinitionFindManyArgs>(args?: SelectSubset<T, RecoveryDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryDefinitionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RecoveryDefinition.
     * @param {RecoveryDefinitionCreateArgs} args - Arguments to create a RecoveryDefinition.
     * @example
     * // Create one RecoveryDefinition
     * const RecoveryDefinition = await prisma.recoveryDefinition.create({
     *   data: {
     *     // ... data to create a RecoveryDefinition
     *   }
     * })
     * 
     */
    create<T extends RecoveryDefinitionCreateArgs>(args: SelectSubset<T, RecoveryDefinitionCreateArgs<ExtArgs>>): Prisma__RecoveryDefinitionClient<$Result.GetResult<Prisma.$RecoveryDefinitionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RecoveryDefinitions.
     * @param {RecoveryDefinitionCreateManyArgs} args - Arguments to create many RecoveryDefinitions.
     * @example
     * // Create many RecoveryDefinitions
     * const recoveryDefinition = await prisma.recoveryDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecoveryDefinitionCreateManyArgs>(args?: SelectSubset<T, RecoveryDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecoveryDefinition.
     * @param {RecoveryDefinitionDeleteArgs} args - Arguments to delete one RecoveryDefinition.
     * @example
     * // Delete one RecoveryDefinition
     * const RecoveryDefinition = await prisma.recoveryDefinition.delete({
     *   where: {
     *     // ... filter to delete one RecoveryDefinition
     *   }
     * })
     * 
     */
    delete<T extends RecoveryDefinitionDeleteArgs>(args: SelectSubset<T, RecoveryDefinitionDeleteArgs<ExtArgs>>): Prisma__RecoveryDefinitionClient<$Result.GetResult<Prisma.$RecoveryDefinitionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RecoveryDefinition.
     * @param {RecoveryDefinitionUpdateArgs} args - Arguments to update one RecoveryDefinition.
     * @example
     * // Update one RecoveryDefinition
     * const recoveryDefinition = await prisma.recoveryDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecoveryDefinitionUpdateArgs>(args: SelectSubset<T, RecoveryDefinitionUpdateArgs<ExtArgs>>): Prisma__RecoveryDefinitionClient<$Result.GetResult<Prisma.$RecoveryDefinitionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RecoveryDefinitions.
     * @param {RecoveryDefinitionDeleteManyArgs} args - Arguments to filter RecoveryDefinitions to delete.
     * @example
     * // Delete a few RecoveryDefinitions
     * const { count } = await prisma.recoveryDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecoveryDefinitionDeleteManyArgs>(args?: SelectSubset<T, RecoveryDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecoveryDefinitions
     * const recoveryDefinition = await prisma.recoveryDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecoveryDefinitionUpdateManyArgs>(args: SelectSubset<T, RecoveryDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecoveryDefinition.
     * @param {RecoveryDefinitionUpsertArgs} args - Arguments to update or create a RecoveryDefinition.
     * @example
     * // Update or create a RecoveryDefinition
     * const recoveryDefinition = await prisma.recoveryDefinition.upsert({
     *   create: {
     *     // ... data to create a RecoveryDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecoveryDefinition we want to update
     *   }
     * })
     */
    upsert<T extends RecoveryDefinitionUpsertArgs>(args: SelectSubset<T, RecoveryDefinitionUpsertArgs<ExtArgs>>): Prisma__RecoveryDefinitionClient<$Result.GetResult<Prisma.$RecoveryDefinitionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RecoveryDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionCountArgs} args - Arguments to filter RecoveryDefinitions to count.
     * @example
     * // Count the number of RecoveryDefinitions
     * const count = await prisma.recoveryDefinition.count({
     *   where: {
     *     // ... the filter for the RecoveryDefinitions we want to count
     *   }
     * })
    **/
    count<T extends RecoveryDefinitionCountArgs>(
      args?: Subset<T, RecoveryDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecoveryDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecoveryDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecoveryDefinitionAggregateArgs>(args: Subset<T, RecoveryDefinitionAggregateArgs>): Prisma.PrismaPromise<GetRecoveryDefinitionAggregateType<T>>

    /**
     * Group by RecoveryDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecoveryDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecoveryDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: RecoveryDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecoveryDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecoveryDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecoveryDefinition model
   */
  readonly fields: RecoveryDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecoveryDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecoveryDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RecoveryDefinitionDetails<T extends RecoveryDefinition$RecoveryDefinitionDetailsArgs<ExtArgs> = {}>(args?: Subset<T, RecoveryDefinition$RecoveryDefinitionDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryDefinitionDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    RecoveryDefinitionRateDetails<T extends RecoveryDefinition$RecoveryDefinitionRateDetailsArgs<ExtArgs> = {}>(args?: Subset<T, RecoveryDefinition$RecoveryDefinitionRateDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryDefinitionRateDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecoveryDefinition model
   */ 
  interface RecoveryDefinitionFieldRefs {
    readonly RecoveryDefinitionID: FieldRef<"RecoveryDefinition", 'Int'>
    readonly RecoveryDefinitionName: FieldRef<"RecoveryDefinition", 'String'>
    readonly RecoveryYear: FieldRef<"RecoveryDefinition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecoveryDefinition findUnique
   */
  export type RecoveryDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinition
     */
    select?: RecoveryDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinition to fetch.
     */
    where: RecoveryDefinitionWhereUniqueInput
  }

  /**
   * RecoveryDefinition findUniqueOrThrow
   */
  export type RecoveryDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinition
     */
    select?: RecoveryDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinition to fetch.
     */
    where: RecoveryDefinitionWhereUniqueInput
  }

  /**
   * RecoveryDefinition findFirst
   */
  export type RecoveryDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinition
     */
    select?: RecoveryDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinition to fetch.
     */
    where?: RecoveryDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryDefinitions to fetch.
     */
    orderBy?: RecoveryDefinitionOrderByWithRelationInput | RecoveryDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryDefinitions.
     */
    cursor?: RecoveryDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryDefinitions.
     */
    distinct?: RecoveryDefinitionScalarFieldEnum | RecoveryDefinitionScalarFieldEnum[]
  }

  /**
   * RecoveryDefinition findFirstOrThrow
   */
  export type RecoveryDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinition
     */
    select?: RecoveryDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinition to fetch.
     */
    where?: RecoveryDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryDefinitions to fetch.
     */
    orderBy?: RecoveryDefinitionOrderByWithRelationInput | RecoveryDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryDefinitions.
     */
    cursor?: RecoveryDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryDefinitions.
     */
    distinct?: RecoveryDefinitionScalarFieldEnum | RecoveryDefinitionScalarFieldEnum[]
  }

  /**
   * RecoveryDefinition findMany
   */
  export type RecoveryDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinition
     */
    select?: RecoveryDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinitions to fetch.
     */
    where?: RecoveryDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryDefinitions to fetch.
     */
    orderBy?: RecoveryDefinitionOrderByWithRelationInput | RecoveryDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecoveryDefinitions.
     */
    cursor?: RecoveryDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryDefinitions.
     */
    skip?: number
    distinct?: RecoveryDefinitionScalarFieldEnum | RecoveryDefinitionScalarFieldEnum[]
  }

  /**
   * RecoveryDefinition create
   */
  export type RecoveryDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinition
     */
    select?: RecoveryDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a RecoveryDefinition.
     */
    data?: XOR<RecoveryDefinitionCreateInput, RecoveryDefinitionUncheckedCreateInput>
  }

  /**
   * RecoveryDefinition createMany
   */
  export type RecoveryDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecoveryDefinitions.
     */
    data: RecoveryDefinitionCreateManyInput | RecoveryDefinitionCreateManyInput[]
  }

  /**
   * RecoveryDefinition update
   */
  export type RecoveryDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinition
     */
    select?: RecoveryDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a RecoveryDefinition.
     */
    data: XOR<RecoveryDefinitionUpdateInput, RecoveryDefinitionUncheckedUpdateInput>
    /**
     * Choose, which RecoveryDefinition to update.
     */
    where: RecoveryDefinitionWhereUniqueInput
  }

  /**
   * RecoveryDefinition updateMany
   */
  export type RecoveryDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecoveryDefinitions.
     */
    data: XOR<RecoveryDefinitionUpdateManyMutationInput, RecoveryDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryDefinitions to update
     */
    where?: RecoveryDefinitionWhereInput
  }

  /**
   * RecoveryDefinition upsert
   */
  export type RecoveryDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinition
     */
    select?: RecoveryDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the RecoveryDefinition to update in case it exists.
     */
    where: RecoveryDefinitionWhereUniqueInput
    /**
     * In case the RecoveryDefinition found by the `where` argument doesn't exist, create a new RecoveryDefinition with this data.
     */
    create: XOR<RecoveryDefinitionCreateInput, RecoveryDefinitionUncheckedCreateInput>
    /**
     * In case the RecoveryDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecoveryDefinitionUpdateInput, RecoveryDefinitionUncheckedUpdateInput>
  }

  /**
   * RecoveryDefinition delete
   */
  export type RecoveryDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinition
     */
    select?: RecoveryDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionInclude<ExtArgs> | null
    /**
     * Filter which RecoveryDefinition to delete.
     */
    where: RecoveryDefinitionWhereUniqueInput
  }

  /**
   * RecoveryDefinition deleteMany
   */
  export type RecoveryDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryDefinitions to delete
     */
    where?: RecoveryDefinitionWhereInput
  }

  /**
   * RecoveryDefinition.RecoveryDefinitionDetails
   */
  export type RecoveryDefinition$RecoveryDefinitionDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionDetails
     */
    select?: RecoveryDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionDetailsInclude<ExtArgs> | null
    where?: RecoveryDefinitionDetailsWhereInput
    orderBy?: RecoveryDefinitionDetailsOrderByWithRelationInput | RecoveryDefinitionDetailsOrderByWithRelationInput[]
    cursor?: RecoveryDefinitionDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecoveryDefinitionDetailsScalarFieldEnum | RecoveryDefinitionDetailsScalarFieldEnum[]
  }

  /**
   * RecoveryDefinition.RecoveryDefinitionRateDetails
   */
  export type RecoveryDefinition$RecoveryDefinitionRateDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionRateDetails
     */
    select?: RecoveryDefinitionRateDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionRateDetailsInclude<ExtArgs> | null
    where?: RecoveryDefinitionRateDetailsWhereInput
    orderBy?: RecoveryDefinitionRateDetailsOrderByWithRelationInput | RecoveryDefinitionRateDetailsOrderByWithRelationInput[]
    cursor?: RecoveryDefinitionRateDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecoveryDefinitionRateDetailsScalarFieldEnum | RecoveryDefinitionRateDetailsScalarFieldEnum[]
  }

  /**
   * RecoveryDefinition without action
   */
  export type RecoveryDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinition
     */
    select?: RecoveryDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model RecoveryDefinitionDetails
   */

  export type AggregateRecoveryDefinitionDetails = {
    _count: RecoveryDefinitionDetailsCountAggregateOutputType | null
    _avg: RecoveryDefinitionDetailsAvgAggregateOutputType | null
    _sum: RecoveryDefinitionDetailsSumAggregateOutputType | null
    _min: RecoveryDefinitionDetailsMinAggregateOutputType | null
    _max: RecoveryDefinitionDetailsMaxAggregateOutputType | null
  }

  export type RecoveryDefinitionDetailsAvgAggregateOutputType = {
    RewardRecoveryVectorID: number | null
    RecoveryDefinitionID: number | null
    StartYearRewardRecovery: number | null
    EndYearRewardRecovery: number | null
    RecoveryDayQuantity: number | null
  }

  export type RecoveryDefinitionDetailsSumAggregateOutputType = {
    RewardRecoveryVectorID: number | null
    RecoveryDefinitionID: number | null
    StartYearRewardRecovery: number | null
    EndYearRewardRecovery: number | null
    RecoveryDayQuantity: number | null
  }

  export type RecoveryDefinitionDetailsMinAggregateOutputType = {
    RewardRecoveryVectorID: number | null
    RecoveryDefinitionID: number | null
    StartYearRewardRecovery: number | null
    EndYearRewardRecovery: number | null
    RecoveryDayQuantity: number | null
    RecoveryYearDescription: string | null
  }

  export type RecoveryDefinitionDetailsMaxAggregateOutputType = {
    RewardRecoveryVectorID: number | null
    RecoveryDefinitionID: number | null
    StartYearRewardRecovery: number | null
    EndYearRewardRecovery: number | null
    RecoveryDayQuantity: number | null
    RecoveryYearDescription: string | null
  }

  export type RecoveryDefinitionDetailsCountAggregateOutputType = {
    RewardRecoveryVectorID: number
    RecoveryDefinitionID: number
    StartYearRewardRecovery: number
    EndYearRewardRecovery: number
    RecoveryDayQuantity: number
    RecoveryYearDescription: number
    _all: number
  }


  export type RecoveryDefinitionDetailsAvgAggregateInputType = {
    RewardRecoveryVectorID?: true
    RecoveryDefinitionID?: true
    StartYearRewardRecovery?: true
    EndYearRewardRecovery?: true
    RecoveryDayQuantity?: true
  }

  export type RecoveryDefinitionDetailsSumAggregateInputType = {
    RewardRecoveryVectorID?: true
    RecoveryDefinitionID?: true
    StartYearRewardRecovery?: true
    EndYearRewardRecovery?: true
    RecoveryDayQuantity?: true
  }

  export type RecoveryDefinitionDetailsMinAggregateInputType = {
    RewardRecoveryVectorID?: true
    RecoveryDefinitionID?: true
    StartYearRewardRecovery?: true
    EndYearRewardRecovery?: true
    RecoveryDayQuantity?: true
    RecoveryYearDescription?: true
  }

  export type RecoveryDefinitionDetailsMaxAggregateInputType = {
    RewardRecoveryVectorID?: true
    RecoveryDefinitionID?: true
    StartYearRewardRecovery?: true
    EndYearRewardRecovery?: true
    RecoveryDayQuantity?: true
    RecoveryYearDescription?: true
  }

  export type RecoveryDefinitionDetailsCountAggregateInputType = {
    RewardRecoveryVectorID?: true
    RecoveryDefinitionID?: true
    StartYearRewardRecovery?: true
    EndYearRewardRecovery?: true
    RecoveryDayQuantity?: true
    RecoveryYearDescription?: true
    _all?: true
  }

  export type RecoveryDefinitionDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryDefinitionDetails to aggregate.
     */
    where?: RecoveryDefinitionDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryDefinitionDetails to fetch.
     */
    orderBy?: RecoveryDefinitionDetailsOrderByWithRelationInput | RecoveryDefinitionDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecoveryDefinitionDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryDefinitionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryDefinitionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecoveryDefinitionDetails
    **/
    _count?: true | RecoveryDefinitionDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecoveryDefinitionDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecoveryDefinitionDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecoveryDefinitionDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecoveryDefinitionDetailsMaxAggregateInputType
  }

  export type GetRecoveryDefinitionDetailsAggregateType<T extends RecoveryDefinitionDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateRecoveryDefinitionDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecoveryDefinitionDetails[P]>
      : GetScalarType<T[P], AggregateRecoveryDefinitionDetails[P]>
  }




  export type RecoveryDefinitionDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryDefinitionDetailsWhereInput
    orderBy?: RecoveryDefinitionDetailsOrderByWithAggregationInput | RecoveryDefinitionDetailsOrderByWithAggregationInput[]
    by: RecoveryDefinitionDetailsScalarFieldEnum[] | RecoveryDefinitionDetailsScalarFieldEnum
    having?: RecoveryDefinitionDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecoveryDefinitionDetailsCountAggregateInputType | true
    _avg?: RecoveryDefinitionDetailsAvgAggregateInputType
    _sum?: RecoveryDefinitionDetailsSumAggregateInputType
    _min?: RecoveryDefinitionDetailsMinAggregateInputType
    _max?: RecoveryDefinitionDetailsMaxAggregateInputType
  }

  export type RecoveryDefinitionDetailsGroupByOutputType = {
    RewardRecoveryVectorID: number
    RecoveryDefinitionID: number | null
    StartYearRewardRecovery: number | null
    EndYearRewardRecovery: number | null
    RecoveryDayQuantity: number | null
    RecoveryYearDescription: string | null
    _count: RecoveryDefinitionDetailsCountAggregateOutputType | null
    _avg: RecoveryDefinitionDetailsAvgAggregateOutputType | null
    _sum: RecoveryDefinitionDetailsSumAggregateOutputType | null
    _min: RecoveryDefinitionDetailsMinAggregateOutputType | null
    _max: RecoveryDefinitionDetailsMaxAggregateOutputType | null
  }

  type GetRecoveryDefinitionDetailsGroupByPayload<T extends RecoveryDefinitionDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecoveryDefinitionDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecoveryDefinitionDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecoveryDefinitionDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], RecoveryDefinitionDetailsGroupByOutputType[P]>
        }
      >
    >


  export type RecoveryDefinitionDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    RewardRecoveryVectorID?: boolean
    RecoveryDefinitionID?: boolean
    StartYearRewardRecovery?: boolean
    EndYearRewardRecovery?: boolean
    RecoveryDayQuantity?: boolean
    RecoveryYearDescription?: boolean
    RecoveryDefinition?: boolean | RecoveryDefinitionDetails$RecoveryDefinitionArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryDefinitionDetails"]>


  export type RecoveryDefinitionDetailsSelectScalar = {
    RewardRecoveryVectorID?: boolean
    RecoveryDefinitionID?: boolean
    StartYearRewardRecovery?: boolean
    EndYearRewardRecovery?: boolean
    RecoveryDayQuantity?: boolean
    RecoveryYearDescription?: boolean
  }

  export type RecoveryDefinitionDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RecoveryDefinition?: boolean | RecoveryDefinitionDetails$RecoveryDefinitionArgs<ExtArgs>
  }

  export type $RecoveryDefinitionDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecoveryDefinitionDetails"
    objects: {
      RecoveryDefinition: Prisma.$RecoveryDefinitionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      RewardRecoveryVectorID: number
      RecoveryDefinitionID: number | null
      StartYearRewardRecovery: number | null
      EndYearRewardRecovery: number | null
      RecoveryDayQuantity: number | null
      RecoveryYearDescription: string | null
    }, ExtArgs["result"]["recoveryDefinitionDetails"]>
    composites: {}
  }

  type RecoveryDefinitionDetailsGetPayload<S extends boolean | null | undefined | RecoveryDefinitionDetailsDefaultArgs> = $Result.GetResult<Prisma.$RecoveryDefinitionDetailsPayload, S>

  type RecoveryDefinitionDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecoveryDefinitionDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecoveryDefinitionDetailsCountAggregateInputType | true
    }

  export interface RecoveryDefinitionDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecoveryDefinitionDetails'], meta: { name: 'RecoveryDefinitionDetails' } }
    /**
     * Find zero or one RecoveryDefinitionDetails that matches the filter.
     * @param {RecoveryDefinitionDetailsFindUniqueArgs} args - Arguments to find a RecoveryDefinitionDetails
     * @example
     * // Get one RecoveryDefinitionDetails
     * const recoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecoveryDefinitionDetailsFindUniqueArgs>(args: SelectSubset<T, RecoveryDefinitionDetailsFindUniqueArgs<ExtArgs>>): Prisma__RecoveryDefinitionDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RecoveryDefinitionDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecoveryDefinitionDetailsFindUniqueOrThrowArgs} args - Arguments to find a RecoveryDefinitionDetails
     * @example
     * // Get one RecoveryDefinitionDetails
     * const recoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecoveryDefinitionDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, RecoveryDefinitionDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecoveryDefinitionDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RecoveryDefinitionDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionDetailsFindFirstArgs} args - Arguments to find a RecoveryDefinitionDetails
     * @example
     * // Get one RecoveryDefinitionDetails
     * const recoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecoveryDefinitionDetailsFindFirstArgs>(args?: SelectSubset<T, RecoveryDefinitionDetailsFindFirstArgs<ExtArgs>>): Prisma__RecoveryDefinitionDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RecoveryDefinitionDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionDetailsFindFirstOrThrowArgs} args - Arguments to find a RecoveryDefinitionDetails
     * @example
     * // Get one RecoveryDefinitionDetails
     * const recoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecoveryDefinitionDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, RecoveryDefinitionDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecoveryDefinitionDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RecoveryDefinitionDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecoveryDefinitionDetails
     * const recoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.findMany()
     * 
     * // Get first 10 RecoveryDefinitionDetails
     * const recoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.findMany({ take: 10 })
     * 
     * // Only select the `RewardRecoveryVectorID`
     * const recoveryDefinitionDetailsWithRewardRecoveryVectorIDOnly = await prisma.recoveryDefinitionDetails.findMany({ select: { RewardRecoveryVectorID: true } })
     * 
     */
    findMany<T extends RecoveryDefinitionDetailsFindManyArgs>(args?: SelectSubset<T, RecoveryDefinitionDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryDefinitionDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RecoveryDefinitionDetails.
     * @param {RecoveryDefinitionDetailsCreateArgs} args - Arguments to create a RecoveryDefinitionDetails.
     * @example
     * // Create one RecoveryDefinitionDetails
     * const RecoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.create({
     *   data: {
     *     // ... data to create a RecoveryDefinitionDetails
     *   }
     * })
     * 
     */
    create<T extends RecoveryDefinitionDetailsCreateArgs>(args: SelectSubset<T, RecoveryDefinitionDetailsCreateArgs<ExtArgs>>): Prisma__RecoveryDefinitionDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RecoveryDefinitionDetails.
     * @param {RecoveryDefinitionDetailsCreateManyArgs} args - Arguments to create many RecoveryDefinitionDetails.
     * @example
     * // Create many RecoveryDefinitionDetails
     * const recoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecoveryDefinitionDetailsCreateManyArgs>(args?: SelectSubset<T, RecoveryDefinitionDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecoveryDefinitionDetails.
     * @param {RecoveryDefinitionDetailsDeleteArgs} args - Arguments to delete one RecoveryDefinitionDetails.
     * @example
     * // Delete one RecoveryDefinitionDetails
     * const RecoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.delete({
     *   where: {
     *     // ... filter to delete one RecoveryDefinitionDetails
     *   }
     * })
     * 
     */
    delete<T extends RecoveryDefinitionDetailsDeleteArgs>(args: SelectSubset<T, RecoveryDefinitionDetailsDeleteArgs<ExtArgs>>): Prisma__RecoveryDefinitionDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RecoveryDefinitionDetails.
     * @param {RecoveryDefinitionDetailsUpdateArgs} args - Arguments to update one RecoveryDefinitionDetails.
     * @example
     * // Update one RecoveryDefinitionDetails
     * const recoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecoveryDefinitionDetailsUpdateArgs>(args: SelectSubset<T, RecoveryDefinitionDetailsUpdateArgs<ExtArgs>>): Prisma__RecoveryDefinitionDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RecoveryDefinitionDetails.
     * @param {RecoveryDefinitionDetailsDeleteManyArgs} args - Arguments to filter RecoveryDefinitionDetails to delete.
     * @example
     * // Delete a few RecoveryDefinitionDetails
     * const { count } = await prisma.recoveryDefinitionDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecoveryDefinitionDetailsDeleteManyArgs>(args?: SelectSubset<T, RecoveryDefinitionDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryDefinitionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecoveryDefinitionDetails
     * const recoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecoveryDefinitionDetailsUpdateManyArgs>(args: SelectSubset<T, RecoveryDefinitionDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecoveryDefinitionDetails.
     * @param {RecoveryDefinitionDetailsUpsertArgs} args - Arguments to update or create a RecoveryDefinitionDetails.
     * @example
     * // Update or create a RecoveryDefinitionDetails
     * const recoveryDefinitionDetails = await prisma.recoveryDefinitionDetails.upsert({
     *   create: {
     *     // ... data to create a RecoveryDefinitionDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecoveryDefinitionDetails we want to update
     *   }
     * })
     */
    upsert<T extends RecoveryDefinitionDetailsUpsertArgs>(args: SelectSubset<T, RecoveryDefinitionDetailsUpsertArgs<ExtArgs>>): Prisma__RecoveryDefinitionDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RecoveryDefinitionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionDetailsCountArgs} args - Arguments to filter RecoveryDefinitionDetails to count.
     * @example
     * // Count the number of RecoveryDefinitionDetails
     * const count = await prisma.recoveryDefinitionDetails.count({
     *   where: {
     *     // ... the filter for the RecoveryDefinitionDetails we want to count
     *   }
     * })
    **/
    count<T extends RecoveryDefinitionDetailsCountArgs>(
      args?: Subset<T, RecoveryDefinitionDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecoveryDefinitionDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecoveryDefinitionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecoveryDefinitionDetailsAggregateArgs>(args: Subset<T, RecoveryDefinitionDetailsAggregateArgs>): Prisma.PrismaPromise<GetRecoveryDefinitionDetailsAggregateType<T>>

    /**
     * Group by RecoveryDefinitionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecoveryDefinitionDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecoveryDefinitionDetailsGroupByArgs['orderBy'] }
        : { orderBy?: RecoveryDefinitionDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecoveryDefinitionDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecoveryDefinitionDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecoveryDefinitionDetails model
   */
  readonly fields: RecoveryDefinitionDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecoveryDefinitionDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecoveryDefinitionDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RecoveryDefinition<T extends RecoveryDefinitionDetails$RecoveryDefinitionArgs<ExtArgs> = {}>(args?: Subset<T, RecoveryDefinitionDetails$RecoveryDefinitionArgs<ExtArgs>>): Prisma__RecoveryDefinitionClient<$Result.GetResult<Prisma.$RecoveryDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecoveryDefinitionDetails model
   */ 
  interface RecoveryDefinitionDetailsFieldRefs {
    readonly RewardRecoveryVectorID: FieldRef<"RecoveryDefinitionDetails", 'Int'>
    readonly RecoveryDefinitionID: FieldRef<"RecoveryDefinitionDetails", 'Int'>
    readonly StartYearRewardRecovery: FieldRef<"RecoveryDefinitionDetails", 'Float'>
    readonly EndYearRewardRecovery: FieldRef<"RecoveryDefinitionDetails", 'Float'>
    readonly RecoveryDayQuantity: FieldRef<"RecoveryDefinitionDetails", 'Int'>
    readonly RecoveryYearDescription: FieldRef<"RecoveryDefinitionDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecoveryDefinitionDetails findUnique
   */
  export type RecoveryDefinitionDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionDetails
     */
    select?: RecoveryDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionDetailsInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinitionDetails to fetch.
     */
    where: RecoveryDefinitionDetailsWhereUniqueInput
  }

  /**
   * RecoveryDefinitionDetails findUniqueOrThrow
   */
  export type RecoveryDefinitionDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionDetails
     */
    select?: RecoveryDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionDetailsInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinitionDetails to fetch.
     */
    where: RecoveryDefinitionDetailsWhereUniqueInput
  }

  /**
   * RecoveryDefinitionDetails findFirst
   */
  export type RecoveryDefinitionDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionDetails
     */
    select?: RecoveryDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionDetailsInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinitionDetails to fetch.
     */
    where?: RecoveryDefinitionDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryDefinitionDetails to fetch.
     */
    orderBy?: RecoveryDefinitionDetailsOrderByWithRelationInput | RecoveryDefinitionDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryDefinitionDetails.
     */
    cursor?: RecoveryDefinitionDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryDefinitionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryDefinitionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryDefinitionDetails.
     */
    distinct?: RecoveryDefinitionDetailsScalarFieldEnum | RecoveryDefinitionDetailsScalarFieldEnum[]
  }

  /**
   * RecoveryDefinitionDetails findFirstOrThrow
   */
  export type RecoveryDefinitionDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionDetails
     */
    select?: RecoveryDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionDetailsInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinitionDetails to fetch.
     */
    where?: RecoveryDefinitionDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryDefinitionDetails to fetch.
     */
    orderBy?: RecoveryDefinitionDetailsOrderByWithRelationInput | RecoveryDefinitionDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryDefinitionDetails.
     */
    cursor?: RecoveryDefinitionDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryDefinitionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryDefinitionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryDefinitionDetails.
     */
    distinct?: RecoveryDefinitionDetailsScalarFieldEnum | RecoveryDefinitionDetailsScalarFieldEnum[]
  }

  /**
   * RecoveryDefinitionDetails findMany
   */
  export type RecoveryDefinitionDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionDetails
     */
    select?: RecoveryDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionDetailsInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinitionDetails to fetch.
     */
    where?: RecoveryDefinitionDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryDefinitionDetails to fetch.
     */
    orderBy?: RecoveryDefinitionDetailsOrderByWithRelationInput | RecoveryDefinitionDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecoveryDefinitionDetails.
     */
    cursor?: RecoveryDefinitionDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryDefinitionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryDefinitionDetails.
     */
    skip?: number
    distinct?: RecoveryDefinitionDetailsScalarFieldEnum | RecoveryDefinitionDetailsScalarFieldEnum[]
  }

  /**
   * RecoveryDefinitionDetails create
   */
  export type RecoveryDefinitionDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionDetails
     */
    select?: RecoveryDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a RecoveryDefinitionDetails.
     */
    data?: XOR<RecoveryDefinitionDetailsCreateInput, RecoveryDefinitionDetailsUncheckedCreateInput>
  }

  /**
   * RecoveryDefinitionDetails createMany
   */
  export type RecoveryDefinitionDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecoveryDefinitionDetails.
     */
    data: RecoveryDefinitionDetailsCreateManyInput | RecoveryDefinitionDetailsCreateManyInput[]
  }

  /**
   * RecoveryDefinitionDetails update
   */
  export type RecoveryDefinitionDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionDetails
     */
    select?: RecoveryDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a RecoveryDefinitionDetails.
     */
    data: XOR<RecoveryDefinitionDetailsUpdateInput, RecoveryDefinitionDetailsUncheckedUpdateInput>
    /**
     * Choose, which RecoveryDefinitionDetails to update.
     */
    where: RecoveryDefinitionDetailsWhereUniqueInput
  }

  /**
   * RecoveryDefinitionDetails updateMany
   */
  export type RecoveryDefinitionDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecoveryDefinitionDetails.
     */
    data: XOR<RecoveryDefinitionDetailsUpdateManyMutationInput, RecoveryDefinitionDetailsUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryDefinitionDetails to update
     */
    where?: RecoveryDefinitionDetailsWhereInput
  }

  /**
   * RecoveryDefinitionDetails upsert
   */
  export type RecoveryDefinitionDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionDetails
     */
    select?: RecoveryDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the RecoveryDefinitionDetails to update in case it exists.
     */
    where: RecoveryDefinitionDetailsWhereUniqueInput
    /**
     * In case the RecoveryDefinitionDetails found by the `where` argument doesn't exist, create a new RecoveryDefinitionDetails with this data.
     */
    create: XOR<RecoveryDefinitionDetailsCreateInput, RecoveryDefinitionDetailsUncheckedCreateInput>
    /**
     * In case the RecoveryDefinitionDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecoveryDefinitionDetailsUpdateInput, RecoveryDefinitionDetailsUncheckedUpdateInput>
  }

  /**
   * RecoveryDefinitionDetails delete
   */
  export type RecoveryDefinitionDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionDetails
     */
    select?: RecoveryDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionDetailsInclude<ExtArgs> | null
    /**
     * Filter which RecoveryDefinitionDetails to delete.
     */
    where: RecoveryDefinitionDetailsWhereUniqueInput
  }

  /**
   * RecoveryDefinitionDetails deleteMany
   */
  export type RecoveryDefinitionDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryDefinitionDetails to delete
     */
    where?: RecoveryDefinitionDetailsWhereInput
  }

  /**
   * RecoveryDefinitionDetails.RecoveryDefinition
   */
  export type RecoveryDefinitionDetails$RecoveryDefinitionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinition
     */
    select?: RecoveryDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionInclude<ExtArgs> | null
    where?: RecoveryDefinitionWhereInput
  }

  /**
   * RecoveryDefinitionDetails without action
   */
  export type RecoveryDefinitionDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionDetails
     */
    select?: RecoveryDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionDetailsInclude<ExtArgs> | null
  }


  /**
   * Model RecoveryDefinitionRateDetails
   */

  export type AggregateRecoveryDefinitionRateDetails = {
    _count: RecoveryDefinitionRateDetailsCountAggregateOutputType | null
    _avg: RecoveryDefinitionRateDetailsAvgAggregateOutputType | null
    _sum: RecoveryDefinitionRateDetailsSumAggregateOutputType | null
    _min: RecoveryDefinitionRateDetailsMinAggregateOutputType | null
    _max: RecoveryDefinitionRateDetailsMaxAggregateOutputType | null
  }

  export type RecoveryDefinitionRateDetailsAvgAggregateOutputType = {
    RecoveryRewardID: number | null
    RecoveryDefinitionID: number | null
    RecoveryRewardRatePerDay: number | null
  }

  export type RecoveryDefinitionRateDetailsSumAggregateOutputType = {
    RecoveryRewardID: number | null
    RecoveryDefinitionID: number | null
    RecoveryRewardRatePerDay: number | null
  }

  export type RecoveryDefinitionRateDetailsMinAggregateOutputType = {
    RecoveryRewardID: number | null
    RecoveryDefinitionID: number | null
    RewardYearMonth: Date | null
    RecoveryRewardRatePerDay: number | null
  }

  export type RecoveryDefinitionRateDetailsMaxAggregateOutputType = {
    RecoveryRewardID: number | null
    RecoveryDefinitionID: number | null
    RewardYearMonth: Date | null
    RecoveryRewardRatePerDay: number | null
  }

  export type RecoveryDefinitionRateDetailsCountAggregateOutputType = {
    RecoveryRewardID: number
    RecoveryDefinitionID: number
    RewardYearMonth: number
    RecoveryRewardRatePerDay: number
    _all: number
  }


  export type RecoveryDefinitionRateDetailsAvgAggregateInputType = {
    RecoveryRewardID?: true
    RecoveryDefinitionID?: true
    RecoveryRewardRatePerDay?: true
  }

  export type RecoveryDefinitionRateDetailsSumAggregateInputType = {
    RecoveryRewardID?: true
    RecoveryDefinitionID?: true
    RecoveryRewardRatePerDay?: true
  }

  export type RecoveryDefinitionRateDetailsMinAggregateInputType = {
    RecoveryRewardID?: true
    RecoveryDefinitionID?: true
    RewardYearMonth?: true
    RecoveryRewardRatePerDay?: true
  }

  export type RecoveryDefinitionRateDetailsMaxAggregateInputType = {
    RecoveryRewardID?: true
    RecoveryDefinitionID?: true
    RewardYearMonth?: true
    RecoveryRewardRatePerDay?: true
  }

  export type RecoveryDefinitionRateDetailsCountAggregateInputType = {
    RecoveryRewardID?: true
    RecoveryDefinitionID?: true
    RewardYearMonth?: true
    RecoveryRewardRatePerDay?: true
    _all?: true
  }

  export type RecoveryDefinitionRateDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryDefinitionRateDetails to aggregate.
     */
    where?: RecoveryDefinitionRateDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryDefinitionRateDetails to fetch.
     */
    orderBy?: RecoveryDefinitionRateDetailsOrderByWithRelationInput | RecoveryDefinitionRateDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecoveryDefinitionRateDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryDefinitionRateDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryDefinitionRateDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecoveryDefinitionRateDetails
    **/
    _count?: true | RecoveryDefinitionRateDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecoveryDefinitionRateDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecoveryDefinitionRateDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecoveryDefinitionRateDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecoveryDefinitionRateDetailsMaxAggregateInputType
  }

  export type GetRecoveryDefinitionRateDetailsAggregateType<T extends RecoveryDefinitionRateDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateRecoveryDefinitionRateDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecoveryDefinitionRateDetails[P]>
      : GetScalarType<T[P], AggregateRecoveryDefinitionRateDetails[P]>
  }




  export type RecoveryDefinitionRateDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryDefinitionRateDetailsWhereInput
    orderBy?: RecoveryDefinitionRateDetailsOrderByWithAggregationInput | RecoveryDefinitionRateDetailsOrderByWithAggregationInput[]
    by: RecoveryDefinitionRateDetailsScalarFieldEnum[] | RecoveryDefinitionRateDetailsScalarFieldEnum
    having?: RecoveryDefinitionRateDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecoveryDefinitionRateDetailsCountAggregateInputType | true
    _avg?: RecoveryDefinitionRateDetailsAvgAggregateInputType
    _sum?: RecoveryDefinitionRateDetailsSumAggregateInputType
    _min?: RecoveryDefinitionRateDetailsMinAggregateInputType
    _max?: RecoveryDefinitionRateDetailsMaxAggregateInputType
  }

  export type RecoveryDefinitionRateDetailsGroupByOutputType = {
    RecoveryRewardID: number
    RecoveryDefinitionID: number | null
    RewardYearMonth: Date | null
    RecoveryRewardRatePerDay: number | null
    _count: RecoveryDefinitionRateDetailsCountAggregateOutputType | null
    _avg: RecoveryDefinitionRateDetailsAvgAggregateOutputType | null
    _sum: RecoveryDefinitionRateDetailsSumAggregateOutputType | null
    _min: RecoveryDefinitionRateDetailsMinAggregateOutputType | null
    _max: RecoveryDefinitionRateDetailsMaxAggregateOutputType | null
  }

  type GetRecoveryDefinitionRateDetailsGroupByPayload<T extends RecoveryDefinitionRateDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecoveryDefinitionRateDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecoveryDefinitionRateDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecoveryDefinitionRateDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], RecoveryDefinitionRateDetailsGroupByOutputType[P]>
        }
      >
    >


  export type RecoveryDefinitionRateDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    RecoveryRewardID?: boolean
    RecoveryDefinitionID?: boolean
    RewardYearMonth?: boolean
    RecoveryRewardRatePerDay?: boolean
    RecoveryDefinition?: boolean | RecoveryDefinitionRateDetails$RecoveryDefinitionArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryDefinitionRateDetails"]>


  export type RecoveryDefinitionRateDetailsSelectScalar = {
    RecoveryRewardID?: boolean
    RecoveryDefinitionID?: boolean
    RewardYearMonth?: boolean
    RecoveryRewardRatePerDay?: boolean
  }

  export type RecoveryDefinitionRateDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RecoveryDefinition?: boolean | RecoveryDefinitionRateDetails$RecoveryDefinitionArgs<ExtArgs>
  }

  export type $RecoveryDefinitionRateDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecoveryDefinitionRateDetails"
    objects: {
      RecoveryDefinition: Prisma.$RecoveryDefinitionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      RecoveryRewardID: number
      RecoveryDefinitionID: number | null
      RewardYearMonth: Date | null
      RecoveryRewardRatePerDay: number | null
    }, ExtArgs["result"]["recoveryDefinitionRateDetails"]>
    composites: {}
  }

  type RecoveryDefinitionRateDetailsGetPayload<S extends boolean | null | undefined | RecoveryDefinitionRateDetailsDefaultArgs> = $Result.GetResult<Prisma.$RecoveryDefinitionRateDetailsPayload, S>

  type RecoveryDefinitionRateDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecoveryDefinitionRateDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecoveryDefinitionRateDetailsCountAggregateInputType | true
    }

  export interface RecoveryDefinitionRateDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecoveryDefinitionRateDetails'], meta: { name: 'RecoveryDefinitionRateDetails' } }
    /**
     * Find zero or one RecoveryDefinitionRateDetails that matches the filter.
     * @param {RecoveryDefinitionRateDetailsFindUniqueArgs} args - Arguments to find a RecoveryDefinitionRateDetails
     * @example
     * // Get one RecoveryDefinitionRateDetails
     * const recoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecoveryDefinitionRateDetailsFindUniqueArgs>(args: SelectSubset<T, RecoveryDefinitionRateDetailsFindUniqueArgs<ExtArgs>>): Prisma__RecoveryDefinitionRateDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionRateDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RecoveryDefinitionRateDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecoveryDefinitionRateDetailsFindUniqueOrThrowArgs} args - Arguments to find a RecoveryDefinitionRateDetails
     * @example
     * // Get one RecoveryDefinitionRateDetails
     * const recoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecoveryDefinitionRateDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, RecoveryDefinitionRateDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecoveryDefinitionRateDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionRateDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RecoveryDefinitionRateDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionRateDetailsFindFirstArgs} args - Arguments to find a RecoveryDefinitionRateDetails
     * @example
     * // Get one RecoveryDefinitionRateDetails
     * const recoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecoveryDefinitionRateDetailsFindFirstArgs>(args?: SelectSubset<T, RecoveryDefinitionRateDetailsFindFirstArgs<ExtArgs>>): Prisma__RecoveryDefinitionRateDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionRateDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RecoveryDefinitionRateDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionRateDetailsFindFirstOrThrowArgs} args - Arguments to find a RecoveryDefinitionRateDetails
     * @example
     * // Get one RecoveryDefinitionRateDetails
     * const recoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecoveryDefinitionRateDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, RecoveryDefinitionRateDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecoveryDefinitionRateDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionRateDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RecoveryDefinitionRateDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionRateDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecoveryDefinitionRateDetails
     * const recoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.findMany()
     * 
     * // Get first 10 RecoveryDefinitionRateDetails
     * const recoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.findMany({ take: 10 })
     * 
     * // Only select the `RecoveryRewardID`
     * const recoveryDefinitionRateDetailsWithRecoveryRewardIDOnly = await prisma.recoveryDefinitionRateDetails.findMany({ select: { RecoveryRewardID: true } })
     * 
     */
    findMany<T extends RecoveryDefinitionRateDetailsFindManyArgs>(args?: SelectSubset<T, RecoveryDefinitionRateDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryDefinitionRateDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RecoveryDefinitionRateDetails.
     * @param {RecoveryDefinitionRateDetailsCreateArgs} args - Arguments to create a RecoveryDefinitionRateDetails.
     * @example
     * // Create one RecoveryDefinitionRateDetails
     * const RecoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.create({
     *   data: {
     *     // ... data to create a RecoveryDefinitionRateDetails
     *   }
     * })
     * 
     */
    create<T extends RecoveryDefinitionRateDetailsCreateArgs>(args: SelectSubset<T, RecoveryDefinitionRateDetailsCreateArgs<ExtArgs>>): Prisma__RecoveryDefinitionRateDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionRateDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RecoveryDefinitionRateDetails.
     * @param {RecoveryDefinitionRateDetailsCreateManyArgs} args - Arguments to create many RecoveryDefinitionRateDetails.
     * @example
     * // Create many RecoveryDefinitionRateDetails
     * const recoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecoveryDefinitionRateDetailsCreateManyArgs>(args?: SelectSubset<T, RecoveryDefinitionRateDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecoveryDefinitionRateDetails.
     * @param {RecoveryDefinitionRateDetailsDeleteArgs} args - Arguments to delete one RecoveryDefinitionRateDetails.
     * @example
     * // Delete one RecoveryDefinitionRateDetails
     * const RecoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.delete({
     *   where: {
     *     // ... filter to delete one RecoveryDefinitionRateDetails
     *   }
     * })
     * 
     */
    delete<T extends RecoveryDefinitionRateDetailsDeleteArgs>(args: SelectSubset<T, RecoveryDefinitionRateDetailsDeleteArgs<ExtArgs>>): Prisma__RecoveryDefinitionRateDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionRateDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RecoveryDefinitionRateDetails.
     * @param {RecoveryDefinitionRateDetailsUpdateArgs} args - Arguments to update one RecoveryDefinitionRateDetails.
     * @example
     * // Update one RecoveryDefinitionRateDetails
     * const recoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecoveryDefinitionRateDetailsUpdateArgs>(args: SelectSubset<T, RecoveryDefinitionRateDetailsUpdateArgs<ExtArgs>>): Prisma__RecoveryDefinitionRateDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionRateDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RecoveryDefinitionRateDetails.
     * @param {RecoveryDefinitionRateDetailsDeleteManyArgs} args - Arguments to filter RecoveryDefinitionRateDetails to delete.
     * @example
     * // Delete a few RecoveryDefinitionRateDetails
     * const { count } = await prisma.recoveryDefinitionRateDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecoveryDefinitionRateDetailsDeleteManyArgs>(args?: SelectSubset<T, RecoveryDefinitionRateDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryDefinitionRateDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionRateDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecoveryDefinitionRateDetails
     * const recoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecoveryDefinitionRateDetailsUpdateManyArgs>(args: SelectSubset<T, RecoveryDefinitionRateDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecoveryDefinitionRateDetails.
     * @param {RecoveryDefinitionRateDetailsUpsertArgs} args - Arguments to update or create a RecoveryDefinitionRateDetails.
     * @example
     * // Update or create a RecoveryDefinitionRateDetails
     * const recoveryDefinitionRateDetails = await prisma.recoveryDefinitionRateDetails.upsert({
     *   create: {
     *     // ... data to create a RecoveryDefinitionRateDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecoveryDefinitionRateDetails we want to update
     *   }
     * })
     */
    upsert<T extends RecoveryDefinitionRateDetailsUpsertArgs>(args: SelectSubset<T, RecoveryDefinitionRateDetailsUpsertArgs<ExtArgs>>): Prisma__RecoveryDefinitionRateDetailsClient<$Result.GetResult<Prisma.$RecoveryDefinitionRateDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RecoveryDefinitionRateDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionRateDetailsCountArgs} args - Arguments to filter RecoveryDefinitionRateDetails to count.
     * @example
     * // Count the number of RecoveryDefinitionRateDetails
     * const count = await prisma.recoveryDefinitionRateDetails.count({
     *   where: {
     *     // ... the filter for the RecoveryDefinitionRateDetails we want to count
     *   }
     * })
    **/
    count<T extends RecoveryDefinitionRateDetailsCountArgs>(
      args?: Subset<T, RecoveryDefinitionRateDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecoveryDefinitionRateDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecoveryDefinitionRateDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionRateDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecoveryDefinitionRateDetailsAggregateArgs>(args: Subset<T, RecoveryDefinitionRateDetailsAggregateArgs>): Prisma.PrismaPromise<GetRecoveryDefinitionRateDetailsAggregateType<T>>

    /**
     * Group by RecoveryDefinitionRateDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryDefinitionRateDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecoveryDefinitionRateDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecoveryDefinitionRateDetailsGroupByArgs['orderBy'] }
        : { orderBy?: RecoveryDefinitionRateDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecoveryDefinitionRateDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecoveryDefinitionRateDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecoveryDefinitionRateDetails model
   */
  readonly fields: RecoveryDefinitionRateDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecoveryDefinitionRateDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecoveryDefinitionRateDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RecoveryDefinition<T extends RecoveryDefinitionRateDetails$RecoveryDefinitionArgs<ExtArgs> = {}>(args?: Subset<T, RecoveryDefinitionRateDetails$RecoveryDefinitionArgs<ExtArgs>>): Prisma__RecoveryDefinitionClient<$Result.GetResult<Prisma.$RecoveryDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecoveryDefinitionRateDetails model
   */ 
  interface RecoveryDefinitionRateDetailsFieldRefs {
    readonly RecoveryRewardID: FieldRef<"RecoveryDefinitionRateDetails", 'Int'>
    readonly RecoveryDefinitionID: FieldRef<"RecoveryDefinitionRateDetails", 'Int'>
    readonly RewardYearMonth: FieldRef<"RecoveryDefinitionRateDetails", 'DateTime'>
    readonly RecoveryRewardRatePerDay: FieldRef<"RecoveryDefinitionRateDetails", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * RecoveryDefinitionRateDetails findUnique
   */
  export type RecoveryDefinitionRateDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionRateDetails
     */
    select?: RecoveryDefinitionRateDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionRateDetailsInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinitionRateDetails to fetch.
     */
    where: RecoveryDefinitionRateDetailsWhereUniqueInput
  }

  /**
   * RecoveryDefinitionRateDetails findUniqueOrThrow
   */
  export type RecoveryDefinitionRateDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionRateDetails
     */
    select?: RecoveryDefinitionRateDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionRateDetailsInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinitionRateDetails to fetch.
     */
    where: RecoveryDefinitionRateDetailsWhereUniqueInput
  }

  /**
   * RecoveryDefinitionRateDetails findFirst
   */
  export type RecoveryDefinitionRateDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionRateDetails
     */
    select?: RecoveryDefinitionRateDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionRateDetailsInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinitionRateDetails to fetch.
     */
    where?: RecoveryDefinitionRateDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryDefinitionRateDetails to fetch.
     */
    orderBy?: RecoveryDefinitionRateDetailsOrderByWithRelationInput | RecoveryDefinitionRateDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryDefinitionRateDetails.
     */
    cursor?: RecoveryDefinitionRateDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryDefinitionRateDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryDefinitionRateDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryDefinitionRateDetails.
     */
    distinct?: RecoveryDefinitionRateDetailsScalarFieldEnum | RecoveryDefinitionRateDetailsScalarFieldEnum[]
  }

  /**
   * RecoveryDefinitionRateDetails findFirstOrThrow
   */
  export type RecoveryDefinitionRateDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionRateDetails
     */
    select?: RecoveryDefinitionRateDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionRateDetailsInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinitionRateDetails to fetch.
     */
    where?: RecoveryDefinitionRateDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryDefinitionRateDetails to fetch.
     */
    orderBy?: RecoveryDefinitionRateDetailsOrderByWithRelationInput | RecoveryDefinitionRateDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryDefinitionRateDetails.
     */
    cursor?: RecoveryDefinitionRateDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryDefinitionRateDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryDefinitionRateDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryDefinitionRateDetails.
     */
    distinct?: RecoveryDefinitionRateDetailsScalarFieldEnum | RecoveryDefinitionRateDetailsScalarFieldEnum[]
  }

  /**
   * RecoveryDefinitionRateDetails findMany
   */
  export type RecoveryDefinitionRateDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionRateDetails
     */
    select?: RecoveryDefinitionRateDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionRateDetailsInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryDefinitionRateDetails to fetch.
     */
    where?: RecoveryDefinitionRateDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryDefinitionRateDetails to fetch.
     */
    orderBy?: RecoveryDefinitionRateDetailsOrderByWithRelationInput | RecoveryDefinitionRateDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecoveryDefinitionRateDetails.
     */
    cursor?: RecoveryDefinitionRateDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryDefinitionRateDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryDefinitionRateDetails.
     */
    skip?: number
    distinct?: RecoveryDefinitionRateDetailsScalarFieldEnum | RecoveryDefinitionRateDetailsScalarFieldEnum[]
  }

  /**
   * RecoveryDefinitionRateDetails create
   */
  export type RecoveryDefinitionRateDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionRateDetails
     */
    select?: RecoveryDefinitionRateDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionRateDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a RecoveryDefinitionRateDetails.
     */
    data: XOR<RecoveryDefinitionRateDetailsCreateInput, RecoveryDefinitionRateDetailsUncheckedCreateInput>
  }

  /**
   * RecoveryDefinitionRateDetails createMany
   */
  export type RecoveryDefinitionRateDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecoveryDefinitionRateDetails.
     */
    data: RecoveryDefinitionRateDetailsCreateManyInput | RecoveryDefinitionRateDetailsCreateManyInput[]
  }

  /**
   * RecoveryDefinitionRateDetails update
   */
  export type RecoveryDefinitionRateDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionRateDetails
     */
    select?: RecoveryDefinitionRateDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionRateDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a RecoveryDefinitionRateDetails.
     */
    data: XOR<RecoveryDefinitionRateDetailsUpdateInput, RecoveryDefinitionRateDetailsUncheckedUpdateInput>
    /**
     * Choose, which RecoveryDefinitionRateDetails to update.
     */
    where: RecoveryDefinitionRateDetailsWhereUniqueInput
  }

  /**
   * RecoveryDefinitionRateDetails updateMany
   */
  export type RecoveryDefinitionRateDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecoveryDefinitionRateDetails.
     */
    data: XOR<RecoveryDefinitionRateDetailsUpdateManyMutationInput, RecoveryDefinitionRateDetailsUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryDefinitionRateDetails to update
     */
    where?: RecoveryDefinitionRateDetailsWhereInput
  }

  /**
   * RecoveryDefinitionRateDetails upsert
   */
  export type RecoveryDefinitionRateDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionRateDetails
     */
    select?: RecoveryDefinitionRateDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionRateDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the RecoveryDefinitionRateDetails to update in case it exists.
     */
    where: RecoveryDefinitionRateDetailsWhereUniqueInput
    /**
     * In case the RecoveryDefinitionRateDetails found by the `where` argument doesn't exist, create a new RecoveryDefinitionRateDetails with this data.
     */
    create: XOR<RecoveryDefinitionRateDetailsCreateInput, RecoveryDefinitionRateDetailsUncheckedCreateInput>
    /**
     * In case the RecoveryDefinitionRateDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecoveryDefinitionRateDetailsUpdateInput, RecoveryDefinitionRateDetailsUncheckedUpdateInput>
  }

  /**
   * RecoveryDefinitionRateDetails delete
   */
  export type RecoveryDefinitionRateDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionRateDetails
     */
    select?: RecoveryDefinitionRateDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionRateDetailsInclude<ExtArgs> | null
    /**
     * Filter which RecoveryDefinitionRateDetails to delete.
     */
    where: RecoveryDefinitionRateDetailsWhereUniqueInput
  }

  /**
   * RecoveryDefinitionRateDetails deleteMany
   */
  export type RecoveryDefinitionRateDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryDefinitionRateDetails to delete
     */
    where?: RecoveryDefinitionRateDetailsWhereInput
  }

  /**
   * RecoveryDefinitionRateDetails.RecoveryDefinition
   */
  export type RecoveryDefinitionRateDetails$RecoveryDefinitionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinition
     */
    select?: RecoveryDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionInclude<ExtArgs> | null
    where?: RecoveryDefinitionWhereInput
  }

  /**
   * RecoveryDefinitionRateDetails without action
   */
  export type RecoveryDefinitionRateDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryDefinitionRateDetails
     */
    select?: RecoveryDefinitionRateDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryDefinitionRateDetailsInclude<ExtArgs> | null
  }


  /**
   * Model ReportDefinitions
   */

  export type AggregateReportDefinitions = {
    _count: ReportDefinitionsCountAggregateOutputType | null
    _avg: ReportDefinitionsAvgAggregateOutputType | null
    _sum: ReportDefinitionsSumAggregateOutputType | null
    _min: ReportDefinitionsMinAggregateOutputType | null
    _max: ReportDefinitionsMaxAggregateOutputType | null
  }

  export type ReportDefinitionsAvgAggregateOutputType = {
    ReportID: number | null
    OrderBy: number | null
    Color: number | null
    Background: number | null
    ColumnWidth: number | null
    FontSize: number | null
    ColorIndex: number | null
  }

  export type ReportDefinitionsSumAggregateOutputType = {
    ReportID: number | null
    OrderBy: number | null
    Color: number | null
    Background: number | null
    ColumnWidth: number | null
    FontSize: number | null
    ColorIndex: number | null
  }

  export type ReportDefinitionsMinAggregateOutputType = {
    ReportID: number | null
    ReportName: string | null
    OrderBy: number | null
    FieldName: string | null
    Caption: string | null
    Color: number | null
    Background: number | null
    ColumnWidth: number | null
    FontStyle: string | null
    FontSize: number | null
    ReportTitle: string | null
    IsSum: boolean | null
    ColorIndex: number | null
  }

  export type ReportDefinitionsMaxAggregateOutputType = {
    ReportID: number | null
    ReportName: string | null
    OrderBy: number | null
    FieldName: string | null
    Caption: string | null
    Color: number | null
    Background: number | null
    ColumnWidth: number | null
    FontStyle: string | null
    FontSize: number | null
    ReportTitle: string | null
    IsSum: boolean | null
    ColorIndex: number | null
  }

  export type ReportDefinitionsCountAggregateOutputType = {
    ReportID: number
    ReportName: number
    OrderBy: number
    FieldName: number
    Caption: number
    Color: number
    Background: number
    ColumnWidth: number
    FontStyle: number
    FontSize: number
    ReportTitle: number
    IsSum: number
    ColorIndex: number
    _all: number
  }


  export type ReportDefinitionsAvgAggregateInputType = {
    ReportID?: true
    OrderBy?: true
    Color?: true
    Background?: true
    ColumnWidth?: true
    FontSize?: true
    ColorIndex?: true
  }

  export type ReportDefinitionsSumAggregateInputType = {
    ReportID?: true
    OrderBy?: true
    Color?: true
    Background?: true
    ColumnWidth?: true
    FontSize?: true
    ColorIndex?: true
  }

  export type ReportDefinitionsMinAggregateInputType = {
    ReportID?: true
    ReportName?: true
    OrderBy?: true
    FieldName?: true
    Caption?: true
    Color?: true
    Background?: true
    ColumnWidth?: true
    FontStyle?: true
    FontSize?: true
    ReportTitle?: true
    IsSum?: true
    ColorIndex?: true
  }

  export type ReportDefinitionsMaxAggregateInputType = {
    ReportID?: true
    ReportName?: true
    OrderBy?: true
    FieldName?: true
    Caption?: true
    Color?: true
    Background?: true
    ColumnWidth?: true
    FontStyle?: true
    FontSize?: true
    ReportTitle?: true
    IsSum?: true
    ColorIndex?: true
  }

  export type ReportDefinitionsCountAggregateInputType = {
    ReportID?: true
    ReportName?: true
    OrderBy?: true
    FieldName?: true
    Caption?: true
    Color?: true
    Background?: true
    ColumnWidth?: true
    FontStyle?: true
    FontSize?: true
    ReportTitle?: true
    IsSum?: true
    ColorIndex?: true
    _all?: true
  }

  export type ReportDefinitionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportDefinitions to aggregate.
     */
    where?: ReportDefinitionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDefinitions to fetch.
     */
    orderBy?: ReportDefinitionsOrderByWithRelationInput | ReportDefinitionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportDefinitionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportDefinitions
    **/
    _count?: true | ReportDefinitionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportDefinitionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportDefinitionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportDefinitionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportDefinitionsMaxAggregateInputType
  }

  export type GetReportDefinitionsAggregateType<T extends ReportDefinitionsAggregateArgs> = {
        [P in keyof T & keyof AggregateReportDefinitions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportDefinitions[P]>
      : GetScalarType<T[P], AggregateReportDefinitions[P]>
  }




  export type ReportDefinitionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportDefinitionsWhereInput
    orderBy?: ReportDefinitionsOrderByWithAggregationInput | ReportDefinitionsOrderByWithAggregationInput[]
    by: ReportDefinitionsScalarFieldEnum[] | ReportDefinitionsScalarFieldEnum
    having?: ReportDefinitionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportDefinitionsCountAggregateInputType | true
    _avg?: ReportDefinitionsAvgAggregateInputType
    _sum?: ReportDefinitionsSumAggregateInputType
    _min?: ReportDefinitionsMinAggregateInputType
    _max?: ReportDefinitionsMaxAggregateInputType
  }

  export type ReportDefinitionsGroupByOutputType = {
    ReportID: number
    ReportName: string | null
    OrderBy: number | null
    FieldName: string | null
    Caption: string | null
    Color: number | null
    Background: number | null
    ColumnWidth: number | null
    FontStyle: string | null
    FontSize: number | null
    ReportTitle: string | null
    IsSum: boolean
    ColorIndex: number | null
    _count: ReportDefinitionsCountAggregateOutputType | null
    _avg: ReportDefinitionsAvgAggregateOutputType | null
    _sum: ReportDefinitionsSumAggregateOutputType | null
    _min: ReportDefinitionsMinAggregateOutputType | null
    _max: ReportDefinitionsMaxAggregateOutputType | null
  }

  type GetReportDefinitionsGroupByPayload<T extends ReportDefinitionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportDefinitionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportDefinitionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportDefinitionsGroupByOutputType[P]>
            : GetScalarType<T[P], ReportDefinitionsGroupByOutputType[P]>
        }
      >
    >


  export type ReportDefinitionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ReportID?: boolean
    ReportName?: boolean
    OrderBy?: boolean
    FieldName?: boolean
    Caption?: boolean
    Color?: boolean
    Background?: boolean
    ColumnWidth?: boolean
    FontStyle?: boolean
    FontSize?: boolean
    ReportTitle?: boolean
    IsSum?: boolean
    ColorIndex?: boolean
  }, ExtArgs["result"]["reportDefinitions"]>


  export type ReportDefinitionsSelectScalar = {
    ReportID?: boolean
    ReportName?: boolean
    OrderBy?: boolean
    FieldName?: boolean
    Caption?: boolean
    Color?: boolean
    Background?: boolean
    ColumnWidth?: boolean
    FontStyle?: boolean
    FontSize?: boolean
    ReportTitle?: boolean
    IsSum?: boolean
    ColorIndex?: boolean
  }


  export type $ReportDefinitionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportDefinitions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ReportID: number
      ReportName: string | null
      OrderBy: number | null
      FieldName: string | null
      Caption: string | null
      Color: number | null
      Background: number | null
      ColumnWidth: number | null
      FontStyle: string | null
      FontSize: number | null
      ReportTitle: string | null
      IsSum: boolean
      ColorIndex: number | null
    }, ExtArgs["result"]["reportDefinitions"]>
    composites: {}
  }

  type ReportDefinitionsGetPayload<S extends boolean | null | undefined | ReportDefinitionsDefaultArgs> = $Result.GetResult<Prisma.$ReportDefinitionsPayload, S>

  type ReportDefinitionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportDefinitionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportDefinitionsCountAggregateInputType | true
    }

  export interface ReportDefinitionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportDefinitions'], meta: { name: 'ReportDefinitions' } }
    /**
     * Find zero or one ReportDefinitions that matches the filter.
     * @param {ReportDefinitionsFindUniqueArgs} args - Arguments to find a ReportDefinitions
     * @example
     * // Get one ReportDefinitions
     * const reportDefinitions = await prisma.reportDefinitions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportDefinitionsFindUniqueArgs>(args: SelectSubset<T, ReportDefinitionsFindUniqueArgs<ExtArgs>>): Prisma__ReportDefinitionsClient<$Result.GetResult<Prisma.$ReportDefinitionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReportDefinitions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportDefinitionsFindUniqueOrThrowArgs} args - Arguments to find a ReportDefinitions
     * @example
     * // Get one ReportDefinitions
     * const reportDefinitions = await prisma.reportDefinitions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportDefinitionsFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportDefinitionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportDefinitionsClient<$Result.GetResult<Prisma.$ReportDefinitionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReportDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDefinitionsFindFirstArgs} args - Arguments to find a ReportDefinitions
     * @example
     * // Get one ReportDefinitions
     * const reportDefinitions = await prisma.reportDefinitions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportDefinitionsFindFirstArgs>(args?: SelectSubset<T, ReportDefinitionsFindFirstArgs<ExtArgs>>): Prisma__ReportDefinitionsClient<$Result.GetResult<Prisma.$ReportDefinitionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReportDefinitions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDefinitionsFindFirstOrThrowArgs} args - Arguments to find a ReportDefinitions
     * @example
     * // Get one ReportDefinitions
     * const reportDefinitions = await prisma.reportDefinitions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportDefinitionsFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportDefinitionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportDefinitionsClient<$Result.GetResult<Prisma.$ReportDefinitionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReportDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDefinitionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportDefinitions
     * const reportDefinitions = await prisma.reportDefinitions.findMany()
     * 
     * // Get first 10 ReportDefinitions
     * const reportDefinitions = await prisma.reportDefinitions.findMany({ take: 10 })
     * 
     * // Only select the `ReportID`
     * const reportDefinitionsWithReportIDOnly = await prisma.reportDefinitions.findMany({ select: { ReportID: true } })
     * 
     */
    findMany<T extends ReportDefinitionsFindManyArgs>(args?: SelectSubset<T, ReportDefinitionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDefinitionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReportDefinitions.
     * @param {ReportDefinitionsCreateArgs} args - Arguments to create a ReportDefinitions.
     * @example
     * // Create one ReportDefinitions
     * const ReportDefinitions = await prisma.reportDefinitions.create({
     *   data: {
     *     // ... data to create a ReportDefinitions
     *   }
     * })
     * 
     */
    create<T extends ReportDefinitionsCreateArgs>(args: SelectSubset<T, ReportDefinitionsCreateArgs<ExtArgs>>): Prisma__ReportDefinitionsClient<$Result.GetResult<Prisma.$ReportDefinitionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReportDefinitions.
     * @param {ReportDefinitionsCreateManyArgs} args - Arguments to create many ReportDefinitions.
     * @example
     * // Create many ReportDefinitions
     * const reportDefinitions = await prisma.reportDefinitions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportDefinitionsCreateManyArgs>(args?: SelectSubset<T, ReportDefinitionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReportDefinitions.
     * @param {ReportDefinitionsDeleteArgs} args - Arguments to delete one ReportDefinitions.
     * @example
     * // Delete one ReportDefinitions
     * const ReportDefinitions = await prisma.reportDefinitions.delete({
     *   where: {
     *     // ... filter to delete one ReportDefinitions
     *   }
     * })
     * 
     */
    delete<T extends ReportDefinitionsDeleteArgs>(args: SelectSubset<T, ReportDefinitionsDeleteArgs<ExtArgs>>): Prisma__ReportDefinitionsClient<$Result.GetResult<Prisma.$ReportDefinitionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReportDefinitions.
     * @param {ReportDefinitionsUpdateArgs} args - Arguments to update one ReportDefinitions.
     * @example
     * // Update one ReportDefinitions
     * const reportDefinitions = await prisma.reportDefinitions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportDefinitionsUpdateArgs>(args: SelectSubset<T, ReportDefinitionsUpdateArgs<ExtArgs>>): Prisma__ReportDefinitionsClient<$Result.GetResult<Prisma.$ReportDefinitionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReportDefinitions.
     * @param {ReportDefinitionsDeleteManyArgs} args - Arguments to filter ReportDefinitions to delete.
     * @example
     * // Delete a few ReportDefinitions
     * const { count } = await prisma.reportDefinitions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDefinitionsDeleteManyArgs>(args?: SelectSubset<T, ReportDefinitionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDefinitionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportDefinitions
     * const reportDefinitions = await prisma.reportDefinitions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportDefinitionsUpdateManyArgs>(args: SelectSubset<T, ReportDefinitionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportDefinitions.
     * @param {ReportDefinitionsUpsertArgs} args - Arguments to update or create a ReportDefinitions.
     * @example
     * // Update or create a ReportDefinitions
     * const reportDefinitions = await prisma.reportDefinitions.upsert({
     *   create: {
     *     // ... data to create a ReportDefinitions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportDefinitions we want to update
     *   }
     * })
     */
    upsert<T extends ReportDefinitionsUpsertArgs>(args: SelectSubset<T, ReportDefinitionsUpsertArgs<ExtArgs>>): Prisma__ReportDefinitionsClient<$Result.GetResult<Prisma.$ReportDefinitionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReportDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDefinitionsCountArgs} args - Arguments to filter ReportDefinitions to count.
     * @example
     * // Count the number of ReportDefinitions
     * const count = await prisma.reportDefinitions.count({
     *   where: {
     *     // ... the filter for the ReportDefinitions we want to count
     *   }
     * })
    **/
    count<T extends ReportDefinitionsCountArgs>(
      args?: Subset<T, ReportDefinitionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportDefinitionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDefinitionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportDefinitionsAggregateArgs>(args: Subset<T, ReportDefinitionsAggregateArgs>): Prisma.PrismaPromise<GetReportDefinitionsAggregateType<T>>

    /**
     * Group by ReportDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDefinitionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportDefinitionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportDefinitionsGroupByArgs['orderBy'] }
        : { orderBy?: ReportDefinitionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportDefinitionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportDefinitionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportDefinitions model
   */
  readonly fields: ReportDefinitionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportDefinitions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportDefinitionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportDefinitions model
   */ 
  interface ReportDefinitionsFieldRefs {
    readonly ReportID: FieldRef<"ReportDefinitions", 'Int'>
    readonly ReportName: FieldRef<"ReportDefinitions", 'String'>
    readonly OrderBy: FieldRef<"ReportDefinitions", 'Int'>
    readonly FieldName: FieldRef<"ReportDefinitions", 'String'>
    readonly Caption: FieldRef<"ReportDefinitions", 'String'>
    readonly Color: FieldRef<"ReportDefinitions", 'Int'>
    readonly Background: FieldRef<"ReportDefinitions", 'Int'>
    readonly ColumnWidth: FieldRef<"ReportDefinitions", 'Float'>
    readonly FontStyle: FieldRef<"ReportDefinitions", 'String'>
    readonly FontSize: FieldRef<"ReportDefinitions", 'Int'>
    readonly ReportTitle: FieldRef<"ReportDefinitions", 'String'>
    readonly IsSum: FieldRef<"ReportDefinitions", 'Boolean'>
    readonly ColorIndex: FieldRef<"ReportDefinitions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ReportDefinitions findUnique
   */
  export type ReportDefinitionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDefinitions
     */
    select?: ReportDefinitionsSelect<ExtArgs> | null
    /**
     * Filter, which ReportDefinitions to fetch.
     */
    where: ReportDefinitionsWhereUniqueInput
  }

  /**
   * ReportDefinitions findUniqueOrThrow
   */
  export type ReportDefinitionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDefinitions
     */
    select?: ReportDefinitionsSelect<ExtArgs> | null
    /**
     * Filter, which ReportDefinitions to fetch.
     */
    where: ReportDefinitionsWhereUniqueInput
  }

  /**
   * ReportDefinitions findFirst
   */
  export type ReportDefinitionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDefinitions
     */
    select?: ReportDefinitionsSelect<ExtArgs> | null
    /**
     * Filter, which ReportDefinitions to fetch.
     */
    where?: ReportDefinitionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDefinitions to fetch.
     */
    orderBy?: ReportDefinitionsOrderByWithRelationInput | ReportDefinitionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportDefinitions.
     */
    cursor?: ReportDefinitionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportDefinitions.
     */
    distinct?: ReportDefinitionsScalarFieldEnum | ReportDefinitionsScalarFieldEnum[]
  }

  /**
   * ReportDefinitions findFirstOrThrow
   */
  export type ReportDefinitionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDefinitions
     */
    select?: ReportDefinitionsSelect<ExtArgs> | null
    /**
     * Filter, which ReportDefinitions to fetch.
     */
    where?: ReportDefinitionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDefinitions to fetch.
     */
    orderBy?: ReportDefinitionsOrderByWithRelationInput | ReportDefinitionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportDefinitions.
     */
    cursor?: ReportDefinitionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportDefinitions.
     */
    distinct?: ReportDefinitionsScalarFieldEnum | ReportDefinitionsScalarFieldEnum[]
  }

  /**
   * ReportDefinitions findMany
   */
  export type ReportDefinitionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDefinitions
     */
    select?: ReportDefinitionsSelect<ExtArgs> | null
    /**
     * Filter, which ReportDefinitions to fetch.
     */
    where?: ReportDefinitionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDefinitions to fetch.
     */
    orderBy?: ReportDefinitionsOrderByWithRelationInput | ReportDefinitionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportDefinitions.
     */
    cursor?: ReportDefinitionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDefinitions.
     */
    skip?: number
    distinct?: ReportDefinitionsScalarFieldEnum | ReportDefinitionsScalarFieldEnum[]
  }

  /**
   * ReportDefinitions create
   */
  export type ReportDefinitionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDefinitions
     */
    select?: ReportDefinitionsSelect<ExtArgs> | null
    /**
     * The data needed to create a ReportDefinitions.
     */
    data: XOR<ReportDefinitionsCreateInput, ReportDefinitionsUncheckedCreateInput>
  }

  /**
   * ReportDefinitions createMany
   */
  export type ReportDefinitionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportDefinitions.
     */
    data: ReportDefinitionsCreateManyInput | ReportDefinitionsCreateManyInput[]
  }

  /**
   * ReportDefinitions update
   */
  export type ReportDefinitionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDefinitions
     */
    select?: ReportDefinitionsSelect<ExtArgs> | null
    /**
     * The data needed to update a ReportDefinitions.
     */
    data: XOR<ReportDefinitionsUpdateInput, ReportDefinitionsUncheckedUpdateInput>
    /**
     * Choose, which ReportDefinitions to update.
     */
    where: ReportDefinitionsWhereUniqueInput
  }

  /**
   * ReportDefinitions updateMany
   */
  export type ReportDefinitionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportDefinitions.
     */
    data: XOR<ReportDefinitionsUpdateManyMutationInput, ReportDefinitionsUncheckedUpdateManyInput>
    /**
     * Filter which ReportDefinitions to update
     */
    where?: ReportDefinitionsWhereInput
  }

  /**
   * ReportDefinitions upsert
   */
  export type ReportDefinitionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDefinitions
     */
    select?: ReportDefinitionsSelect<ExtArgs> | null
    /**
     * The filter to search for the ReportDefinitions to update in case it exists.
     */
    where: ReportDefinitionsWhereUniqueInput
    /**
     * In case the ReportDefinitions found by the `where` argument doesn't exist, create a new ReportDefinitions with this data.
     */
    create: XOR<ReportDefinitionsCreateInput, ReportDefinitionsUncheckedCreateInput>
    /**
     * In case the ReportDefinitions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportDefinitionsUpdateInput, ReportDefinitionsUncheckedUpdateInput>
  }

  /**
   * ReportDefinitions delete
   */
  export type ReportDefinitionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDefinitions
     */
    select?: ReportDefinitionsSelect<ExtArgs> | null
    /**
     * Filter which ReportDefinitions to delete.
     */
    where: ReportDefinitionsWhereUniqueInput
  }

  /**
   * ReportDefinitions deleteMany
   */
  export type ReportDefinitionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportDefinitions to delete
     */
    where?: ReportDefinitionsWhereInput
  }

  /**
   * ReportDefinitions without action
   */
  export type ReportDefinitionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDefinitions
     */
    select?: ReportDefinitionsSelect<ExtArgs> | null
  }


  /**
   * Model RewardRecoveryRate
   */

  export type AggregateRewardRecoveryRate = {
    _count: RewardRecoveryRateCountAggregateOutputType | null
    _avg: RewardRecoveryRateAvgAggregateOutputType | null
    _sum: RewardRecoveryRateSumAggregateOutputType | null
    _min: RewardRecoveryRateMinAggregateOutputType | null
    _max: RewardRecoveryRateMaxAggregateOutputType | null
  }

  export type RewardRecoveryRateAvgAggregateOutputType = {
    RecoveryRewardID: number | null
    RewardYear: number | null
    RecoveryRewardRatePerDay: number | null
  }

  export type RewardRecoveryRateSumAggregateOutputType = {
    RecoveryRewardID: number | null
    RewardYear: number | null
    RecoveryRewardRatePerDay: number | null
  }

  export type RewardRecoveryRateMinAggregateOutputType = {
    RecoveryRewardID: number | null
    RewardYear: number | null
    RecoveryRewardRatePerDay: number | null
  }

  export type RewardRecoveryRateMaxAggregateOutputType = {
    RecoveryRewardID: number | null
    RewardYear: number | null
    RecoveryRewardRatePerDay: number | null
  }

  export type RewardRecoveryRateCountAggregateOutputType = {
    RecoveryRewardID: number
    RewardYear: number
    RecoveryRewardRatePerDay: number
    _all: number
  }


  export type RewardRecoveryRateAvgAggregateInputType = {
    RecoveryRewardID?: true
    RewardYear?: true
    RecoveryRewardRatePerDay?: true
  }

  export type RewardRecoveryRateSumAggregateInputType = {
    RecoveryRewardID?: true
    RewardYear?: true
    RecoveryRewardRatePerDay?: true
  }

  export type RewardRecoveryRateMinAggregateInputType = {
    RecoveryRewardID?: true
    RewardYear?: true
    RecoveryRewardRatePerDay?: true
  }

  export type RewardRecoveryRateMaxAggregateInputType = {
    RecoveryRewardID?: true
    RewardYear?: true
    RecoveryRewardRatePerDay?: true
  }

  export type RewardRecoveryRateCountAggregateInputType = {
    RecoveryRewardID?: true
    RewardYear?: true
    RecoveryRewardRatePerDay?: true
    _all?: true
  }

  export type RewardRecoveryRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardRecoveryRate to aggregate.
     */
    where?: RewardRecoveryRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardRecoveryRates to fetch.
     */
    orderBy?: RewardRecoveryRateOrderByWithRelationInput | RewardRecoveryRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardRecoveryRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardRecoveryRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardRecoveryRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardRecoveryRates
    **/
    _count?: true | RewardRecoveryRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardRecoveryRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardRecoveryRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardRecoveryRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardRecoveryRateMaxAggregateInputType
  }

  export type GetRewardRecoveryRateAggregateType<T extends RewardRecoveryRateAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardRecoveryRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardRecoveryRate[P]>
      : GetScalarType<T[P], AggregateRewardRecoveryRate[P]>
  }




  export type RewardRecoveryRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardRecoveryRateWhereInput
    orderBy?: RewardRecoveryRateOrderByWithAggregationInput | RewardRecoveryRateOrderByWithAggregationInput[]
    by: RewardRecoveryRateScalarFieldEnum[] | RewardRecoveryRateScalarFieldEnum
    having?: RewardRecoveryRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardRecoveryRateCountAggregateInputType | true
    _avg?: RewardRecoveryRateAvgAggregateInputType
    _sum?: RewardRecoveryRateSumAggregateInputType
    _min?: RewardRecoveryRateMinAggregateInputType
    _max?: RewardRecoveryRateMaxAggregateInputType
  }

  export type RewardRecoveryRateGroupByOutputType = {
    RecoveryRewardID: number
    RewardYear: number | null
    RecoveryRewardRatePerDay: number | null
    _count: RewardRecoveryRateCountAggregateOutputType | null
    _avg: RewardRecoveryRateAvgAggregateOutputType | null
    _sum: RewardRecoveryRateSumAggregateOutputType | null
    _min: RewardRecoveryRateMinAggregateOutputType | null
    _max: RewardRecoveryRateMaxAggregateOutputType | null
  }

  type GetRewardRecoveryRateGroupByPayload<T extends RewardRecoveryRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardRecoveryRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardRecoveryRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardRecoveryRateGroupByOutputType[P]>
            : GetScalarType<T[P], RewardRecoveryRateGroupByOutputType[P]>
        }
      >
    >


  export type RewardRecoveryRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    RecoveryRewardID?: boolean
    RewardYear?: boolean
    RecoveryRewardRatePerDay?: boolean
  }, ExtArgs["result"]["rewardRecoveryRate"]>


  export type RewardRecoveryRateSelectScalar = {
    RecoveryRewardID?: boolean
    RewardYear?: boolean
    RecoveryRewardRatePerDay?: boolean
  }


  export type $RewardRecoveryRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardRecoveryRate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      RecoveryRewardID: number
      RewardYear: number | null
      RecoveryRewardRatePerDay: number | null
    }, ExtArgs["result"]["rewardRecoveryRate"]>
    composites: {}
  }

  type RewardRecoveryRateGetPayload<S extends boolean | null | undefined | RewardRecoveryRateDefaultArgs> = $Result.GetResult<Prisma.$RewardRecoveryRatePayload, S>

  type RewardRecoveryRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RewardRecoveryRateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RewardRecoveryRateCountAggregateInputType | true
    }

  export interface RewardRecoveryRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardRecoveryRate'], meta: { name: 'RewardRecoveryRate' } }
    /**
     * Find zero or one RewardRecoveryRate that matches the filter.
     * @param {RewardRecoveryRateFindUniqueArgs} args - Arguments to find a RewardRecoveryRate
     * @example
     * // Get one RewardRecoveryRate
     * const rewardRecoveryRate = await prisma.rewardRecoveryRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardRecoveryRateFindUniqueArgs>(args: SelectSubset<T, RewardRecoveryRateFindUniqueArgs<ExtArgs>>): Prisma__RewardRecoveryRateClient<$Result.GetResult<Prisma.$RewardRecoveryRatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RewardRecoveryRate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RewardRecoveryRateFindUniqueOrThrowArgs} args - Arguments to find a RewardRecoveryRate
     * @example
     * // Get one RewardRecoveryRate
     * const rewardRecoveryRate = await prisma.rewardRecoveryRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardRecoveryRateFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardRecoveryRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardRecoveryRateClient<$Result.GetResult<Prisma.$RewardRecoveryRatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RewardRecoveryRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryRateFindFirstArgs} args - Arguments to find a RewardRecoveryRate
     * @example
     * // Get one RewardRecoveryRate
     * const rewardRecoveryRate = await prisma.rewardRecoveryRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardRecoveryRateFindFirstArgs>(args?: SelectSubset<T, RewardRecoveryRateFindFirstArgs<ExtArgs>>): Prisma__RewardRecoveryRateClient<$Result.GetResult<Prisma.$RewardRecoveryRatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RewardRecoveryRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryRateFindFirstOrThrowArgs} args - Arguments to find a RewardRecoveryRate
     * @example
     * // Get one RewardRecoveryRate
     * const rewardRecoveryRate = await prisma.rewardRecoveryRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardRecoveryRateFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardRecoveryRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardRecoveryRateClient<$Result.GetResult<Prisma.$RewardRecoveryRatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RewardRecoveryRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardRecoveryRates
     * const rewardRecoveryRates = await prisma.rewardRecoveryRate.findMany()
     * 
     * // Get first 10 RewardRecoveryRates
     * const rewardRecoveryRates = await prisma.rewardRecoveryRate.findMany({ take: 10 })
     * 
     * // Only select the `RecoveryRewardID`
     * const rewardRecoveryRateWithRecoveryRewardIDOnly = await prisma.rewardRecoveryRate.findMany({ select: { RecoveryRewardID: true } })
     * 
     */
    findMany<T extends RewardRecoveryRateFindManyArgs>(args?: SelectSubset<T, RewardRecoveryRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardRecoveryRatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RewardRecoveryRate.
     * @param {RewardRecoveryRateCreateArgs} args - Arguments to create a RewardRecoveryRate.
     * @example
     * // Create one RewardRecoveryRate
     * const RewardRecoveryRate = await prisma.rewardRecoveryRate.create({
     *   data: {
     *     // ... data to create a RewardRecoveryRate
     *   }
     * })
     * 
     */
    create<T extends RewardRecoveryRateCreateArgs>(args: SelectSubset<T, RewardRecoveryRateCreateArgs<ExtArgs>>): Prisma__RewardRecoveryRateClient<$Result.GetResult<Prisma.$RewardRecoveryRatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RewardRecoveryRates.
     * @param {RewardRecoveryRateCreateManyArgs} args - Arguments to create many RewardRecoveryRates.
     * @example
     * // Create many RewardRecoveryRates
     * const rewardRecoveryRate = await prisma.rewardRecoveryRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardRecoveryRateCreateManyArgs>(args?: SelectSubset<T, RewardRecoveryRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RewardRecoveryRate.
     * @param {RewardRecoveryRateDeleteArgs} args - Arguments to delete one RewardRecoveryRate.
     * @example
     * // Delete one RewardRecoveryRate
     * const RewardRecoveryRate = await prisma.rewardRecoveryRate.delete({
     *   where: {
     *     // ... filter to delete one RewardRecoveryRate
     *   }
     * })
     * 
     */
    delete<T extends RewardRecoveryRateDeleteArgs>(args: SelectSubset<T, RewardRecoveryRateDeleteArgs<ExtArgs>>): Prisma__RewardRecoveryRateClient<$Result.GetResult<Prisma.$RewardRecoveryRatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RewardRecoveryRate.
     * @param {RewardRecoveryRateUpdateArgs} args - Arguments to update one RewardRecoveryRate.
     * @example
     * // Update one RewardRecoveryRate
     * const rewardRecoveryRate = await prisma.rewardRecoveryRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardRecoveryRateUpdateArgs>(args: SelectSubset<T, RewardRecoveryRateUpdateArgs<ExtArgs>>): Prisma__RewardRecoveryRateClient<$Result.GetResult<Prisma.$RewardRecoveryRatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RewardRecoveryRates.
     * @param {RewardRecoveryRateDeleteManyArgs} args - Arguments to filter RewardRecoveryRates to delete.
     * @example
     * // Delete a few RewardRecoveryRates
     * const { count } = await prisma.rewardRecoveryRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardRecoveryRateDeleteManyArgs>(args?: SelectSubset<T, RewardRecoveryRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardRecoveryRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardRecoveryRates
     * const rewardRecoveryRate = await prisma.rewardRecoveryRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardRecoveryRateUpdateManyArgs>(args: SelectSubset<T, RewardRecoveryRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RewardRecoveryRate.
     * @param {RewardRecoveryRateUpsertArgs} args - Arguments to update or create a RewardRecoveryRate.
     * @example
     * // Update or create a RewardRecoveryRate
     * const rewardRecoveryRate = await prisma.rewardRecoveryRate.upsert({
     *   create: {
     *     // ... data to create a RewardRecoveryRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardRecoveryRate we want to update
     *   }
     * })
     */
    upsert<T extends RewardRecoveryRateUpsertArgs>(args: SelectSubset<T, RewardRecoveryRateUpsertArgs<ExtArgs>>): Prisma__RewardRecoveryRateClient<$Result.GetResult<Prisma.$RewardRecoveryRatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RewardRecoveryRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryRateCountArgs} args - Arguments to filter RewardRecoveryRates to count.
     * @example
     * // Count the number of RewardRecoveryRates
     * const count = await prisma.rewardRecoveryRate.count({
     *   where: {
     *     // ... the filter for the RewardRecoveryRates we want to count
     *   }
     * })
    **/
    count<T extends RewardRecoveryRateCountArgs>(
      args?: Subset<T, RewardRecoveryRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardRecoveryRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardRecoveryRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardRecoveryRateAggregateArgs>(args: Subset<T, RewardRecoveryRateAggregateArgs>): Prisma.PrismaPromise<GetRewardRecoveryRateAggregateType<T>>

    /**
     * Group by RewardRecoveryRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardRecoveryRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardRecoveryRateGroupByArgs['orderBy'] }
        : { orderBy?: RewardRecoveryRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardRecoveryRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardRecoveryRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardRecoveryRate model
   */
  readonly fields: RewardRecoveryRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardRecoveryRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardRecoveryRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardRecoveryRate model
   */ 
  interface RewardRecoveryRateFieldRefs {
    readonly RecoveryRewardID: FieldRef<"RewardRecoveryRate", 'Int'>
    readonly RewardYear: FieldRef<"RewardRecoveryRate", 'Int'>
    readonly RecoveryRewardRatePerDay: FieldRef<"RewardRecoveryRate", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * RewardRecoveryRate findUnique
   */
  export type RewardRecoveryRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryRate
     */
    select?: RewardRecoveryRateSelect<ExtArgs> | null
    /**
     * Filter, which RewardRecoveryRate to fetch.
     */
    where: RewardRecoveryRateWhereUniqueInput
  }

  /**
   * RewardRecoveryRate findUniqueOrThrow
   */
  export type RewardRecoveryRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryRate
     */
    select?: RewardRecoveryRateSelect<ExtArgs> | null
    /**
     * Filter, which RewardRecoveryRate to fetch.
     */
    where: RewardRecoveryRateWhereUniqueInput
  }

  /**
   * RewardRecoveryRate findFirst
   */
  export type RewardRecoveryRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryRate
     */
    select?: RewardRecoveryRateSelect<ExtArgs> | null
    /**
     * Filter, which RewardRecoveryRate to fetch.
     */
    where?: RewardRecoveryRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardRecoveryRates to fetch.
     */
    orderBy?: RewardRecoveryRateOrderByWithRelationInput | RewardRecoveryRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardRecoveryRates.
     */
    cursor?: RewardRecoveryRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardRecoveryRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardRecoveryRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardRecoveryRates.
     */
    distinct?: RewardRecoveryRateScalarFieldEnum | RewardRecoveryRateScalarFieldEnum[]
  }

  /**
   * RewardRecoveryRate findFirstOrThrow
   */
  export type RewardRecoveryRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryRate
     */
    select?: RewardRecoveryRateSelect<ExtArgs> | null
    /**
     * Filter, which RewardRecoveryRate to fetch.
     */
    where?: RewardRecoveryRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardRecoveryRates to fetch.
     */
    orderBy?: RewardRecoveryRateOrderByWithRelationInput | RewardRecoveryRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardRecoveryRates.
     */
    cursor?: RewardRecoveryRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardRecoveryRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardRecoveryRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardRecoveryRates.
     */
    distinct?: RewardRecoveryRateScalarFieldEnum | RewardRecoveryRateScalarFieldEnum[]
  }

  /**
   * RewardRecoveryRate findMany
   */
  export type RewardRecoveryRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryRate
     */
    select?: RewardRecoveryRateSelect<ExtArgs> | null
    /**
     * Filter, which RewardRecoveryRates to fetch.
     */
    where?: RewardRecoveryRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardRecoveryRates to fetch.
     */
    orderBy?: RewardRecoveryRateOrderByWithRelationInput | RewardRecoveryRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardRecoveryRates.
     */
    cursor?: RewardRecoveryRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardRecoveryRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardRecoveryRates.
     */
    skip?: number
    distinct?: RewardRecoveryRateScalarFieldEnum | RewardRecoveryRateScalarFieldEnum[]
  }

  /**
   * RewardRecoveryRate create
   */
  export type RewardRecoveryRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryRate
     */
    select?: RewardRecoveryRateSelect<ExtArgs> | null
    /**
     * The data needed to create a RewardRecoveryRate.
     */
    data?: XOR<RewardRecoveryRateCreateInput, RewardRecoveryRateUncheckedCreateInput>
  }

  /**
   * RewardRecoveryRate createMany
   */
  export type RewardRecoveryRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardRecoveryRates.
     */
    data: RewardRecoveryRateCreateManyInput | RewardRecoveryRateCreateManyInput[]
  }

  /**
   * RewardRecoveryRate update
   */
  export type RewardRecoveryRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryRate
     */
    select?: RewardRecoveryRateSelect<ExtArgs> | null
    /**
     * The data needed to update a RewardRecoveryRate.
     */
    data: XOR<RewardRecoveryRateUpdateInput, RewardRecoveryRateUncheckedUpdateInput>
    /**
     * Choose, which RewardRecoveryRate to update.
     */
    where: RewardRecoveryRateWhereUniqueInput
  }

  /**
   * RewardRecoveryRate updateMany
   */
  export type RewardRecoveryRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardRecoveryRates.
     */
    data: XOR<RewardRecoveryRateUpdateManyMutationInput, RewardRecoveryRateUncheckedUpdateManyInput>
    /**
     * Filter which RewardRecoveryRates to update
     */
    where?: RewardRecoveryRateWhereInput
  }

  /**
   * RewardRecoveryRate upsert
   */
  export type RewardRecoveryRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryRate
     */
    select?: RewardRecoveryRateSelect<ExtArgs> | null
    /**
     * The filter to search for the RewardRecoveryRate to update in case it exists.
     */
    where: RewardRecoveryRateWhereUniqueInput
    /**
     * In case the RewardRecoveryRate found by the `where` argument doesn't exist, create a new RewardRecoveryRate with this data.
     */
    create: XOR<RewardRecoveryRateCreateInput, RewardRecoveryRateUncheckedCreateInput>
    /**
     * In case the RewardRecoveryRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardRecoveryRateUpdateInput, RewardRecoveryRateUncheckedUpdateInput>
  }

  /**
   * RewardRecoveryRate delete
   */
  export type RewardRecoveryRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryRate
     */
    select?: RewardRecoveryRateSelect<ExtArgs> | null
    /**
     * Filter which RewardRecoveryRate to delete.
     */
    where: RewardRecoveryRateWhereUniqueInput
  }

  /**
   * RewardRecoveryRate deleteMany
   */
  export type RewardRecoveryRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardRecoveryRates to delete
     */
    where?: RewardRecoveryRateWhereInput
  }

  /**
   * RewardRecoveryRate without action
   */
  export type RewardRecoveryRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryRate
     */
    select?: RewardRecoveryRateSelect<ExtArgs> | null
  }


  /**
   * Model RewardRecoveryVector
   */

  export type AggregateRewardRecoveryVector = {
    _count: RewardRecoveryVectorCountAggregateOutputType | null
    _avg: RewardRecoveryVectorAvgAggregateOutputType | null
    _sum: RewardRecoveryVectorSumAggregateOutputType | null
    _min: RewardRecoveryVectorMinAggregateOutputType | null
    _max: RewardRecoveryVectorMaxAggregateOutputType | null
  }

  export type RewardRecoveryVectorAvgAggregateOutputType = {
    RewardRecoveryVectorID: number | null
    StartYearRewardRecovery: number | null
    EndYearRewardRecovery: number | null
    RecoveryDayQuantity: number | null
  }

  export type RewardRecoveryVectorSumAggregateOutputType = {
    RewardRecoveryVectorID: number | null
    StartYearRewardRecovery: number | null
    EndYearRewardRecovery: number | null
    RecoveryDayQuantity: number | null
  }

  export type RewardRecoveryVectorMinAggregateOutputType = {
    RewardRecoveryVectorID: number | null
    StartYearRewardRecovery: number | null
    EndYearRewardRecovery: number | null
    RecoveryDayQuantity: number | null
  }

  export type RewardRecoveryVectorMaxAggregateOutputType = {
    RewardRecoveryVectorID: number | null
    StartYearRewardRecovery: number | null
    EndYearRewardRecovery: number | null
    RecoveryDayQuantity: number | null
  }

  export type RewardRecoveryVectorCountAggregateOutputType = {
    RewardRecoveryVectorID: number
    StartYearRewardRecovery: number
    EndYearRewardRecovery: number
    RecoveryDayQuantity: number
    _all: number
  }


  export type RewardRecoveryVectorAvgAggregateInputType = {
    RewardRecoveryVectorID?: true
    StartYearRewardRecovery?: true
    EndYearRewardRecovery?: true
    RecoveryDayQuantity?: true
  }

  export type RewardRecoveryVectorSumAggregateInputType = {
    RewardRecoveryVectorID?: true
    StartYearRewardRecovery?: true
    EndYearRewardRecovery?: true
    RecoveryDayQuantity?: true
  }

  export type RewardRecoveryVectorMinAggregateInputType = {
    RewardRecoveryVectorID?: true
    StartYearRewardRecovery?: true
    EndYearRewardRecovery?: true
    RecoveryDayQuantity?: true
  }

  export type RewardRecoveryVectorMaxAggregateInputType = {
    RewardRecoveryVectorID?: true
    StartYearRewardRecovery?: true
    EndYearRewardRecovery?: true
    RecoveryDayQuantity?: true
  }

  export type RewardRecoveryVectorCountAggregateInputType = {
    RewardRecoveryVectorID?: true
    StartYearRewardRecovery?: true
    EndYearRewardRecovery?: true
    RecoveryDayQuantity?: true
    _all?: true
  }

  export type RewardRecoveryVectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardRecoveryVector to aggregate.
     */
    where?: RewardRecoveryVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardRecoveryVectors to fetch.
     */
    orderBy?: RewardRecoveryVectorOrderByWithRelationInput | RewardRecoveryVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardRecoveryVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardRecoveryVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardRecoveryVectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardRecoveryVectors
    **/
    _count?: true | RewardRecoveryVectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardRecoveryVectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardRecoveryVectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardRecoveryVectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardRecoveryVectorMaxAggregateInputType
  }

  export type GetRewardRecoveryVectorAggregateType<T extends RewardRecoveryVectorAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardRecoveryVector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardRecoveryVector[P]>
      : GetScalarType<T[P], AggregateRewardRecoveryVector[P]>
  }




  export type RewardRecoveryVectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardRecoveryVectorWhereInput
    orderBy?: RewardRecoveryVectorOrderByWithAggregationInput | RewardRecoveryVectorOrderByWithAggregationInput[]
    by: RewardRecoveryVectorScalarFieldEnum[] | RewardRecoveryVectorScalarFieldEnum
    having?: RewardRecoveryVectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardRecoveryVectorCountAggregateInputType | true
    _avg?: RewardRecoveryVectorAvgAggregateInputType
    _sum?: RewardRecoveryVectorSumAggregateInputType
    _min?: RewardRecoveryVectorMinAggregateInputType
    _max?: RewardRecoveryVectorMaxAggregateInputType
  }

  export type RewardRecoveryVectorGroupByOutputType = {
    RewardRecoveryVectorID: number
    StartYearRewardRecovery: number | null
    EndYearRewardRecovery: number | null
    RecoveryDayQuantity: number | null
    _count: RewardRecoveryVectorCountAggregateOutputType | null
    _avg: RewardRecoveryVectorAvgAggregateOutputType | null
    _sum: RewardRecoveryVectorSumAggregateOutputType | null
    _min: RewardRecoveryVectorMinAggregateOutputType | null
    _max: RewardRecoveryVectorMaxAggregateOutputType | null
  }

  type GetRewardRecoveryVectorGroupByPayload<T extends RewardRecoveryVectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardRecoveryVectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardRecoveryVectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardRecoveryVectorGroupByOutputType[P]>
            : GetScalarType<T[P], RewardRecoveryVectorGroupByOutputType[P]>
        }
      >
    >


  export type RewardRecoveryVectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    RewardRecoveryVectorID?: boolean
    StartYearRewardRecovery?: boolean
    EndYearRewardRecovery?: boolean
    RecoveryDayQuantity?: boolean
  }, ExtArgs["result"]["rewardRecoveryVector"]>


  export type RewardRecoveryVectorSelectScalar = {
    RewardRecoveryVectorID?: boolean
    StartYearRewardRecovery?: boolean
    EndYearRewardRecovery?: boolean
    RecoveryDayQuantity?: boolean
  }


  export type $RewardRecoveryVectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardRecoveryVector"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      RewardRecoveryVectorID: number
      StartYearRewardRecovery: number | null
      EndYearRewardRecovery: number | null
      RecoveryDayQuantity: number | null
    }, ExtArgs["result"]["rewardRecoveryVector"]>
    composites: {}
  }

  type RewardRecoveryVectorGetPayload<S extends boolean | null | undefined | RewardRecoveryVectorDefaultArgs> = $Result.GetResult<Prisma.$RewardRecoveryVectorPayload, S>

  type RewardRecoveryVectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RewardRecoveryVectorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RewardRecoveryVectorCountAggregateInputType | true
    }

  export interface RewardRecoveryVectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardRecoveryVector'], meta: { name: 'RewardRecoveryVector' } }
    /**
     * Find zero or one RewardRecoveryVector that matches the filter.
     * @param {RewardRecoveryVectorFindUniqueArgs} args - Arguments to find a RewardRecoveryVector
     * @example
     * // Get one RewardRecoveryVector
     * const rewardRecoveryVector = await prisma.rewardRecoveryVector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardRecoveryVectorFindUniqueArgs>(args: SelectSubset<T, RewardRecoveryVectorFindUniqueArgs<ExtArgs>>): Prisma__RewardRecoveryVectorClient<$Result.GetResult<Prisma.$RewardRecoveryVectorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RewardRecoveryVector that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RewardRecoveryVectorFindUniqueOrThrowArgs} args - Arguments to find a RewardRecoveryVector
     * @example
     * // Get one RewardRecoveryVector
     * const rewardRecoveryVector = await prisma.rewardRecoveryVector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardRecoveryVectorFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardRecoveryVectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardRecoveryVectorClient<$Result.GetResult<Prisma.$RewardRecoveryVectorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RewardRecoveryVector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryVectorFindFirstArgs} args - Arguments to find a RewardRecoveryVector
     * @example
     * // Get one RewardRecoveryVector
     * const rewardRecoveryVector = await prisma.rewardRecoveryVector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardRecoveryVectorFindFirstArgs>(args?: SelectSubset<T, RewardRecoveryVectorFindFirstArgs<ExtArgs>>): Prisma__RewardRecoveryVectorClient<$Result.GetResult<Prisma.$RewardRecoveryVectorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RewardRecoveryVector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryVectorFindFirstOrThrowArgs} args - Arguments to find a RewardRecoveryVector
     * @example
     * // Get one RewardRecoveryVector
     * const rewardRecoveryVector = await prisma.rewardRecoveryVector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardRecoveryVectorFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardRecoveryVectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardRecoveryVectorClient<$Result.GetResult<Prisma.$RewardRecoveryVectorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RewardRecoveryVectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryVectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardRecoveryVectors
     * const rewardRecoveryVectors = await prisma.rewardRecoveryVector.findMany()
     * 
     * // Get first 10 RewardRecoveryVectors
     * const rewardRecoveryVectors = await prisma.rewardRecoveryVector.findMany({ take: 10 })
     * 
     * // Only select the `RewardRecoveryVectorID`
     * const rewardRecoveryVectorWithRewardRecoveryVectorIDOnly = await prisma.rewardRecoveryVector.findMany({ select: { RewardRecoveryVectorID: true } })
     * 
     */
    findMany<T extends RewardRecoveryVectorFindManyArgs>(args?: SelectSubset<T, RewardRecoveryVectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardRecoveryVectorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RewardRecoveryVector.
     * @param {RewardRecoveryVectorCreateArgs} args - Arguments to create a RewardRecoveryVector.
     * @example
     * // Create one RewardRecoveryVector
     * const RewardRecoveryVector = await prisma.rewardRecoveryVector.create({
     *   data: {
     *     // ... data to create a RewardRecoveryVector
     *   }
     * })
     * 
     */
    create<T extends RewardRecoveryVectorCreateArgs>(args: SelectSubset<T, RewardRecoveryVectorCreateArgs<ExtArgs>>): Prisma__RewardRecoveryVectorClient<$Result.GetResult<Prisma.$RewardRecoveryVectorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RewardRecoveryVectors.
     * @param {RewardRecoveryVectorCreateManyArgs} args - Arguments to create many RewardRecoveryVectors.
     * @example
     * // Create many RewardRecoveryVectors
     * const rewardRecoveryVector = await prisma.rewardRecoveryVector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardRecoveryVectorCreateManyArgs>(args?: SelectSubset<T, RewardRecoveryVectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RewardRecoveryVector.
     * @param {RewardRecoveryVectorDeleteArgs} args - Arguments to delete one RewardRecoveryVector.
     * @example
     * // Delete one RewardRecoveryVector
     * const RewardRecoveryVector = await prisma.rewardRecoveryVector.delete({
     *   where: {
     *     // ... filter to delete one RewardRecoveryVector
     *   }
     * })
     * 
     */
    delete<T extends RewardRecoveryVectorDeleteArgs>(args: SelectSubset<T, RewardRecoveryVectorDeleteArgs<ExtArgs>>): Prisma__RewardRecoveryVectorClient<$Result.GetResult<Prisma.$RewardRecoveryVectorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RewardRecoveryVector.
     * @param {RewardRecoveryVectorUpdateArgs} args - Arguments to update one RewardRecoveryVector.
     * @example
     * // Update one RewardRecoveryVector
     * const rewardRecoveryVector = await prisma.rewardRecoveryVector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardRecoveryVectorUpdateArgs>(args: SelectSubset<T, RewardRecoveryVectorUpdateArgs<ExtArgs>>): Prisma__RewardRecoveryVectorClient<$Result.GetResult<Prisma.$RewardRecoveryVectorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RewardRecoveryVectors.
     * @param {RewardRecoveryVectorDeleteManyArgs} args - Arguments to filter RewardRecoveryVectors to delete.
     * @example
     * // Delete a few RewardRecoveryVectors
     * const { count } = await prisma.rewardRecoveryVector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardRecoveryVectorDeleteManyArgs>(args?: SelectSubset<T, RewardRecoveryVectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardRecoveryVectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryVectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardRecoveryVectors
     * const rewardRecoveryVector = await prisma.rewardRecoveryVector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardRecoveryVectorUpdateManyArgs>(args: SelectSubset<T, RewardRecoveryVectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RewardRecoveryVector.
     * @param {RewardRecoveryVectorUpsertArgs} args - Arguments to update or create a RewardRecoveryVector.
     * @example
     * // Update or create a RewardRecoveryVector
     * const rewardRecoveryVector = await prisma.rewardRecoveryVector.upsert({
     *   create: {
     *     // ... data to create a RewardRecoveryVector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardRecoveryVector we want to update
     *   }
     * })
     */
    upsert<T extends RewardRecoveryVectorUpsertArgs>(args: SelectSubset<T, RewardRecoveryVectorUpsertArgs<ExtArgs>>): Prisma__RewardRecoveryVectorClient<$Result.GetResult<Prisma.$RewardRecoveryVectorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RewardRecoveryVectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryVectorCountArgs} args - Arguments to filter RewardRecoveryVectors to count.
     * @example
     * // Count the number of RewardRecoveryVectors
     * const count = await prisma.rewardRecoveryVector.count({
     *   where: {
     *     // ... the filter for the RewardRecoveryVectors we want to count
     *   }
     * })
    **/
    count<T extends RewardRecoveryVectorCountArgs>(
      args?: Subset<T, RewardRecoveryVectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardRecoveryVectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardRecoveryVector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryVectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardRecoveryVectorAggregateArgs>(args: Subset<T, RewardRecoveryVectorAggregateArgs>): Prisma.PrismaPromise<GetRewardRecoveryVectorAggregateType<T>>

    /**
     * Group by RewardRecoveryVector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardRecoveryVectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardRecoveryVectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardRecoveryVectorGroupByArgs['orderBy'] }
        : { orderBy?: RewardRecoveryVectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardRecoveryVectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardRecoveryVectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardRecoveryVector model
   */
  readonly fields: RewardRecoveryVectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardRecoveryVector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardRecoveryVectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardRecoveryVector model
   */ 
  interface RewardRecoveryVectorFieldRefs {
    readonly RewardRecoveryVectorID: FieldRef<"RewardRecoveryVector", 'Int'>
    readonly StartYearRewardRecovery: FieldRef<"RewardRecoveryVector", 'Float'>
    readonly EndYearRewardRecovery: FieldRef<"RewardRecoveryVector", 'Float'>
    readonly RecoveryDayQuantity: FieldRef<"RewardRecoveryVector", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RewardRecoveryVector findUnique
   */
  export type RewardRecoveryVectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryVector
     */
    select?: RewardRecoveryVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardRecoveryVector to fetch.
     */
    where: RewardRecoveryVectorWhereUniqueInput
  }

  /**
   * RewardRecoveryVector findUniqueOrThrow
   */
  export type RewardRecoveryVectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryVector
     */
    select?: RewardRecoveryVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardRecoveryVector to fetch.
     */
    where: RewardRecoveryVectorWhereUniqueInput
  }

  /**
   * RewardRecoveryVector findFirst
   */
  export type RewardRecoveryVectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryVector
     */
    select?: RewardRecoveryVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardRecoveryVector to fetch.
     */
    where?: RewardRecoveryVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardRecoveryVectors to fetch.
     */
    orderBy?: RewardRecoveryVectorOrderByWithRelationInput | RewardRecoveryVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardRecoveryVectors.
     */
    cursor?: RewardRecoveryVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardRecoveryVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardRecoveryVectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardRecoveryVectors.
     */
    distinct?: RewardRecoveryVectorScalarFieldEnum | RewardRecoveryVectorScalarFieldEnum[]
  }

  /**
   * RewardRecoveryVector findFirstOrThrow
   */
  export type RewardRecoveryVectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryVector
     */
    select?: RewardRecoveryVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardRecoveryVector to fetch.
     */
    where?: RewardRecoveryVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardRecoveryVectors to fetch.
     */
    orderBy?: RewardRecoveryVectorOrderByWithRelationInput | RewardRecoveryVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardRecoveryVectors.
     */
    cursor?: RewardRecoveryVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardRecoveryVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardRecoveryVectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardRecoveryVectors.
     */
    distinct?: RewardRecoveryVectorScalarFieldEnum | RewardRecoveryVectorScalarFieldEnum[]
  }

  /**
   * RewardRecoveryVector findMany
   */
  export type RewardRecoveryVectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryVector
     */
    select?: RewardRecoveryVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardRecoveryVectors to fetch.
     */
    where?: RewardRecoveryVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardRecoveryVectors to fetch.
     */
    orderBy?: RewardRecoveryVectorOrderByWithRelationInput | RewardRecoveryVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardRecoveryVectors.
     */
    cursor?: RewardRecoveryVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardRecoveryVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardRecoveryVectors.
     */
    skip?: number
    distinct?: RewardRecoveryVectorScalarFieldEnum | RewardRecoveryVectorScalarFieldEnum[]
  }

  /**
   * RewardRecoveryVector create
   */
  export type RewardRecoveryVectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryVector
     */
    select?: RewardRecoveryVectorSelect<ExtArgs> | null
    /**
     * The data needed to create a RewardRecoveryVector.
     */
    data?: XOR<RewardRecoveryVectorCreateInput, RewardRecoveryVectorUncheckedCreateInput>
  }

  /**
   * RewardRecoveryVector createMany
   */
  export type RewardRecoveryVectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardRecoveryVectors.
     */
    data: RewardRecoveryVectorCreateManyInput | RewardRecoveryVectorCreateManyInput[]
  }

  /**
   * RewardRecoveryVector update
   */
  export type RewardRecoveryVectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryVector
     */
    select?: RewardRecoveryVectorSelect<ExtArgs> | null
    /**
     * The data needed to update a RewardRecoveryVector.
     */
    data: XOR<RewardRecoveryVectorUpdateInput, RewardRecoveryVectorUncheckedUpdateInput>
    /**
     * Choose, which RewardRecoveryVector to update.
     */
    where: RewardRecoveryVectorWhereUniqueInput
  }

  /**
   * RewardRecoveryVector updateMany
   */
  export type RewardRecoveryVectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardRecoveryVectors.
     */
    data: XOR<RewardRecoveryVectorUpdateManyMutationInput, RewardRecoveryVectorUncheckedUpdateManyInput>
    /**
     * Filter which RewardRecoveryVectors to update
     */
    where?: RewardRecoveryVectorWhereInput
  }

  /**
   * RewardRecoveryVector upsert
   */
  export type RewardRecoveryVectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryVector
     */
    select?: RewardRecoveryVectorSelect<ExtArgs> | null
    /**
     * The filter to search for the RewardRecoveryVector to update in case it exists.
     */
    where: RewardRecoveryVectorWhereUniqueInput
    /**
     * In case the RewardRecoveryVector found by the `where` argument doesn't exist, create a new RewardRecoveryVector with this data.
     */
    create: XOR<RewardRecoveryVectorCreateInput, RewardRecoveryVectorUncheckedCreateInput>
    /**
     * In case the RewardRecoveryVector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardRecoveryVectorUpdateInput, RewardRecoveryVectorUncheckedUpdateInput>
  }

  /**
   * RewardRecoveryVector delete
   */
  export type RewardRecoveryVectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryVector
     */
    select?: RewardRecoveryVectorSelect<ExtArgs> | null
    /**
     * Filter which RewardRecoveryVector to delete.
     */
    where: RewardRecoveryVectorWhereUniqueInput
  }

  /**
   * RewardRecoveryVector deleteMany
   */
  export type RewardRecoveryVectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardRecoveryVectors to delete
     */
    where?: RewardRecoveryVectorWhereInput
  }

  /**
   * RewardRecoveryVector without action
   */
  export type RewardRecoveryVectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardRecoveryVector
     */
    select?: RewardRecoveryVectorSelect<ExtArgs> | null
  }


  /**
   * Model RewardSickVector
   */

  export type AggregateRewardSickVector = {
    _count: RewardSickVectorCountAggregateOutputType | null
    _avg: RewardSickVectorAvgAggregateOutputType | null
    _sum: RewardSickVectorSumAggregateOutputType | null
    _min: RewardSickVectorMinAggregateOutputType | null
    _max: RewardSickVectorMaxAggregateOutputType | null
  }

  export type RewardSickVectorAvgAggregateOutputType = {
    RewardSickVectorID: number | null
    StartYearRewardSick: number | null
    EndYearRewardSick: number | null
    SickDayQuantity: number | null
  }

  export type RewardSickVectorSumAggregateOutputType = {
    RewardSickVectorID: number | null
    StartYearRewardSick: number | null
    EndYearRewardSick: number | null
    SickDayQuantity: number | null
  }

  export type RewardSickVectorMinAggregateOutputType = {
    RewardSickVectorID: number | null
    StartYearRewardSick: number | null
    EndYearRewardSick: number | null
    SickDayQuantity: number | null
  }

  export type RewardSickVectorMaxAggregateOutputType = {
    RewardSickVectorID: number | null
    StartYearRewardSick: number | null
    EndYearRewardSick: number | null
    SickDayQuantity: number | null
  }

  export type RewardSickVectorCountAggregateOutputType = {
    RewardSickVectorID: number
    StartYearRewardSick: number
    EndYearRewardSick: number
    SickDayQuantity: number
    _all: number
  }


  export type RewardSickVectorAvgAggregateInputType = {
    RewardSickVectorID?: true
    StartYearRewardSick?: true
    EndYearRewardSick?: true
    SickDayQuantity?: true
  }

  export type RewardSickVectorSumAggregateInputType = {
    RewardSickVectorID?: true
    StartYearRewardSick?: true
    EndYearRewardSick?: true
    SickDayQuantity?: true
  }

  export type RewardSickVectorMinAggregateInputType = {
    RewardSickVectorID?: true
    StartYearRewardSick?: true
    EndYearRewardSick?: true
    SickDayQuantity?: true
  }

  export type RewardSickVectorMaxAggregateInputType = {
    RewardSickVectorID?: true
    StartYearRewardSick?: true
    EndYearRewardSick?: true
    SickDayQuantity?: true
  }

  export type RewardSickVectorCountAggregateInputType = {
    RewardSickVectorID?: true
    StartYearRewardSick?: true
    EndYearRewardSick?: true
    SickDayQuantity?: true
    _all?: true
  }

  export type RewardSickVectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardSickVector to aggregate.
     */
    where?: RewardSickVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardSickVectors to fetch.
     */
    orderBy?: RewardSickVectorOrderByWithRelationInput | RewardSickVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardSickVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardSickVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardSickVectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardSickVectors
    **/
    _count?: true | RewardSickVectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardSickVectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardSickVectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardSickVectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardSickVectorMaxAggregateInputType
  }

  export type GetRewardSickVectorAggregateType<T extends RewardSickVectorAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardSickVector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardSickVector[P]>
      : GetScalarType<T[P], AggregateRewardSickVector[P]>
  }




  export type RewardSickVectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardSickVectorWhereInput
    orderBy?: RewardSickVectorOrderByWithAggregationInput | RewardSickVectorOrderByWithAggregationInput[]
    by: RewardSickVectorScalarFieldEnum[] | RewardSickVectorScalarFieldEnum
    having?: RewardSickVectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardSickVectorCountAggregateInputType | true
    _avg?: RewardSickVectorAvgAggregateInputType
    _sum?: RewardSickVectorSumAggregateInputType
    _min?: RewardSickVectorMinAggregateInputType
    _max?: RewardSickVectorMaxAggregateInputType
  }

  export type RewardSickVectorGroupByOutputType = {
    RewardSickVectorID: number
    StartYearRewardSick: number | null
    EndYearRewardSick: number | null
    SickDayQuantity: number | null
    _count: RewardSickVectorCountAggregateOutputType | null
    _avg: RewardSickVectorAvgAggregateOutputType | null
    _sum: RewardSickVectorSumAggregateOutputType | null
    _min: RewardSickVectorMinAggregateOutputType | null
    _max: RewardSickVectorMaxAggregateOutputType | null
  }

  type GetRewardSickVectorGroupByPayload<T extends RewardSickVectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardSickVectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardSickVectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardSickVectorGroupByOutputType[P]>
            : GetScalarType<T[P], RewardSickVectorGroupByOutputType[P]>
        }
      >
    >


  export type RewardSickVectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    RewardSickVectorID?: boolean
    StartYearRewardSick?: boolean
    EndYearRewardSick?: boolean
    SickDayQuantity?: boolean
  }, ExtArgs["result"]["rewardSickVector"]>


  export type RewardSickVectorSelectScalar = {
    RewardSickVectorID?: boolean
    StartYearRewardSick?: boolean
    EndYearRewardSick?: boolean
    SickDayQuantity?: boolean
  }


  export type $RewardSickVectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardSickVector"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      RewardSickVectorID: number
      StartYearRewardSick: number | null
      EndYearRewardSick: number | null
      SickDayQuantity: number | null
    }, ExtArgs["result"]["rewardSickVector"]>
    composites: {}
  }

  type RewardSickVectorGetPayload<S extends boolean | null | undefined | RewardSickVectorDefaultArgs> = $Result.GetResult<Prisma.$RewardSickVectorPayload, S>

  type RewardSickVectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RewardSickVectorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RewardSickVectorCountAggregateInputType | true
    }

  export interface RewardSickVectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardSickVector'], meta: { name: 'RewardSickVector' } }
    /**
     * Find zero or one RewardSickVector that matches the filter.
     * @param {RewardSickVectorFindUniqueArgs} args - Arguments to find a RewardSickVector
     * @example
     * // Get one RewardSickVector
     * const rewardSickVector = await prisma.rewardSickVector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardSickVectorFindUniqueArgs>(args: SelectSubset<T, RewardSickVectorFindUniqueArgs<ExtArgs>>): Prisma__RewardSickVectorClient<$Result.GetResult<Prisma.$RewardSickVectorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RewardSickVector that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RewardSickVectorFindUniqueOrThrowArgs} args - Arguments to find a RewardSickVector
     * @example
     * // Get one RewardSickVector
     * const rewardSickVector = await prisma.rewardSickVector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardSickVectorFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardSickVectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardSickVectorClient<$Result.GetResult<Prisma.$RewardSickVectorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RewardSickVector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardSickVectorFindFirstArgs} args - Arguments to find a RewardSickVector
     * @example
     * // Get one RewardSickVector
     * const rewardSickVector = await prisma.rewardSickVector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardSickVectorFindFirstArgs>(args?: SelectSubset<T, RewardSickVectorFindFirstArgs<ExtArgs>>): Prisma__RewardSickVectorClient<$Result.GetResult<Prisma.$RewardSickVectorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RewardSickVector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardSickVectorFindFirstOrThrowArgs} args - Arguments to find a RewardSickVector
     * @example
     * // Get one RewardSickVector
     * const rewardSickVector = await prisma.rewardSickVector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardSickVectorFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardSickVectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardSickVectorClient<$Result.GetResult<Prisma.$RewardSickVectorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RewardSickVectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardSickVectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardSickVectors
     * const rewardSickVectors = await prisma.rewardSickVector.findMany()
     * 
     * // Get first 10 RewardSickVectors
     * const rewardSickVectors = await prisma.rewardSickVector.findMany({ take: 10 })
     * 
     * // Only select the `RewardSickVectorID`
     * const rewardSickVectorWithRewardSickVectorIDOnly = await prisma.rewardSickVector.findMany({ select: { RewardSickVectorID: true } })
     * 
     */
    findMany<T extends RewardSickVectorFindManyArgs>(args?: SelectSubset<T, RewardSickVectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardSickVectorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RewardSickVector.
     * @param {RewardSickVectorCreateArgs} args - Arguments to create a RewardSickVector.
     * @example
     * // Create one RewardSickVector
     * const RewardSickVector = await prisma.rewardSickVector.create({
     *   data: {
     *     // ... data to create a RewardSickVector
     *   }
     * })
     * 
     */
    create<T extends RewardSickVectorCreateArgs>(args: SelectSubset<T, RewardSickVectorCreateArgs<ExtArgs>>): Prisma__RewardSickVectorClient<$Result.GetResult<Prisma.$RewardSickVectorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RewardSickVectors.
     * @param {RewardSickVectorCreateManyArgs} args - Arguments to create many RewardSickVectors.
     * @example
     * // Create many RewardSickVectors
     * const rewardSickVector = await prisma.rewardSickVector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardSickVectorCreateManyArgs>(args?: SelectSubset<T, RewardSickVectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RewardSickVector.
     * @param {RewardSickVectorDeleteArgs} args - Arguments to delete one RewardSickVector.
     * @example
     * // Delete one RewardSickVector
     * const RewardSickVector = await prisma.rewardSickVector.delete({
     *   where: {
     *     // ... filter to delete one RewardSickVector
     *   }
     * })
     * 
     */
    delete<T extends RewardSickVectorDeleteArgs>(args: SelectSubset<T, RewardSickVectorDeleteArgs<ExtArgs>>): Prisma__RewardSickVectorClient<$Result.GetResult<Prisma.$RewardSickVectorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RewardSickVector.
     * @param {RewardSickVectorUpdateArgs} args - Arguments to update one RewardSickVector.
     * @example
     * // Update one RewardSickVector
     * const rewardSickVector = await prisma.rewardSickVector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardSickVectorUpdateArgs>(args: SelectSubset<T, RewardSickVectorUpdateArgs<ExtArgs>>): Prisma__RewardSickVectorClient<$Result.GetResult<Prisma.$RewardSickVectorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RewardSickVectors.
     * @param {RewardSickVectorDeleteManyArgs} args - Arguments to filter RewardSickVectors to delete.
     * @example
     * // Delete a few RewardSickVectors
     * const { count } = await prisma.rewardSickVector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardSickVectorDeleteManyArgs>(args?: SelectSubset<T, RewardSickVectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardSickVectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardSickVectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardSickVectors
     * const rewardSickVector = await prisma.rewardSickVector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardSickVectorUpdateManyArgs>(args: SelectSubset<T, RewardSickVectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RewardSickVector.
     * @param {RewardSickVectorUpsertArgs} args - Arguments to update or create a RewardSickVector.
     * @example
     * // Update or create a RewardSickVector
     * const rewardSickVector = await prisma.rewardSickVector.upsert({
     *   create: {
     *     // ... data to create a RewardSickVector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardSickVector we want to update
     *   }
     * })
     */
    upsert<T extends RewardSickVectorUpsertArgs>(args: SelectSubset<T, RewardSickVectorUpsertArgs<ExtArgs>>): Prisma__RewardSickVectorClient<$Result.GetResult<Prisma.$RewardSickVectorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RewardSickVectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardSickVectorCountArgs} args - Arguments to filter RewardSickVectors to count.
     * @example
     * // Count the number of RewardSickVectors
     * const count = await prisma.rewardSickVector.count({
     *   where: {
     *     // ... the filter for the RewardSickVectors we want to count
     *   }
     * })
    **/
    count<T extends RewardSickVectorCountArgs>(
      args?: Subset<T, RewardSickVectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardSickVectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardSickVector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardSickVectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardSickVectorAggregateArgs>(args: Subset<T, RewardSickVectorAggregateArgs>): Prisma.PrismaPromise<GetRewardSickVectorAggregateType<T>>

    /**
     * Group by RewardSickVector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardSickVectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardSickVectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardSickVectorGroupByArgs['orderBy'] }
        : { orderBy?: RewardSickVectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardSickVectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardSickVectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardSickVector model
   */
  readonly fields: RewardSickVectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardSickVector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardSickVectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardSickVector model
   */ 
  interface RewardSickVectorFieldRefs {
    readonly RewardSickVectorID: FieldRef<"RewardSickVector", 'Int'>
    readonly StartYearRewardSick: FieldRef<"RewardSickVector", 'Int'>
    readonly EndYearRewardSick: FieldRef<"RewardSickVector", 'Int'>
    readonly SickDayQuantity: FieldRef<"RewardSickVector", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * RewardSickVector findUnique
   */
  export type RewardSickVectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardSickVector
     */
    select?: RewardSickVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardSickVector to fetch.
     */
    where: RewardSickVectorWhereUniqueInput
  }

  /**
   * RewardSickVector findUniqueOrThrow
   */
  export type RewardSickVectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardSickVector
     */
    select?: RewardSickVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardSickVector to fetch.
     */
    where: RewardSickVectorWhereUniqueInput
  }

  /**
   * RewardSickVector findFirst
   */
  export type RewardSickVectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardSickVector
     */
    select?: RewardSickVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardSickVector to fetch.
     */
    where?: RewardSickVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardSickVectors to fetch.
     */
    orderBy?: RewardSickVectorOrderByWithRelationInput | RewardSickVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardSickVectors.
     */
    cursor?: RewardSickVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardSickVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardSickVectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardSickVectors.
     */
    distinct?: RewardSickVectorScalarFieldEnum | RewardSickVectorScalarFieldEnum[]
  }

  /**
   * RewardSickVector findFirstOrThrow
   */
  export type RewardSickVectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardSickVector
     */
    select?: RewardSickVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardSickVector to fetch.
     */
    where?: RewardSickVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardSickVectors to fetch.
     */
    orderBy?: RewardSickVectorOrderByWithRelationInput | RewardSickVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardSickVectors.
     */
    cursor?: RewardSickVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardSickVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardSickVectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardSickVectors.
     */
    distinct?: RewardSickVectorScalarFieldEnum | RewardSickVectorScalarFieldEnum[]
  }

  /**
   * RewardSickVector findMany
   */
  export type RewardSickVectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardSickVector
     */
    select?: RewardSickVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardSickVectors to fetch.
     */
    where?: RewardSickVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardSickVectors to fetch.
     */
    orderBy?: RewardSickVectorOrderByWithRelationInput | RewardSickVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardSickVectors.
     */
    cursor?: RewardSickVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardSickVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardSickVectors.
     */
    skip?: number
    distinct?: RewardSickVectorScalarFieldEnum | RewardSickVectorScalarFieldEnum[]
  }

  /**
   * RewardSickVector create
   */
  export type RewardSickVectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardSickVector
     */
    select?: RewardSickVectorSelect<ExtArgs> | null
    /**
     * The data needed to create a RewardSickVector.
     */
    data: XOR<RewardSickVectorCreateInput, RewardSickVectorUncheckedCreateInput>
  }

  /**
   * RewardSickVector createMany
   */
  export type RewardSickVectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardSickVectors.
     */
    data: RewardSickVectorCreateManyInput | RewardSickVectorCreateManyInput[]
  }

  /**
   * RewardSickVector update
   */
  export type RewardSickVectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardSickVector
     */
    select?: RewardSickVectorSelect<ExtArgs> | null
    /**
     * The data needed to update a RewardSickVector.
     */
    data: XOR<RewardSickVectorUpdateInput, RewardSickVectorUncheckedUpdateInput>
    /**
     * Choose, which RewardSickVector to update.
     */
    where: RewardSickVectorWhereUniqueInput
  }

  /**
   * RewardSickVector updateMany
   */
  export type RewardSickVectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardSickVectors.
     */
    data: XOR<RewardSickVectorUpdateManyMutationInput, RewardSickVectorUncheckedUpdateManyInput>
    /**
     * Filter which RewardSickVectors to update
     */
    where?: RewardSickVectorWhereInput
  }

  /**
   * RewardSickVector upsert
   */
  export type RewardSickVectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardSickVector
     */
    select?: RewardSickVectorSelect<ExtArgs> | null
    /**
     * The filter to search for the RewardSickVector to update in case it exists.
     */
    where: RewardSickVectorWhereUniqueInput
    /**
     * In case the RewardSickVector found by the `where` argument doesn't exist, create a new RewardSickVector with this data.
     */
    create: XOR<RewardSickVectorCreateInput, RewardSickVectorUncheckedCreateInput>
    /**
     * In case the RewardSickVector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardSickVectorUpdateInput, RewardSickVectorUncheckedUpdateInput>
  }

  /**
   * RewardSickVector delete
   */
  export type RewardSickVectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardSickVector
     */
    select?: RewardSickVectorSelect<ExtArgs> | null
    /**
     * Filter which RewardSickVector to delete.
     */
    where: RewardSickVectorWhereUniqueInput
  }

  /**
   * RewardSickVector deleteMany
   */
  export type RewardSickVectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardSickVectors to delete
     */
    where?: RewardSickVectorWhereInput
  }

  /**
   * RewardSickVector without action
   */
  export type RewardSickVectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardSickVector
     */
    select?: RewardSickVectorSelect<ExtArgs> | null
  }


  /**
   * Model RewardVacationVector
   */

  export type AggregateRewardVacationVector = {
    _count: RewardVacationVectorCountAggregateOutputType | null
    _avg: RewardVacationVectorAvgAggregateOutputType | null
    _sum: RewardVacationVectorSumAggregateOutputType | null
    _min: RewardVacationVectorMinAggregateOutputType | null
    _max: RewardVacationVectorMaxAggregateOutputType | null
  }

  export type RewardVacationVectorAvgAggregateOutputType = {
    RewardVocationVectorID: number | null
    StartYearRewardVocation: number | null
    EndYearRewardVocation: number | null
    VocationDayQuantity6days: number | null
    VocationDayQuantity5days: number | null
  }

  export type RewardVacationVectorSumAggregateOutputType = {
    RewardVocationVectorID: number | null
    StartYearRewardVocation: number | null
    EndYearRewardVocation: number | null
    VocationDayQuantity6days: number | null
    VocationDayQuantity5days: number | null
  }

  export type RewardVacationVectorMinAggregateOutputType = {
    RewardVocationVectorID: number | null
    StartYearRewardVocation: number | null
    EndYearRewardVocation: number | null
    VocationDayQuantity6days: number | null
    VocationDayQuantity5days: number | null
  }

  export type RewardVacationVectorMaxAggregateOutputType = {
    RewardVocationVectorID: number | null
    StartYearRewardVocation: number | null
    EndYearRewardVocation: number | null
    VocationDayQuantity6days: number | null
    VocationDayQuantity5days: number | null
  }

  export type RewardVacationVectorCountAggregateOutputType = {
    RewardVocationVectorID: number
    StartYearRewardVocation: number
    EndYearRewardVocation: number
    VocationDayQuantity6days: number
    VocationDayQuantity5days: number
    _all: number
  }


  export type RewardVacationVectorAvgAggregateInputType = {
    RewardVocationVectorID?: true
    StartYearRewardVocation?: true
    EndYearRewardVocation?: true
    VocationDayQuantity6days?: true
    VocationDayQuantity5days?: true
  }

  export type RewardVacationVectorSumAggregateInputType = {
    RewardVocationVectorID?: true
    StartYearRewardVocation?: true
    EndYearRewardVocation?: true
    VocationDayQuantity6days?: true
    VocationDayQuantity5days?: true
  }

  export type RewardVacationVectorMinAggregateInputType = {
    RewardVocationVectorID?: true
    StartYearRewardVocation?: true
    EndYearRewardVocation?: true
    VocationDayQuantity6days?: true
    VocationDayQuantity5days?: true
  }

  export type RewardVacationVectorMaxAggregateInputType = {
    RewardVocationVectorID?: true
    StartYearRewardVocation?: true
    EndYearRewardVocation?: true
    VocationDayQuantity6days?: true
    VocationDayQuantity5days?: true
  }

  export type RewardVacationVectorCountAggregateInputType = {
    RewardVocationVectorID?: true
    StartYearRewardVocation?: true
    EndYearRewardVocation?: true
    VocationDayQuantity6days?: true
    VocationDayQuantity5days?: true
    _all?: true
  }

  export type RewardVacationVectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardVacationVector to aggregate.
     */
    where?: RewardVacationVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardVacationVectors to fetch.
     */
    orderBy?: RewardVacationVectorOrderByWithRelationInput | RewardVacationVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardVacationVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardVacationVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardVacationVectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardVacationVectors
    **/
    _count?: true | RewardVacationVectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardVacationVectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardVacationVectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardVacationVectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardVacationVectorMaxAggregateInputType
  }

  export type GetRewardVacationVectorAggregateType<T extends RewardVacationVectorAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardVacationVector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardVacationVector[P]>
      : GetScalarType<T[P], AggregateRewardVacationVector[P]>
  }




  export type RewardVacationVectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardVacationVectorWhereInput
    orderBy?: RewardVacationVectorOrderByWithAggregationInput | RewardVacationVectorOrderByWithAggregationInput[]
    by: RewardVacationVectorScalarFieldEnum[] | RewardVacationVectorScalarFieldEnum
    having?: RewardVacationVectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardVacationVectorCountAggregateInputType | true
    _avg?: RewardVacationVectorAvgAggregateInputType
    _sum?: RewardVacationVectorSumAggregateInputType
    _min?: RewardVacationVectorMinAggregateInputType
    _max?: RewardVacationVectorMaxAggregateInputType
  }

  export type RewardVacationVectorGroupByOutputType = {
    RewardVocationVectorID: number
    StartYearRewardVocation: number | null
    EndYearRewardVocation: number | null
    VocationDayQuantity6days: number | null
    VocationDayQuantity5days: number | null
    _count: RewardVacationVectorCountAggregateOutputType | null
    _avg: RewardVacationVectorAvgAggregateOutputType | null
    _sum: RewardVacationVectorSumAggregateOutputType | null
    _min: RewardVacationVectorMinAggregateOutputType | null
    _max: RewardVacationVectorMaxAggregateOutputType | null
  }

  type GetRewardVacationVectorGroupByPayload<T extends RewardVacationVectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardVacationVectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardVacationVectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardVacationVectorGroupByOutputType[P]>
            : GetScalarType<T[P], RewardVacationVectorGroupByOutputType[P]>
        }
      >
    >


  export type RewardVacationVectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    RewardVocationVectorID?: boolean
    StartYearRewardVocation?: boolean
    EndYearRewardVocation?: boolean
    VocationDayQuantity6days?: boolean
    VocationDayQuantity5days?: boolean
  }, ExtArgs["result"]["rewardVacationVector"]>


  export type RewardVacationVectorSelectScalar = {
    RewardVocationVectorID?: boolean
    StartYearRewardVocation?: boolean
    EndYearRewardVocation?: boolean
    VocationDayQuantity6days?: boolean
    VocationDayQuantity5days?: boolean
  }


  export type $RewardVacationVectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardVacationVector"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      RewardVocationVectorID: number
      StartYearRewardVocation: number | null
      EndYearRewardVocation: number | null
      VocationDayQuantity6days: number | null
      VocationDayQuantity5days: number | null
    }, ExtArgs["result"]["rewardVacationVector"]>
    composites: {}
  }

  type RewardVacationVectorGetPayload<S extends boolean | null | undefined | RewardVacationVectorDefaultArgs> = $Result.GetResult<Prisma.$RewardVacationVectorPayload, S>

  type RewardVacationVectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RewardVacationVectorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RewardVacationVectorCountAggregateInputType | true
    }

  export interface RewardVacationVectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardVacationVector'], meta: { name: 'RewardVacationVector' } }
    /**
     * Find zero or one RewardVacationVector that matches the filter.
     * @param {RewardVacationVectorFindUniqueArgs} args - Arguments to find a RewardVacationVector
     * @example
     * // Get one RewardVacationVector
     * const rewardVacationVector = await prisma.rewardVacationVector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardVacationVectorFindUniqueArgs>(args: SelectSubset<T, RewardVacationVectorFindUniqueArgs<ExtArgs>>): Prisma__RewardVacationVectorClient<$Result.GetResult<Prisma.$RewardVacationVectorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RewardVacationVector that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RewardVacationVectorFindUniqueOrThrowArgs} args - Arguments to find a RewardVacationVector
     * @example
     * // Get one RewardVacationVector
     * const rewardVacationVector = await prisma.rewardVacationVector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardVacationVectorFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardVacationVectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardVacationVectorClient<$Result.GetResult<Prisma.$RewardVacationVectorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RewardVacationVector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardVacationVectorFindFirstArgs} args - Arguments to find a RewardVacationVector
     * @example
     * // Get one RewardVacationVector
     * const rewardVacationVector = await prisma.rewardVacationVector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardVacationVectorFindFirstArgs>(args?: SelectSubset<T, RewardVacationVectorFindFirstArgs<ExtArgs>>): Prisma__RewardVacationVectorClient<$Result.GetResult<Prisma.$RewardVacationVectorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RewardVacationVector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardVacationVectorFindFirstOrThrowArgs} args - Arguments to find a RewardVacationVector
     * @example
     * // Get one RewardVacationVector
     * const rewardVacationVector = await prisma.rewardVacationVector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardVacationVectorFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardVacationVectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardVacationVectorClient<$Result.GetResult<Prisma.$RewardVacationVectorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RewardVacationVectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardVacationVectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardVacationVectors
     * const rewardVacationVectors = await prisma.rewardVacationVector.findMany()
     * 
     * // Get first 10 RewardVacationVectors
     * const rewardVacationVectors = await prisma.rewardVacationVector.findMany({ take: 10 })
     * 
     * // Only select the `RewardVocationVectorID`
     * const rewardVacationVectorWithRewardVocationVectorIDOnly = await prisma.rewardVacationVector.findMany({ select: { RewardVocationVectorID: true } })
     * 
     */
    findMany<T extends RewardVacationVectorFindManyArgs>(args?: SelectSubset<T, RewardVacationVectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardVacationVectorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RewardVacationVector.
     * @param {RewardVacationVectorCreateArgs} args - Arguments to create a RewardVacationVector.
     * @example
     * // Create one RewardVacationVector
     * const RewardVacationVector = await prisma.rewardVacationVector.create({
     *   data: {
     *     // ... data to create a RewardVacationVector
     *   }
     * })
     * 
     */
    create<T extends RewardVacationVectorCreateArgs>(args: SelectSubset<T, RewardVacationVectorCreateArgs<ExtArgs>>): Prisma__RewardVacationVectorClient<$Result.GetResult<Prisma.$RewardVacationVectorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RewardVacationVectors.
     * @param {RewardVacationVectorCreateManyArgs} args - Arguments to create many RewardVacationVectors.
     * @example
     * // Create many RewardVacationVectors
     * const rewardVacationVector = await prisma.rewardVacationVector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardVacationVectorCreateManyArgs>(args?: SelectSubset<T, RewardVacationVectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RewardVacationVector.
     * @param {RewardVacationVectorDeleteArgs} args - Arguments to delete one RewardVacationVector.
     * @example
     * // Delete one RewardVacationVector
     * const RewardVacationVector = await prisma.rewardVacationVector.delete({
     *   where: {
     *     // ... filter to delete one RewardVacationVector
     *   }
     * })
     * 
     */
    delete<T extends RewardVacationVectorDeleteArgs>(args: SelectSubset<T, RewardVacationVectorDeleteArgs<ExtArgs>>): Prisma__RewardVacationVectorClient<$Result.GetResult<Prisma.$RewardVacationVectorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RewardVacationVector.
     * @param {RewardVacationVectorUpdateArgs} args - Arguments to update one RewardVacationVector.
     * @example
     * // Update one RewardVacationVector
     * const rewardVacationVector = await prisma.rewardVacationVector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardVacationVectorUpdateArgs>(args: SelectSubset<T, RewardVacationVectorUpdateArgs<ExtArgs>>): Prisma__RewardVacationVectorClient<$Result.GetResult<Prisma.$RewardVacationVectorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RewardVacationVectors.
     * @param {RewardVacationVectorDeleteManyArgs} args - Arguments to filter RewardVacationVectors to delete.
     * @example
     * // Delete a few RewardVacationVectors
     * const { count } = await prisma.rewardVacationVector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardVacationVectorDeleteManyArgs>(args?: SelectSubset<T, RewardVacationVectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardVacationVectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardVacationVectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardVacationVectors
     * const rewardVacationVector = await prisma.rewardVacationVector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardVacationVectorUpdateManyArgs>(args: SelectSubset<T, RewardVacationVectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RewardVacationVector.
     * @param {RewardVacationVectorUpsertArgs} args - Arguments to update or create a RewardVacationVector.
     * @example
     * // Update or create a RewardVacationVector
     * const rewardVacationVector = await prisma.rewardVacationVector.upsert({
     *   create: {
     *     // ... data to create a RewardVacationVector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardVacationVector we want to update
     *   }
     * })
     */
    upsert<T extends RewardVacationVectorUpsertArgs>(args: SelectSubset<T, RewardVacationVectorUpsertArgs<ExtArgs>>): Prisma__RewardVacationVectorClient<$Result.GetResult<Prisma.$RewardVacationVectorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RewardVacationVectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardVacationVectorCountArgs} args - Arguments to filter RewardVacationVectors to count.
     * @example
     * // Count the number of RewardVacationVectors
     * const count = await prisma.rewardVacationVector.count({
     *   where: {
     *     // ... the filter for the RewardVacationVectors we want to count
     *   }
     * })
    **/
    count<T extends RewardVacationVectorCountArgs>(
      args?: Subset<T, RewardVacationVectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardVacationVectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardVacationVector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardVacationVectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardVacationVectorAggregateArgs>(args: Subset<T, RewardVacationVectorAggregateArgs>): Prisma.PrismaPromise<GetRewardVacationVectorAggregateType<T>>

    /**
     * Group by RewardVacationVector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardVacationVectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardVacationVectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardVacationVectorGroupByArgs['orderBy'] }
        : { orderBy?: RewardVacationVectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardVacationVectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardVacationVectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardVacationVector model
   */
  readonly fields: RewardVacationVectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardVacationVector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardVacationVectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardVacationVector model
   */ 
  interface RewardVacationVectorFieldRefs {
    readonly RewardVocationVectorID: FieldRef<"RewardVacationVector", 'Int'>
    readonly StartYearRewardVocation: FieldRef<"RewardVacationVector", 'Float'>
    readonly EndYearRewardVocation: FieldRef<"RewardVacationVector", 'Float'>
    readonly VocationDayQuantity6days: FieldRef<"RewardVacationVector", 'Int'>
    readonly VocationDayQuantity5days: FieldRef<"RewardVacationVector", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RewardVacationVector findUnique
   */
  export type RewardVacationVectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardVacationVector
     */
    select?: RewardVacationVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardVacationVector to fetch.
     */
    where: RewardVacationVectorWhereUniqueInput
  }

  /**
   * RewardVacationVector findUniqueOrThrow
   */
  export type RewardVacationVectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardVacationVector
     */
    select?: RewardVacationVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardVacationVector to fetch.
     */
    where: RewardVacationVectorWhereUniqueInput
  }

  /**
   * RewardVacationVector findFirst
   */
  export type RewardVacationVectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardVacationVector
     */
    select?: RewardVacationVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardVacationVector to fetch.
     */
    where?: RewardVacationVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardVacationVectors to fetch.
     */
    orderBy?: RewardVacationVectorOrderByWithRelationInput | RewardVacationVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardVacationVectors.
     */
    cursor?: RewardVacationVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardVacationVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardVacationVectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardVacationVectors.
     */
    distinct?: RewardVacationVectorScalarFieldEnum | RewardVacationVectorScalarFieldEnum[]
  }

  /**
   * RewardVacationVector findFirstOrThrow
   */
  export type RewardVacationVectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardVacationVector
     */
    select?: RewardVacationVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardVacationVector to fetch.
     */
    where?: RewardVacationVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardVacationVectors to fetch.
     */
    orderBy?: RewardVacationVectorOrderByWithRelationInput | RewardVacationVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardVacationVectors.
     */
    cursor?: RewardVacationVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardVacationVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardVacationVectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardVacationVectors.
     */
    distinct?: RewardVacationVectorScalarFieldEnum | RewardVacationVectorScalarFieldEnum[]
  }

  /**
   * RewardVacationVector findMany
   */
  export type RewardVacationVectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardVacationVector
     */
    select?: RewardVacationVectorSelect<ExtArgs> | null
    /**
     * Filter, which RewardVacationVectors to fetch.
     */
    where?: RewardVacationVectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardVacationVectors to fetch.
     */
    orderBy?: RewardVacationVectorOrderByWithRelationInput | RewardVacationVectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardVacationVectors.
     */
    cursor?: RewardVacationVectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardVacationVectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardVacationVectors.
     */
    skip?: number
    distinct?: RewardVacationVectorScalarFieldEnum | RewardVacationVectorScalarFieldEnum[]
  }

  /**
   * RewardVacationVector create
   */
  export type RewardVacationVectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardVacationVector
     */
    select?: RewardVacationVectorSelect<ExtArgs> | null
    /**
     * The data needed to create a RewardVacationVector.
     */
    data?: XOR<RewardVacationVectorCreateInput, RewardVacationVectorUncheckedCreateInput>
  }

  /**
   * RewardVacationVector createMany
   */
  export type RewardVacationVectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardVacationVectors.
     */
    data: RewardVacationVectorCreateManyInput | RewardVacationVectorCreateManyInput[]
  }

  /**
   * RewardVacationVector update
   */
  export type RewardVacationVectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardVacationVector
     */
    select?: RewardVacationVectorSelect<ExtArgs> | null
    /**
     * The data needed to update a RewardVacationVector.
     */
    data: XOR<RewardVacationVectorUpdateInput, RewardVacationVectorUncheckedUpdateInput>
    /**
     * Choose, which RewardVacationVector to update.
     */
    where: RewardVacationVectorWhereUniqueInput
  }

  /**
   * RewardVacationVector updateMany
   */
  export type RewardVacationVectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardVacationVectors.
     */
    data: XOR<RewardVacationVectorUpdateManyMutationInput, RewardVacationVectorUncheckedUpdateManyInput>
    /**
     * Filter which RewardVacationVectors to update
     */
    where?: RewardVacationVectorWhereInput
  }

  /**
   * RewardVacationVector upsert
   */
  export type RewardVacationVectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardVacationVector
     */
    select?: RewardVacationVectorSelect<ExtArgs> | null
    /**
     * The filter to search for the RewardVacationVector to update in case it exists.
     */
    where: RewardVacationVectorWhereUniqueInput
    /**
     * In case the RewardVacationVector found by the `where` argument doesn't exist, create a new RewardVacationVector with this data.
     */
    create: XOR<RewardVacationVectorCreateInput, RewardVacationVectorUncheckedCreateInput>
    /**
     * In case the RewardVacationVector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardVacationVectorUpdateInput, RewardVacationVectorUncheckedUpdateInput>
  }

  /**
   * RewardVacationVector delete
   */
  export type RewardVacationVectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardVacationVector
     */
    select?: RewardVacationVectorSelect<ExtArgs> | null
    /**
     * Filter which RewardVacationVector to delete.
     */
    where: RewardVacationVectorWhereUniqueInput
  }

  /**
   * RewardVacationVector deleteMany
   */
  export type RewardVacationVectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardVacationVectors to delete
     */
    where?: RewardVacationVectorWhereInput
  }

  /**
   * RewardVacationVector without action
   */
  export type RewardVacationVectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardVacationVector
     */
    select?: RewardVacationVectorSelect<ExtArgs> | null
  }


  /**
   * Model SickDefinition
   */

  export type AggregateSickDefinition = {
    _count: SickDefinitionCountAggregateOutputType | null
    _avg: SickDefinitionAvgAggregateOutputType | null
    _sum: SickDefinitionSumAggregateOutputType | null
    _min: SickDefinitionMinAggregateOutputType | null
    _max: SickDefinitionMaxAggregateOutputType | null
  }

  export type SickDefinitionAvgAggregateOutputType = {
    SickDefinitionID: number | null
  }

  export type SickDefinitionSumAggregateOutputType = {
    SickDefinitionID: number | null
  }

  export type SickDefinitionMinAggregateOutputType = {
    SickDefinitionID: number | null
    SickDescription: string | null
  }

  export type SickDefinitionMaxAggregateOutputType = {
    SickDefinitionID: number | null
    SickDescription: string | null
  }

  export type SickDefinitionCountAggregateOutputType = {
    SickDefinitionID: number
    SickDescription: number
    _all: number
  }


  export type SickDefinitionAvgAggregateInputType = {
    SickDefinitionID?: true
  }

  export type SickDefinitionSumAggregateInputType = {
    SickDefinitionID?: true
  }

  export type SickDefinitionMinAggregateInputType = {
    SickDefinitionID?: true
    SickDescription?: true
  }

  export type SickDefinitionMaxAggregateInputType = {
    SickDefinitionID?: true
    SickDescription?: true
  }

  export type SickDefinitionCountAggregateInputType = {
    SickDefinitionID?: true
    SickDescription?: true
    _all?: true
  }

  export type SickDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SickDefinition to aggregate.
     */
    where?: SickDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SickDefinitions to fetch.
     */
    orderBy?: SickDefinitionOrderByWithRelationInput | SickDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SickDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SickDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SickDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SickDefinitions
    **/
    _count?: true | SickDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SickDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SickDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SickDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SickDefinitionMaxAggregateInputType
  }

  export type GetSickDefinitionAggregateType<T extends SickDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateSickDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSickDefinition[P]>
      : GetScalarType<T[P], AggregateSickDefinition[P]>
  }




  export type SickDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SickDefinitionWhereInput
    orderBy?: SickDefinitionOrderByWithAggregationInput | SickDefinitionOrderByWithAggregationInput[]
    by: SickDefinitionScalarFieldEnum[] | SickDefinitionScalarFieldEnum
    having?: SickDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SickDefinitionCountAggregateInputType | true
    _avg?: SickDefinitionAvgAggregateInputType
    _sum?: SickDefinitionSumAggregateInputType
    _min?: SickDefinitionMinAggregateInputType
    _max?: SickDefinitionMaxAggregateInputType
  }

  export type SickDefinitionGroupByOutputType = {
    SickDefinitionID: number
    SickDescription: string | null
    _count: SickDefinitionCountAggregateOutputType | null
    _avg: SickDefinitionAvgAggregateOutputType | null
    _sum: SickDefinitionSumAggregateOutputType | null
    _min: SickDefinitionMinAggregateOutputType | null
    _max: SickDefinitionMaxAggregateOutputType | null
  }

  type GetSickDefinitionGroupByPayload<T extends SickDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SickDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SickDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SickDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], SickDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type SickDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SickDefinitionID?: boolean
    SickDescription?: boolean
    SickDefinitionDetail?: boolean | SickDefinition$SickDefinitionDetailArgs<ExtArgs>
    _count?: boolean | SickDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sickDefinition"]>


  export type SickDefinitionSelectScalar = {
    SickDefinitionID?: boolean
    SickDescription?: boolean
  }

  export type SickDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SickDefinitionDetail?: boolean | SickDefinition$SickDefinitionDetailArgs<ExtArgs>
    _count?: boolean | SickDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SickDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SickDefinition"
    objects: {
      SickDefinitionDetail: Prisma.$SickDefinitionDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      SickDefinitionID: number
      SickDescription: string | null
    }, ExtArgs["result"]["sickDefinition"]>
    composites: {}
  }

  type SickDefinitionGetPayload<S extends boolean | null | undefined | SickDefinitionDefaultArgs> = $Result.GetResult<Prisma.$SickDefinitionPayload, S>

  type SickDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SickDefinitionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SickDefinitionCountAggregateInputType | true
    }

  export interface SickDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SickDefinition'], meta: { name: 'SickDefinition' } }
    /**
     * Find zero or one SickDefinition that matches the filter.
     * @param {SickDefinitionFindUniqueArgs} args - Arguments to find a SickDefinition
     * @example
     * // Get one SickDefinition
     * const sickDefinition = await prisma.sickDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SickDefinitionFindUniqueArgs>(args: SelectSubset<T, SickDefinitionFindUniqueArgs<ExtArgs>>): Prisma__SickDefinitionClient<$Result.GetResult<Prisma.$SickDefinitionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SickDefinition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SickDefinitionFindUniqueOrThrowArgs} args - Arguments to find a SickDefinition
     * @example
     * // Get one SickDefinition
     * const sickDefinition = await prisma.sickDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SickDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, SickDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SickDefinitionClient<$Result.GetResult<Prisma.$SickDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SickDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionFindFirstArgs} args - Arguments to find a SickDefinition
     * @example
     * // Get one SickDefinition
     * const sickDefinition = await prisma.sickDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SickDefinitionFindFirstArgs>(args?: SelectSubset<T, SickDefinitionFindFirstArgs<ExtArgs>>): Prisma__SickDefinitionClient<$Result.GetResult<Prisma.$SickDefinitionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SickDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionFindFirstOrThrowArgs} args - Arguments to find a SickDefinition
     * @example
     * // Get one SickDefinition
     * const sickDefinition = await prisma.sickDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SickDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, SickDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SickDefinitionClient<$Result.GetResult<Prisma.$SickDefinitionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SickDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SickDefinitions
     * const sickDefinitions = await prisma.sickDefinition.findMany()
     * 
     * // Get first 10 SickDefinitions
     * const sickDefinitions = await prisma.sickDefinition.findMany({ take: 10 })
     * 
     * // Only select the `SickDefinitionID`
     * const sickDefinitionWithSickDefinitionIDOnly = await prisma.sickDefinition.findMany({ select: { SickDefinitionID: true } })
     * 
     */
    findMany<T extends SickDefinitionFindManyArgs>(args?: SelectSubset<T, SickDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SickDefinitionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SickDefinition.
     * @param {SickDefinitionCreateArgs} args - Arguments to create a SickDefinition.
     * @example
     * // Create one SickDefinition
     * const SickDefinition = await prisma.sickDefinition.create({
     *   data: {
     *     // ... data to create a SickDefinition
     *   }
     * })
     * 
     */
    create<T extends SickDefinitionCreateArgs>(args: SelectSubset<T, SickDefinitionCreateArgs<ExtArgs>>): Prisma__SickDefinitionClient<$Result.GetResult<Prisma.$SickDefinitionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SickDefinitions.
     * @param {SickDefinitionCreateManyArgs} args - Arguments to create many SickDefinitions.
     * @example
     * // Create many SickDefinitions
     * const sickDefinition = await prisma.sickDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SickDefinitionCreateManyArgs>(args?: SelectSubset<T, SickDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SickDefinition.
     * @param {SickDefinitionDeleteArgs} args - Arguments to delete one SickDefinition.
     * @example
     * // Delete one SickDefinition
     * const SickDefinition = await prisma.sickDefinition.delete({
     *   where: {
     *     // ... filter to delete one SickDefinition
     *   }
     * })
     * 
     */
    delete<T extends SickDefinitionDeleteArgs>(args: SelectSubset<T, SickDefinitionDeleteArgs<ExtArgs>>): Prisma__SickDefinitionClient<$Result.GetResult<Prisma.$SickDefinitionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SickDefinition.
     * @param {SickDefinitionUpdateArgs} args - Arguments to update one SickDefinition.
     * @example
     * // Update one SickDefinition
     * const sickDefinition = await prisma.sickDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SickDefinitionUpdateArgs>(args: SelectSubset<T, SickDefinitionUpdateArgs<ExtArgs>>): Prisma__SickDefinitionClient<$Result.GetResult<Prisma.$SickDefinitionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SickDefinitions.
     * @param {SickDefinitionDeleteManyArgs} args - Arguments to filter SickDefinitions to delete.
     * @example
     * // Delete a few SickDefinitions
     * const { count } = await prisma.sickDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SickDefinitionDeleteManyArgs>(args?: SelectSubset<T, SickDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SickDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SickDefinitions
     * const sickDefinition = await prisma.sickDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SickDefinitionUpdateManyArgs>(args: SelectSubset<T, SickDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SickDefinition.
     * @param {SickDefinitionUpsertArgs} args - Arguments to update or create a SickDefinition.
     * @example
     * // Update or create a SickDefinition
     * const sickDefinition = await prisma.sickDefinition.upsert({
     *   create: {
     *     // ... data to create a SickDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SickDefinition we want to update
     *   }
     * })
     */
    upsert<T extends SickDefinitionUpsertArgs>(args: SelectSubset<T, SickDefinitionUpsertArgs<ExtArgs>>): Prisma__SickDefinitionClient<$Result.GetResult<Prisma.$SickDefinitionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SickDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionCountArgs} args - Arguments to filter SickDefinitions to count.
     * @example
     * // Count the number of SickDefinitions
     * const count = await prisma.sickDefinition.count({
     *   where: {
     *     // ... the filter for the SickDefinitions we want to count
     *   }
     * })
    **/
    count<T extends SickDefinitionCountArgs>(
      args?: Subset<T, SickDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SickDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SickDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SickDefinitionAggregateArgs>(args: Subset<T, SickDefinitionAggregateArgs>): Prisma.PrismaPromise<GetSickDefinitionAggregateType<T>>

    /**
     * Group by SickDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SickDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SickDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: SickDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SickDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSickDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SickDefinition model
   */
  readonly fields: SickDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SickDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SickDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SickDefinitionDetail<T extends SickDefinition$SickDefinitionDetailArgs<ExtArgs> = {}>(args?: Subset<T, SickDefinition$SickDefinitionDetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SickDefinitionDetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SickDefinition model
   */ 
  interface SickDefinitionFieldRefs {
    readonly SickDefinitionID: FieldRef<"SickDefinition", 'Int'>
    readonly SickDescription: FieldRef<"SickDefinition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SickDefinition findUnique
   */
  export type SickDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinition
     */
    select?: SickDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which SickDefinition to fetch.
     */
    where: SickDefinitionWhereUniqueInput
  }

  /**
   * SickDefinition findUniqueOrThrow
   */
  export type SickDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinition
     */
    select?: SickDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which SickDefinition to fetch.
     */
    where: SickDefinitionWhereUniqueInput
  }

  /**
   * SickDefinition findFirst
   */
  export type SickDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinition
     */
    select?: SickDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which SickDefinition to fetch.
     */
    where?: SickDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SickDefinitions to fetch.
     */
    orderBy?: SickDefinitionOrderByWithRelationInput | SickDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SickDefinitions.
     */
    cursor?: SickDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SickDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SickDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SickDefinitions.
     */
    distinct?: SickDefinitionScalarFieldEnum | SickDefinitionScalarFieldEnum[]
  }

  /**
   * SickDefinition findFirstOrThrow
   */
  export type SickDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinition
     */
    select?: SickDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which SickDefinition to fetch.
     */
    where?: SickDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SickDefinitions to fetch.
     */
    orderBy?: SickDefinitionOrderByWithRelationInput | SickDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SickDefinitions.
     */
    cursor?: SickDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SickDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SickDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SickDefinitions.
     */
    distinct?: SickDefinitionScalarFieldEnum | SickDefinitionScalarFieldEnum[]
  }

  /**
   * SickDefinition findMany
   */
  export type SickDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinition
     */
    select?: SickDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which SickDefinitions to fetch.
     */
    where?: SickDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SickDefinitions to fetch.
     */
    orderBy?: SickDefinitionOrderByWithRelationInput | SickDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SickDefinitions.
     */
    cursor?: SickDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SickDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SickDefinitions.
     */
    skip?: number
    distinct?: SickDefinitionScalarFieldEnum | SickDefinitionScalarFieldEnum[]
  }

  /**
   * SickDefinition create
   */
  export type SickDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinition
     */
    select?: SickDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a SickDefinition.
     */
    data: XOR<SickDefinitionCreateInput, SickDefinitionUncheckedCreateInput>
  }

  /**
   * SickDefinition createMany
   */
  export type SickDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SickDefinitions.
     */
    data: SickDefinitionCreateManyInput | SickDefinitionCreateManyInput[]
  }

  /**
   * SickDefinition update
   */
  export type SickDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinition
     */
    select?: SickDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a SickDefinition.
     */
    data: XOR<SickDefinitionUpdateInput, SickDefinitionUncheckedUpdateInput>
    /**
     * Choose, which SickDefinition to update.
     */
    where: SickDefinitionWhereUniqueInput
  }

  /**
   * SickDefinition updateMany
   */
  export type SickDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SickDefinitions.
     */
    data: XOR<SickDefinitionUpdateManyMutationInput, SickDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which SickDefinitions to update
     */
    where?: SickDefinitionWhereInput
  }

  /**
   * SickDefinition upsert
   */
  export type SickDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinition
     */
    select?: SickDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the SickDefinition to update in case it exists.
     */
    where: SickDefinitionWhereUniqueInput
    /**
     * In case the SickDefinition found by the `where` argument doesn't exist, create a new SickDefinition with this data.
     */
    create: XOR<SickDefinitionCreateInput, SickDefinitionUncheckedCreateInput>
    /**
     * In case the SickDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SickDefinitionUpdateInput, SickDefinitionUncheckedUpdateInput>
  }

  /**
   * SickDefinition delete
   */
  export type SickDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinition
     */
    select?: SickDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionInclude<ExtArgs> | null
    /**
     * Filter which SickDefinition to delete.
     */
    where: SickDefinitionWhereUniqueInput
  }

  /**
   * SickDefinition deleteMany
   */
  export type SickDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SickDefinitions to delete
     */
    where?: SickDefinitionWhereInput
  }

  /**
   * SickDefinition.SickDefinitionDetail
   */
  export type SickDefinition$SickDefinitionDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinitionDetail
     */
    select?: SickDefinitionDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionDetailInclude<ExtArgs> | null
    where?: SickDefinitionDetailWhereInput
    orderBy?: SickDefinitionDetailOrderByWithRelationInput | SickDefinitionDetailOrderByWithRelationInput[]
    cursor?: SickDefinitionDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SickDefinitionDetailScalarFieldEnum | SickDefinitionDetailScalarFieldEnum[]
  }

  /**
   * SickDefinition without action
   */
  export type SickDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinition
     */
    select?: SickDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model SickDefinitionDetail
   */

  export type AggregateSickDefinitionDetail = {
    _count: SickDefinitionDetailCountAggregateOutputType | null
    _avg: SickDefinitionDetailAvgAggregateOutputType | null
    _sum: SickDefinitionDetailSumAggregateOutputType | null
    _min: SickDefinitionDetailMinAggregateOutputType | null
    _max: SickDefinitionDetailMaxAggregateOutputType | null
  }

  export type SickDefinitionDetailAvgAggregateOutputType = {
    RewardSickVectorID: number | null
    SickDefinitionID: number | null
    StartYearRewardSick: number | null
    EndYearRewardSick: number | null
    SickDayQuantity: number | null
  }

  export type SickDefinitionDetailSumAggregateOutputType = {
    RewardSickVectorID: number | null
    SickDefinitionID: number | null
    StartYearRewardSick: number | null
    EndYearRewardSick: number | null
    SickDayQuantity: number | null
  }

  export type SickDefinitionDetailMinAggregateOutputType = {
    RewardSickVectorID: number | null
    SickDefinitionID: number | null
    StartYearRewardSick: number | null
    EndYearRewardSick: number | null
    SickDayQuantity: number | null
    SocialYearDescription: string | null
  }

  export type SickDefinitionDetailMaxAggregateOutputType = {
    RewardSickVectorID: number | null
    SickDefinitionID: number | null
    StartYearRewardSick: number | null
    EndYearRewardSick: number | null
    SickDayQuantity: number | null
    SocialYearDescription: string | null
  }

  export type SickDefinitionDetailCountAggregateOutputType = {
    RewardSickVectorID: number
    SickDefinitionID: number
    StartYearRewardSick: number
    EndYearRewardSick: number
    SickDayQuantity: number
    SocialYearDescription: number
    _all: number
  }


  export type SickDefinitionDetailAvgAggregateInputType = {
    RewardSickVectorID?: true
    SickDefinitionID?: true
    StartYearRewardSick?: true
    EndYearRewardSick?: true
    SickDayQuantity?: true
  }

  export type SickDefinitionDetailSumAggregateInputType = {
    RewardSickVectorID?: true
    SickDefinitionID?: true
    StartYearRewardSick?: true
    EndYearRewardSick?: true
    SickDayQuantity?: true
  }

  export type SickDefinitionDetailMinAggregateInputType = {
    RewardSickVectorID?: true
    SickDefinitionID?: true
    StartYearRewardSick?: true
    EndYearRewardSick?: true
    SickDayQuantity?: true
    SocialYearDescription?: true
  }

  export type SickDefinitionDetailMaxAggregateInputType = {
    RewardSickVectorID?: true
    SickDefinitionID?: true
    StartYearRewardSick?: true
    EndYearRewardSick?: true
    SickDayQuantity?: true
    SocialYearDescription?: true
  }

  export type SickDefinitionDetailCountAggregateInputType = {
    RewardSickVectorID?: true
    SickDefinitionID?: true
    StartYearRewardSick?: true
    EndYearRewardSick?: true
    SickDayQuantity?: true
    SocialYearDescription?: true
    _all?: true
  }

  export type SickDefinitionDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SickDefinitionDetail to aggregate.
     */
    where?: SickDefinitionDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SickDefinitionDetails to fetch.
     */
    orderBy?: SickDefinitionDetailOrderByWithRelationInput | SickDefinitionDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SickDefinitionDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SickDefinitionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SickDefinitionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SickDefinitionDetails
    **/
    _count?: true | SickDefinitionDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SickDefinitionDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SickDefinitionDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SickDefinitionDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SickDefinitionDetailMaxAggregateInputType
  }

  export type GetSickDefinitionDetailAggregateType<T extends SickDefinitionDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateSickDefinitionDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSickDefinitionDetail[P]>
      : GetScalarType<T[P], AggregateSickDefinitionDetail[P]>
  }




  export type SickDefinitionDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SickDefinitionDetailWhereInput
    orderBy?: SickDefinitionDetailOrderByWithAggregationInput | SickDefinitionDetailOrderByWithAggregationInput[]
    by: SickDefinitionDetailScalarFieldEnum[] | SickDefinitionDetailScalarFieldEnum
    having?: SickDefinitionDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SickDefinitionDetailCountAggregateInputType | true
    _avg?: SickDefinitionDetailAvgAggregateInputType
    _sum?: SickDefinitionDetailSumAggregateInputType
    _min?: SickDefinitionDetailMinAggregateInputType
    _max?: SickDefinitionDetailMaxAggregateInputType
  }

  export type SickDefinitionDetailGroupByOutputType = {
    RewardSickVectorID: number
    SickDefinitionID: number
    StartYearRewardSick: number | null
    EndYearRewardSick: number | null
    SickDayQuantity: number | null
    SocialYearDescription: string | null
    _count: SickDefinitionDetailCountAggregateOutputType | null
    _avg: SickDefinitionDetailAvgAggregateOutputType | null
    _sum: SickDefinitionDetailSumAggregateOutputType | null
    _min: SickDefinitionDetailMinAggregateOutputType | null
    _max: SickDefinitionDetailMaxAggregateOutputType | null
  }

  type GetSickDefinitionDetailGroupByPayload<T extends SickDefinitionDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SickDefinitionDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SickDefinitionDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SickDefinitionDetailGroupByOutputType[P]>
            : GetScalarType<T[P], SickDefinitionDetailGroupByOutputType[P]>
        }
      >
    >


  export type SickDefinitionDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    RewardSickVectorID?: boolean
    SickDefinitionID?: boolean
    StartYearRewardSick?: boolean
    EndYearRewardSick?: boolean
    SickDayQuantity?: boolean
    SocialYearDescription?: boolean
    SickDefinition?: boolean | SickDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sickDefinitionDetail"]>


  export type SickDefinitionDetailSelectScalar = {
    RewardSickVectorID?: boolean
    SickDefinitionID?: boolean
    StartYearRewardSick?: boolean
    EndYearRewardSick?: boolean
    SickDayQuantity?: boolean
    SocialYearDescription?: boolean
  }

  export type SickDefinitionDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SickDefinition?: boolean | SickDefinitionDefaultArgs<ExtArgs>
  }

  export type $SickDefinitionDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SickDefinitionDetail"
    objects: {
      SickDefinition: Prisma.$SickDefinitionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      RewardSickVectorID: number
      SickDefinitionID: number
      StartYearRewardSick: number | null
      EndYearRewardSick: number | null
      SickDayQuantity: number | null
      SocialYearDescription: string | null
    }, ExtArgs["result"]["sickDefinitionDetail"]>
    composites: {}
  }

  type SickDefinitionDetailGetPayload<S extends boolean | null | undefined | SickDefinitionDetailDefaultArgs> = $Result.GetResult<Prisma.$SickDefinitionDetailPayload, S>

  type SickDefinitionDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SickDefinitionDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SickDefinitionDetailCountAggregateInputType | true
    }

  export interface SickDefinitionDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SickDefinitionDetail'], meta: { name: 'SickDefinitionDetail' } }
    /**
     * Find zero or one SickDefinitionDetail that matches the filter.
     * @param {SickDefinitionDetailFindUniqueArgs} args - Arguments to find a SickDefinitionDetail
     * @example
     * // Get one SickDefinitionDetail
     * const sickDefinitionDetail = await prisma.sickDefinitionDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SickDefinitionDetailFindUniqueArgs>(args: SelectSubset<T, SickDefinitionDetailFindUniqueArgs<ExtArgs>>): Prisma__SickDefinitionDetailClient<$Result.GetResult<Prisma.$SickDefinitionDetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SickDefinitionDetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SickDefinitionDetailFindUniqueOrThrowArgs} args - Arguments to find a SickDefinitionDetail
     * @example
     * // Get one SickDefinitionDetail
     * const sickDefinitionDetail = await prisma.sickDefinitionDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SickDefinitionDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, SickDefinitionDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SickDefinitionDetailClient<$Result.GetResult<Prisma.$SickDefinitionDetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SickDefinitionDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionDetailFindFirstArgs} args - Arguments to find a SickDefinitionDetail
     * @example
     * // Get one SickDefinitionDetail
     * const sickDefinitionDetail = await prisma.sickDefinitionDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SickDefinitionDetailFindFirstArgs>(args?: SelectSubset<T, SickDefinitionDetailFindFirstArgs<ExtArgs>>): Prisma__SickDefinitionDetailClient<$Result.GetResult<Prisma.$SickDefinitionDetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SickDefinitionDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionDetailFindFirstOrThrowArgs} args - Arguments to find a SickDefinitionDetail
     * @example
     * // Get one SickDefinitionDetail
     * const sickDefinitionDetail = await prisma.sickDefinitionDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SickDefinitionDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, SickDefinitionDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__SickDefinitionDetailClient<$Result.GetResult<Prisma.$SickDefinitionDetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SickDefinitionDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SickDefinitionDetails
     * const sickDefinitionDetails = await prisma.sickDefinitionDetail.findMany()
     * 
     * // Get first 10 SickDefinitionDetails
     * const sickDefinitionDetails = await prisma.sickDefinitionDetail.findMany({ take: 10 })
     * 
     * // Only select the `RewardSickVectorID`
     * const sickDefinitionDetailWithRewardSickVectorIDOnly = await prisma.sickDefinitionDetail.findMany({ select: { RewardSickVectorID: true } })
     * 
     */
    findMany<T extends SickDefinitionDetailFindManyArgs>(args?: SelectSubset<T, SickDefinitionDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SickDefinitionDetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SickDefinitionDetail.
     * @param {SickDefinitionDetailCreateArgs} args - Arguments to create a SickDefinitionDetail.
     * @example
     * // Create one SickDefinitionDetail
     * const SickDefinitionDetail = await prisma.sickDefinitionDetail.create({
     *   data: {
     *     // ... data to create a SickDefinitionDetail
     *   }
     * })
     * 
     */
    create<T extends SickDefinitionDetailCreateArgs>(args: SelectSubset<T, SickDefinitionDetailCreateArgs<ExtArgs>>): Prisma__SickDefinitionDetailClient<$Result.GetResult<Prisma.$SickDefinitionDetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SickDefinitionDetails.
     * @param {SickDefinitionDetailCreateManyArgs} args - Arguments to create many SickDefinitionDetails.
     * @example
     * // Create many SickDefinitionDetails
     * const sickDefinitionDetail = await prisma.sickDefinitionDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SickDefinitionDetailCreateManyArgs>(args?: SelectSubset<T, SickDefinitionDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SickDefinitionDetail.
     * @param {SickDefinitionDetailDeleteArgs} args - Arguments to delete one SickDefinitionDetail.
     * @example
     * // Delete one SickDefinitionDetail
     * const SickDefinitionDetail = await prisma.sickDefinitionDetail.delete({
     *   where: {
     *     // ... filter to delete one SickDefinitionDetail
     *   }
     * })
     * 
     */
    delete<T extends SickDefinitionDetailDeleteArgs>(args: SelectSubset<T, SickDefinitionDetailDeleteArgs<ExtArgs>>): Prisma__SickDefinitionDetailClient<$Result.GetResult<Prisma.$SickDefinitionDetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SickDefinitionDetail.
     * @param {SickDefinitionDetailUpdateArgs} args - Arguments to update one SickDefinitionDetail.
     * @example
     * // Update one SickDefinitionDetail
     * const sickDefinitionDetail = await prisma.sickDefinitionDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SickDefinitionDetailUpdateArgs>(args: SelectSubset<T, SickDefinitionDetailUpdateArgs<ExtArgs>>): Prisma__SickDefinitionDetailClient<$Result.GetResult<Prisma.$SickDefinitionDetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SickDefinitionDetails.
     * @param {SickDefinitionDetailDeleteManyArgs} args - Arguments to filter SickDefinitionDetails to delete.
     * @example
     * // Delete a few SickDefinitionDetails
     * const { count } = await prisma.sickDefinitionDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SickDefinitionDetailDeleteManyArgs>(args?: SelectSubset<T, SickDefinitionDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SickDefinitionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SickDefinitionDetails
     * const sickDefinitionDetail = await prisma.sickDefinitionDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SickDefinitionDetailUpdateManyArgs>(args: SelectSubset<T, SickDefinitionDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SickDefinitionDetail.
     * @param {SickDefinitionDetailUpsertArgs} args - Arguments to update or create a SickDefinitionDetail.
     * @example
     * // Update or create a SickDefinitionDetail
     * const sickDefinitionDetail = await prisma.sickDefinitionDetail.upsert({
     *   create: {
     *     // ... data to create a SickDefinitionDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SickDefinitionDetail we want to update
     *   }
     * })
     */
    upsert<T extends SickDefinitionDetailUpsertArgs>(args: SelectSubset<T, SickDefinitionDetailUpsertArgs<ExtArgs>>): Prisma__SickDefinitionDetailClient<$Result.GetResult<Prisma.$SickDefinitionDetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SickDefinitionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionDetailCountArgs} args - Arguments to filter SickDefinitionDetails to count.
     * @example
     * // Count the number of SickDefinitionDetails
     * const count = await prisma.sickDefinitionDetail.count({
     *   where: {
     *     // ... the filter for the SickDefinitionDetails we want to count
     *   }
     * })
    **/
    count<T extends SickDefinitionDetailCountArgs>(
      args?: Subset<T, SickDefinitionDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SickDefinitionDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SickDefinitionDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SickDefinitionDetailAggregateArgs>(args: Subset<T, SickDefinitionDetailAggregateArgs>): Prisma.PrismaPromise<GetSickDefinitionDetailAggregateType<T>>

    /**
     * Group by SickDefinitionDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SickDefinitionDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SickDefinitionDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SickDefinitionDetailGroupByArgs['orderBy'] }
        : { orderBy?: SickDefinitionDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SickDefinitionDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSickDefinitionDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SickDefinitionDetail model
   */
  readonly fields: SickDefinitionDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SickDefinitionDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SickDefinitionDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SickDefinition<T extends SickDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SickDefinitionDefaultArgs<ExtArgs>>): Prisma__SickDefinitionClient<$Result.GetResult<Prisma.$SickDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SickDefinitionDetail model
   */ 
  interface SickDefinitionDetailFieldRefs {
    readonly RewardSickVectorID: FieldRef<"SickDefinitionDetail", 'Int'>
    readonly SickDefinitionID: FieldRef<"SickDefinitionDetail", 'Int'>
    readonly StartYearRewardSick: FieldRef<"SickDefinitionDetail", 'Int'>
    readonly EndYearRewardSick: FieldRef<"SickDefinitionDetail", 'Int'>
    readonly SickDayQuantity: FieldRef<"SickDefinitionDetail", 'Float'>
    readonly SocialYearDescription: FieldRef<"SickDefinitionDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SickDefinitionDetail findUnique
   */
  export type SickDefinitionDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinitionDetail
     */
    select?: SickDefinitionDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionDetailInclude<ExtArgs> | null
    /**
     * Filter, which SickDefinitionDetail to fetch.
     */
    where: SickDefinitionDetailWhereUniqueInput
  }

  /**
   * SickDefinitionDetail findUniqueOrThrow
   */
  export type SickDefinitionDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinitionDetail
     */
    select?: SickDefinitionDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionDetailInclude<ExtArgs> | null
    /**
     * Filter, which SickDefinitionDetail to fetch.
     */
    where: SickDefinitionDetailWhereUniqueInput
  }

  /**
   * SickDefinitionDetail findFirst
   */
  export type SickDefinitionDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinitionDetail
     */
    select?: SickDefinitionDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionDetailInclude<ExtArgs> | null
    /**
     * Filter, which SickDefinitionDetail to fetch.
     */
    where?: SickDefinitionDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SickDefinitionDetails to fetch.
     */
    orderBy?: SickDefinitionDetailOrderByWithRelationInput | SickDefinitionDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SickDefinitionDetails.
     */
    cursor?: SickDefinitionDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SickDefinitionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SickDefinitionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SickDefinitionDetails.
     */
    distinct?: SickDefinitionDetailScalarFieldEnum | SickDefinitionDetailScalarFieldEnum[]
  }

  /**
   * SickDefinitionDetail findFirstOrThrow
   */
  export type SickDefinitionDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinitionDetail
     */
    select?: SickDefinitionDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionDetailInclude<ExtArgs> | null
    /**
     * Filter, which SickDefinitionDetail to fetch.
     */
    where?: SickDefinitionDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SickDefinitionDetails to fetch.
     */
    orderBy?: SickDefinitionDetailOrderByWithRelationInput | SickDefinitionDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SickDefinitionDetails.
     */
    cursor?: SickDefinitionDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SickDefinitionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SickDefinitionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SickDefinitionDetails.
     */
    distinct?: SickDefinitionDetailScalarFieldEnum | SickDefinitionDetailScalarFieldEnum[]
  }

  /**
   * SickDefinitionDetail findMany
   */
  export type SickDefinitionDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinitionDetail
     */
    select?: SickDefinitionDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionDetailInclude<ExtArgs> | null
    /**
     * Filter, which SickDefinitionDetails to fetch.
     */
    where?: SickDefinitionDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SickDefinitionDetails to fetch.
     */
    orderBy?: SickDefinitionDetailOrderByWithRelationInput | SickDefinitionDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SickDefinitionDetails.
     */
    cursor?: SickDefinitionDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SickDefinitionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SickDefinitionDetails.
     */
    skip?: number
    distinct?: SickDefinitionDetailScalarFieldEnum | SickDefinitionDetailScalarFieldEnum[]
  }

  /**
   * SickDefinitionDetail create
   */
  export type SickDefinitionDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinitionDetail
     */
    select?: SickDefinitionDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a SickDefinitionDetail.
     */
    data: XOR<SickDefinitionDetailCreateInput, SickDefinitionDetailUncheckedCreateInput>
  }

  /**
   * SickDefinitionDetail createMany
   */
  export type SickDefinitionDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SickDefinitionDetails.
     */
    data: SickDefinitionDetailCreateManyInput | SickDefinitionDetailCreateManyInput[]
  }

  /**
   * SickDefinitionDetail update
   */
  export type SickDefinitionDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinitionDetail
     */
    select?: SickDefinitionDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a SickDefinitionDetail.
     */
    data: XOR<SickDefinitionDetailUpdateInput, SickDefinitionDetailUncheckedUpdateInput>
    /**
     * Choose, which SickDefinitionDetail to update.
     */
    where: SickDefinitionDetailWhereUniqueInput
  }

  /**
   * SickDefinitionDetail updateMany
   */
  export type SickDefinitionDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SickDefinitionDetails.
     */
    data: XOR<SickDefinitionDetailUpdateManyMutationInput, SickDefinitionDetailUncheckedUpdateManyInput>
    /**
     * Filter which SickDefinitionDetails to update
     */
    where?: SickDefinitionDetailWhereInput
  }

  /**
   * SickDefinitionDetail upsert
   */
  export type SickDefinitionDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinitionDetail
     */
    select?: SickDefinitionDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the SickDefinitionDetail to update in case it exists.
     */
    where: SickDefinitionDetailWhereUniqueInput
    /**
     * In case the SickDefinitionDetail found by the `where` argument doesn't exist, create a new SickDefinitionDetail with this data.
     */
    create: XOR<SickDefinitionDetailCreateInput, SickDefinitionDetailUncheckedCreateInput>
    /**
     * In case the SickDefinitionDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SickDefinitionDetailUpdateInput, SickDefinitionDetailUncheckedUpdateInput>
  }

  /**
   * SickDefinitionDetail delete
   */
  export type SickDefinitionDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinitionDetail
     */
    select?: SickDefinitionDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionDetailInclude<ExtArgs> | null
    /**
     * Filter which SickDefinitionDetail to delete.
     */
    where: SickDefinitionDetailWhereUniqueInput
  }

  /**
   * SickDefinitionDetail deleteMany
   */
  export type SickDefinitionDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SickDefinitionDetails to delete
     */
    where?: SickDefinitionDetailWhereInput
  }

  /**
   * SickDefinitionDetail without action
   */
  export type SickDefinitionDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SickDefinitionDetail
     */
    select?: SickDefinitionDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SickDefinitionDetailInclude<ExtArgs> | null
  }


  /**
   * Model SocialSecurity
   */

  export type AggregateSocialSecurity = {
    _count: SocialSecurityCountAggregateOutputType | null
    _avg: SocialSecurityAvgAggregateOutputType | null
    _sum: SocialSecuritySumAggregateOutputType | null
    _min: SocialSecurityMinAggregateOutputType | null
    _max: SocialSecurityMaxAggregateOutputType | null
  }

  export type SocialSecurityAvgAggregateOutputType = {
    SocialSecurityID: number | null
    SocialSecurityYear: number | null
    SocialSecurityMonth: number | null
    MinAccountTotalForDivuach: number | null
  }

  export type SocialSecuritySumAggregateOutputType = {
    SocialSecurityID: number | null
    SocialSecurityYear: number | null
    SocialSecurityMonth: number | null
    MinAccountTotalForDivuach: number | null
  }

  export type SocialSecurityMinAggregateOutputType = {
    SocialSecurityID: number | null
    SocialSecurityYear: number | null
    SocialSecurityMonth: number | null
    CurrentSocialSecurity: boolean | null
    MinAccountTotalForDivuach: number | null
  }

  export type SocialSecurityMaxAggregateOutputType = {
    SocialSecurityID: number | null
    SocialSecurityYear: number | null
    SocialSecurityMonth: number | null
    CurrentSocialSecurity: boolean | null
    MinAccountTotalForDivuach: number | null
  }

  export type SocialSecurityCountAggregateOutputType = {
    SocialSecurityID: number
    SocialSecurityYear: number
    SocialSecurityMonth: number
    CurrentSocialSecurity: number
    MinAccountTotalForDivuach: number
    _all: number
  }


  export type SocialSecurityAvgAggregateInputType = {
    SocialSecurityID?: true
    SocialSecurityYear?: true
    SocialSecurityMonth?: true
    MinAccountTotalForDivuach?: true
  }

  export type SocialSecuritySumAggregateInputType = {
    SocialSecurityID?: true
    SocialSecurityYear?: true
    SocialSecurityMonth?: true
    MinAccountTotalForDivuach?: true
  }

  export type SocialSecurityMinAggregateInputType = {
    SocialSecurityID?: true
    SocialSecurityYear?: true
    SocialSecurityMonth?: true
    CurrentSocialSecurity?: true
    MinAccountTotalForDivuach?: true
  }

  export type SocialSecurityMaxAggregateInputType = {
    SocialSecurityID?: true
    SocialSecurityYear?: true
    SocialSecurityMonth?: true
    CurrentSocialSecurity?: true
    MinAccountTotalForDivuach?: true
  }

  export type SocialSecurityCountAggregateInputType = {
    SocialSecurityID?: true
    SocialSecurityYear?: true
    SocialSecurityMonth?: true
    CurrentSocialSecurity?: true
    MinAccountTotalForDivuach?: true
    _all?: true
  }

  export type SocialSecurityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialSecurity to aggregate.
     */
    where?: SocialSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialSecurities to fetch.
     */
    orderBy?: SocialSecurityOrderByWithRelationInput | SocialSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialSecurities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialSecurities
    **/
    _count?: true | SocialSecurityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocialSecurityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocialSecuritySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialSecurityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialSecurityMaxAggregateInputType
  }

  export type GetSocialSecurityAggregateType<T extends SocialSecurityAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialSecurity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialSecurity[P]>
      : GetScalarType<T[P], AggregateSocialSecurity[P]>
  }




  export type SocialSecurityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialSecurityWhereInput
    orderBy?: SocialSecurityOrderByWithAggregationInput | SocialSecurityOrderByWithAggregationInput[]
    by: SocialSecurityScalarFieldEnum[] | SocialSecurityScalarFieldEnum
    having?: SocialSecurityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialSecurityCountAggregateInputType | true
    _avg?: SocialSecurityAvgAggregateInputType
    _sum?: SocialSecuritySumAggregateInputType
    _min?: SocialSecurityMinAggregateInputType
    _max?: SocialSecurityMaxAggregateInputType
  }

  export type SocialSecurityGroupByOutputType = {
    SocialSecurityID: number
    SocialSecurityYear: number
    SocialSecurityMonth: number
    CurrentSocialSecurity: boolean
    MinAccountTotalForDivuach: number | null
    _count: SocialSecurityCountAggregateOutputType | null
    _avg: SocialSecurityAvgAggregateOutputType | null
    _sum: SocialSecuritySumAggregateOutputType | null
    _min: SocialSecurityMinAggregateOutputType | null
    _max: SocialSecurityMaxAggregateOutputType | null
  }

  type GetSocialSecurityGroupByPayload<T extends SocialSecurityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialSecurityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialSecurityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialSecurityGroupByOutputType[P]>
            : GetScalarType<T[P], SocialSecurityGroupByOutputType[P]>
        }
      >
    >


  export type SocialSecuritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SocialSecurityID?: boolean
    SocialSecurityYear?: boolean
    SocialSecurityMonth?: boolean
    CurrentSocialSecurity?: boolean
    MinAccountTotalForDivuach?: boolean
    SocialSecurityDetile?: boolean | SocialSecurity$SocialSecurityDetileArgs<ExtArgs>
    _count?: boolean | SocialSecurityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialSecurity"]>


  export type SocialSecuritySelectScalar = {
    SocialSecurityID?: boolean
    SocialSecurityYear?: boolean
    SocialSecurityMonth?: boolean
    CurrentSocialSecurity?: boolean
    MinAccountTotalForDivuach?: boolean
  }

  export type SocialSecurityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SocialSecurityDetile?: boolean | SocialSecurity$SocialSecurityDetileArgs<ExtArgs>
    _count?: boolean | SocialSecurityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SocialSecurityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialSecurity"
    objects: {
      SocialSecurityDetile: Prisma.$SocialSecurityDetilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      SocialSecurityID: number
      SocialSecurityYear: number
      SocialSecurityMonth: number
      CurrentSocialSecurity: boolean
      MinAccountTotalForDivuach: number | null
    }, ExtArgs["result"]["socialSecurity"]>
    composites: {}
  }

  type SocialSecurityGetPayload<S extends boolean | null | undefined | SocialSecurityDefaultArgs> = $Result.GetResult<Prisma.$SocialSecurityPayload, S>

  type SocialSecurityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SocialSecurityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SocialSecurityCountAggregateInputType | true
    }

  export interface SocialSecurityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialSecurity'], meta: { name: 'SocialSecurity' } }
    /**
     * Find zero or one SocialSecurity that matches the filter.
     * @param {SocialSecurityFindUniqueArgs} args - Arguments to find a SocialSecurity
     * @example
     * // Get one SocialSecurity
     * const socialSecurity = await prisma.socialSecurity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialSecurityFindUniqueArgs>(args: SelectSubset<T, SocialSecurityFindUniqueArgs<ExtArgs>>): Prisma__SocialSecurityClient<$Result.GetResult<Prisma.$SocialSecurityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SocialSecurity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SocialSecurityFindUniqueOrThrowArgs} args - Arguments to find a SocialSecurity
     * @example
     * // Get one SocialSecurity
     * const socialSecurity = await prisma.socialSecurity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialSecurityFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialSecurityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialSecurityClient<$Result.GetResult<Prisma.$SocialSecurityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SocialSecurity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityFindFirstArgs} args - Arguments to find a SocialSecurity
     * @example
     * // Get one SocialSecurity
     * const socialSecurity = await prisma.socialSecurity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialSecurityFindFirstArgs>(args?: SelectSubset<T, SocialSecurityFindFirstArgs<ExtArgs>>): Prisma__SocialSecurityClient<$Result.GetResult<Prisma.$SocialSecurityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SocialSecurity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityFindFirstOrThrowArgs} args - Arguments to find a SocialSecurity
     * @example
     * // Get one SocialSecurity
     * const socialSecurity = await prisma.socialSecurity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialSecurityFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialSecurityFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialSecurityClient<$Result.GetResult<Prisma.$SocialSecurityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SocialSecurities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialSecurities
     * const socialSecurities = await prisma.socialSecurity.findMany()
     * 
     * // Get first 10 SocialSecurities
     * const socialSecurities = await prisma.socialSecurity.findMany({ take: 10 })
     * 
     * // Only select the `SocialSecurityID`
     * const socialSecurityWithSocialSecurityIDOnly = await prisma.socialSecurity.findMany({ select: { SocialSecurityID: true } })
     * 
     */
    findMany<T extends SocialSecurityFindManyArgs>(args?: SelectSubset<T, SocialSecurityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialSecurityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SocialSecurity.
     * @param {SocialSecurityCreateArgs} args - Arguments to create a SocialSecurity.
     * @example
     * // Create one SocialSecurity
     * const SocialSecurity = await prisma.socialSecurity.create({
     *   data: {
     *     // ... data to create a SocialSecurity
     *   }
     * })
     * 
     */
    create<T extends SocialSecurityCreateArgs>(args: SelectSubset<T, SocialSecurityCreateArgs<ExtArgs>>): Prisma__SocialSecurityClient<$Result.GetResult<Prisma.$SocialSecurityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SocialSecurities.
     * @param {SocialSecurityCreateManyArgs} args - Arguments to create many SocialSecurities.
     * @example
     * // Create many SocialSecurities
     * const socialSecurity = await prisma.socialSecurity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialSecurityCreateManyArgs>(args?: SelectSubset<T, SocialSecurityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SocialSecurity.
     * @param {SocialSecurityDeleteArgs} args - Arguments to delete one SocialSecurity.
     * @example
     * // Delete one SocialSecurity
     * const SocialSecurity = await prisma.socialSecurity.delete({
     *   where: {
     *     // ... filter to delete one SocialSecurity
     *   }
     * })
     * 
     */
    delete<T extends SocialSecurityDeleteArgs>(args: SelectSubset<T, SocialSecurityDeleteArgs<ExtArgs>>): Prisma__SocialSecurityClient<$Result.GetResult<Prisma.$SocialSecurityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SocialSecurity.
     * @param {SocialSecurityUpdateArgs} args - Arguments to update one SocialSecurity.
     * @example
     * // Update one SocialSecurity
     * const socialSecurity = await prisma.socialSecurity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialSecurityUpdateArgs>(args: SelectSubset<T, SocialSecurityUpdateArgs<ExtArgs>>): Prisma__SocialSecurityClient<$Result.GetResult<Prisma.$SocialSecurityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SocialSecurities.
     * @param {SocialSecurityDeleteManyArgs} args - Arguments to filter SocialSecurities to delete.
     * @example
     * // Delete a few SocialSecurities
     * const { count } = await prisma.socialSecurity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialSecurityDeleteManyArgs>(args?: SelectSubset<T, SocialSecurityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialSecurities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialSecurities
     * const socialSecurity = await prisma.socialSecurity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialSecurityUpdateManyArgs>(args: SelectSubset<T, SocialSecurityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialSecurity.
     * @param {SocialSecurityUpsertArgs} args - Arguments to update or create a SocialSecurity.
     * @example
     * // Update or create a SocialSecurity
     * const socialSecurity = await prisma.socialSecurity.upsert({
     *   create: {
     *     // ... data to create a SocialSecurity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialSecurity we want to update
     *   }
     * })
     */
    upsert<T extends SocialSecurityUpsertArgs>(args: SelectSubset<T, SocialSecurityUpsertArgs<ExtArgs>>): Prisma__SocialSecurityClient<$Result.GetResult<Prisma.$SocialSecurityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SocialSecurities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityCountArgs} args - Arguments to filter SocialSecurities to count.
     * @example
     * // Count the number of SocialSecurities
     * const count = await prisma.socialSecurity.count({
     *   where: {
     *     // ... the filter for the SocialSecurities we want to count
     *   }
     * })
    **/
    count<T extends SocialSecurityCountArgs>(
      args?: Subset<T, SocialSecurityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialSecurityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialSecurity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialSecurityAggregateArgs>(args: Subset<T, SocialSecurityAggregateArgs>): Prisma.PrismaPromise<GetSocialSecurityAggregateType<T>>

    /**
     * Group by SocialSecurity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialSecurityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialSecurityGroupByArgs['orderBy'] }
        : { orderBy?: SocialSecurityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialSecurityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialSecurityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialSecurity model
   */
  readonly fields: SocialSecurityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialSecurity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialSecurityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SocialSecurityDetile<T extends SocialSecurity$SocialSecurityDetileArgs<ExtArgs> = {}>(args?: Subset<T, SocialSecurity$SocialSecurityDetileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialSecurityDetilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialSecurity model
   */ 
  interface SocialSecurityFieldRefs {
    readonly SocialSecurityID: FieldRef<"SocialSecurity", 'Int'>
    readonly SocialSecurityYear: FieldRef<"SocialSecurity", 'Int'>
    readonly SocialSecurityMonth: FieldRef<"SocialSecurity", 'Int'>
    readonly CurrentSocialSecurity: FieldRef<"SocialSecurity", 'Boolean'>
    readonly MinAccountTotalForDivuach: FieldRef<"SocialSecurity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SocialSecurity findUnique
   */
  export type SocialSecurityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurity
     */
    select?: SocialSecuritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityInclude<ExtArgs> | null
    /**
     * Filter, which SocialSecurity to fetch.
     */
    where: SocialSecurityWhereUniqueInput
  }

  /**
   * SocialSecurity findUniqueOrThrow
   */
  export type SocialSecurityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurity
     */
    select?: SocialSecuritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityInclude<ExtArgs> | null
    /**
     * Filter, which SocialSecurity to fetch.
     */
    where: SocialSecurityWhereUniqueInput
  }

  /**
   * SocialSecurity findFirst
   */
  export type SocialSecurityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurity
     */
    select?: SocialSecuritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityInclude<ExtArgs> | null
    /**
     * Filter, which SocialSecurity to fetch.
     */
    where?: SocialSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialSecurities to fetch.
     */
    orderBy?: SocialSecurityOrderByWithRelationInput | SocialSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialSecurities.
     */
    cursor?: SocialSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialSecurities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialSecurities.
     */
    distinct?: SocialSecurityScalarFieldEnum | SocialSecurityScalarFieldEnum[]
  }

  /**
   * SocialSecurity findFirstOrThrow
   */
  export type SocialSecurityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurity
     */
    select?: SocialSecuritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityInclude<ExtArgs> | null
    /**
     * Filter, which SocialSecurity to fetch.
     */
    where?: SocialSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialSecurities to fetch.
     */
    orderBy?: SocialSecurityOrderByWithRelationInput | SocialSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialSecurities.
     */
    cursor?: SocialSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialSecurities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialSecurities.
     */
    distinct?: SocialSecurityScalarFieldEnum | SocialSecurityScalarFieldEnum[]
  }

  /**
   * SocialSecurity findMany
   */
  export type SocialSecurityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurity
     */
    select?: SocialSecuritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityInclude<ExtArgs> | null
    /**
     * Filter, which SocialSecurities to fetch.
     */
    where?: SocialSecurityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialSecurities to fetch.
     */
    orderBy?: SocialSecurityOrderByWithRelationInput | SocialSecurityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialSecurities.
     */
    cursor?: SocialSecurityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialSecurities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialSecurities.
     */
    skip?: number
    distinct?: SocialSecurityScalarFieldEnum | SocialSecurityScalarFieldEnum[]
  }

  /**
   * SocialSecurity create
   */
  export type SocialSecurityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurity
     */
    select?: SocialSecuritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialSecurity.
     */
    data: XOR<SocialSecurityCreateInput, SocialSecurityUncheckedCreateInput>
  }

  /**
   * SocialSecurity createMany
   */
  export type SocialSecurityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialSecurities.
     */
    data: SocialSecurityCreateManyInput | SocialSecurityCreateManyInput[]
  }

  /**
   * SocialSecurity update
   */
  export type SocialSecurityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurity
     */
    select?: SocialSecuritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialSecurity.
     */
    data: XOR<SocialSecurityUpdateInput, SocialSecurityUncheckedUpdateInput>
    /**
     * Choose, which SocialSecurity to update.
     */
    where: SocialSecurityWhereUniqueInput
  }

  /**
   * SocialSecurity updateMany
   */
  export type SocialSecurityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialSecurities.
     */
    data: XOR<SocialSecurityUpdateManyMutationInput, SocialSecurityUncheckedUpdateManyInput>
    /**
     * Filter which SocialSecurities to update
     */
    where?: SocialSecurityWhereInput
  }

  /**
   * SocialSecurity upsert
   */
  export type SocialSecurityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurity
     */
    select?: SocialSecuritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialSecurity to update in case it exists.
     */
    where: SocialSecurityWhereUniqueInput
    /**
     * In case the SocialSecurity found by the `where` argument doesn't exist, create a new SocialSecurity with this data.
     */
    create: XOR<SocialSecurityCreateInput, SocialSecurityUncheckedCreateInput>
    /**
     * In case the SocialSecurity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialSecurityUpdateInput, SocialSecurityUncheckedUpdateInput>
  }

  /**
   * SocialSecurity delete
   */
  export type SocialSecurityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurity
     */
    select?: SocialSecuritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityInclude<ExtArgs> | null
    /**
     * Filter which SocialSecurity to delete.
     */
    where: SocialSecurityWhereUniqueInput
  }

  /**
   * SocialSecurity deleteMany
   */
  export type SocialSecurityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialSecurities to delete
     */
    where?: SocialSecurityWhereInput
  }

  /**
   * SocialSecurity.SocialSecurityDetile
   */
  export type SocialSecurity$SocialSecurityDetileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurityDetile
     */
    select?: SocialSecurityDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityDetileInclude<ExtArgs> | null
    where?: SocialSecurityDetileWhereInput
    orderBy?: SocialSecurityDetileOrderByWithRelationInput | SocialSecurityDetileOrderByWithRelationInput[]
    cursor?: SocialSecurityDetileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialSecurityDetileScalarFieldEnum | SocialSecurityDetileScalarFieldEnum[]
  }

  /**
   * SocialSecurity without action
   */
  export type SocialSecurityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurity
     */
    select?: SocialSecuritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityInclude<ExtArgs> | null
  }


  /**
   * Model SocialSecurityDetile
   */

  export type AggregateSocialSecurityDetile = {
    _count: SocialSecurityDetileCountAggregateOutputType | null
    _avg: SocialSecurityDetileAvgAggregateOutputType | null
    _sum: SocialSecurityDetileSumAggregateOutputType | null
    _min: SocialSecurityDetileMinAggregateOutputType | null
    _max: SocialSecurityDetileMaxAggregateOutputType | null
  }

  export type SocialSecurityDetileAvgAggregateOutputType = {
    SocialSecurityDetailID: number | null
    SocialSecurityID: number | null
    SocialYear: number | null
    SocialMonth: number | null
    Sector: number | null
    SocialSecurityCode: number | null
    AverageSalary: number | null
    MinNationalInsByMony: number | null
    MaxNationalInsByMony: number | null
    MinDeductionNationalInsByMony: number | null
    MinNationalInsByEmployee: number | null
    MaxNationalInsByEmployee: number | null
    MinNationalInsByEmployer: number | null
    MaxNationalInsByEmployer: number | null
    MaxNationalInsByMonyEmployee: number | null
    AverageEmbodiment: number | null
    DeductionMax: number | null
    DeductionPercent: number | null
    CreditPoint: number | null
    FactorToReduction: number | null
    MinHoursToPay: number | null
    MinimumPayFor5Day: number | null
    MinimumPayFor6Day: number | null
    MaxPrecentReduction: number | null
    hourPerDayfor5: number | null
    hourPerDayfor6: number | null
    hourInfridayDay: number | null
    TaxPrecent: number | null
    EmployerTax: number | null
    DiscountInTaxInEilat: number | null
    TaxUnitNumber: number | null
    FundPercentConstruction: number | null
    Hour100: number | null
    Hour125: number | null
    Hour150: number | null
    Hour175: number | null
    Hour200: number | null
    CreditCardMan: number | null
    CreditCardWoman: number | null
    CreditCardChild: number | null
    CreditCardBaby: number | null
    CreditCardInAddition: number | null
    CreditCardLackMobilityChild: number | null
    CreditCardImmigrant18: number | null
    HealthInsuranceEmployeeLow: number | null
    HealthInsuranceEmployeeAbove: number | null
    HealthInsuranceEmployerLow: number | null
    HealthInsuranceEmployerAbove: number | null
    ValueOfVehicleUseHibberdDiscount: number | null
    Deposit: number | null
    ValueOfMobileUse: number | null
    PensionCeiling: number | null
    PensionCredit: number | null
    DepositEmployerPrecent: number | null
    DepositEmployeePrecent: number | null
    TotalHourPerWeek: number | null
    CreditCardAdultChild: number | null
    CreditCardChild1_5: number | null
    DepositEmployeePrecentExecption: number | null
  }

  export type SocialSecurityDetileSumAggregateOutputType = {
    SocialSecurityDetailID: number | null
    SocialSecurityID: number | null
    SocialYear: number | null
    SocialMonth: number | null
    Sector: number | null
    SocialSecurityCode: number | null
    AverageSalary: number | null
    MinNationalInsByMony: number | null
    MaxNationalInsByMony: number | null
    MinDeductionNationalInsByMony: number | null
    MinNationalInsByEmployee: number | null
    MaxNationalInsByEmployee: number | null
    MinNationalInsByEmployer: number | null
    MaxNationalInsByEmployer: number | null
    MaxNationalInsByMonyEmployee: number | null
    AverageEmbodiment: number | null
    DeductionMax: number | null
    DeductionPercent: number | null
    CreditPoint: number | null
    FactorToReduction: number | null
    MinHoursToPay: number | null
    MinimumPayFor5Day: number | null
    MinimumPayFor6Day: number | null
    MaxPrecentReduction: number | null
    hourPerDayfor5: number | null
    hourPerDayfor6: number | null
    hourInfridayDay: number | null
    TaxPrecent: number | null
    EmployerTax: number | null
    DiscountInTaxInEilat: number | null
    TaxUnitNumber: number | null
    FundPercentConstruction: number | null
    Hour100: number | null
    Hour125: number | null
    Hour150: number | null
    Hour175: number | null
    Hour200: number | null
    CreditCardMan: number | null
    CreditCardWoman: number | null
    CreditCardChild: number | null
    CreditCardBaby: number | null
    CreditCardInAddition: number | null
    CreditCardLackMobilityChild: number | null
    CreditCardImmigrant18: number | null
    HealthInsuranceEmployeeLow: number | null
    HealthInsuranceEmployeeAbove: number | null
    HealthInsuranceEmployerLow: number | null
    HealthInsuranceEmployerAbove: number | null
    ValueOfVehicleUseHibberdDiscount: number | null
    Deposit: number | null
    ValueOfMobileUse: number | null
    PensionCeiling: number | null
    PensionCredit: number | null
    DepositEmployerPrecent: number | null
    DepositEmployeePrecent: number | null
    TotalHourPerWeek: number | null
    CreditCardAdultChild: number | null
    CreditCardChild1_5: number | null
    DepositEmployeePrecentExecption: number | null
  }

  export type SocialSecurityDetileMinAggregateOutputType = {
    SocialSecurityDetailID: number | null
    SocialSecurityID: number | null
    SocialYear: number | null
    SocialMonth: number | null
    Sector: number | null
    SocialSecurityCode: number | null
    AverageSalary: number | null
    MinNationalInsByMony: number | null
    MaxNationalInsByMony: number | null
    MinDeductionNationalInsByMony: number | null
    MinNationalInsByEmployee: number | null
    MaxNationalInsByEmployee: number | null
    MinNationalInsByEmployer: number | null
    MaxNationalInsByEmployer: number | null
    MaxNationalInsByMonyEmployee: number | null
    AverageEmbodiment: number | null
    DeductionMax: number | null
    DeductionPercent: number | null
    CreditPoint: number | null
    FactorToReduction: number | null
    MinHoursToPay: number | null
    MinimumPayFor5Day: number | null
    MinimumPayFor6Day: number | null
    MaxPrecentReduction: number | null
    hourPerDayfor5: number | null
    hourPerDayfor6: number | null
    hourInfridayDay: number | null
    TaxPrecent: number | null
    EmployerTax: number | null
    DiscountInTaxInEilat: number | null
    TaxUnitNumber: number | null
    FundPercentConstruction: number | null
    Hour100: number | null
    Hour125: number | null
    Hour150: number | null
    Hour175: number | null
    Hour200: number | null
    CreditCardMan: number | null
    CreditCardWoman: number | null
    CreditCardChild: number | null
    CreditCardBaby: number | null
    CreditCardInAddition: number | null
    CreditCardLackMobilityChild: number | null
    CreditCardImmigrant18: number | null
    ControlingShareholder: boolean | null
    HealthInsuranceEmployeeLow: number | null
    HealthInsuranceEmployeeAbove: number | null
    HealthInsuranceEmployerLow: number | null
    HealthInsuranceEmployerAbove: number | null
    ValueOfVehicleUseHibberdDiscount: number | null
    Deposit: number | null
    ValueOfMobileUse: number | null
    PensionCeiling: number | null
    PensionCredit: number | null
    DepositEmployerPrecent: number | null
    DepositEmployeePrecent: number | null
    TotalHourPerWeek: number | null
    CreditCardAdultChild: number | null
    CreditCardChild1_5: number | null
    DepositEmployeePrecentExecption: number | null
  }

  export type SocialSecurityDetileMaxAggregateOutputType = {
    SocialSecurityDetailID: number | null
    SocialSecurityID: number | null
    SocialYear: number | null
    SocialMonth: number | null
    Sector: number | null
    SocialSecurityCode: number | null
    AverageSalary: number | null
    MinNationalInsByMony: number | null
    MaxNationalInsByMony: number | null
    MinDeductionNationalInsByMony: number | null
    MinNationalInsByEmployee: number | null
    MaxNationalInsByEmployee: number | null
    MinNationalInsByEmployer: number | null
    MaxNationalInsByEmployer: number | null
    MaxNationalInsByMonyEmployee: number | null
    AverageEmbodiment: number | null
    DeductionMax: number | null
    DeductionPercent: number | null
    CreditPoint: number | null
    FactorToReduction: number | null
    MinHoursToPay: number | null
    MinimumPayFor5Day: number | null
    MinimumPayFor6Day: number | null
    MaxPrecentReduction: number | null
    hourPerDayfor5: number | null
    hourPerDayfor6: number | null
    hourInfridayDay: number | null
    TaxPrecent: number | null
    EmployerTax: number | null
    DiscountInTaxInEilat: number | null
    TaxUnitNumber: number | null
    FundPercentConstruction: number | null
    Hour100: number | null
    Hour125: number | null
    Hour150: number | null
    Hour175: number | null
    Hour200: number | null
    CreditCardMan: number | null
    CreditCardWoman: number | null
    CreditCardChild: number | null
    CreditCardBaby: number | null
    CreditCardInAddition: number | null
    CreditCardLackMobilityChild: number | null
    CreditCardImmigrant18: number | null
    ControlingShareholder: boolean | null
    HealthInsuranceEmployeeLow: number | null
    HealthInsuranceEmployeeAbove: number | null
    HealthInsuranceEmployerLow: number | null
    HealthInsuranceEmployerAbove: number | null
    ValueOfVehicleUseHibberdDiscount: number | null
    Deposit: number | null
    ValueOfMobileUse: number | null
    PensionCeiling: number | null
    PensionCredit: number | null
    DepositEmployerPrecent: number | null
    DepositEmployeePrecent: number | null
    TotalHourPerWeek: number | null
    CreditCardAdultChild: number | null
    CreditCardChild1_5: number | null
    DepositEmployeePrecentExecption: number | null
  }

  export type SocialSecurityDetileCountAggregateOutputType = {
    SocialSecurityDetailID: number
    SocialSecurityID: number
    SocialYear: number
    SocialMonth: number
    Sector: number
    SocialSecurityCode: number
    AverageSalary: number
    MinNationalInsByMony: number
    MaxNationalInsByMony: number
    MinDeductionNationalInsByMony: number
    MinNationalInsByEmployee: number
    MaxNationalInsByEmployee: number
    MinNationalInsByEmployer: number
    MaxNationalInsByEmployer: number
    MaxNationalInsByMonyEmployee: number
    AverageEmbodiment: number
    DeductionMax: number
    DeductionPercent: number
    CreditPoint: number
    FactorToReduction: number
    MinHoursToPay: number
    MinimumPayFor5Day: number
    MinimumPayFor6Day: number
    MaxPrecentReduction: number
    hourPerDayfor5: number
    hourPerDayfor6: number
    hourInfridayDay: number
    TaxPrecent: number
    EmployerTax: number
    DiscountInTaxInEilat: number
    TaxUnitNumber: number
    FundPercentConstruction: number
    Hour100: number
    Hour125: number
    Hour150: number
    Hour175: number
    Hour200: number
    CreditCardMan: number
    CreditCardWoman: number
    CreditCardChild: number
    CreditCardBaby: number
    CreditCardInAddition: number
    CreditCardLackMobilityChild: number
    CreditCardImmigrant18: number
    ControlingShareholder: number
    HealthInsuranceEmployeeLow: number
    HealthInsuranceEmployeeAbove: number
    HealthInsuranceEmployerLow: number
    HealthInsuranceEmployerAbove: number
    ValueOfVehicleUseHibberdDiscount: number
    Deposit: number
    ValueOfMobileUse: number
    PensionCeiling: number
    PensionCredit: number
    DepositEmployerPrecent: number
    DepositEmployeePrecent: number
    TotalHourPerWeek: number
    CreditCardAdultChild: number
    CreditCardChild1_5: number
    DepositEmployeePrecentExecption: number
    _all: number
  }


  export type SocialSecurityDetileAvgAggregateInputType = {
    SocialSecurityDetailID?: true
    SocialSecurityID?: true
    SocialYear?: true
    SocialMonth?: true
    Sector?: true
    SocialSecurityCode?: true
    AverageSalary?: true
    MinNationalInsByMony?: true
    MaxNationalInsByMony?: true
    MinDeductionNationalInsByMony?: true
    MinNationalInsByEmployee?: true
    MaxNationalInsByEmployee?: true
    MinNationalInsByEmployer?: true
    MaxNationalInsByEmployer?: true
    MaxNationalInsByMonyEmployee?: true
    AverageEmbodiment?: true
    DeductionMax?: true
    DeductionPercent?: true
    CreditPoint?: true
    FactorToReduction?: true
    MinHoursToPay?: true
    MinimumPayFor5Day?: true
    MinimumPayFor6Day?: true
    MaxPrecentReduction?: true
    hourPerDayfor5?: true
    hourPerDayfor6?: true
    hourInfridayDay?: true
    TaxPrecent?: true
    EmployerTax?: true
    DiscountInTaxInEilat?: true
    TaxUnitNumber?: true
    FundPercentConstruction?: true
    Hour100?: true
    Hour125?: true
    Hour150?: true
    Hour175?: true
    Hour200?: true
    CreditCardMan?: true
    CreditCardWoman?: true
    CreditCardChild?: true
    CreditCardBaby?: true
    CreditCardInAddition?: true
    CreditCardLackMobilityChild?: true
    CreditCardImmigrant18?: true
    HealthInsuranceEmployeeLow?: true
    HealthInsuranceEmployeeAbove?: true
    HealthInsuranceEmployerLow?: true
    HealthInsuranceEmployerAbove?: true
    ValueOfVehicleUseHibberdDiscount?: true
    Deposit?: true
    ValueOfMobileUse?: true
    PensionCeiling?: true
    PensionCredit?: true
    DepositEmployerPrecent?: true
    DepositEmployeePrecent?: true
    TotalHourPerWeek?: true
    CreditCardAdultChild?: true
    CreditCardChild1_5?: true
    DepositEmployeePrecentExecption?: true
  }

  export type SocialSecurityDetileSumAggregateInputType = {
    SocialSecurityDetailID?: true
    SocialSecurityID?: true
    SocialYear?: true
    SocialMonth?: true
    Sector?: true
    SocialSecurityCode?: true
    AverageSalary?: true
    MinNationalInsByMony?: true
    MaxNationalInsByMony?: true
    MinDeductionNationalInsByMony?: true
    MinNationalInsByEmployee?: true
    MaxNationalInsByEmployee?: true
    MinNationalInsByEmployer?: true
    MaxNationalInsByEmployer?: true
    MaxNationalInsByMonyEmployee?: true
    AverageEmbodiment?: true
    DeductionMax?: true
    DeductionPercent?: true
    CreditPoint?: true
    FactorToReduction?: true
    MinHoursToPay?: true
    MinimumPayFor5Day?: true
    MinimumPayFor6Day?: true
    MaxPrecentReduction?: true
    hourPerDayfor5?: true
    hourPerDayfor6?: true
    hourInfridayDay?: true
    TaxPrecent?: true
    EmployerTax?: true
    DiscountInTaxInEilat?: true
    TaxUnitNumber?: true
    FundPercentConstruction?: true
    Hour100?: true
    Hour125?: true
    Hour150?: true
    Hour175?: true
    Hour200?: true
    CreditCardMan?: true
    CreditCardWoman?: true
    CreditCardChild?: true
    CreditCardBaby?: true
    CreditCardInAddition?: true
    CreditCardLackMobilityChild?: true
    CreditCardImmigrant18?: true
    HealthInsuranceEmployeeLow?: true
    HealthInsuranceEmployeeAbove?: true
    HealthInsuranceEmployerLow?: true
    HealthInsuranceEmployerAbove?: true
    ValueOfVehicleUseHibberdDiscount?: true
    Deposit?: true
    ValueOfMobileUse?: true
    PensionCeiling?: true
    PensionCredit?: true
    DepositEmployerPrecent?: true
    DepositEmployeePrecent?: true
    TotalHourPerWeek?: true
    CreditCardAdultChild?: true
    CreditCardChild1_5?: true
    DepositEmployeePrecentExecption?: true
  }

  export type SocialSecurityDetileMinAggregateInputType = {
    SocialSecurityDetailID?: true
    SocialSecurityID?: true
    SocialYear?: true
    SocialMonth?: true
    Sector?: true
    SocialSecurityCode?: true
    AverageSalary?: true
    MinNationalInsByMony?: true
    MaxNationalInsByMony?: true
    MinDeductionNationalInsByMony?: true
    MinNationalInsByEmployee?: true
    MaxNationalInsByEmployee?: true
    MinNationalInsByEmployer?: true
    MaxNationalInsByEmployer?: true
    MaxNationalInsByMonyEmployee?: true
    AverageEmbodiment?: true
    DeductionMax?: true
    DeductionPercent?: true
    CreditPoint?: true
    FactorToReduction?: true
    MinHoursToPay?: true
    MinimumPayFor5Day?: true
    MinimumPayFor6Day?: true
    MaxPrecentReduction?: true
    hourPerDayfor5?: true
    hourPerDayfor6?: true
    hourInfridayDay?: true
    TaxPrecent?: true
    EmployerTax?: true
    DiscountInTaxInEilat?: true
    TaxUnitNumber?: true
    FundPercentConstruction?: true
    Hour100?: true
    Hour125?: true
    Hour150?: true
    Hour175?: true
    Hour200?: true
    CreditCardMan?: true
    CreditCardWoman?: true
    CreditCardChild?: true
    CreditCardBaby?: true
    CreditCardInAddition?: true
    CreditCardLackMobilityChild?: true
    CreditCardImmigrant18?: true
    ControlingShareholder?: true
    HealthInsuranceEmployeeLow?: true
    HealthInsuranceEmployeeAbove?: true
    HealthInsuranceEmployerLow?: true
    HealthInsuranceEmployerAbove?: true
    ValueOfVehicleUseHibberdDiscount?: true
    Deposit?: true
    ValueOfMobileUse?: true
    PensionCeiling?: true
    PensionCredit?: true
    DepositEmployerPrecent?: true
    DepositEmployeePrecent?: true
    TotalHourPerWeek?: true
    CreditCardAdultChild?: true
    CreditCardChild1_5?: true
    DepositEmployeePrecentExecption?: true
  }

  export type SocialSecurityDetileMaxAggregateInputType = {
    SocialSecurityDetailID?: true
    SocialSecurityID?: true
    SocialYear?: true
    SocialMonth?: true
    Sector?: true
    SocialSecurityCode?: true
    AverageSalary?: true
    MinNationalInsByMony?: true
    MaxNationalInsByMony?: true
    MinDeductionNationalInsByMony?: true
    MinNationalInsByEmployee?: true
    MaxNationalInsByEmployee?: true
    MinNationalInsByEmployer?: true
    MaxNationalInsByEmployer?: true
    MaxNationalInsByMonyEmployee?: true
    AverageEmbodiment?: true
    DeductionMax?: true
    DeductionPercent?: true
    CreditPoint?: true
    FactorToReduction?: true
    MinHoursToPay?: true
    MinimumPayFor5Day?: true
    MinimumPayFor6Day?: true
    MaxPrecentReduction?: true
    hourPerDayfor5?: true
    hourPerDayfor6?: true
    hourInfridayDay?: true
    TaxPrecent?: true
    EmployerTax?: true
    DiscountInTaxInEilat?: true
    TaxUnitNumber?: true
    FundPercentConstruction?: true
    Hour100?: true
    Hour125?: true
    Hour150?: true
    Hour175?: true
    Hour200?: true
    CreditCardMan?: true
    CreditCardWoman?: true
    CreditCardChild?: true
    CreditCardBaby?: true
    CreditCardInAddition?: true
    CreditCardLackMobilityChild?: true
    CreditCardImmigrant18?: true
    ControlingShareholder?: true
    HealthInsuranceEmployeeLow?: true
    HealthInsuranceEmployeeAbove?: true
    HealthInsuranceEmployerLow?: true
    HealthInsuranceEmployerAbove?: true
    ValueOfVehicleUseHibberdDiscount?: true
    Deposit?: true
    ValueOfMobileUse?: true
    PensionCeiling?: true
    PensionCredit?: true
    DepositEmployerPrecent?: true
    DepositEmployeePrecent?: true
    TotalHourPerWeek?: true
    CreditCardAdultChild?: true
    CreditCardChild1_5?: true
    DepositEmployeePrecentExecption?: true
  }

  export type SocialSecurityDetileCountAggregateInputType = {
    SocialSecurityDetailID?: true
    SocialSecurityID?: true
    SocialYear?: true
    SocialMonth?: true
    Sector?: true
    SocialSecurityCode?: true
    AverageSalary?: true
    MinNationalInsByMony?: true
    MaxNationalInsByMony?: true
    MinDeductionNationalInsByMony?: true
    MinNationalInsByEmployee?: true
    MaxNationalInsByEmployee?: true
    MinNationalInsByEmployer?: true
    MaxNationalInsByEmployer?: true
    MaxNationalInsByMonyEmployee?: true
    AverageEmbodiment?: true
    DeductionMax?: true
    DeductionPercent?: true
    CreditPoint?: true
    FactorToReduction?: true
    MinHoursToPay?: true
    MinimumPayFor5Day?: true
    MinimumPayFor6Day?: true
    MaxPrecentReduction?: true
    hourPerDayfor5?: true
    hourPerDayfor6?: true
    hourInfridayDay?: true
    TaxPrecent?: true
    EmployerTax?: true
    DiscountInTaxInEilat?: true
    TaxUnitNumber?: true
    FundPercentConstruction?: true
    Hour100?: true
    Hour125?: true
    Hour150?: true
    Hour175?: true
    Hour200?: true
    CreditCardMan?: true
    CreditCardWoman?: true
    CreditCardChild?: true
    CreditCardBaby?: true
    CreditCardInAddition?: true
    CreditCardLackMobilityChild?: true
    CreditCardImmigrant18?: true
    ControlingShareholder?: true
    HealthInsuranceEmployeeLow?: true
    HealthInsuranceEmployeeAbove?: true
    HealthInsuranceEmployerLow?: true
    HealthInsuranceEmployerAbove?: true
    ValueOfVehicleUseHibberdDiscount?: true
    Deposit?: true
    ValueOfMobileUse?: true
    PensionCeiling?: true
    PensionCredit?: true
    DepositEmployerPrecent?: true
    DepositEmployeePrecent?: true
    TotalHourPerWeek?: true
    CreditCardAdultChild?: true
    CreditCardChild1_5?: true
    DepositEmployeePrecentExecption?: true
    _all?: true
  }

  export type SocialSecurityDetileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialSecurityDetile to aggregate.
     */
    where?: SocialSecurityDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialSecurityDetiles to fetch.
     */
    orderBy?: SocialSecurityDetileOrderByWithRelationInput | SocialSecurityDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialSecurityDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialSecurityDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialSecurityDetiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialSecurityDetiles
    **/
    _count?: true | SocialSecurityDetileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocialSecurityDetileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocialSecurityDetileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialSecurityDetileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialSecurityDetileMaxAggregateInputType
  }

  export type GetSocialSecurityDetileAggregateType<T extends SocialSecurityDetileAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialSecurityDetile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialSecurityDetile[P]>
      : GetScalarType<T[P], AggregateSocialSecurityDetile[P]>
  }




  export type SocialSecurityDetileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialSecurityDetileWhereInput
    orderBy?: SocialSecurityDetileOrderByWithAggregationInput | SocialSecurityDetileOrderByWithAggregationInput[]
    by: SocialSecurityDetileScalarFieldEnum[] | SocialSecurityDetileScalarFieldEnum
    having?: SocialSecurityDetileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialSecurityDetileCountAggregateInputType | true
    _avg?: SocialSecurityDetileAvgAggregateInputType
    _sum?: SocialSecurityDetileSumAggregateInputType
    _min?: SocialSecurityDetileMinAggregateInputType
    _max?: SocialSecurityDetileMaxAggregateInputType
  }

  export type SocialSecurityDetileGroupByOutputType = {
    SocialSecurityDetailID: number
    SocialSecurityID: number
    SocialYear: number
    SocialMonth: number
    Sector: number
    SocialSecurityCode: number
    AverageSalary: number | null
    MinNationalInsByMony: number | null
    MaxNationalInsByMony: number | null
    MinDeductionNationalInsByMony: number | null
    MinNationalInsByEmployee: number | null
    MaxNationalInsByEmployee: number | null
    MinNationalInsByEmployer: number | null
    MaxNationalInsByEmployer: number | null
    MaxNationalInsByMonyEmployee: number | null
    AverageEmbodiment: number | null
    DeductionMax: number | null
    DeductionPercent: number | null
    CreditPoint: number | null
    FactorToReduction: number | null
    MinHoursToPay: number | null
    MinimumPayFor5Day: number | null
    MinimumPayFor6Day: number | null
    MaxPrecentReduction: number | null
    hourPerDayfor5: number | null
    hourPerDayfor6: number | null
    hourInfridayDay: number | null
    TaxPrecent: number | null
    EmployerTax: number | null
    DiscountInTaxInEilat: number | null
    TaxUnitNumber: number | null
    FundPercentConstruction: number | null
    Hour100: number | null
    Hour125: number | null
    Hour150: number | null
    Hour175: number | null
    Hour200: number | null
    CreditCardMan: number | null
    CreditCardWoman: number | null
    CreditCardChild: number | null
    CreditCardBaby: number | null
    CreditCardInAddition: number | null
    CreditCardLackMobilityChild: number | null
    CreditCardImmigrant18: number | null
    ControlingShareholder: boolean
    HealthInsuranceEmployeeLow: number | null
    HealthInsuranceEmployeeAbove: number | null
    HealthInsuranceEmployerLow: number | null
    HealthInsuranceEmployerAbove: number | null
    ValueOfVehicleUseHibberdDiscount: number | null
    Deposit: number | null
    ValueOfMobileUse: number | null
    PensionCeiling: number | null
    PensionCredit: number | null
    DepositEmployerPrecent: number | null
    DepositEmployeePrecent: number | null
    TotalHourPerWeek: number | null
    CreditCardAdultChild: number | null
    CreditCardChild1_5: number | null
    DepositEmployeePrecentExecption: number | null
    _count: SocialSecurityDetileCountAggregateOutputType | null
    _avg: SocialSecurityDetileAvgAggregateOutputType | null
    _sum: SocialSecurityDetileSumAggregateOutputType | null
    _min: SocialSecurityDetileMinAggregateOutputType | null
    _max: SocialSecurityDetileMaxAggregateOutputType | null
  }

  type GetSocialSecurityDetileGroupByPayload<T extends SocialSecurityDetileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialSecurityDetileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialSecurityDetileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialSecurityDetileGroupByOutputType[P]>
            : GetScalarType<T[P], SocialSecurityDetileGroupByOutputType[P]>
        }
      >
    >


  export type SocialSecurityDetileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SocialSecurityDetailID?: boolean
    SocialSecurityID?: boolean
    SocialYear?: boolean
    SocialMonth?: boolean
    Sector?: boolean
    SocialSecurityCode?: boolean
    AverageSalary?: boolean
    MinNationalInsByMony?: boolean
    MaxNationalInsByMony?: boolean
    MinDeductionNationalInsByMony?: boolean
    MinNationalInsByEmployee?: boolean
    MaxNationalInsByEmployee?: boolean
    MinNationalInsByEmployer?: boolean
    MaxNationalInsByEmployer?: boolean
    MaxNationalInsByMonyEmployee?: boolean
    AverageEmbodiment?: boolean
    DeductionMax?: boolean
    DeductionPercent?: boolean
    CreditPoint?: boolean
    FactorToReduction?: boolean
    MinHoursToPay?: boolean
    MinimumPayFor5Day?: boolean
    MinimumPayFor6Day?: boolean
    MaxPrecentReduction?: boolean
    hourPerDayfor5?: boolean
    hourPerDayfor6?: boolean
    hourInfridayDay?: boolean
    TaxPrecent?: boolean
    EmployerTax?: boolean
    DiscountInTaxInEilat?: boolean
    TaxUnitNumber?: boolean
    FundPercentConstruction?: boolean
    Hour100?: boolean
    Hour125?: boolean
    Hour150?: boolean
    Hour175?: boolean
    Hour200?: boolean
    CreditCardMan?: boolean
    CreditCardWoman?: boolean
    CreditCardChild?: boolean
    CreditCardBaby?: boolean
    CreditCardInAddition?: boolean
    CreditCardLackMobilityChild?: boolean
    CreditCardImmigrant18?: boolean
    ControlingShareholder?: boolean
    HealthInsuranceEmployeeLow?: boolean
    HealthInsuranceEmployeeAbove?: boolean
    HealthInsuranceEmployerLow?: boolean
    HealthInsuranceEmployerAbove?: boolean
    ValueOfVehicleUseHibberdDiscount?: boolean
    Deposit?: boolean
    ValueOfMobileUse?: boolean
    PensionCeiling?: boolean
    PensionCredit?: boolean
    DepositEmployerPrecent?: boolean
    DepositEmployeePrecent?: boolean
    TotalHourPerWeek?: boolean
    CreditCardAdultChild?: boolean
    CreditCardChild1_5?: boolean
    DepositEmployeePrecentExecption?: boolean
    SocialSecurity?: boolean | SocialSecurityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialSecurityDetile"]>


  export type SocialSecurityDetileSelectScalar = {
    SocialSecurityDetailID?: boolean
    SocialSecurityID?: boolean
    SocialYear?: boolean
    SocialMonth?: boolean
    Sector?: boolean
    SocialSecurityCode?: boolean
    AverageSalary?: boolean
    MinNationalInsByMony?: boolean
    MaxNationalInsByMony?: boolean
    MinDeductionNationalInsByMony?: boolean
    MinNationalInsByEmployee?: boolean
    MaxNationalInsByEmployee?: boolean
    MinNationalInsByEmployer?: boolean
    MaxNationalInsByEmployer?: boolean
    MaxNationalInsByMonyEmployee?: boolean
    AverageEmbodiment?: boolean
    DeductionMax?: boolean
    DeductionPercent?: boolean
    CreditPoint?: boolean
    FactorToReduction?: boolean
    MinHoursToPay?: boolean
    MinimumPayFor5Day?: boolean
    MinimumPayFor6Day?: boolean
    MaxPrecentReduction?: boolean
    hourPerDayfor5?: boolean
    hourPerDayfor6?: boolean
    hourInfridayDay?: boolean
    TaxPrecent?: boolean
    EmployerTax?: boolean
    DiscountInTaxInEilat?: boolean
    TaxUnitNumber?: boolean
    FundPercentConstruction?: boolean
    Hour100?: boolean
    Hour125?: boolean
    Hour150?: boolean
    Hour175?: boolean
    Hour200?: boolean
    CreditCardMan?: boolean
    CreditCardWoman?: boolean
    CreditCardChild?: boolean
    CreditCardBaby?: boolean
    CreditCardInAddition?: boolean
    CreditCardLackMobilityChild?: boolean
    CreditCardImmigrant18?: boolean
    ControlingShareholder?: boolean
    HealthInsuranceEmployeeLow?: boolean
    HealthInsuranceEmployeeAbove?: boolean
    HealthInsuranceEmployerLow?: boolean
    HealthInsuranceEmployerAbove?: boolean
    ValueOfVehicleUseHibberdDiscount?: boolean
    Deposit?: boolean
    ValueOfMobileUse?: boolean
    PensionCeiling?: boolean
    PensionCredit?: boolean
    DepositEmployerPrecent?: boolean
    DepositEmployeePrecent?: boolean
    TotalHourPerWeek?: boolean
    CreditCardAdultChild?: boolean
    CreditCardChild1_5?: boolean
    DepositEmployeePrecentExecption?: boolean
  }

  export type SocialSecurityDetileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SocialSecurity?: boolean | SocialSecurityDefaultArgs<ExtArgs>
  }

  export type $SocialSecurityDetilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialSecurityDetile"
    objects: {
      SocialSecurity: Prisma.$SocialSecurityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      SocialSecurityDetailID: number
      SocialSecurityID: number
      SocialYear: number
      SocialMonth: number
      Sector: number
      SocialSecurityCode: number
      AverageSalary: number | null
      MinNationalInsByMony: number | null
      MaxNationalInsByMony: number | null
      MinDeductionNationalInsByMony: number | null
      MinNationalInsByEmployee: number | null
      MaxNationalInsByEmployee: number | null
      MinNationalInsByEmployer: number | null
      MaxNationalInsByEmployer: number | null
      MaxNationalInsByMonyEmployee: number | null
      AverageEmbodiment: number | null
      DeductionMax: number | null
      DeductionPercent: number | null
      CreditPoint: number | null
      FactorToReduction: number | null
      MinHoursToPay: number | null
      MinimumPayFor5Day: number | null
      MinimumPayFor6Day: number | null
      MaxPrecentReduction: number | null
      hourPerDayfor5: number | null
      hourPerDayfor6: number | null
      hourInfridayDay: number | null
      TaxPrecent: number | null
      EmployerTax: number | null
      DiscountInTaxInEilat: number | null
      TaxUnitNumber: number | null
      FundPercentConstruction: number | null
      Hour100: number | null
      Hour125: number | null
      Hour150: number | null
      Hour175: number | null
      Hour200: number | null
      CreditCardMan: number | null
      CreditCardWoman: number | null
      CreditCardChild: number | null
      CreditCardBaby: number | null
      CreditCardInAddition: number | null
      CreditCardLackMobilityChild: number | null
      CreditCardImmigrant18: number | null
      ControlingShareholder: boolean
      HealthInsuranceEmployeeLow: number | null
      HealthInsuranceEmployeeAbove: number | null
      HealthInsuranceEmployerLow: number | null
      HealthInsuranceEmployerAbove: number | null
      ValueOfVehicleUseHibberdDiscount: number | null
      Deposit: number | null
      ValueOfMobileUse: number | null
      PensionCeiling: number | null
      PensionCredit: number | null
      DepositEmployerPrecent: number | null
      DepositEmployeePrecent: number | null
      TotalHourPerWeek: number | null
      CreditCardAdultChild: number | null
      CreditCardChild1_5: number | null
      DepositEmployeePrecentExecption: number | null
    }, ExtArgs["result"]["socialSecurityDetile"]>
    composites: {}
  }

  type SocialSecurityDetileGetPayload<S extends boolean | null | undefined | SocialSecurityDetileDefaultArgs> = $Result.GetResult<Prisma.$SocialSecurityDetilePayload, S>

  type SocialSecurityDetileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SocialSecurityDetileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SocialSecurityDetileCountAggregateInputType | true
    }

  export interface SocialSecurityDetileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialSecurityDetile'], meta: { name: 'SocialSecurityDetile' } }
    /**
     * Find zero or one SocialSecurityDetile that matches the filter.
     * @param {SocialSecurityDetileFindUniqueArgs} args - Arguments to find a SocialSecurityDetile
     * @example
     * // Get one SocialSecurityDetile
     * const socialSecurityDetile = await prisma.socialSecurityDetile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialSecurityDetileFindUniqueArgs>(args: SelectSubset<T, SocialSecurityDetileFindUniqueArgs<ExtArgs>>): Prisma__SocialSecurityDetileClient<$Result.GetResult<Prisma.$SocialSecurityDetilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SocialSecurityDetile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SocialSecurityDetileFindUniqueOrThrowArgs} args - Arguments to find a SocialSecurityDetile
     * @example
     * // Get one SocialSecurityDetile
     * const socialSecurityDetile = await prisma.socialSecurityDetile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialSecurityDetileFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialSecurityDetileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialSecurityDetileClient<$Result.GetResult<Prisma.$SocialSecurityDetilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SocialSecurityDetile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityDetileFindFirstArgs} args - Arguments to find a SocialSecurityDetile
     * @example
     * // Get one SocialSecurityDetile
     * const socialSecurityDetile = await prisma.socialSecurityDetile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialSecurityDetileFindFirstArgs>(args?: SelectSubset<T, SocialSecurityDetileFindFirstArgs<ExtArgs>>): Prisma__SocialSecurityDetileClient<$Result.GetResult<Prisma.$SocialSecurityDetilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SocialSecurityDetile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityDetileFindFirstOrThrowArgs} args - Arguments to find a SocialSecurityDetile
     * @example
     * // Get one SocialSecurityDetile
     * const socialSecurityDetile = await prisma.socialSecurityDetile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialSecurityDetileFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialSecurityDetileFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialSecurityDetileClient<$Result.GetResult<Prisma.$SocialSecurityDetilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SocialSecurityDetiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityDetileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialSecurityDetiles
     * const socialSecurityDetiles = await prisma.socialSecurityDetile.findMany()
     * 
     * // Get first 10 SocialSecurityDetiles
     * const socialSecurityDetiles = await prisma.socialSecurityDetile.findMany({ take: 10 })
     * 
     * // Only select the `SocialSecurityDetailID`
     * const socialSecurityDetileWithSocialSecurityDetailIDOnly = await prisma.socialSecurityDetile.findMany({ select: { SocialSecurityDetailID: true } })
     * 
     */
    findMany<T extends SocialSecurityDetileFindManyArgs>(args?: SelectSubset<T, SocialSecurityDetileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialSecurityDetilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SocialSecurityDetile.
     * @param {SocialSecurityDetileCreateArgs} args - Arguments to create a SocialSecurityDetile.
     * @example
     * // Create one SocialSecurityDetile
     * const SocialSecurityDetile = await prisma.socialSecurityDetile.create({
     *   data: {
     *     // ... data to create a SocialSecurityDetile
     *   }
     * })
     * 
     */
    create<T extends SocialSecurityDetileCreateArgs>(args: SelectSubset<T, SocialSecurityDetileCreateArgs<ExtArgs>>): Prisma__SocialSecurityDetileClient<$Result.GetResult<Prisma.$SocialSecurityDetilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SocialSecurityDetiles.
     * @param {SocialSecurityDetileCreateManyArgs} args - Arguments to create many SocialSecurityDetiles.
     * @example
     * // Create many SocialSecurityDetiles
     * const socialSecurityDetile = await prisma.socialSecurityDetile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialSecurityDetileCreateManyArgs>(args?: SelectSubset<T, SocialSecurityDetileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SocialSecurityDetile.
     * @param {SocialSecurityDetileDeleteArgs} args - Arguments to delete one SocialSecurityDetile.
     * @example
     * // Delete one SocialSecurityDetile
     * const SocialSecurityDetile = await prisma.socialSecurityDetile.delete({
     *   where: {
     *     // ... filter to delete one SocialSecurityDetile
     *   }
     * })
     * 
     */
    delete<T extends SocialSecurityDetileDeleteArgs>(args: SelectSubset<T, SocialSecurityDetileDeleteArgs<ExtArgs>>): Prisma__SocialSecurityDetileClient<$Result.GetResult<Prisma.$SocialSecurityDetilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SocialSecurityDetile.
     * @param {SocialSecurityDetileUpdateArgs} args - Arguments to update one SocialSecurityDetile.
     * @example
     * // Update one SocialSecurityDetile
     * const socialSecurityDetile = await prisma.socialSecurityDetile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialSecurityDetileUpdateArgs>(args: SelectSubset<T, SocialSecurityDetileUpdateArgs<ExtArgs>>): Prisma__SocialSecurityDetileClient<$Result.GetResult<Prisma.$SocialSecurityDetilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SocialSecurityDetiles.
     * @param {SocialSecurityDetileDeleteManyArgs} args - Arguments to filter SocialSecurityDetiles to delete.
     * @example
     * // Delete a few SocialSecurityDetiles
     * const { count } = await prisma.socialSecurityDetile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialSecurityDetileDeleteManyArgs>(args?: SelectSubset<T, SocialSecurityDetileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialSecurityDetiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityDetileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialSecurityDetiles
     * const socialSecurityDetile = await prisma.socialSecurityDetile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialSecurityDetileUpdateManyArgs>(args: SelectSubset<T, SocialSecurityDetileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialSecurityDetile.
     * @param {SocialSecurityDetileUpsertArgs} args - Arguments to update or create a SocialSecurityDetile.
     * @example
     * // Update or create a SocialSecurityDetile
     * const socialSecurityDetile = await prisma.socialSecurityDetile.upsert({
     *   create: {
     *     // ... data to create a SocialSecurityDetile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialSecurityDetile we want to update
     *   }
     * })
     */
    upsert<T extends SocialSecurityDetileUpsertArgs>(args: SelectSubset<T, SocialSecurityDetileUpsertArgs<ExtArgs>>): Prisma__SocialSecurityDetileClient<$Result.GetResult<Prisma.$SocialSecurityDetilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SocialSecurityDetiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityDetileCountArgs} args - Arguments to filter SocialSecurityDetiles to count.
     * @example
     * // Count the number of SocialSecurityDetiles
     * const count = await prisma.socialSecurityDetile.count({
     *   where: {
     *     // ... the filter for the SocialSecurityDetiles we want to count
     *   }
     * })
    **/
    count<T extends SocialSecurityDetileCountArgs>(
      args?: Subset<T, SocialSecurityDetileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialSecurityDetileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialSecurityDetile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityDetileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialSecurityDetileAggregateArgs>(args: Subset<T, SocialSecurityDetileAggregateArgs>): Prisma.PrismaPromise<GetSocialSecurityDetileAggregateType<T>>

    /**
     * Group by SocialSecurityDetile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialSecurityDetileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialSecurityDetileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialSecurityDetileGroupByArgs['orderBy'] }
        : { orderBy?: SocialSecurityDetileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialSecurityDetileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialSecurityDetileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialSecurityDetile model
   */
  readonly fields: SocialSecurityDetileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialSecurityDetile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialSecurityDetileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SocialSecurity<T extends SocialSecurityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocialSecurityDefaultArgs<ExtArgs>>): Prisma__SocialSecurityClient<$Result.GetResult<Prisma.$SocialSecurityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialSecurityDetile model
   */ 
  interface SocialSecurityDetileFieldRefs {
    readonly SocialSecurityDetailID: FieldRef<"SocialSecurityDetile", 'Int'>
    readonly SocialSecurityID: FieldRef<"SocialSecurityDetile", 'Int'>
    readonly SocialYear: FieldRef<"SocialSecurityDetile", 'Int'>
    readonly SocialMonth: FieldRef<"SocialSecurityDetile", 'Int'>
    readonly Sector: FieldRef<"SocialSecurityDetile", 'Int'>
    readonly SocialSecurityCode: FieldRef<"SocialSecurityDetile", 'Int'>
    readonly AverageSalary: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly MinNationalInsByMony: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly MaxNationalInsByMony: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly MinDeductionNationalInsByMony: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly MinNationalInsByEmployee: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly MaxNationalInsByEmployee: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly MinNationalInsByEmployer: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly MaxNationalInsByEmployer: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly MaxNationalInsByMonyEmployee: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly AverageEmbodiment: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly DeductionMax: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly DeductionPercent: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly CreditPoint: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly FactorToReduction: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly MinHoursToPay: FieldRef<"SocialSecurityDetile", 'Int'>
    readonly MinimumPayFor5Day: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly MinimumPayFor6Day: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly MaxPrecentReduction: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly hourPerDayfor5: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly hourPerDayfor6: FieldRef<"SocialSecurityDetile", 'Int'>
    readonly hourInfridayDay: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly TaxPrecent: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly EmployerTax: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly DiscountInTaxInEilat: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly TaxUnitNumber: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly FundPercentConstruction: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly Hour100: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly Hour125: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly Hour150: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly Hour175: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly Hour200: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly CreditCardMan: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly CreditCardWoman: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly CreditCardChild: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly CreditCardBaby: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly CreditCardInAddition: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly CreditCardLackMobilityChild: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly CreditCardImmigrant18: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly ControlingShareholder: FieldRef<"SocialSecurityDetile", 'Boolean'>
    readonly HealthInsuranceEmployeeLow: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly HealthInsuranceEmployeeAbove: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly HealthInsuranceEmployerLow: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly HealthInsuranceEmployerAbove: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly ValueOfVehicleUseHibberdDiscount: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly Deposit: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly ValueOfMobileUse: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly PensionCeiling: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly PensionCredit: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly DepositEmployerPrecent: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly DepositEmployeePrecent: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly TotalHourPerWeek: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly CreditCardAdultChild: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly CreditCardChild1_5: FieldRef<"SocialSecurityDetile", 'Float'>
    readonly DepositEmployeePrecentExecption: FieldRef<"SocialSecurityDetile", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * SocialSecurityDetile findUnique
   */
  export type SocialSecurityDetileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurityDetile
     */
    select?: SocialSecurityDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityDetileInclude<ExtArgs> | null
    /**
     * Filter, which SocialSecurityDetile to fetch.
     */
    where: SocialSecurityDetileWhereUniqueInput
  }

  /**
   * SocialSecurityDetile findUniqueOrThrow
   */
  export type SocialSecurityDetileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurityDetile
     */
    select?: SocialSecurityDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityDetileInclude<ExtArgs> | null
    /**
     * Filter, which SocialSecurityDetile to fetch.
     */
    where: SocialSecurityDetileWhereUniqueInput
  }

  /**
   * SocialSecurityDetile findFirst
   */
  export type SocialSecurityDetileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurityDetile
     */
    select?: SocialSecurityDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityDetileInclude<ExtArgs> | null
    /**
     * Filter, which SocialSecurityDetile to fetch.
     */
    where?: SocialSecurityDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialSecurityDetiles to fetch.
     */
    orderBy?: SocialSecurityDetileOrderByWithRelationInput | SocialSecurityDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialSecurityDetiles.
     */
    cursor?: SocialSecurityDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialSecurityDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialSecurityDetiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialSecurityDetiles.
     */
    distinct?: SocialSecurityDetileScalarFieldEnum | SocialSecurityDetileScalarFieldEnum[]
  }

  /**
   * SocialSecurityDetile findFirstOrThrow
   */
  export type SocialSecurityDetileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurityDetile
     */
    select?: SocialSecurityDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityDetileInclude<ExtArgs> | null
    /**
     * Filter, which SocialSecurityDetile to fetch.
     */
    where?: SocialSecurityDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialSecurityDetiles to fetch.
     */
    orderBy?: SocialSecurityDetileOrderByWithRelationInput | SocialSecurityDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialSecurityDetiles.
     */
    cursor?: SocialSecurityDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialSecurityDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialSecurityDetiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialSecurityDetiles.
     */
    distinct?: SocialSecurityDetileScalarFieldEnum | SocialSecurityDetileScalarFieldEnum[]
  }

  /**
   * SocialSecurityDetile findMany
   */
  export type SocialSecurityDetileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurityDetile
     */
    select?: SocialSecurityDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityDetileInclude<ExtArgs> | null
    /**
     * Filter, which SocialSecurityDetiles to fetch.
     */
    where?: SocialSecurityDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialSecurityDetiles to fetch.
     */
    orderBy?: SocialSecurityDetileOrderByWithRelationInput | SocialSecurityDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialSecurityDetiles.
     */
    cursor?: SocialSecurityDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialSecurityDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialSecurityDetiles.
     */
    skip?: number
    distinct?: SocialSecurityDetileScalarFieldEnum | SocialSecurityDetileScalarFieldEnum[]
  }

  /**
   * SocialSecurityDetile create
   */
  export type SocialSecurityDetileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurityDetile
     */
    select?: SocialSecurityDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityDetileInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialSecurityDetile.
     */
    data: XOR<SocialSecurityDetileCreateInput, SocialSecurityDetileUncheckedCreateInput>
  }

  /**
   * SocialSecurityDetile createMany
   */
  export type SocialSecurityDetileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialSecurityDetiles.
     */
    data: SocialSecurityDetileCreateManyInput | SocialSecurityDetileCreateManyInput[]
  }

  /**
   * SocialSecurityDetile update
   */
  export type SocialSecurityDetileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurityDetile
     */
    select?: SocialSecurityDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityDetileInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialSecurityDetile.
     */
    data: XOR<SocialSecurityDetileUpdateInput, SocialSecurityDetileUncheckedUpdateInput>
    /**
     * Choose, which SocialSecurityDetile to update.
     */
    where: SocialSecurityDetileWhereUniqueInput
  }

  /**
   * SocialSecurityDetile updateMany
   */
  export type SocialSecurityDetileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialSecurityDetiles.
     */
    data: XOR<SocialSecurityDetileUpdateManyMutationInput, SocialSecurityDetileUncheckedUpdateManyInput>
    /**
     * Filter which SocialSecurityDetiles to update
     */
    where?: SocialSecurityDetileWhereInput
  }

  /**
   * SocialSecurityDetile upsert
   */
  export type SocialSecurityDetileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurityDetile
     */
    select?: SocialSecurityDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityDetileInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialSecurityDetile to update in case it exists.
     */
    where: SocialSecurityDetileWhereUniqueInput
    /**
     * In case the SocialSecurityDetile found by the `where` argument doesn't exist, create a new SocialSecurityDetile with this data.
     */
    create: XOR<SocialSecurityDetileCreateInput, SocialSecurityDetileUncheckedCreateInput>
    /**
     * In case the SocialSecurityDetile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialSecurityDetileUpdateInput, SocialSecurityDetileUncheckedUpdateInput>
  }

  /**
   * SocialSecurityDetile delete
   */
  export type SocialSecurityDetileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurityDetile
     */
    select?: SocialSecurityDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityDetileInclude<ExtArgs> | null
    /**
     * Filter which SocialSecurityDetile to delete.
     */
    where: SocialSecurityDetileWhereUniqueInput
  }

  /**
   * SocialSecurityDetile deleteMany
   */
  export type SocialSecurityDetileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialSecurityDetiles to delete
     */
    where?: SocialSecurityDetileWhereInput
  }

  /**
   * SocialSecurityDetile without action
   */
  export type SocialSecurityDetileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialSecurityDetile
     */
    select?: SocialSecurityDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialSecurityDetileInclude<ExtArgs> | null
  }


  /**
   * Model sysdiagrams
   */

  export type AggregateSysdiagrams = {
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  export type SysdiagramsAvgAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsSumAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsMinAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Uint8Array | null
  }

  export type SysdiagramsMaxAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Uint8Array | null
  }

  export type SysdiagramsCountAggregateOutputType = {
    name: number
    principal_id: number
    diagram_id: number
    version: number
    definition: number
    _all: number
  }


  export type SysdiagramsAvgAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsSumAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsMinAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsMaxAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsCountAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
    _all?: true
  }

  export type SysdiagramsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to aggregate.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sysdiagrams
    **/
    _count?: true | SysdiagramsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SysdiagramsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SysdiagramsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SysdiagramsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type GetSysdiagramsAggregateType<T extends SysdiagramsAggregateArgs> = {
        [P in keyof T & keyof AggregateSysdiagrams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSysdiagrams[P]>
      : GetScalarType<T[P], AggregateSysdiagrams[P]>
  }




  export type sysdiagramsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sysdiagramsWhereInput
    orderBy?: sysdiagramsOrderByWithAggregationInput | sysdiagramsOrderByWithAggregationInput[]
    by: SysdiagramsScalarFieldEnum[] | SysdiagramsScalarFieldEnum
    having?: sysdiagramsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SysdiagramsCountAggregateInputType | true
    _avg?: SysdiagramsAvgAggregateInputType
    _sum?: SysdiagramsSumAggregateInputType
    _min?: SysdiagramsMinAggregateInputType
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type SysdiagramsGroupByOutputType = {
    name: string
    principal_id: number
    diagram_id: number
    version: number | null
    definition: Uint8Array | null
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  type GetSysdiagramsGroupByPayload<T extends sysdiagramsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SysdiagramsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SysdiagramsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
            : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
        }
      >
    >


  export type sysdiagramsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }, ExtArgs["result"]["sysdiagrams"]>


  export type sysdiagramsSelectScalar = {
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }


  export type $sysdiagramsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sysdiagrams"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      name: string
      principal_id: number
      diagram_id: number
      version: number | null
      definition: Uint8Array | null
    }, ExtArgs["result"]["sysdiagrams"]>
    composites: {}
  }

  type sysdiagramsGetPayload<S extends boolean | null | undefined | sysdiagramsDefaultArgs> = $Result.GetResult<Prisma.$sysdiagramsPayload, S>

  type sysdiagramsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sysdiagramsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SysdiagramsCountAggregateInputType | true
    }

  export interface sysdiagramsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sysdiagrams'], meta: { name: 'sysdiagrams' } }
    /**
     * Find zero or one Sysdiagrams that matches the filter.
     * @param {sysdiagramsFindUniqueArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sysdiagramsFindUniqueArgs>(args: SelectSubset<T, sysdiagramsFindUniqueArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sysdiagrams that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {sysdiagramsFindUniqueOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sysdiagramsFindUniqueOrThrowArgs>(args: SelectSubset<T, sysdiagramsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sysdiagramsFindFirstArgs>(args?: SelectSubset<T, sysdiagramsFindFirstArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sysdiagrams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sysdiagramsFindFirstOrThrowArgs>(args?: SelectSubset<T, sysdiagramsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany()
     * 
     * // Get first 10 Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sysdiagramsWithNameOnly = await prisma.sysdiagrams.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends sysdiagramsFindManyArgs>(args?: SelectSubset<T, sysdiagramsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sysdiagrams.
     * @param {sysdiagramsCreateArgs} args - Arguments to create a Sysdiagrams.
     * @example
     * // Create one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.create({
     *   data: {
     *     // ... data to create a Sysdiagrams
     *   }
     * })
     * 
     */
    create<T extends sysdiagramsCreateArgs>(args: SelectSubset<T, sysdiagramsCreateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sysdiagrams.
     * @param {sysdiagramsCreateManyArgs} args - Arguments to create many Sysdiagrams.
     * @example
     * // Create many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sysdiagramsCreateManyArgs>(args?: SelectSubset<T, sysdiagramsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sysdiagrams.
     * @param {sysdiagramsDeleteArgs} args - Arguments to delete one Sysdiagrams.
     * @example
     * // Delete one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.delete({
     *   where: {
     *     // ... filter to delete one Sysdiagrams
     *   }
     * })
     * 
     */
    delete<T extends sysdiagramsDeleteArgs>(args: SelectSubset<T, sysdiagramsDeleteArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sysdiagrams.
     * @param {sysdiagramsUpdateArgs} args - Arguments to update one Sysdiagrams.
     * @example
     * // Update one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sysdiagramsUpdateArgs>(args: SelectSubset<T, sysdiagramsUpdateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sysdiagrams.
     * @param {sysdiagramsDeleteManyArgs} args - Arguments to filter Sysdiagrams to delete.
     * @example
     * // Delete a few Sysdiagrams
     * const { count } = await prisma.sysdiagrams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sysdiagramsDeleteManyArgs>(args?: SelectSubset<T, sysdiagramsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sysdiagramsUpdateManyArgs>(args: SelectSubset<T, sysdiagramsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sysdiagrams.
     * @param {sysdiagramsUpsertArgs} args - Arguments to update or create a Sysdiagrams.
     * @example
     * // Update or create a Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.upsert({
     *   create: {
     *     // ... data to create a Sysdiagrams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to update
     *   }
     * })
     */
    upsert<T extends sysdiagramsUpsertArgs>(args: SelectSubset<T, sysdiagramsUpsertArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsCountArgs} args - Arguments to filter Sysdiagrams to count.
     * @example
     * // Count the number of Sysdiagrams
     * const count = await prisma.sysdiagrams.count({
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to count
     *   }
     * })
    **/
    count<T extends sysdiagramsCountArgs>(
      args?: Subset<T, sysdiagramsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SysdiagramsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysdiagramsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SysdiagramsAggregateArgs>(args: Subset<T, SysdiagramsAggregateArgs>): Prisma.PrismaPromise<GetSysdiagramsAggregateType<T>>

    /**
     * Group by Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sysdiagramsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sysdiagramsGroupByArgs['orderBy'] }
        : { orderBy?: sysdiagramsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sysdiagramsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSysdiagramsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sysdiagrams model
   */
  readonly fields: sysdiagramsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sysdiagrams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sysdiagramsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sysdiagrams model
   */ 
  interface sysdiagramsFieldRefs {
    readonly name: FieldRef<"sysdiagrams", 'String'>
    readonly principal_id: FieldRef<"sysdiagrams", 'Int'>
    readonly diagram_id: FieldRef<"sysdiagrams", 'Int'>
    readonly version: FieldRef<"sysdiagrams", 'Int'>
    readonly definition: FieldRef<"sysdiagrams", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * sysdiagrams findUnique
   */
  export type sysdiagramsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findUniqueOrThrow
   */
  export type sysdiagramsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findFirst
   */
  export type sysdiagramsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findFirstOrThrow
   */
  export type sysdiagramsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findMany
   */
  export type sysdiagramsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams create
   */
  export type sysdiagramsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * The data needed to create a sysdiagrams.
     */
    data: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
  }

  /**
   * sysdiagrams createMany
   */
  export type sysdiagramsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sysdiagrams.
     */
    data: sysdiagramsCreateManyInput | sysdiagramsCreateManyInput[]
  }

  /**
   * sysdiagrams update
   */
  export type sysdiagramsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * The data needed to update a sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
    /**
     * Choose, which sysdiagrams to update.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams updateMany
   */
  export type sysdiagramsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateManyMutationInput, sysdiagramsUncheckedUpdateManyInput>
    /**
     * Filter which sysdiagrams to update
     */
    where?: sysdiagramsWhereInput
  }

  /**
   * sysdiagrams upsert
   */
  export type sysdiagramsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * The filter to search for the sysdiagrams to update in case it exists.
     */
    where: sysdiagramsWhereUniqueInput
    /**
     * In case the sysdiagrams found by the `where` argument doesn't exist, create a new sysdiagrams with this data.
     */
    create: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
    /**
     * In case the sysdiagrams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
  }

  /**
   * sysdiagrams delete
   */
  export type sysdiagramsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter which sysdiagrams to delete.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams deleteMany
   */
  export type sysdiagramsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to delete
     */
    where?: sysdiagramsWhereInput
  }

  /**
   * sysdiagrams without action
   */
  export type sysdiagramsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
  }


  /**
   * Model SystemDefinition
   */

  export type AggregateSystemDefinition = {
    _count: SystemDefinitionCountAggregateOutputType | null
    _min: SystemDefinitionMinAggregateOutputType | null
    _max: SystemDefinitionMaxAggregateOutputType | null
  }

  export type SystemDefinitionMinAggregateOutputType = {
    SystemDefinitionId: string | null
    CreatedAt: Date | null
    FieldDescription: string | null
    FieldValue: string | null
  }

  export type SystemDefinitionMaxAggregateOutputType = {
    SystemDefinitionId: string | null
    CreatedAt: Date | null
    FieldDescription: string | null
    FieldValue: string | null
  }

  export type SystemDefinitionCountAggregateOutputType = {
    SystemDefinitionId: number
    CreatedAt: number
    FieldDescription: number
    FieldValue: number
    _all: number
  }


  export type SystemDefinitionMinAggregateInputType = {
    SystemDefinitionId?: true
    CreatedAt?: true
    FieldDescription?: true
    FieldValue?: true
  }

  export type SystemDefinitionMaxAggregateInputType = {
    SystemDefinitionId?: true
    CreatedAt?: true
    FieldDescription?: true
    FieldValue?: true
  }

  export type SystemDefinitionCountAggregateInputType = {
    SystemDefinitionId?: true
    CreatedAt?: true
    FieldDescription?: true
    FieldValue?: true
    _all?: true
  }

  export type SystemDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemDefinition to aggregate.
     */
    where?: SystemDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemDefinitions to fetch.
     */
    orderBy?: SystemDefinitionOrderByWithRelationInput | SystemDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemDefinitions
    **/
    _count?: true | SystemDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemDefinitionMaxAggregateInputType
  }

  export type GetSystemDefinitionAggregateType<T extends SystemDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemDefinition[P]>
      : GetScalarType<T[P], AggregateSystemDefinition[P]>
  }




  export type SystemDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemDefinitionWhereInput
    orderBy?: SystemDefinitionOrderByWithAggregationInput | SystemDefinitionOrderByWithAggregationInput[]
    by: SystemDefinitionScalarFieldEnum[] | SystemDefinitionScalarFieldEnum
    having?: SystemDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemDefinitionCountAggregateInputType | true
    _min?: SystemDefinitionMinAggregateInputType
    _max?: SystemDefinitionMaxAggregateInputType
  }

  export type SystemDefinitionGroupByOutputType = {
    SystemDefinitionId: string
    CreatedAt: Date | null
    FieldDescription: string | null
    FieldValue: string | null
    _count: SystemDefinitionCountAggregateOutputType | null
    _min: SystemDefinitionMinAggregateOutputType | null
    _max: SystemDefinitionMaxAggregateOutputType | null
  }

  type GetSystemDefinitionGroupByPayload<T extends SystemDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], SystemDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type SystemDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SystemDefinitionId?: boolean
    CreatedAt?: boolean
    FieldDescription?: boolean
    FieldValue?: boolean
  }, ExtArgs["result"]["systemDefinition"]>


  export type SystemDefinitionSelectScalar = {
    SystemDefinitionId?: boolean
    CreatedAt?: boolean
    FieldDescription?: boolean
    FieldValue?: boolean
  }


  export type $SystemDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemDefinition"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SystemDefinitionId: string
      CreatedAt: Date | null
      FieldDescription: string | null
      FieldValue: string | null
    }, ExtArgs["result"]["systemDefinition"]>
    composites: {}
  }

  type SystemDefinitionGetPayload<S extends boolean | null | undefined | SystemDefinitionDefaultArgs> = $Result.GetResult<Prisma.$SystemDefinitionPayload, S>

  type SystemDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemDefinitionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemDefinitionCountAggregateInputType | true
    }

  export interface SystemDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemDefinition'], meta: { name: 'SystemDefinition' } }
    /**
     * Find zero or one SystemDefinition that matches the filter.
     * @param {SystemDefinitionFindUniqueArgs} args - Arguments to find a SystemDefinition
     * @example
     * // Get one SystemDefinition
     * const systemDefinition = await prisma.systemDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemDefinitionFindUniqueArgs>(args: SelectSubset<T, SystemDefinitionFindUniqueArgs<ExtArgs>>): Prisma__SystemDefinitionClient<$Result.GetResult<Prisma.$SystemDefinitionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemDefinition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemDefinitionFindUniqueOrThrowArgs} args - Arguments to find a SystemDefinition
     * @example
     * // Get one SystemDefinition
     * const systemDefinition = await prisma.systemDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemDefinitionClient<$Result.GetResult<Prisma.$SystemDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemDefinitionFindFirstArgs} args - Arguments to find a SystemDefinition
     * @example
     * // Get one SystemDefinition
     * const systemDefinition = await prisma.systemDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemDefinitionFindFirstArgs>(args?: SelectSubset<T, SystemDefinitionFindFirstArgs<ExtArgs>>): Prisma__SystemDefinitionClient<$Result.GetResult<Prisma.$SystemDefinitionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemDefinitionFindFirstOrThrowArgs} args - Arguments to find a SystemDefinition
     * @example
     * // Get one SystemDefinition
     * const systemDefinition = await prisma.systemDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemDefinitionClient<$Result.GetResult<Prisma.$SystemDefinitionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemDefinitions
     * const systemDefinitions = await prisma.systemDefinition.findMany()
     * 
     * // Get first 10 SystemDefinitions
     * const systemDefinitions = await prisma.systemDefinition.findMany({ take: 10 })
     * 
     * // Only select the `SystemDefinitionId`
     * const systemDefinitionWithSystemDefinitionIdOnly = await prisma.systemDefinition.findMany({ select: { SystemDefinitionId: true } })
     * 
     */
    findMany<T extends SystemDefinitionFindManyArgs>(args?: SelectSubset<T, SystemDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemDefinitionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemDefinition.
     * @param {SystemDefinitionCreateArgs} args - Arguments to create a SystemDefinition.
     * @example
     * // Create one SystemDefinition
     * const SystemDefinition = await prisma.systemDefinition.create({
     *   data: {
     *     // ... data to create a SystemDefinition
     *   }
     * })
     * 
     */
    create<T extends SystemDefinitionCreateArgs>(args: SelectSubset<T, SystemDefinitionCreateArgs<ExtArgs>>): Prisma__SystemDefinitionClient<$Result.GetResult<Prisma.$SystemDefinitionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemDefinitions.
     * @param {SystemDefinitionCreateManyArgs} args - Arguments to create many SystemDefinitions.
     * @example
     * // Create many SystemDefinitions
     * const systemDefinition = await prisma.systemDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemDefinitionCreateManyArgs>(args?: SelectSubset<T, SystemDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemDefinition.
     * @param {SystemDefinitionDeleteArgs} args - Arguments to delete one SystemDefinition.
     * @example
     * // Delete one SystemDefinition
     * const SystemDefinition = await prisma.systemDefinition.delete({
     *   where: {
     *     // ... filter to delete one SystemDefinition
     *   }
     * })
     * 
     */
    delete<T extends SystemDefinitionDeleteArgs>(args: SelectSubset<T, SystemDefinitionDeleteArgs<ExtArgs>>): Prisma__SystemDefinitionClient<$Result.GetResult<Prisma.$SystemDefinitionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemDefinition.
     * @param {SystemDefinitionUpdateArgs} args - Arguments to update one SystemDefinition.
     * @example
     * // Update one SystemDefinition
     * const systemDefinition = await prisma.systemDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemDefinitionUpdateArgs>(args: SelectSubset<T, SystemDefinitionUpdateArgs<ExtArgs>>): Prisma__SystemDefinitionClient<$Result.GetResult<Prisma.$SystemDefinitionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemDefinitions.
     * @param {SystemDefinitionDeleteManyArgs} args - Arguments to filter SystemDefinitions to delete.
     * @example
     * // Delete a few SystemDefinitions
     * const { count } = await prisma.systemDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemDefinitionDeleteManyArgs>(args?: SelectSubset<T, SystemDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemDefinitions
     * const systemDefinition = await prisma.systemDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemDefinitionUpdateManyArgs>(args: SelectSubset<T, SystemDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemDefinition.
     * @param {SystemDefinitionUpsertArgs} args - Arguments to update or create a SystemDefinition.
     * @example
     * // Update or create a SystemDefinition
     * const systemDefinition = await prisma.systemDefinition.upsert({
     *   create: {
     *     // ... data to create a SystemDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemDefinition we want to update
     *   }
     * })
     */
    upsert<T extends SystemDefinitionUpsertArgs>(args: SelectSubset<T, SystemDefinitionUpsertArgs<ExtArgs>>): Prisma__SystemDefinitionClient<$Result.GetResult<Prisma.$SystemDefinitionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemDefinitionCountArgs} args - Arguments to filter SystemDefinitions to count.
     * @example
     * // Count the number of SystemDefinitions
     * const count = await prisma.systemDefinition.count({
     *   where: {
     *     // ... the filter for the SystemDefinitions we want to count
     *   }
     * })
    **/
    count<T extends SystemDefinitionCountArgs>(
      args?: Subset<T, SystemDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemDefinitionAggregateArgs>(args: Subset<T, SystemDefinitionAggregateArgs>): Prisma.PrismaPromise<GetSystemDefinitionAggregateType<T>>

    /**
     * Group by SystemDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: SystemDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemDefinition model
   */
  readonly fields: SystemDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemDefinition model
   */ 
  interface SystemDefinitionFieldRefs {
    readonly SystemDefinitionId: FieldRef<"SystemDefinition", 'String'>
    readonly CreatedAt: FieldRef<"SystemDefinition", 'DateTime'>
    readonly FieldDescription: FieldRef<"SystemDefinition", 'String'>
    readonly FieldValue: FieldRef<"SystemDefinition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SystemDefinition findUnique
   */
  export type SystemDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemDefinition
     */
    select?: SystemDefinitionSelect<ExtArgs> | null
    /**
     * Filter, which SystemDefinition to fetch.
     */
    where: SystemDefinitionWhereUniqueInput
  }

  /**
   * SystemDefinition findUniqueOrThrow
   */
  export type SystemDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemDefinition
     */
    select?: SystemDefinitionSelect<ExtArgs> | null
    /**
     * Filter, which SystemDefinition to fetch.
     */
    where: SystemDefinitionWhereUniqueInput
  }

  /**
   * SystemDefinition findFirst
   */
  export type SystemDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemDefinition
     */
    select?: SystemDefinitionSelect<ExtArgs> | null
    /**
     * Filter, which SystemDefinition to fetch.
     */
    where?: SystemDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemDefinitions to fetch.
     */
    orderBy?: SystemDefinitionOrderByWithRelationInput | SystemDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemDefinitions.
     */
    cursor?: SystemDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemDefinitions.
     */
    distinct?: SystemDefinitionScalarFieldEnum | SystemDefinitionScalarFieldEnum[]
  }

  /**
   * SystemDefinition findFirstOrThrow
   */
  export type SystemDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemDefinition
     */
    select?: SystemDefinitionSelect<ExtArgs> | null
    /**
     * Filter, which SystemDefinition to fetch.
     */
    where?: SystemDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemDefinitions to fetch.
     */
    orderBy?: SystemDefinitionOrderByWithRelationInput | SystemDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemDefinitions.
     */
    cursor?: SystemDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemDefinitions.
     */
    distinct?: SystemDefinitionScalarFieldEnum | SystemDefinitionScalarFieldEnum[]
  }

  /**
   * SystemDefinition findMany
   */
  export type SystemDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemDefinition
     */
    select?: SystemDefinitionSelect<ExtArgs> | null
    /**
     * Filter, which SystemDefinitions to fetch.
     */
    where?: SystemDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemDefinitions to fetch.
     */
    orderBy?: SystemDefinitionOrderByWithRelationInput | SystemDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemDefinitions.
     */
    cursor?: SystemDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemDefinitions.
     */
    skip?: number
    distinct?: SystemDefinitionScalarFieldEnum | SystemDefinitionScalarFieldEnum[]
  }

  /**
   * SystemDefinition create
   */
  export type SystemDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemDefinition
     */
    select?: SystemDefinitionSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemDefinition.
     */
    data?: XOR<SystemDefinitionCreateInput, SystemDefinitionUncheckedCreateInput>
  }

  /**
   * SystemDefinition createMany
   */
  export type SystemDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemDefinitions.
     */
    data: SystemDefinitionCreateManyInput | SystemDefinitionCreateManyInput[]
  }

  /**
   * SystemDefinition update
   */
  export type SystemDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemDefinition
     */
    select?: SystemDefinitionSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemDefinition.
     */
    data: XOR<SystemDefinitionUpdateInput, SystemDefinitionUncheckedUpdateInput>
    /**
     * Choose, which SystemDefinition to update.
     */
    where: SystemDefinitionWhereUniqueInput
  }

  /**
   * SystemDefinition updateMany
   */
  export type SystemDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemDefinitions.
     */
    data: XOR<SystemDefinitionUpdateManyMutationInput, SystemDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which SystemDefinitions to update
     */
    where?: SystemDefinitionWhereInput
  }

  /**
   * SystemDefinition upsert
   */
  export type SystemDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemDefinition
     */
    select?: SystemDefinitionSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemDefinition to update in case it exists.
     */
    where: SystemDefinitionWhereUniqueInput
    /**
     * In case the SystemDefinition found by the `where` argument doesn't exist, create a new SystemDefinition with this data.
     */
    create: XOR<SystemDefinitionCreateInput, SystemDefinitionUncheckedCreateInput>
    /**
     * In case the SystemDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemDefinitionUpdateInput, SystemDefinitionUncheckedUpdateInput>
  }

  /**
   * SystemDefinition delete
   */
  export type SystemDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemDefinition
     */
    select?: SystemDefinitionSelect<ExtArgs> | null
    /**
     * Filter which SystemDefinition to delete.
     */
    where: SystemDefinitionWhereUniqueInput
  }

  /**
   * SystemDefinition deleteMany
   */
  export type SystemDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemDefinitions to delete
     */
    where?: SystemDefinitionWhereInput
  }

  /**
   * SystemDefinition without action
   */
  export type SystemDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemDefinition
     */
    select?: SystemDefinitionSelect<ExtArgs> | null
  }


  /**
   * Model SystemMaintenanc
   */

  export type AggregateSystemMaintenanc = {
    _count: SystemMaintenancCountAggregateOutputType | null
    _avg: SystemMaintenancAvgAggregateOutputType | null
    _sum: SystemMaintenancSumAggregateOutputType | null
    _min: SystemMaintenancMinAggregateOutputType | null
    _max: SystemMaintenancMaxAggregateOutputType | null
  }

  export type SystemMaintenancAvgAggregateOutputType = {
    SystemMaintenancID: number | null
    LogOutFrequency: number | null
  }

  export type SystemMaintenancSumAggregateOutputType = {
    SystemMaintenancID: number | null
    LogOutFrequency: number | null
  }

  export type SystemMaintenancMinAggregateOutputType = {
    SystemMaintenancID: number | null
    UserMsg: string | null
    LogOutFrequency: number | null
    SystemMaintenanc: boolean | null
  }

  export type SystemMaintenancMaxAggregateOutputType = {
    SystemMaintenancID: number | null
    UserMsg: string | null
    LogOutFrequency: number | null
    SystemMaintenanc: boolean | null
  }

  export type SystemMaintenancCountAggregateOutputType = {
    SystemMaintenancID: number
    UserMsg: number
    LogOutFrequency: number
    SystemMaintenanc: number
    _all: number
  }


  export type SystemMaintenancAvgAggregateInputType = {
    SystemMaintenancID?: true
    LogOutFrequency?: true
  }

  export type SystemMaintenancSumAggregateInputType = {
    SystemMaintenancID?: true
    LogOutFrequency?: true
  }

  export type SystemMaintenancMinAggregateInputType = {
    SystemMaintenancID?: true
    UserMsg?: true
    LogOutFrequency?: true
    SystemMaintenanc?: true
  }

  export type SystemMaintenancMaxAggregateInputType = {
    SystemMaintenancID?: true
    UserMsg?: true
    LogOutFrequency?: true
    SystemMaintenanc?: true
  }

  export type SystemMaintenancCountAggregateInputType = {
    SystemMaintenancID?: true
    UserMsg?: true
    LogOutFrequency?: true
    SystemMaintenanc?: true
    _all?: true
  }

  export type SystemMaintenancAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemMaintenanc to aggregate.
     */
    where?: SystemMaintenancWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMaintenancs to fetch.
     */
    orderBy?: SystemMaintenancOrderByWithRelationInput | SystemMaintenancOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemMaintenancWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMaintenancs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMaintenancs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemMaintenancs
    **/
    _count?: true | SystemMaintenancCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemMaintenancAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemMaintenancSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemMaintenancMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemMaintenancMaxAggregateInputType
  }

  export type GetSystemMaintenancAggregateType<T extends SystemMaintenancAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemMaintenanc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemMaintenanc[P]>
      : GetScalarType<T[P], AggregateSystemMaintenanc[P]>
  }




  export type SystemMaintenancGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemMaintenancWhereInput
    orderBy?: SystemMaintenancOrderByWithAggregationInput | SystemMaintenancOrderByWithAggregationInput[]
    by: SystemMaintenancScalarFieldEnum[] | SystemMaintenancScalarFieldEnum
    having?: SystemMaintenancScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemMaintenancCountAggregateInputType | true
    _avg?: SystemMaintenancAvgAggregateInputType
    _sum?: SystemMaintenancSumAggregateInputType
    _min?: SystemMaintenancMinAggregateInputType
    _max?: SystemMaintenancMaxAggregateInputType
  }

  export type SystemMaintenancGroupByOutputType = {
    SystemMaintenancID: number
    UserMsg: string
    LogOutFrequency: number
    SystemMaintenanc: boolean
    _count: SystemMaintenancCountAggregateOutputType | null
    _avg: SystemMaintenancAvgAggregateOutputType | null
    _sum: SystemMaintenancSumAggregateOutputType | null
    _min: SystemMaintenancMinAggregateOutputType | null
    _max: SystemMaintenancMaxAggregateOutputType | null
  }

  type GetSystemMaintenancGroupByPayload<T extends SystemMaintenancGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemMaintenancGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemMaintenancGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemMaintenancGroupByOutputType[P]>
            : GetScalarType<T[P], SystemMaintenancGroupByOutputType[P]>
        }
      >
    >


  export type SystemMaintenancSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SystemMaintenancID?: boolean
    UserMsg?: boolean
    LogOutFrequency?: boolean
    SystemMaintenanc?: boolean
  }, ExtArgs["result"]["systemMaintenanc"]>


  export type SystemMaintenancSelectScalar = {
    SystemMaintenancID?: boolean
    UserMsg?: boolean
    LogOutFrequency?: boolean
    SystemMaintenanc?: boolean
  }


  export type $SystemMaintenancPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemMaintenanc"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SystemMaintenancID: number
      UserMsg: string
      LogOutFrequency: number
      SystemMaintenanc: boolean
    }, ExtArgs["result"]["systemMaintenanc"]>
    composites: {}
  }

  type SystemMaintenancGetPayload<S extends boolean | null | undefined | SystemMaintenancDefaultArgs> = $Result.GetResult<Prisma.$SystemMaintenancPayload, S>

  type SystemMaintenancCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemMaintenancFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemMaintenancCountAggregateInputType | true
    }

  export interface SystemMaintenancDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemMaintenanc'], meta: { name: 'SystemMaintenanc' } }
    /**
     * Find zero or one SystemMaintenanc that matches the filter.
     * @param {SystemMaintenancFindUniqueArgs} args - Arguments to find a SystemMaintenanc
     * @example
     * // Get one SystemMaintenanc
     * const systemMaintenanc = await prisma.systemMaintenanc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemMaintenancFindUniqueArgs>(args: SelectSubset<T, SystemMaintenancFindUniqueArgs<ExtArgs>>): Prisma__SystemMaintenancClient<$Result.GetResult<Prisma.$SystemMaintenancPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemMaintenanc that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemMaintenancFindUniqueOrThrowArgs} args - Arguments to find a SystemMaintenanc
     * @example
     * // Get one SystemMaintenanc
     * const systemMaintenanc = await prisma.systemMaintenanc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemMaintenancFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemMaintenancFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemMaintenancClient<$Result.GetResult<Prisma.$SystemMaintenancPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemMaintenanc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMaintenancFindFirstArgs} args - Arguments to find a SystemMaintenanc
     * @example
     * // Get one SystemMaintenanc
     * const systemMaintenanc = await prisma.systemMaintenanc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemMaintenancFindFirstArgs>(args?: SelectSubset<T, SystemMaintenancFindFirstArgs<ExtArgs>>): Prisma__SystemMaintenancClient<$Result.GetResult<Prisma.$SystemMaintenancPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemMaintenanc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMaintenancFindFirstOrThrowArgs} args - Arguments to find a SystemMaintenanc
     * @example
     * // Get one SystemMaintenanc
     * const systemMaintenanc = await prisma.systemMaintenanc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemMaintenancFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemMaintenancFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemMaintenancClient<$Result.GetResult<Prisma.$SystemMaintenancPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemMaintenancs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMaintenancFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemMaintenancs
     * const systemMaintenancs = await prisma.systemMaintenanc.findMany()
     * 
     * // Get first 10 SystemMaintenancs
     * const systemMaintenancs = await prisma.systemMaintenanc.findMany({ take: 10 })
     * 
     * // Only select the `SystemMaintenancID`
     * const systemMaintenancWithSystemMaintenancIDOnly = await prisma.systemMaintenanc.findMany({ select: { SystemMaintenancID: true } })
     * 
     */
    findMany<T extends SystemMaintenancFindManyArgs>(args?: SelectSubset<T, SystemMaintenancFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemMaintenancPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemMaintenanc.
     * @param {SystemMaintenancCreateArgs} args - Arguments to create a SystemMaintenanc.
     * @example
     * // Create one SystemMaintenanc
     * const SystemMaintenanc = await prisma.systemMaintenanc.create({
     *   data: {
     *     // ... data to create a SystemMaintenanc
     *   }
     * })
     * 
     */
    create<T extends SystemMaintenancCreateArgs>(args: SelectSubset<T, SystemMaintenancCreateArgs<ExtArgs>>): Prisma__SystemMaintenancClient<$Result.GetResult<Prisma.$SystemMaintenancPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemMaintenancs.
     * @param {SystemMaintenancCreateManyArgs} args - Arguments to create many SystemMaintenancs.
     * @example
     * // Create many SystemMaintenancs
     * const systemMaintenanc = await prisma.systemMaintenanc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemMaintenancCreateManyArgs>(args?: SelectSubset<T, SystemMaintenancCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemMaintenanc.
     * @param {SystemMaintenancDeleteArgs} args - Arguments to delete one SystemMaintenanc.
     * @example
     * // Delete one SystemMaintenanc
     * const SystemMaintenanc = await prisma.systemMaintenanc.delete({
     *   where: {
     *     // ... filter to delete one SystemMaintenanc
     *   }
     * })
     * 
     */
    delete<T extends SystemMaintenancDeleteArgs>(args: SelectSubset<T, SystemMaintenancDeleteArgs<ExtArgs>>): Prisma__SystemMaintenancClient<$Result.GetResult<Prisma.$SystemMaintenancPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemMaintenanc.
     * @param {SystemMaintenancUpdateArgs} args - Arguments to update one SystemMaintenanc.
     * @example
     * // Update one SystemMaintenanc
     * const systemMaintenanc = await prisma.systemMaintenanc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemMaintenancUpdateArgs>(args: SelectSubset<T, SystemMaintenancUpdateArgs<ExtArgs>>): Prisma__SystemMaintenancClient<$Result.GetResult<Prisma.$SystemMaintenancPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemMaintenancs.
     * @param {SystemMaintenancDeleteManyArgs} args - Arguments to filter SystemMaintenancs to delete.
     * @example
     * // Delete a few SystemMaintenancs
     * const { count } = await prisma.systemMaintenanc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemMaintenancDeleteManyArgs>(args?: SelectSubset<T, SystemMaintenancDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemMaintenancs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMaintenancUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemMaintenancs
     * const systemMaintenanc = await prisma.systemMaintenanc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemMaintenancUpdateManyArgs>(args: SelectSubset<T, SystemMaintenancUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemMaintenanc.
     * @param {SystemMaintenancUpsertArgs} args - Arguments to update or create a SystemMaintenanc.
     * @example
     * // Update or create a SystemMaintenanc
     * const systemMaintenanc = await prisma.systemMaintenanc.upsert({
     *   create: {
     *     // ... data to create a SystemMaintenanc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemMaintenanc we want to update
     *   }
     * })
     */
    upsert<T extends SystemMaintenancUpsertArgs>(args: SelectSubset<T, SystemMaintenancUpsertArgs<ExtArgs>>): Prisma__SystemMaintenancClient<$Result.GetResult<Prisma.$SystemMaintenancPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemMaintenancs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMaintenancCountArgs} args - Arguments to filter SystemMaintenancs to count.
     * @example
     * // Count the number of SystemMaintenancs
     * const count = await prisma.systemMaintenanc.count({
     *   where: {
     *     // ... the filter for the SystemMaintenancs we want to count
     *   }
     * })
    **/
    count<T extends SystemMaintenancCountArgs>(
      args?: Subset<T, SystemMaintenancCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemMaintenancCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemMaintenanc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMaintenancAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemMaintenancAggregateArgs>(args: Subset<T, SystemMaintenancAggregateArgs>): Prisma.PrismaPromise<GetSystemMaintenancAggregateType<T>>

    /**
     * Group by SystemMaintenanc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMaintenancGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemMaintenancGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemMaintenancGroupByArgs['orderBy'] }
        : { orderBy?: SystemMaintenancGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemMaintenancGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemMaintenancGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemMaintenanc model
   */
  readonly fields: SystemMaintenancFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemMaintenanc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemMaintenancClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemMaintenanc model
   */ 
  interface SystemMaintenancFieldRefs {
    readonly SystemMaintenancID: FieldRef<"SystemMaintenanc", 'Int'>
    readonly UserMsg: FieldRef<"SystemMaintenanc", 'String'>
    readonly LogOutFrequency: FieldRef<"SystemMaintenanc", 'Int'>
    readonly SystemMaintenanc: FieldRef<"SystemMaintenanc", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SystemMaintenanc findUnique
   */
  export type SystemMaintenancFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMaintenanc
     */
    select?: SystemMaintenancSelect<ExtArgs> | null
    /**
     * Filter, which SystemMaintenanc to fetch.
     */
    where: SystemMaintenancWhereUniqueInput
  }

  /**
   * SystemMaintenanc findUniqueOrThrow
   */
  export type SystemMaintenancFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMaintenanc
     */
    select?: SystemMaintenancSelect<ExtArgs> | null
    /**
     * Filter, which SystemMaintenanc to fetch.
     */
    where: SystemMaintenancWhereUniqueInput
  }

  /**
   * SystemMaintenanc findFirst
   */
  export type SystemMaintenancFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMaintenanc
     */
    select?: SystemMaintenancSelect<ExtArgs> | null
    /**
     * Filter, which SystemMaintenanc to fetch.
     */
    where?: SystemMaintenancWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMaintenancs to fetch.
     */
    orderBy?: SystemMaintenancOrderByWithRelationInput | SystemMaintenancOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemMaintenancs.
     */
    cursor?: SystemMaintenancWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMaintenancs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMaintenancs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemMaintenancs.
     */
    distinct?: SystemMaintenancScalarFieldEnum | SystemMaintenancScalarFieldEnum[]
  }

  /**
   * SystemMaintenanc findFirstOrThrow
   */
  export type SystemMaintenancFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMaintenanc
     */
    select?: SystemMaintenancSelect<ExtArgs> | null
    /**
     * Filter, which SystemMaintenanc to fetch.
     */
    where?: SystemMaintenancWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMaintenancs to fetch.
     */
    orderBy?: SystemMaintenancOrderByWithRelationInput | SystemMaintenancOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemMaintenancs.
     */
    cursor?: SystemMaintenancWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMaintenancs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMaintenancs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemMaintenancs.
     */
    distinct?: SystemMaintenancScalarFieldEnum | SystemMaintenancScalarFieldEnum[]
  }

  /**
   * SystemMaintenanc findMany
   */
  export type SystemMaintenancFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMaintenanc
     */
    select?: SystemMaintenancSelect<ExtArgs> | null
    /**
     * Filter, which SystemMaintenancs to fetch.
     */
    where?: SystemMaintenancWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMaintenancs to fetch.
     */
    orderBy?: SystemMaintenancOrderByWithRelationInput | SystemMaintenancOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemMaintenancs.
     */
    cursor?: SystemMaintenancWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMaintenancs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMaintenancs.
     */
    skip?: number
    distinct?: SystemMaintenancScalarFieldEnum | SystemMaintenancScalarFieldEnum[]
  }

  /**
   * SystemMaintenanc create
   */
  export type SystemMaintenancCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMaintenanc
     */
    select?: SystemMaintenancSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemMaintenanc.
     */
    data: XOR<SystemMaintenancCreateInput, SystemMaintenancUncheckedCreateInput>
  }

  /**
   * SystemMaintenanc createMany
   */
  export type SystemMaintenancCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemMaintenancs.
     */
    data: SystemMaintenancCreateManyInput | SystemMaintenancCreateManyInput[]
  }

  /**
   * SystemMaintenanc update
   */
  export type SystemMaintenancUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMaintenanc
     */
    select?: SystemMaintenancSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemMaintenanc.
     */
    data: XOR<SystemMaintenancUpdateInput, SystemMaintenancUncheckedUpdateInput>
    /**
     * Choose, which SystemMaintenanc to update.
     */
    where: SystemMaintenancWhereUniqueInput
  }

  /**
   * SystemMaintenanc updateMany
   */
  export type SystemMaintenancUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemMaintenancs.
     */
    data: XOR<SystemMaintenancUpdateManyMutationInput, SystemMaintenancUncheckedUpdateManyInput>
    /**
     * Filter which SystemMaintenancs to update
     */
    where?: SystemMaintenancWhereInput
  }

  /**
   * SystemMaintenanc upsert
   */
  export type SystemMaintenancUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMaintenanc
     */
    select?: SystemMaintenancSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemMaintenanc to update in case it exists.
     */
    where: SystemMaintenancWhereUniqueInput
    /**
     * In case the SystemMaintenanc found by the `where` argument doesn't exist, create a new SystemMaintenanc with this data.
     */
    create: XOR<SystemMaintenancCreateInput, SystemMaintenancUncheckedCreateInput>
    /**
     * In case the SystemMaintenanc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemMaintenancUpdateInput, SystemMaintenancUncheckedUpdateInput>
  }

  /**
   * SystemMaintenanc delete
   */
  export type SystemMaintenancDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMaintenanc
     */
    select?: SystemMaintenancSelect<ExtArgs> | null
    /**
     * Filter which SystemMaintenanc to delete.
     */
    where: SystemMaintenancWhereUniqueInput
  }

  /**
   * SystemMaintenanc deleteMany
   */
  export type SystemMaintenancDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemMaintenancs to delete
     */
    where?: SystemMaintenancWhereInput
  }

  /**
   * SystemMaintenanc without action
   */
  export type SystemMaintenancDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMaintenanc
     */
    select?: SystemMaintenancSelect<ExtArgs> | null
  }


  /**
   * Model TaxStepDetile
   */

  export type AggregateTaxStepDetile = {
    _count: TaxStepDetileCountAggregateOutputType | null
    _avg: TaxStepDetileAvgAggregateOutputType | null
    _sum: TaxStepDetileSumAggregateOutputType | null
    _min: TaxStepDetileMinAggregateOutputType | null
    _max: TaxStepDetileMaxAggregateOutputType | null
  }

  export type TaxStepDetileAvgAggregateOutputType = {
    TaxStepDetileID: number | null
    TaxStapID: number | null
    TaxYear: number | null
    TaxMonth: number | null
    StepNumber: number | null
    TaxStap: number | null
    TaxStapPercent: number | null
  }

  export type TaxStepDetileSumAggregateOutputType = {
    TaxStepDetileID: number | null
    TaxStapID: number | null
    TaxYear: number | null
    TaxMonth: number | null
    StepNumber: number | null
    TaxStap: number | null
    TaxStapPercent: number | null
  }

  export type TaxStepDetileMinAggregateOutputType = {
    TaxStepDetileID: number | null
    TaxStapID: number | null
    TaxYear: number | null
    TaxMonth: number | null
    StepNumber: number | null
    TaxStap: number | null
    TaxStapPercent: number | null
  }

  export type TaxStepDetileMaxAggregateOutputType = {
    TaxStepDetileID: number | null
    TaxStapID: number | null
    TaxYear: number | null
    TaxMonth: number | null
    StepNumber: number | null
    TaxStap: number | null
    TaxStapPercent: number | null
  }

  export type TaxStepDetileCountAggregateOutputType = {
    TaxStepDetileID: number
    TaxStapID: number
    TaxYear: number
    TaxMonth: number
    StepNumber: number
    TaxStap: number
    TaxStapPercent: number
    _all: number
  }


  export type TaxStepDetileAvgAggregateInputType = {
    TaxStepDetileID?: true
    TaxStapID?: true
    TaxYear?: true
    TaxMonth?: true
    StepNumber?: true
    TaxStap?: true
    TaxStapPercent?: true
  }

  export type TaxStepDetileSumAggregateInputType = {
    TaxStepDetileID?: true
    TaxStapID?: true
    TaxYear?: true
    TaxMonth?: true
    StepNumber?: true
    TaxStap?: true
    TaxStapPercent?: true
  }

  export type TaxStepDetileMinAggregateInputType = {
    TaxStepDetileID?: true
    TaxStapID?: true
    TaxYear?: true
    TaxMonth?: true
    StepNumber?: true
    TaxStap?: true
    TaxStapPercent?: true
  }

  export type TaxStepDetileMaxAggregateInputType = {
    TaxStepDetileID?: true
    TaxStapID?: true
    TaxYear?: true
    TaxMonth?: true
    StepNumber?: true
    TaxStap?: true
    TaxStapPercent?: true
  }

  export type TaxStepDetileCountAggregateInputType = {
    TaxStepDetileID?: true
    TaxStapID?: true
    TaxYear?: true
    TaxMonth?: true
    StepNumber?: true
    TaxStap?: true
    TaxStapPercent?: true
    _all?: true
  }

  export type TaxStepDetileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxStepDetile to aggregate.
     */
    where?: TaxStepDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxStepDetiles to fetch.
     */
    orderBy?: TaxStepDetileOrderByWithRelationInput | TaxStepDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxStepDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxStepDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxStepDetiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxStepDetiles
    **/
    _count?: true | TaxStepDetileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxStepDetileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxStepDetileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxStepDetileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxStepDetileMaxAggregateInputType
  }

  export type GetTaxStepDetileAggregateType<T extends TaxStepDetileAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxStepDetile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxStepDetile[P]>
      : GetScalarType<T[P], AggregateTaxStepDetile[P]>
  }




  export type TaxStepDetileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxStepDetileWhereInput
    orderBy?: TaxStepDetileOrderByWithAggregationInput | TaxStepDetileOrderByWithAggregationInput[]
    by: TaxStepDetileScalarFieldEnum[] | TaxStepDetileScalarFieldEnum
    having?: TaxStepDetileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxStepDetileCountAggregateInputType | true
    _avg?: TaxStepDetileAvgAggregateInputType
    _sum?: TaxStepDetileSumAggregateInputType
    _min?: TaxStepDetileMinAggregateInputType
    _max?: TaxStepDetileMaxAggregateInputType
  }

  export type TaxStepDetileGroupByOutputType = {
    TaxStepDetileID: number
    TaxStapID: number
    TaxYear: number
    TaxMonth: number
    StepNumber: number | null
    TaxStap: number | null
    TaxStapPercent: number | null
    _count: TaxStepDetileCountAggregateOutputType | null
    _avg: TaxStepDetileAvgAggregateOutputType | null
    _sum: TaxStepDetileSumAggregateOutputType | null
    _min: TaxStepDetileMinAggregateOutputType | null
    _max: TaxStepDetileMaxAggregateOutputType | null
  }

  type GetTaxStepDetileGroupByPayload<T extends TaxStepDetileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxStepDetileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxStepDetileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxStepDetileGroupByOutputType[P]>
            : GetScalarType<T[P], TaxStepDetileGroupByOutputType[P]>
        }
      >
    >


  export type TaxStepDetileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TaxStepDetileID?: boolean
    TaxStapID?: boolean
    TaxYear?: boolean
    TaxMonth?: boolean
    StepNumber?: boolean
    TaxStap?: boolean
    TaxStapPercent?: boolean
    TaxSteps?: boolean | TaxStepsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxStepDetile"]>


  export type TaxStepDetileSelectScalar = {
    TaxStepDetileID?: boolean
    TaxStapID?: boolean
    TaxYear?: boolean
    TaxMonth?: boolean
    StepNumber?: boolean
    TaxStap?: boolean
    TaxStapPercent?: boolean
  }

  export type TaxStepDetileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TaxSteps?: boolean | TaxStepsDefaultArgs<ExtArgs>
  }

  export type $TaxStepDetilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxStepDetile"
    objects: {
      TaxSteps: Prisma.$TaxStepsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      TaxStepDetileID: number
      TaxStapID: number
      TaxYear: number
      TaxMonth: number
      StepNumber: number | null
      TaxStap: number | null
      TaxStapPercent: number | null
    }, ExtArgs["result"]["taxStepDetile"]>
    composites: {}
  }

  type TaxStepDetileGetPayload<S extends boolean | null | undefined | TaxStepDetileDefaultArgs> = $Result.GetResult<Prisma.$TaxStepDetilePayload, S>

  type TaxStepDetileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaxStepDetileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaxStepDetileCountAggregateInputType | true
    }

  export interface TaxStepDetileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxStepDetile'], meta: { name: 'TaxStepDetile' } }
    /**
     * Find zero or one TaxStepDetile that matches the filter.
     * @param {TaxStepDetileFindUniqueArgs} args - Arguments to find a TaxStepDetile
     * @example
     * // Get one TaxStepDetile
     * const taxStepDetile = await prisma.taxStepDetile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxStepDetileFindUniqueArgs>(args: SelectSubset<T, TaxStepDetileFindUniqueArgs<ExtArgs>>): Prisma__TaxStepDetileClient<$Result.GetResult<Prisma.$TaxStepDetilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaxStepDetile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaxStepDetileFindUniqueOrThrowArgs} args - Arguments to find a TaxStepDetile
     * @example
     * // Get one TaxStepDetile
     * const taxStepDetile = await prisma.taxStepDetile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxStepDetileFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxStepDetileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxStepDetileClient<$Result.GetResult<Prisma.$TaxStepDetilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaxStepDetile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepDetileFindFirstArgs} args - Arguments to find a TaxStepDetile
     * @example
     * // Get one TaxStepDetile
     * const taxStepDetile = await prisma.taxStepDetile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxStepDetileFindFirstArgs>(args?: SelectSubset<T, TaxStepDetileFindFirstArgs<ExtArgs>>): Prisma__TaxStepDetileClient<$Result.GetResult<Prisma.$TaxStepDetilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaxStepDetile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepDetileFindFirstOrThrowArgs} args - Arguments to find a TaxStepDetile
     * @example
     * // Get one TaxStepDetile
     * const taxStepDetile = await prisma.taxStepDetile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxStepDetileFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxStepDetileFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxStepDetileClient<$Result.GetResult<Prisma.$TaxStepDetilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaxStepDetiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepDetileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxStepDetiles
     * const taxStepDetiles = await prisma.taxStepDetile.findMany()
     * 
     * // Get first 10 TaxStepDetiles
     * const taxStepDetiles = await prisma.taxStepDetile.findMany({ take: 10 })
     * 
     * // Only select the `TaxStepDetileID`
     * const taxStepDetileWithTaxStepDetileIDOnly = await prisma.taxStepDetile.findMany({ select: { TaxStepDetileID: true } })
     * 
     */
    findMany<T extends TaxStepDetileFindManyArgs>(args?: SelectSubset<T, TaxStepDetileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxStepDetilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaxStepDetile.
     * @param {TaxStepDetileCreateArgs} args - Arguments to create a TaxStepDetile.
     * @example
     * // Create one TaxStepDetile
     * const TaxStepDetile = await prisma.taxStepDetile.create({
     *   data: {
     *     // ... data to create a TaxStepDetile
     *   }
     * })
     * 
     */
    create<T extends TaxStepDetileCreateArgs>(args: SelectSubset<T, TaxStepDetileCreateArgs<ExtArgs>>): Prisma__TaxStepDetileClient<$Result.GetResult<Prisma.$TaxStepDetilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaxStepDetiles.
     * @param {TaxStepDetileCreateManyArgs} args - Arguments to create many TaxStepDetiles.
     * @example
     * // Create many TaxStepDetiles
     * const taxStepDetile = await prisma.taxStepDetile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxStepDetileCreateManyArgs>(args?: SelectSubset<T, TaxStepDetileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaxStepDetile.
     * @param {TaxStepDetileDeleteArgs} args - Arguments to delete one TaxStepDetile.
     * @example
     * // Delete one TaxStepDetile
     * const TaxStepDetile = await prisma.taxStepDetile.delete({
     *   where: {
     *     // ... filter to delete one TaxStepDetile
     *   }
     * })
     * 
     */
    delete<T extends TaxStepDetileDeleteArgs>(args: SelectSubset<T, TaxStepDetileDeleteArgs<ExtArgs>>): Prisma__TaxStepDetileClient<$Result.GetResult<Prisma.$TaxStepDetilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaxStepDetile.
     * @param {TaxStepDetileUpdateArgs} args - Arguments to update one TaxStepDetile.
     * @example
     * // Update one TaxStepDetile
     * const taxStepDetile = await prisma.taxStepDetile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxStepDetileUpdateArgs>(args: SelectSubset<T, TaxStepDetileUpdateArgs<ExtArgs>>): Prisma__TaxStepDetileClient<$Result.GetResult<Prisma.$TaxStepDetilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaxStepDetiles.
     * @param {TaxStepDetileDeleteManyArgs} args - Arguments to filter TaxStepDetiles to delete.
     * @example
     * // Delete a few TaxStepDetiles
     * const { count } = await prisma.taxStepDetile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxStepDetileDeleteManyArgs>(args?: SelectSubset<T, TaxStepDetileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxStepDetiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepDetileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxStepDetiles
     * const taxStepDetile = await prisma.taxStepDetile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxStepDetileUpdateManyArgs>(args: SelectSubset<T, TaxStepDetileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaxStepDetile.
     * @param {TaxStepDetileUpsertArgs} args - Arguments to update or create a TaxStepDetile.
     * @example
     * // Update or create a TaxStepDetile
     * const taxStepDetile = await prisma.taxStepDetile.upsert({
     *   create: {
     *     // ... data to create a TaxStepDetile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxStepDetile we want to update
     *   }
     * })
     */
    upsert<T extends TaxStepDetileUpsertArgs>(args: SelectSubset<T, TaxStepDetileUpsertArgs<ExtArgs>>): Prisma__TaxStepDetileClient<$Result.GetResult<Prisma.$TaxStepDetilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaxStepDetiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepDetileCountArgs} args - Arguments to filter TaxStepDetiles to count.
     * @example
     * // Count the number of TaxStepDetiles
     * const count = await prisma.taxStepDetile.count({
     *   where: {
     *     // ... the filter for the TaxStepDetiles we want to count
     *   }
     * })
    **/
    count<T extends TaxStepDetileCountArgs>(
      args?: Subset<T, TaxStepDetileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxStepDetileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxStepDetile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepDetileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxStepDetileAggregateArgs>(args: Subset<T, TaxStepDetileAggregateArgs>): Prisma.PrismaPromise<GetTaxStepDetileAggregateType<T>>

    /**
     * Group by TaxStepDetile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepDetileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxStepDetileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxStepDetileGroupByArgs['orderBy'] }
        : { orderBy?: TaxStepDetileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxStepDetileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxStepDetileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxStepDetile model
   */
  readonly fields: TaxStepDetileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxStepDetile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxStepDetileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TaxSteps<T extends TaxStepsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaxStepsDefaultArgs<ExtArgs>>): Prisma__TaxStepsClient<$Result.GetResult<Prisma.$TaxStepsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxStepDetile model
   */ 
  interface TaxStepDetileFieldRefs {
    readonly TaxStepDetileID: FieldRef<"TaxStepDetile", 'Int'>
    readonly TaxStapID: FieldRef<"TaxStepDetile", 'Int'>
    readonly TaxYear: FieldRef<"TaxStepDetile", 'Int'>
    readonly TaxMonth: FieldRef<"TaxStepDetile", 'Int'>
    readonly StepNumber: FieldRef<"TaxStepDetile", 'Int'>
    readonly TaxStap: FieldRef<"TaxStepDetile", 'Int'>
    readonly TaxStapPercent: FieldRef<"TaxStepDetile", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * TaxStepDetile findUnique
   */
  export type TaxStepDetileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxStepDetile
     */
    select?: TaxStepDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepDetileInclude<ExtArgs> | null
    /**
     * Filter, which TaxStepDetile to fetch.
     */
    where: TaxStepDetileWhereUniqueInput
  }

  /**
   * TaxStepDetile findUniqueOrThrow
   */
  export type TaxStepDetileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxStepDetile
     */
    select?: TaxStepDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepDetileInclude<ExtArgs> | null
    /**
     * Filter, which TaxStepDetile to fetch.
     */
    where: TaxStepDetileWhereUniqueInput
  }

  /**
   * TaxStepDetile findFirst
   */
  export type TaxStepDetileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxStepDetile
     */
    select?: TaxStepDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepDetileInclude<ExtArgs> | null
    /**
     * Filter, which TaxStepDetile to fetch.
     */
    where?: TaxStepDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxStepDetiles to fetch.
     */
    orderBy?: TaxStepDetileOrderByWithRelationInput | TaxStepDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxStepDetiles.
     */
    cursor?: TaxStepDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxStepDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxStepDetiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxStepDetiles.
     */
    distinct?: TaxStepDetileScalarFieldEnum | TaxStepDetileScalarFieldEnum[]
  }

  /**
   * TaxStepDetile findFirstOrThrow
   */
  export type TaxStepDetileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxStepDetile
     */
    select?: TaxStepDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepDetileInclude<ExtArgs> | null
    /**
     * Filter, which TaxStepDetile to fetch.
     */
    where?: TaxStepDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxStepDetiles to fetch.
     */
    orderBy?: TaxStepDetileOrderByWithRelationInput | TaxStepDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxStepDetiles.
     */
    cursor?: TaxStepDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxStepDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxStepDetiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxStepDetiles.
     */
    distinct?: TaxStepDetileScalarFieldEnum | TaxStepDetileScalarFieldEnum[]
  }

  /**
   * TaxStepDetile findMany
   */
  export type TaxStepDetileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxStepDetile
     */
    select?: TaxStepDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepDetileInclude<ExtArgs> | null
    /**
     * Filter, which TaxStepDetiles to fetch.
     */
    where?: TaxStepDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxStepDetiles to fetch.
     */
    orderBy?: TaxStepDetileOrderByWithRelationInput | TaxStepDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxStepDetiles.
     */
    cursor?: TaxStepDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxStepDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxStepDetiles.
     */
    skip?: number
    distinct?: TaxStepDetileScalarFieldEnum | TaxStepDetileScalarFieldEnum[]
  }

  /**
   * TaxStepDetile create
   */
  export type TaxStepDetileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxStepDetile
     */
    select?: TaxStepDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepDetileInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxStepDetile.
     */
    data: XOR<TaxStepDetileCreateInput, TaxStepDetileUncheckedCreateInput>
  }

  /**
   * TaxStepDetile createMany
   */
  export type TaxStepDetileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxStepDetiles.
     */
    data: TaxStepDetileCreateManyInput | TaxStepDetileCreateManyInput[]
  }

  /**
   * TaxStepDetile update
   */
  export type TaxStepDetileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxStepDetile
     */
    select?: TaxStepDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepDetileInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxStepDetile.
     */
    data: XOR<TaxStepDetileUpdateInput, TaxStepDetileUncheckedUpdateInput>
    /**
     * Choose, which TaxStepDetile to update.
     */
    where: TaxStepDetileWhereUniqueInput
  }

  /**
   * TaxStepDetile updateMany
   */
  export type TaxStepDetileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxStepDetiles.
     */
    data: XOR<TaxStepDetileUpdateManyMutationInput, TaxStepDetileUncheckedUpdateManyInput>
    /**
     * Filter which TaxStepDetiles to update
     */
    where?: TaxStepDetileWhereInput
  }

  /**
   * TaxStepDetile upsert
   */
  export type TaxStepDetileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxStepDetile
     */
    select?: TaxStepDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepDetileInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxStepDetile to update in case it exists.
     */
    where: TaxStepDetileWhereUniqueInput
    /**
     * In case the TaxStepDetile found by the `where` argument doesn't exist, create a new TaxStepDetile with this data.
     */
    create: XOR<TaxStepDetileCreateInput, TaxStepDetileUncheckedCreateInput>
    /**
     * In case the TaxStepDetile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxStepDetileUpdateInput, TaxStepDetileUncheckedUpdateInput>
  }

  /**
   * TaxStepDetile delete
   */
  export type TaxStepDetileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxStepDetile
     */
    select?: TaxStepDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepDetileInclude<ExtArgs> | null
    /**
     * Filter which TaxStepDetile to delete.
     */
    where: TaxStepDetileWhereUniqueInput
  }

  /**
   * TaxStepDetile deleteMany
   */
  export type TaxStepDetileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxStepDetiles to delete
     */
    where?: TaxStepDetileWhereInput
  }

  /**
   * TaxStepDetile without action
   */
  export type TaxStepDetileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxStepDetile
     */
    select?: TaxStepDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepDetileInclude<ExtArgs> | null
  }


  /**
   * Model TaxSteps
   */

  export type AggregateTaxSteps = {
    _count: TaxStepsCountAggregateOutputType | null
    _avg: TaxStepsAvgAggregateOutputType | null
    _sum: TaxStepsSumAggregateOutputType | null
    _min: TaxStepsMinAggregateOutputType | null
    _max: TaxStepsMaxAggregateOutputType | null
  }

  export type TaxStepsAvgAggregateOutputType = {
    TaxStapID: number | null
    TaxMonth: number | null
    TaxYear: number | null
  }

  export type TaxStepsSumAggregateOutputType = {
    TaxStapID: number | null
    TaxMonth: number | null
    TaxYear: number | null
  }

  export type TaxStepsMinAggregateOutputType = {
    TaxStapID: number | null
    TaxMonth: number | null
    TaxYear: number | null
    CurrentTaxStep: boolean | null
  }

  export type TaxStepsMaxAggregateOutputType = {
    TaxStapID: number | null
    TaxMonth: number | null
    TaxYear: number | null
    CurrentTaxStep: boolean | null
  }

  export type TaxStepsCountAggregateOutputType = {
    TaxStapID: number
    TaxMonth: number
    TaxYear: number
    CurrentTaxStep: number
    _all: number
  }


  export type TaxStepsAvgAggregateInputType = {
    TaxStapID?: true
    TaxMonth?: true
    TaxYear?: true
  }

  export type TaxStepsSumAggregateInputType = {
    TaxStapID?: true
    TaxMonth?: true
    TaxYear?: true
  }

  export type TaxStepsMinAggregateInputType = {
    TaxStapID?: true
    TaxMonth?: true
    TaxYear?: true
    CurrentTaxStep?: true
  }

  export type TaxStepsMaxAggregateInputType = {
    TaxStapID?: true
    TaxMonth?: true
    TaxYear?: true
    CurrentTaxStep?: true
  }

  export type TaxStepsCountAggregateInputType = {
    TaxStapID?: true
    TaxMonth?: true
    TaxYear?: true
    CurrentTaxStep?: true
    _all?: true
  }

  export type TaxStepsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxSteps to aggregate.
     */
    where?: TaxStepsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSteps to fetch.
     */
    orderBy?: TaxStepsOrderByWithRelationInput | TaxStepsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxStepsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxSteps
    **/
    _count?: true | TaxStepsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxStepsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxStepsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxStepsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxStepsMaxAggregateInputType
  }

  export type GetTaxStepsAggregateType<T extends TaxStepsAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxSteps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxSteps[P]>
      : GetScalarType<T[P], AggregateTaxSteps[P]>
  }




  export type TaxStepsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxStepsWhereInput
    orderBy?: TaxStepsOrderByWithAggregationInput | TaxStepsOrderByWithAggregationInput[]
    by: TaxStepsScalarFieldEnum[] | TaxStepsScalarFieldEnum
    having?: TaxStepsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxStepsCountAggregateInputType | true
    _avg?: TaxStepsAvgAggregateInputType
    _sum?: TaxStepsSumAggregateInputType
    _min?: TaxStepsMinAggregateInputType
    _max?: TaxStepsMaxAggregateInputType
  }

  export type TaxStepsGroupByOutputType = {
    TaxStapID: number
    TaxMonth: number
    TaxYear: number
    CurrentTaxStep: boolean
    _count: TaxStepsCountAggregateOutputType | null
    _avg: TaxStepsAvgAggregateOutputType | null
    _sum: TaxStepsSumAggregateOutputType | null
    _min: TaxStepsMinAggregateOutputType | null
    _max: TaxStepsMaxAggregateOutputType | null
  }

  type GetTaxStepsGroupByPayload<T extends TaxStepsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxStepsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxStepsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxStepsGroupByOutputType[P]>
            : GetScalarType<T[P], TaxStepsGroupByOutputType[P]>
        }
      >
    >


  export type TaxStepsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TaxStapID?: boolean
    TaxMonth?: boolean
    TaxYear?: boolean
    CurrentTaxStep?: boolean
    TaxStepDetile?: boolean | TaxSteps$TaxStepDetileArgs<ExtArgs>
    _count?: boolean | TaxStepsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxSteps"]>


  export type TaxStepsSelectScalar = {
    TaxStapID?: boolean
    TaxMonth?: boolean
    TaxYear?: boolean
    CurrentTaxStep?: boolean
  }

  export type TaxStepsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TaxStepDetile?: boolean | TaxSteps$TaxStepDetileArgs<ExtArgs>
    _count?: boolean | TaxStepsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TaxStepsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxSteps"
    objects: {
      TaxStepDetile: Prisma.$TaxStepDetilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      TaxStapID: number
      TaxMonth: number
      TaxYear: number
      CurrentTaxStep: boolean
    }, ExtArgs["result"]["taxSteps"]>
    composites: {}
  }

  type TaxStepsGetPayload<S extends boolean | null | undefined | TaxStepsDefaultArgs> = $Result.GetResult<Prisma.$TaxStepsPayload, S>

  type TaxStepsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaxStepsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaxStepsCountAggregateInputType | true
    }

  export interface TaxStepsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxSteps'], meta: { name: 'TaxSteps' } }
    /**
     * Find zero or one TaxSteps that matches the filter.
     * @param {TaxStepsFindUniqueArgs} args - Arguments to find a TaxSteps
     * @example
     * // Get one TaxSteps
     * const taxSteps = await prisma.taxSteps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxStepsFindUniqueArgs>(args: SelectSubset<T, TaxStepsFindUniqueArgs<ExtArgs>>): Prisma__TaxStepsClient<$Result.GetResult<Prisma.$TaxStepsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaxSteps that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaxStepsFindUniqueOrThrowArgs} args - Arguments to find a TaxSteps
     * @example
     * // Get one TaxSteps
     * const taxSteps = await prisma.taxSteps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxStepsFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxStepsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxStepsClient<$Result.GetResult<Prisma.$TaxStepsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaxSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepsFindFirstArgs} args - Arguments to find a TaxSteps
     * @example
     * // Get one TaxSteps
     * const taxSteps = await prisma.taxSteps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxStepsFindFirstArgs>(args?: SelectSubset<T, TaxStepsFindFirstArgs<ExtArgs>>): Prisma__TaxStepsClient<$Result.GetResult<Prisma.$TaxStepsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaxSteps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepsFindFirstOrThrowArgs} args - Arguments to find a TaxSteps
     * @example
     * // Get one TaxSteps
     * const taxSteps = await prisma.taxSteps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxStepsFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxStepsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxStepsClient<$Result.GetResult<Prisma.$TaxStepsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaxSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxSteps
     * const taxSteps = await prisma.taxSteps.findMany()
     * 
     * // Get first 10 TaxSteps
     * const taxSteps = await prisma.taxSteps.findMany({ take: 10 })
     * 
     * // Only select the `TaxStapID`
     * const taxStepsWithTaxStapIDOnly = await prisma.taxSteps.findMany({ select: { TaxStapID: true } })
     * 
     */
    findMany<T extends TaxStepsFindManyArgs>(args?: SelectSubset<T, TaxStepsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxStepsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaxSteps.
     * @param {TaxStepsCreateArgs} args - Arguments to create a TaxSteps.
     * @example
     * // Create one TaxSteps
     * const TaxSteps = await prisma.taxSteps.create({
     *   data: {
     *     // ... data to create a TaxSteps
     *   }
     * })
     * 
     */
    create<T extends TaxStepsCreateArgs>(args: SelectSubset<T, TaxStepsCreateArgs<ExtArgs>>): Prisma__TaxStepsClient<$Result.GetResult<Prisma.$TaxStepsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaxSteps.
     * @param {TaxStepsCreateManyArgs} args - Arguments to create many TaxSteps.
     * @example
     * // Create many TaxSteps
     * const taxSteps = await prisma.taxSteps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxStepsCreateManyArgs>(args?: SelectSubset<T, TaxStepsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaxSteps.
     * @param {TaxStepsDeleteArgs} args - Arguments to delete one TaxSteps.
     * @example
     * // Delete one TaxSteps
     * const TaxSteps = await prisma.taxSteps.delete({
     *   where: {
     *     // ... filter to delete one TaxSteps
     *   }
     * })
     * 
     */
    delete<T extends TaxStepsDeleteArgs>(args: SelectSubset<T, TaxStepsDeleteArgs<ExtArgs>>): Prisma__TaxStepsClient<$Result.GetResult<Prisma.$TaxStepsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaxSteps.
     * @param {TaxStepsUpdateArgs} args - Arguments to update one TaxSteps.
     * @example
     * // Update one TaxSteps
     * const taxSteps = await prisma.taxSteps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxStepsUpdateArgs>(args: SelectSubset<T, TaxStepsUpdateArgs<ExtArgs>>): Prisma__TaxStepsClient<$Result.GetResult<Prisma.$TaxStepsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaxSteps.
     * @param {TaxStepsDeleteManyArgs} args - Arguments to filter TaxSteps to delete.
     * @example
     * // Delete a few TaxSteps
     * const { count } = await prisma.taxSteps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxStepsDeleteManyArgs>(args?: SelectSubset<T, TaxStepsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxSteps
     * const taxSteps = await prisma.taxSteps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxStepsUpdateManyArgs>(args: SelectSubset<T, TaxStepsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaxSteps.
     * @param {TaxStepsUpsertArgs} args - Arguments to update or create a TaxSteps.
     * @example
     * // Update or create a TaxSteps
     * const taxSteps = await prisma.taxSteps.upsert({
     *   create: {
     *     // ... data to create a TaxSteps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxSteps we want to update
     *   }
     * })
     */
    upsert<T extends TaxStepsUpsertArgs>(args: SelectSubset<T, TaxStepsUpsertArgs<ExtArgs>>): Prisma__TaxStepsClient<$Result.GetResult<Prisma.$TaxStepsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaxSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepsCountArgs} args - Arguments to filter TaxSteps to count.
     * @example
     * // Count the number of TaxSteps
     * const count = await prisma.taxSteps.count({
     *   where: {
     *     // ... the filter for the TaxSteps we want to count
     *   }
     * })
    **/
    count<T extends TaxStepsCountArgs>(
      args?: Subset<T, TaxStepsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxStepsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxStepsAggregateArgs>(args: Subset<T, TaxStepsAggregateArgs>): Prisma.PrismaPromise<GetTaxStepsAggregateType<T>>

    /**
     * Group by TaxSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxStepsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxStepsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxStepsGroupByArgs['orderBy'] }
        : { orderBy?: TaxStepsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxStepsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxStepsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxSteps model
   */
  readonly fields: TaxStepsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxSteps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxStepsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TaxStepDetile<T extends TaxSteps$TaxStepDetileArgs<ExtArgs> = {}>(args?: Subset<T, TaxSteps$TaxStepDetileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxStepDetilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxSteps model
   */ 
  interface TaxStepsFieldRefs {
    readonly TaxStapID: FieldRef<"TaxSteps", 'Int'>
    readonly TaxMonth: FieldRef<"TaxSteps", 'Int'>
    readonly TaxYear: FieldRef<"TaxSteps", 'Int'>
    readonly CurrentTaxStep: FieldRef<"TaxSteps", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TaxSteps findUnique
   */
  export type TaxStepsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSteps
     */
    select?: TaxStepsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepsInclude<ExtArgs> | null
    /**
     * Filter, which TaxSteps to fetch.
     */
    where: TaxStepsWhereUniqueInput
  }

  /**
   * TaxSteps findUniqueOrThrow
   */
  export type TaxStepsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSteps
     */
    select?: TaxStepsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepsInclude<ExtArgs> | null
    /**
     * Filter, which TaxSteps to fetch.
     */
    where: TaxStepsWhereUniqueInput
  }

  /**
   * TaxSteps findFirst
   */
  export type TaxStepsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSteps
     */
    select?: TaxStepsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepsInclude<ExtArgs> | null
    /**
     * Filter, which TaxSteps to fetch.
     */
    where?: TaxStepsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSteps to fetch.
     */
    orderBy?: TaxStepsOrderByWithRelationInput | TaxStepsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxSteps.
     */
    cursor?: TaxStepsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxSteps.
     */
    distinct?: TaxStepsScalarFieldEnum | TaxStepsScalarFieldEnum[]
  }

  /**
   * TaxSteps findFirstOrThrow
   */
  export type TaxStepsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSteps
     */
    select?: TaxStepsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepsInclude<ExtArgs> | null
    /**
     * Filter, which TaxSteps to fetch.
     */
    where?: TaxStepsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSteps to fetch.
     */
    orderBy?: TaxStepsOrderByWithRelationInput | TaxStepsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxSteps.
     */
    cursor?: TaxStepsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxSteps.
     */
    distinct?: TaxStepsScalarFieldEnum | TaxStepsScalarFieldEnum[]
  }

  /**
   * TaxSteps findMany
   */
  export type TaxStepsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSteps
     */
    select?: TaxStepsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepsInclude<ExtArgs> | null
    /**
     * Filter, which TaxSteps to fetch.
     */
    where?: TaxStepsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSteps to fetch.
     */
    orderBy?: TaxStepsOrderByWithRelationInput | TaxStepsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxSteps.
     */
    cursor?: TaxStepsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSteps.
     */
    skip?: number
    distinct?: TaxStepsScalarFieldEnum | TaxStepsScalarFieldEnum[]
  }

  /**
   * TaxSteps create
   */
  export type TaxStepsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSteps
     */
    select?: TaxStepsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepsInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxSteps.
     */
    data: XOR<TaxStepsCreateInput, TaxStepsUncheckedCreateInput>
  }

  /**
   * TaxSteps createMany
   */
  export type TaxStepsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxSteps.
     */
    data: TaxStepsCreateManyInput | TaxStepsCreateManyInput[]
  }

  /**
   * TaxSteps update
   */
  export type TaxStepsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSteps
     */
    select?: TaxStepsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepsInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxSteps.
     */
    data: XOR<TaxStepsUpdateInput, TaxStepsUncheckedUpdateInput>
    /**
     * Choose, which TaxSteps to update.
     */
    where: TaxStepsWhereUniqueInput
  }

  /**
   * TaxSteps updateMany
   */
  export type TaxStepsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxSteps.
     */
    data: XOR<TaxStepsUpdateManyMutationInput, TaxStepsUncheckedUpdateManyInput>
    /**
     * Filter which TaxSteps to update
     */
    where?: TaxStepsWhereInput
  }

  /**
   * TaxSteps upsert
   */
  export type TaxStepsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSteps
     */
    select?: TaxStepsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepsInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxSteps to update in case it exists.
     */
    where: TaxStepsWhereUniqueInput
    /**
     * In case the TaxSteps found by the `where` argument doesn't exist, create a new TaxSteps with this data.
     */
    create: XOR<TaxStepsCreateInput, TaxStepsUncheckedCreateInput>
    /**
     * In case the TaxSteps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxStepsUpdateInput, TaxStepsUncheckedUpdateInput>
  }

  /**
   * TaxSteps delete
   */
  export type TaxStepsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSteps
     */
    select?: TaxStepsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepsInclude<ExtArgs> | null
    /**
     * Filter which TaxSteps to delete.
     */
    where: TaxStepsWhereUniqueInput
  }

  /**
   * TaxSteps deleteMany
   */
  export type TaxStepsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxSteps to delete
     */
    where?: TaxStepsWhereInput
  }

  /**
   * TaxSteps.TaxStepDetile
   */
  export type TaxSteps$TaxStepDetileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxStepDetile
     */
    select?: TaxStepDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepDetileInclude<ExtArgs> | null
    where?: TaxStepDetileWhereInput
    orderBy?: TaxStepDetileOrderByWithRelationInput | TaxStepDetileOrderByWithRelationInput[]
    cursor?: TaxStepDetileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxStepDetileScalarFieldEnum | TaxStepDetileScalarFieldEnum[]
  }

  /**
   * TaxSteps without action
   */
  export type TaxStepsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSteps
     */
    select?: TaxStepsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxStepsInclude<ExtArgs> | null
  }


  /**
   * Model UnionFee
   */

  export type AggregateUnionFee = {
    _count: UnionFeeCountAggregateOutputType | null
    _avg: UnionFeeAvgAggregateOutputType | null
    _sum: UnionFeeSumAggregateOutputType | null
    _min: UnionFeeMinAggregateOutputType | null
    _max: UnionFeeMaxAggregateOutputType | null
  }

  export type UnionFeeAvgAggregateOutputType = {
    ID: number | null
    UnionCode: number | null
  }

  export type UnionFeeSumAggregateOutputType = {
    ID: number | null
    UnionCode: number | null
  }

  export type UnionFeeMinAggregateOutputType = {
    ID: number | null
    UnionCode: number | null
    UnionName: string | null
  }

  export type UnionFeeMaxAggregateOutputType = {
    ID: number | null
    UnionCode: number | null
    UnionName: string | null
  }

  export type UnionFeeCountAggregateOutputType = {
    ID: number
    UnionCode: number
    UnionName: number
    _all: number
  }


  export type UnionFeeAvgAggregateInputType = {
    ID?: true
    UnionCode?: true
  }

  export type UnionFeeSumAggregateInputType = {
    ID?: true
    UnionCode?: true
  }

  export type UnionFeeMinAggregateInputType = {
    ID?: true
    UnionCode?: true
    UnionName?: true
  }

  export type UnionFeeMaxAggregateInputType = {
    ID?: true
    UnionCode?: true
    UnionName?: true
  }

  export type UnionFeeCountAggregateInputType = {
    ID?: true
    UnionCode?: true
    UnionName?: true
    _all?: true
  }

  export type UnionFeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnionFee to aggregate.
     */
    where?: UnionFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnionFees to fetch.
     */
    orderBy?: UnionFeeOrderByWithRelationInput | UnionFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnionFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnionFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnionFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnionFees
    **/
    _count?: true | UnionFeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnionFeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnionFeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnionFeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnionFeeMaxAggregateInputType
  }

  export type GetUnionFeeAggregateType<T extends UnionFeeAggregateArgs> = {
        [P in keyof T & keyof AggregateUnionFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnionFee[P]>
      : GetScalarType<T[P], AggregateUnionFee[P]>
  }




  export type UnionFeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnionFeeWhereInput
    orderBy?: UnionFeeOrderByWithAggregationInput | UnionFeeOrderByWithAggregationInput[]
    by: UnionFeeScalarFieldEnum[] | UnionFeeScalarFieldEnum
    having?: UnionFeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnionFeeCountAggregateInputType | true
    _avg?: UnionFeeAvgAggregateInputType
    _sum?: UnionFeeSumAggregateInputType
    _min?: UnionFeeMinAggregateInputType
    _max?: UnionFeeMaxAggregateInputType
  }

  export type UnionFeeGroupByOutputType = {
    ID: number
    UnionCode: number
    UnionName: string
    _count: UnionFeeCountAggregateOutputType | null
    _avg: UnionFeeAvgAggregateOutputType | null
    _sum: UnionFeeSumAggregateOutputType | null
    _min: UnionFeeMinAggregateOutputType | null
    _max: UnionFeeMaxAggregateOutputType | null
  }

  type GetUnionFeeGroupByPayload<T extends UnionFeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnionFeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnionFeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnionFeeGroupByOutputType[P]>
            : GetScalarType<T[P], UnionFeeGroupByOutputType[P]>
        }
      >
    >


  export type UnionFeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    UnionCode?: boolean
    UnionName?: boolean
    UnionFeeDetile?: boolean | UnionFee$UnionFeeDetileArgs<ExtArgs>
    _count?: boolean | UnionFeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unionFee"]>


  export type UnionFeeSelectScalar = {
    ID?: boolean
    UnionCode?: boolean
    UnionName?: boolean
  }

  export type UnionFeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UnionFeeDetile?: boolean | UnionFee$UnionFeeDetileArgs<ExtArgs>
    _count?: boolean | UnionFeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UnionFeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnionFee"
    objects: {
      UnionFeeDetile: Prisma.$UnionFeeDetilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      UnionCode: number
      UnionName: string
    }, ExtArgs["result"]["unionFee"]>
    composites: {}
  }

  type UnionFeeGetPayload<S extends boolean | null | undefined | UnionFeeDefaultArgs> = $Result.GetResult<Prisma.$UnionFeePayload, S>

  type UnionFeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnionFeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnionFeeCountAggregateInputType | true
    }

  export interface UnionFeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnionFee'], meta: { name: 'UnionFee' } }
    /**
     * Find zero or one UnionFee that matches the filter.
     * @param {UnionFeeFindUniqueArgs} args - Arguments to find a UnionFee
     * @example
     * // Get one UnionFee
     * const unionFee = await prisma.unionFee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnionFeeFindUniqueArgs>(args: SelectSubset<T, UnionFeeFindUniqueArgs<ExtArgs>>): Prisma__UnionFeeClient<$Result.GetResult<Prisma.$UnionFeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UnionFee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnionFeeFindUniqueOrThrowArgs} args - Arguments to find a UnionFee
     * @example
     * // Get one UnionFee
     * const unionFee = await prisma.unionFee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnionFeeFindUniqueOrThrowArgs>(args: SelectSubset<T, UnionFeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnionFeeClient<$Result.GetResult<Prisma.$UnionFeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UnionFee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeFindFirstArgs} args - Arguments to find a UnionFee
     * @example
     * // Get one UnionFee
     * const unionFee = await prisma.unionFee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnionFeeFindFirstArgs>(args?: SelectSubset<T, UnionFeeFindFirstArgs<ExtArgs>>): Prisma__UnionFeeClient<$Result.GetResult<Prisma.$UnionFeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UnionFee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeFindFirstOrThrowArgs} args - Arguments to find a UnionFee
     * @example
     * // Get one UnionFee
     * const unionFee = await prisma.unionFee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnionFeeFindFirstOrThrowArgs>(args?: SelectSubset<T, UnionFeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnionFeeClient<$Result.GetResult<Prisma.$UnionFeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UnionFees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnionFees
     * const unionFees = await prisma.unionFee.findMany()
     * 
     * // Get first 10 UnionFees
     * const unionFees = await prisma.unionFee.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const unionFeeWithIDOnly = await prisma.unionFee.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends UnionFeeFindManyArgs>(args?: SelectSubset<T, UnionFeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnionFeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UnionFee.
     * @param {UnionFeeCreateArgs} args - Arguments to create a UnionFee.
     * @example
     * // Create one UnionFee
     * const UnionFee = await prisma.unionFee.create({
     *   data: {
     *     // ... data to create a UnionFee
     *   }
     * })
     * 
     */
    create<T extends UnionFeeCreateArgs>(args: SelectSubset<T, UnionFeeCreateArgs<ExtArgs>>): Prisma__UnionFeeClient<$Result.GetResult<Prisma.$UnionFeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UnionFees.
     * @param {UnionFeeCreateManyArgs} args - Arguments to create many UnionFees.
     * @example
     * // Create many UnionFees
     * const unionFee = await prisma.unionFee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnionFeeCreateManyArgs>(args?: SelectSubset<T, UnionFeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UnionFee.
     * @param {UnionFeeDeleteArgs} args - Arguments to delete one UnionFee.
     * @example
     * // Delete one UnionFee
     * const UnionFee = await prisma.unionFee.delete({
     *   where: {
     *     // ... filter to delete one UnionFee
     *   }
     * })
     * 
     */
    delete<T extends UnionFeeDeleteArgs>(args: SelectSubset<T, UnionFeeDeleteArgs<ExtArgs>>): Prisma__UnionFeeClient<$Result.GetResult<Prisma.$UnionFeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UnionFee.
     * @param {UnionFeeUpdateArgs} args - Arguments to update one UnionFee.
     * @example
     * // Update one UnionFee
     * const unionFee = await prisma.unionFee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnionFeeUpdateArgs>(args: SelectSubset<T, UnionFeeUpdateArgs<ExtArgs>>): Prisma__UnionFeeClient<$Result.GetResult<Prisma.$UnionFeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UnionFees.
     * @param {UnionFeeDeleteManyArgs} args - Arguments to filter UnionFees to delete.
     * @example
     * // Delete a few UnionFees
     * const { count } = await prisma.unionFee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnionFeeDeleteManyArgs>(args?: SelectSubset<T, UnionFeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnionFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnionFees
     * const unionFee = await prisma.unionFee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnionFeeUpdateManyArgs>(args: SelectSubset<T, UnionFeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnionFee.
     * @param {UnionFeeUpsertArgs} args - Arguments to update or create a UnionFee.
     * @example
     * // Update or create a UnionFee
     * const unionFee = await prisma.unionFee.upsert({
     *   create: {
     *     // ... data to create a UnionFee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnionFee we want to update
     *   }
     * })
     */
    upsert<T extends UnionFeeUpsertArgs>(args: SelectSubset<T, UnionFeeUpsertArgs<ExtArgs>>): Prisma__UnionFeeClient<$Result.GetResult<Prisma.$UnionFeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UnionFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeCountArgs} args - Arguments to filter UnionFees to count.
     * @example
     * // Count the number of UnionFees
     * const count = await prisma.unionFee.count({
     *   where: {
     *     // ... the filter for the UnionFees we want to count
     *   }
     * })
    **/
    count<T extends UnionFeeCountArgs>(
      args?: Subset<T, UnionFeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnionFeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnionFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnionFeeAggregateArgs>(args: Subset<T, UnionFeeAggregateArgs>): Prisma.PrismaPromise<GetUnionFeeAggregateType<T>>

    /**
     * Group by UnionFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnionFeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnionFeeGroupByArgs['orderBy'] }
        : { orderBy?: UnionFeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnionFeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnionFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnionFee model
   */
  readonly fields: UnionFeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnionFee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnionFeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UnionFeeDetile<T extends UnionFee$UnionFeeDetileArgs<ExtArgs> = {}>(args?: Subset<T, UnionFee$UnionFeeDetileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnionFeeDetilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnionFee model
   */ 
  interface UnionFeeFieldRefs {
    readonly ID: FieldRef<"UnionFee", 'Int'>
    readonly UnionCode: FieldRef<"UnionFee", 'Int'>
    readonly UnionName: FieldRef<"UnionFee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UnionFee findUnique
   */
  export type UnionFeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFee
     */
    select?: UnionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeInclude<ExtArgs> | null
    /**
     * Filter, which UnionFee to fetch.
     */
    where: UnionFeeWhereUniqueInput
  }

  /**
   * UnionFee findUniqueOrThrow
   */
  export type UnionFeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFee
     */
    select?: UnionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeInclude<ExtArgs> | null
    /**
     * Filter, which UnionFee to fetch.
     */
    where: UnionFeeWhereUniqueInput
  }

  /**
   * UnionFee findFirst
   */
  export type UnionFeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFee
     */
    select?: UnionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeInclude<ExtArgs> | null
    /**
     * Filter, which UnionFee to fetch.
     */
    where?: UnionFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnionFees to fetch.
     */
    orderBy?: UnionFeeOrderByWithRelationInput | UnionFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnionFees.
     */
    cursor?: UnionFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnionFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnionFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnionFees.
     */
    distinct?: UnionFeeScalarFieldEnum | UnionFeeScalarFieldEnum[]
  }

  /**
   * UnionFee findFirstOrThrow
   */
  export type UnionFeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFee
     */
    select?: UnionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeInclude<ExtArgs> | null
    /**
     * Filter, which UnionFee to fetch.
     */
    where?: UnionFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnionFees to fetch.
     */
    orderBy?: UnionFeeOrderByWithRelationInput | UnionFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnionFees.
     */
    cursor?: UnionFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnionFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnionFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnionFees.
     */
    distinct?: UnionFeeScalarFieldEnum | UnionFeeScalarFieldEnum[]
  }

  /**
   * UnionFee findMany
   */
  export type UnionFeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFee
     */
    select?: UnionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeInclude<ExtArgs> | null
    /**
     * Filter, which UnionFees to fetch.
     */
    where?: UnionFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnionFees to fetch.
     */
    orderBy?: UnionFeeOrderByWithRelationInput | UnionFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnionFees.
     */
    cursor?: UnionFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnionFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnionFees.
     */
    skip?: number
    distinct?: UnionFeeScalarFieldEnum | UnionFeeScalarFieldEnum[]
  }

  /**
   * UnionFee create
   */
  export type UnionFeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFee
     */
    select?: UnionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeInclude<ExtArgs> | null
    /**
     * The data needed to create a UnionFee.
     */
    data: XOR<UnionFeeCreateInput, UnionFeeUncheckedCreateInput>
  }

  /**
   * UnionFee createMany
   */
  export type UnionFeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnionFees.
     */
    data: UnionFeeCreateManyInput | UnionFeeCreateManyInput[]
  }

  /**
   * UnionFee update
   */
  export type UnionFeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFee
     */
    select?: UnionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeInclude<ExtArgs> | null
    /**
     * The data needed to update a UnionFee.
     */
    data: XOR<UnionFeeUpdateInput, UnionFeeUncheckedUpdateInput>
    /**
     * Choose, which UnionFee to update.
     */
    where: UnionFeeWhereUniqueInput
  }

  /**
   * UnionFee updateMany
   */
  export type UnionFeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnionFees.
     */
    data: XOR<UnionFeeUpdateManyMutationInput, UnionFeeUncheckedUpdateManyInput>
    /**
     * Filter which UnionFees to update
     */
    where?: UnionFeeWhereInput
  }

  /**
   * UnionFee upsert
   */
  export type UnionFeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFee
     */
    select?: UnionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeInclude<ExtArgs> | null
    /**
     * The filter to search for the UnionFee to update in case it exists.
     */
    where: UnionFeeWhereUniqueInput
    /**
     * In case the UnionFee found by the `where` argument doesn't exist, create a new UnionFee with this data.
     */
    create: XOR<UnionFeeCreateInput, UnionFeeUncheckedCreateInput>
    /**
     * In case the UnionFee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnionFeeUpdateInput, UnionFeeUncheckedUpdateInput>
  }

  /**
   * UnionFee delete
   */
  export type UnionFeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFee
     */
    select?: UnionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeInclude<ExtArgs> | null
    /**
     * Filter which UnionFee to delete.
     */
    where: UnionFeeWhereUniqueInput
  }

  /**
   * UnionFee deleteMany
   */
  export type UnionFeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnionFees to delete
     */
    where?: UnionFeeWhereInput
  }

  /**
   * UnionFee.UnionFeeDetile
   */
  export type UnionFee$UnionFeeDetileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFeeDetile
     */
    select?: UnionFeeDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeDetileInclude<ExtArgs> | null
    where?: UnionFeeDetileWhereInput
    orderBy?: UnionFeeDetileOrderByWithRelationInput | UnionFeeDetileOrderByWithRelationInput[]
    cursor?: UnionFeeDetileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnionFeeDetileScalarFieldEnum | UnionFeeDetileScalarFieldEnum[]
  }

  /**
   * UnionFee without action
   */
  export type UnionFeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFee
     */
    select?: UnionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeInclude<ExtArgs> | null
  }


  /**
   * Model UnionFeeDetile
   */

  export type AggregateUnionFeeDetile = {
    _count: UnionFeeDetileCountAggregateOutputType | null
    _avg: UnionFeeDetileAvgAggregateOutputType | null
    _sum: UnionFeeDetileSumAggregateOutputType | null
    _min: UnionFeeDetileMinAggregateOutputType | null
    _max: UnionFeeDetileMaxAggregateOutputType | null
  }

  export type UnionFeeDetileAvgAggregateOutputType = {
    ID: number | null
    UnionCode: number | null
    SocialYear: number | null
    SocialMonth: number | null
    FeePercentage_No: number | null
    FeePercentage_Yes: number | null
    MaxFee: number | null
    MaxAdminFee: number | null
  }

  export type UnionFeeDetileSumAggregateOutputType = {
    ID: number | null
    UnionCode: number | null
    SocialYear: number | null
    SocialMonth: number | null
    FeePercentage_No: number | null
    FeePercentage_Yes: number | null
    MaxFee: number | null
    MaxAdminFee: number | null
  }

  export type UnionFeeDetileMinAggregateOutputType = {
    ID: number | null
    UnionCode: number | null
    SocialYear: number | null
    SocialMonth: number | null
    FeePercentage_No: number | null
    FeePercentage_Yes: number | null
    MaxFee: number | null
    MaxAdminFee: number | null
  }

  export type UnionFeeDetileMaxAggregateOutputType = {
    ID: number | null
    UnionCode: number | null
    SocialYear: number | null
    SocialMonth: number | null
    FeePercentage_No: number | null
    FeePercentage_Yes: number | null
    MaxFee: number | null
    MaxAdminFee: number | null
  }

  export type UnionFeeDetileCountAggregateOutputType = {
    ID: number
    UnionCode: number
    SocialYear: number
    SocialMonth: number
    FeePercentage_No: number
    FeePercentage_Yes: number
    MaxFee: number
    MaxAdminFee: number
    _all: number
  }


  export type UnionFeeDetileAvgAggregateInputType = {
    ID?: true
    UnionCode?: true
    SocialYear?: true
    SocialMonth?: true
    FeePercentage_No?: true
    FeePercentage_Yes?: true
    MaxFee?: true
    MaxAdminFee?: true
  }

  export type UnionFeeDetileSumAggregateInputType = {
    ID?: true
    UnionCode?: true
    SocialYear?: true
    SocialMonth?: true
    FeePercentage_No?: true
    FeePercentage_Yes?: true
    MaxFee?: true
    MaxAdminFee?: true
  }

  export type UnionFeeDetileMinAggregateInputType = {
    ID?: true
    UnionCode?: true
    SocialYear?: true
    SocialMonth?: true
    FeePercentage_No?: true
    FeePercentage_Yes?: true
    MaxFee?: true
    MaxAdminFee?: true
  }

  export type UnionFeeDetileMaxAggregateInputType = {
    ID?: true
    UnionCode?: true
    SocialYear?: true
    SocialMonth?: true
    FeePercentage_No?: true
    FeePercentage_Yes?: true
    MaxFee?: true
    MaxAdminFee?: true
  }

  export type UnionFeeDetileCountAggregateInputType = {
    ID?: true
    UnionCode?: true
    SocialYear?: true
    SocialMonth?: true
    FeePercentage_No?: true
    FeePercentage_Yes?: true
    MaxFee?: true
    MaxAdminFee?: true
    _all?: true
  }

  export type UnionFeeDetileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnionFeeDetile to aggregate.
     */
    where?: UnionFeeDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnionFeeDetiles to fetch.
     */
    orderBy?: UnionFeeDetileOrderByWithRelationInput | UnionFeeDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnionFeeDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnionFeeDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnionFeeDetiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnionFeeDetiles
    **/
    _count?: true | UnionFeeDetileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnionFeeDetileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnionFeeDetileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnionFeeDetileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnionFeeDetileMaxAggregateInputType
  }

  export type GetUnionFeeDetileAggregateType<T extends UnionFeeDetileAggregateArgs> = {
        [P in keyof T & keyof AggregateUnionFeeDetile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnionFeeDetile[P]>
      : GetScalarType<T[P], AggregateUnionFeeDetile[P]>
  }




  export type UnionFeeDetileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnionFeeDetileWhereInput
    orderBy?: UnionFeeDetileOrderByWithAggregationInput | UnionFeeDetileOrderByWithAggregationInput[]
    by: UnionFeeDetileScalarFieldEnum[] | UnionFeeDetileScalarFieldEnum
    having?: UnionFeeDetileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnionFeeDetileCountAggregateInputType | true
    _avg?: UnionFeeDetileAvgAggregateInputType
    _sum?: UnionFeeDetileSumAggregateInputType
    _min?: UnionFeeDetileMinAggregateInputType
    _max?: UnionFeeDetileMaxAggregateInputType
  }

  export type UnionFeeDetileGroupByOutputType = {
    ID: number
    UnionCode: number
    SocialYear: number
    SocialMonth: number
    FeePercentage_No: number | null
    FeePercentage_Yes: number | null
    MaxFee: number | null
    MaxAdminFee: number | null
    _count: UnionFeeDetileCountAggregateOutputType | null
    _avg: UnionFeeDetileAvgAggregateOutputType | null
    _sum: UnionFeeDetileSumAggregateOutputType | null
    _min: UnionFeeDetileMinAggregateOutputType | null
    _max: UnionFeeDetileMaxAggregateOutputType | null
  }

  type GetUnionFeeDetileGroupByPayload<T extends UnionFeeDetileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnionFeeDetileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnionFeeDetileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnionFeeDetileGroupByOutputType[P]>
            : GetScalarType<T[P], UnionFeeDetileGroupByOutputType[P]>
        }
      >
    >


  export type UnionFeeDetileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    UnionCode?: boolean
    SocialYear?: boolean
    SocialMonth?: boolean
    FeePercentage_No?: boolean
    FeePercentage_Yes?: boolean
    MaxFee?: boolean
    MaxAdminFee?: boolean
    UnionFee?: boolean | UnionFeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unionFeeDetile"]>


  export type UnionFeeDetileSelectScalar = {
    ID?: boolean
    UnionCode?: boolean
    SocialYear?: boolean
    SocialMonth?: boolean
    FeePercentage_No?: boolean
    FeePercentage_Yes?: boolean
    MaxFee?: boolean
    MaxAdminFee?: boolean
  }

  export type UnionFeeDetileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UnionFee?: boolean | UnionFeeDefaultArgs<ExtArgs>
  }

  export type $UnionFeeDetilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnionFeeDetile"
    objects: {
      UnionFee: Prisma.$UnionFeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      UnionCode: number
      SocialYear: number
      SocialMonth: number
      FeePercentage_No: number | null
      FeePercentage_Yes: number | null
      MaxFee: number | null
      MaxAdminFee: number | null
    }, ExtArgs["result"]["unionFeeDetile"]>
    composites: {}
  }

  type UnionFeeDetileGetPayload<S extends boolean | null | undefined | UnionFeeDetileDefaultArgs> = $Result.GetResult<Prisma.$UnionFeeDetilePayload, S>

  type UnionFeeDetileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnionFeeDetileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnionFeeDetileCountAggregateInputType | true
    }

  export interface UnionFeeDetileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnionFeeDetile'], meta: { name: 'UnionFeeDetile' } }
    /**
     * Find zero or one UnionFeeDetile that matches the filter.
     * @param {UnionFeeDetileFindUniqueArgs} args - Arguments to find a UnionFeeDetile
     * @example
     * // Get one UnionFeeDetile
     * const unionFeeDetile = await prisma.unionFeeDetile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnionFeeDetileFindUniqueArgs>(args: SelectSubset<T, UnionFeeDetileFindUniqueArgs<ExtArgs>>): Prisma__UnionFeeDetileClient<$Result.GetResult<Prisma.$UnionFeeDetilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UnionFeeDetile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnionFeeDetileFindUniqueOrThrowArgs} args - Arguments to find a UnionFeeDetile
     * @example
     * // Get one UnionFeeDetile
     * const unionFeeDetile = await prisma.unionFeeDetile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnionFeeDetileFindUniqueOrThrowArgs>(args: SelectSubset<T, UnionFeeDetileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnionFeeDetileClient<$Result.GetResult<Prisma.$UnionFeeDetilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UnionFeeDetile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeDetileFindFirstArgs} args - Arguments to find a UnionFeeDetile
     * @example
     * // Get one UnionFeeDetile
     * const unionFeeDetile = await prisma.unionFeeDetile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnionFeeDetileFindFirstArgs>(args?: SelectSubset<T, UnionFeeDetileFindFirstArgs<ExtArgs>>): Prisma__UnionFeeDetileClient<$Result.GetResult<Prisma.$UnionFeeDetilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UnionFeeDetile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeDetileFindFirstOrThrowArgs} args - Arguments to find a UnionFeeDetile
     * @example
     * // Get one UnionFeeDetile
     * const unionFeeDetile = await prisma.unionFeeDetile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnionFeeDetileFindFirstOrThrowArgs>(args?: SelectSubset<T, UnionFeeDetileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnionFeeDetileClient<$Result.GetResult<Prisma.$UnionFeeDetilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UnionFeeDetiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeDetileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnionFeeDetiles
     * const unionFeeDetiles = await prisma.unionFeeDetile.findMany()
     * 
     * // Get first 10 UnionFeeDetiles
     * const unionFeeDetiles = await prisma.unionFeeDetile.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const unionFeeDetileWithIDOnly = await prisma.unionFeeDetile.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends UnionFeeDetileFindManyArgs>(args?: SelectSubset<T, UnionFeeDetileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnionFeeDetilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UnionFeeDetile.
     * @param {UnionFeeDetileCreateArgs} args - Arguments to create a UnionFeeDetile.
     * @example
     * // Create one UnionFeeDetile
     * const UnionFeeDetile = await prisma.unionFeeDetile.create({
     *   data: {
     *     // ... data to create a UnionFeeDetile
     *   }
     * })
     * 
     */
    create<T extends UnionFeeDetileCreateArgs>(args: SelectSubset<T, UnionFeeDetileCreateArgs<ExtArgs>>): Prisma__UnionFeeDetileClient<$Result.GetResult<Prisma.$UnionFeeDetilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UnionFeeDetiles.
     * @param {UnionFeeDetileCreateManyArgs} args - Arguments to create many UnionFeeDetiles.
     * @example
     * // Create many UnionFeeDetiles
     * const unionFeeDetile = await prisma.unionFeeDetile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnionFeeDetileCreateManyArgs>(args?: SelectSubset<T, UnionFeeDetileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UnionFeeDetile.
     * @param {UnionFeeDetileDeleteArgs} args - Arguments to delete one UnionFeeDetile.
     * @example
     * // Delete one UnionFeeDetile
     * const UnionFeeDetile = await prisma.unionFeeDetile.delete({
     *   where: {
     *     // ... filter to delete one UnionFeeDetile
     *   }
     * })
     * 
     */
    delete<T extends UnionFeeDetileDeleteArgs>(args: SelectSubset<T, UnionFeeDetileDeleteArgs<ExtArgs>>): Prisma__UnionFeeDetileClient<$Result.GetResult<Prisma.$UnionFeeDetilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UnionFeeDetile.
     * @param {UnionFeeDetileUpdateArgs} args - Arguments to update one UnionFeeDetile.
     * @example
     * // Update one UnionFeeDetile
     * const unionFeeDetile = await prisma.unionFeeDetile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnionFeeDetileUpdateArgs>(args: SelectSubset<T, UnionFeeDetileUpdateArgs<ExtArgs>>): Prisma__UnionFeeDetileClient<$Result.GetResult<Prisma.$UnionFeeDetilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UnionFeeDetiles.
     * @param {UnionFeeDetileDeleteManyArgs} args - Arguments to filter UnionFeeDetiles to delete.
     * @example
     * // Delete a few UnionFeeDetiles
     * const { count } = await prisma.unionFeeDetile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnionFeeDetileDeleteManyArgs>(args?: SelectSubset<T, UnionFeeDetileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnionFeeDetiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeDetileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnionFeeDetiles
     * const unionFeeDetile = await prisma.unionFeeDetile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnionFeeDetileUpdateManyArgs>(args: SelectSubset<T, UnionFeeDetileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnionFeeDetile.
     * @param {UnionFeeDetileUpsertArgs} args - Arguments to update or create a UnionFeeDetile.
     * @example
     * // Update or create a UnionFeeDetile
     * const unionFeeDetile = await prisma.unionFeeDetile.upsert({
     *   create: {
     *     // ... data to create a UnionFeeDetile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnionFeeDetile we want to update
     *   }
     * })
     */
    upsert<T extends UnionFeeDetileUpsertArgs>(args: SelectSubset<T, UnionFeeDetileUpsertArgs<ExtArgs>>): Prisma__UnionFeeDetileClient<$Result.GetResult<Prisma.$UnionFeeDetilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UnionFeeDetiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeDetileCountArgs} args - Arguments to filter UnionFeeDetiles to count.
     * @example
     * // Count the number of UnionFeeDetiles
     * const count = await prisma.unionFeeDetile.count({
     *   where: {
     *     // ... the filter for the UnionFeeDetiles we want to count
     *   }
     * })
    **/
    count<T extends UnionFeeDetileCountArgs>(
      args?: Subset<T, UnionFeeDetileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnionFeeDetileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnionFeeDetile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeDetileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnionFeeDetileAggregateArgs>(args: Subset<T, UnionFeeDetileAggregateArgs>): Prisma.PrismaPromise<GetUnionFeeDetileAggregateType<T>>

    /**
     * Group by UnionFeeDetile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnionFeeDetileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnionFeeDetileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnionFeeDetileGroupByArgs['orderBy'] }
        : { orderBy?: UnionFeeDetileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnionFeeDetileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnionFeeDetileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnionFeeDetile model
   */
  readonly fields: UnionFeeDetileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnionFeeDetile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnionFeeDetileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UnionFee<T extends UnionFeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnionFeeDefaultArgs<ExtArgs>>): Prisma__UnionFeeClient<$Result.GetResult<Prisma.$UnionFeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnionFeeDetile model
   */ 
  interface UnionFeeDetileFieldRefs {
    readonly ID: FieldRef<"UnionFeeDetile", 'Int'>
    readonly UnionCode: FieldRef<"UnionFeeDetile", 'Int'>
    readonly SocialYear: FieldRef<"UnionFeeDetile", 'Int'>
    readonly SocialMonth: FieldRef<"UnionFeeDetile", 'Int'>
    readonly FeePercentage_No: FieldRef<"UnionFeeDetile", 'Float'>
    readonly FeePercentage_Yes: FieldRef<"UnionFeeDetile", 'Float'>
    readonly MaxFee: FieldRef<"UnionFeeDetile", 'Float'>
    readonly MaxAdminFee: FieldRef<"UnionFeeDetile", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * UnionFeeDetile findUnique
   */
  export type UnionFeeDetileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFeeDetile
     */
    select?: UnionFeeDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeDetileInclude<ExtArgs> | null
    /**
     * Filter, which UnionFeeDetile to fetch.
     */
    where: UnionFeeDetileWhereUniqueInput
  }

  /**
   * UnionFeeDetile findUniqueOrThrow
   */
  export type UnionFeeDetileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFeeDetile
     */
    select?: UnionFeeDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeDetileInclude<ExtArgs> | null
    /**
     * Filter, which UnionFeeDetile to fetch.
     */
    where: UnionFeeDetileWhereUniqueInput
  }

  /**
   * UnionFeeDetile findFirst
   */
  export type UnionFeeDetileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFeeDetile
     */
    select?: UnionFeeDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeDetileInclude<ExtArgs> | null
    /**
     * Filter, which UnionFeeDetile to fetch.
     */
    where?: UnionFeeDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnionFeeDetiles to fetch.
     */
    orderBy?: UnionFeeDetileOrderByWithRelationInput | UnionFeeDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnionFeeDetiles.
     */
    cursor?: UnionFeeDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnionFeeDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnionFeeDetiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnionFeeDetiles.
     */
    distinct?: UnionFeeDetileScalarFieldEnum | UnionFeeDetileScalarFieldEnum[]
  }

  /**
   * UnionFeeDetile findFirstOrThrow
   */
  export type UnionFeeDetileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFeeDetile
     */
    select?: UnionFeeDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeDetileInclude<ExtArgs> | null
    /**
     * Filter, which UnionFeeDetile to fetch.
     */
    where?: UnionFeeDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnionFeeDetiles to fetch.
     */
    orderBy?: UnionFeeDetileOrderByWithRelationInput | UnionFeeDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnionFeeDetiles.
     */
    cursor?: UnionFeeDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnionFeeDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnionFeeDetiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnionFeeDetiles.
     */
    distinct?: UnionFeeDetileScalarFieldEnum | UnionFeeDetileScalarFieldEnum[]
  }

  /**
   * UnionFeeDetile findMany
   */
  export type UnionFeeDetileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFeeDetile
     */
    select?: UnionFeeDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeDetileInclude<ExtArgs> | null
    /**
     * Filter, which UnionFeeDetiles to fetch.
     */
    where?: UnionFeeDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnionFeeDetiles to fetch.
     */
    orderBy?: UnionFeeDetileOrderByWithRelationInput | UnionFeeDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnionFeeDetiles.
     */
    cursor?: UnionFeeDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnionFeeDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnionFeeDetiles.
     */
    skip?: number
    distinct?: UnionFeeDetileScalarFieldEnum | UnionFeeDetileScalarFieldEnum[]
  }

  /**
   * UnionFeeDetile create
   */
  export type UnionFeeDetileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFeeDetile
     */
    select?: UnionFeeDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeDetileInclude<ExtArgs> | null
    /**
     * The data needed to create a UnionFeeDetile.
     */
    data: XOR<UnionFeeDetileCreateInput, UnionFeeDetileUncheckedCreateInput>
  }

  /**
   * UnionFeeDetile createMany
   */
  export type UnionFeeDetileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnionFeeDetiles.
     */
    data: UnionFeeDetileCreateManyInput | UnionFeeDetileCreateManyInput[]
  }

  /**
   * UnionFeeDetile update
   */
  export type UnionFeeDetileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFeeDetile
     */
    select?: UnionFeeDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeDetileInclude<ExtArgs> | null
    /**
     * The data needed to update a UnionFeeDetile.
     */
    data: XOR<UnionFeeDetileUpdateInput, UnionFeeDetileUncheckedUpdateInput>
    /**
     * Choose, which UnionFeeDetile to update.
     */
    where: UnionFeeDetileWhereUniqueInput
  }

  /**
   * UnionFeeDetile updateMany
   */
  export type UnionFeeDetileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnionFeeDetiles.
     */
    data: XOR<UnionFeeDetileUpdateManyMutationInput, UnionFeeDetileUncheckedUpdateManyInput>
    /**
     * Filter which UnionFeeDetiles to update
     */
    where?: UnionFeeDetileWhereInput
  }

  /**
   * UnionFeeDetile upsert
   */
  export type UnionFeeDetileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFeeDetile
     */
    select?: UnionFeeDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeDetileInclude<ExtArgs> | null
    /**
     * The filter to search for the UnionFeeDetile to update in case it exists.
     */
    where: UnionFeeDetileWhereUniqueInput
    /**
     * In case the UnionFeeDetile found by the `where` argument doesn't exist, create a new UnionFeeDetile with this data.
     */
    create: XOR<UnionFeeDetileCreateInput, UnionFeeDetileUncheckedCreateInput>
    /**
     * In case the UnionFeeDetile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnionFeeDetileUpdateInput, UnionFeeDetileUncheckedUpdateInput>
  }

  /**
   * UnionFeeDetile delete
   */
  export type UnionFeeDetileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFeeDetile
     */
    select?: UnionFeeDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeDetileInclude<ExtArgs> | null
    /**
     * Filter which UnionFeeDetile to delete.
     */
    where: UnionFeeDetileWhereUniqueInput
  }

  /**
   * UnionFeeDetile deleteMany
   */
  export type UnionFeeDetileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnionFeeDetiles to delete
     */
    where?: UnionFeeDetileWhereInput
  }

  /**
   * UnionFeeDetile without action
   */
  export type UnionFeeDetileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnionFeeDetile
     */
    select?: UnionFeeDetileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnionFeeDetileInclude<ExtArgs> | null
  }


  /**
   * Model VacationDefinitionDetails
   */

  export type AggregateVacationDefinitionDetails = {
    _count: VacationDefinitionDetailsCountAggregateOutputType | null
    _avg: VacationDefinitionDetailsAvgAggregateOutputType | null
    _sum: VacationDefinitionDetailsSumAggregateOutputType | null
    _min: VacationDefinitionDetailsMinAggregateOutputType | null
    _max: VacationDefinitionDetailsMaxAggregateOutputType | null
  }

  export type VacationDefinitionDetailsAvgAggregateOutputType = {
    VacationlDefinitionDetaillID: number | null
    VacationlDefinitionID: number | null
    StartMonthReward: number | null
    EndMonthrReward: number | null
    DayQuantity6days: number | null
    DayQuantity5days: number | null
    DayQuantity: number | null
  }

  export type VacationDefinitionDetailsSumAggregateOutputType = {
    VacationlDefinitionDetaillID: number | null
    VacationlDefinitionID: number | null
    StartMonthReward: number | null
    EndMonthrReward: number | null
    DayQuantity6days: number | null
    DayQuantity5days: number | null
    DayQuantity: number | null
  }

  export type VacationDefinitionDetailsMinAggregateOutputType = {
    VacationlDefinitionDetaillID: number | null
    VacationlDefinitionID: number | null
    StartMonthReward: number | null
    EndMonthrReward: number | null
    DayQuantity6days: number | null
    DayQuantity5days: number | null
    SocialYearDescription: string | null
    DayQuantity: number | null
  }

  export type VacationDefinitionDetailsMaxAggregateOutputType = {
    VacationlDefinitionDetaillID: number | null
    VacationlDefinitionID: number | null
    StartMonthReward: number | null
    EndMonthrReward: number | null
    DayQuantity6days: number | null
    DayQuantity5days: number | null
    SocialYearDescription: string | null
    DayQuantity: number | null
  }

  export type VacationDefinitionDetailsCountAggregateOutputType = {
    VacationlDefinitionDetaillID: number
    VacationlDefinitionID: number
    StartMonthReward: number
    EndMonthrReward: number
    DayQuantity6days: number
    DayQuantity5days: number
    SocialYearDescription: number
    DayQuantity: number
    _all: number
  }


  export type VacationDefinitionDetailsAvgAggregateInputType = {
    VacationlDefinitionDetaillID?: true
    VacationlDefinitionID?: true
    StartMonthReward?: true
    EndMonthrReward?: true
    DayQuantity6days?: true
    DayQuantity5days?: true
    DayQuantity?: true
  }

  export type VacationDefinitionDetailsSumAggregateInputType = {
    VacationlDefinitionDetaillID?: true
    VacationlDefinitionID?: true
    StartMonthReward?: true
    EndMonthrReward?: true
    DayQuantity6days?: true
    DayQuantity5days?: true
    DayQuantity?: true
  }

  export type VacationDefinitionDetailsMinAggregateInputType = {
    VacationlDefinitionDetaillID?: true
    VacationlDefinitionID?: true
    StartMonthReward?: true
    EndMonthrReward?: true
    DayQuantity6days?: true
    DayQuantity5days?: true
    SocialYearDescription?: true
    DayQuantity?: true
  }

  export type VacationDefinitionDetailsMaxAggregateInputType = {
    VacationlDefinitionDetaillID?: true
    VacationlDefinitionID?: true
    StartMonthReward?: true
    EndMonthrReward?: true
    DayQuantity6days?: true
    DayQuantity5days?: true
    SocialYearDescription?: true
    DayQuantity?: true
  }

  export type VacationDefinitionDetailsCountAggregateInputType = {
    VacationlDefinitionDetaillID?: true
    VacationlDefinitionID?: true
    StartMonthReward?: true
    EndMonthrReward?: true
    DayQuantity6days?: true
    DayQuantity5days?: true
    SocialYearDescription?: true
    DayQuantity?: true
    _all?: true
  }

  export type VacationDefinitionDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VacationDefinitionDetails to aggregate.
     */
    where?: VacationDefinitionDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VacationDefinitionDetails to fetch.
     */
    orderBy?: VacationDefinitionDetailsOrderByWithRelationInput | VacationDefinitionDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VacationDefinitionDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VacationDefinitionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VacationDefinitionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VacationDefinitionDetails
    **/
    _count?: true | VacationDefinitionDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VacationDefinitionDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VacationDefinitionDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VacationDefinitionDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VacationDefinitionDetailsMaxAggregateInputType
  }

  export type GetVacationDefinitionDetailsAggregateType<T extends VacationDefinitionDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateVacationDefinitionDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVacationDefinitionDetails[P]>
      : GetScalarType<T[P], AggregateVacationDefinitionDetails[P]>
  }




  export type VacationDefinitionDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VacationDefinitionDetailsWhereInput
    orderBy?: VacationDefinitionDetailsOrderByWithAggregationInput | VacationDefinitionDetailsOrderByWithAggregationInput[]
    by: VacationDefinitionDetailsScalarFieldEnum[] | VacationDefinitionDetailsScalarFieldEnum
    having?: VacationDefinitionDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VacationDefinitionDetailsCountAggregateInputType | true
    _avg?: VacationDefinitionDetailsAvgAggregateInputType
    _sum?: VacationDefinitionDetailsSumAggregateInputType
    _min?: VacationDefinitionDetailsMinAggregateInputType
    _max?: VacationDefinitionDetailsMaxAggregateInputType
  }

  export type VacationDefinitionDetailsGroupByOutputType = {
    VacationlDefinitionDetaillID: number
    VacationlDefinitionID: number | null
    StartMonthReward: number | null
    EndMonthrReward: number | null
    DayQuantity6days: number | null
    DayQuantity5days: number | null
    SocialYearDescription: string | null
    DayQuantity: number | null
    _count: VacationDefinitionDetailsCountAggregateOutputType | null
    _avg: VacationDefinitionDetailsAvgAggregateOutputType | null
    _sum: VacationDefinitionDetailsSumAggregateOutputType | null
    _min: VacationDefinitionDetailsMinAggregateOutputType | null
    _max: VacationDefinitionDetailsMaxAggregateOutputType | null
  }

  type GetVacationDefinitionDetailsGroupByPayload<T extends VacationDefinitionDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VacationDefinitionDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VacationDefinitionDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VacationDefinitionDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], VacationDefinitionDetailsGroupByOutputType[P]>
        }
      >
    >


  export type VacationDefinitionDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    VacationlDefinitionDetaillID?: boolean
    VacationlDefinitionID?: boolean
    StartMonthReward?: boolean
    EndMonthrReward?: boolean
    DayQuantity6days?: boolean
    DayQuantity5days?: boolean
    SocialYearDescription?: boolean
    DayQuantity?: boolean
    VacationlDefinition?: boolean | VacationDefinitionDetails$VacationlDefinitionArgs<ExtArgs>
  }, ExtArgs["result"]["vacationDefinitionDetails"]>


  export type VacationDefinitionDetailsSelectScalar = {
    VacationlDefinitionDetaillID?: boolean
    VacationlDefinitionID?: boolean
    StartMonthReward?: boolean
    EndMonthrReward?: boolean
    DayQuantity6days?: boolean
    DayQuantity5days?: boolean
    SocialYearDescription?: boolean
    DayQuantity?: boolean
  }

  export type VacationDefinitionDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VacationlDefinition?: boolean | VacationDefinitionDetails$VacationlDefinitionArgs<ExtArgs>
  }

  export type $VacationDefinitionDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VacationDefinitionDetails"
    objects: {
      VacationlDefinition: Prisma.$VacationlDefinitionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      VacationlDefinitionDetaillID: number
      VacationlDefinitionID: number | null
      StartMonthReward: number | null
      EndMonthrReward: number | null
      DayQuantity6days: number | null
      DayQuantity5days: number | null
      SocialYearDescription: string | null
      DayQuantity: number | null
    }, ExtArgs["result"]["vacationDefinitionDetails"]>
    composites: {}
  }

  type VacationDefinitionDetailsGetPayload<S extends boolean | null | undefined | VacationDefinitionDetailsDefaultArgs> = $Result.GetResult<Prisma.$VacationDefinitionDetailsPayload, S>

  type VacationDefinitionDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VacationDefinitionDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VacationDefinitionDetailsCountAggregateInputType | true
    }

  export interface VacationDefinitionDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VacationDefinitionDetails'], meta: { name: 'VacationDefinitionDetails' } }
    /**
     * Find zero or one VacationDefinitionDetails that matches the filter.
     * @param {VacationDefinitionDetailsFindUniqueArgs} args - Arguments to find a VacationDefinitionDetails
     * @example
     * // Get one VacationDefinitionDetails
     * const vacationDefinitionDetails = await prisma.vacationDefinitionDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VacationDefinitionDetailsFindUniqueArgs>(args: SelectSubset<T, VacationDefinitionDetailsFindUniqueArgs<ExtArgs>>): Prisma__VacationDefinitionDetailsClient<$Result.GetResult<Prisma.$VacationDefinitionDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VacationDefinitionDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VacationDefinitionDetailsFindUniqueOrThrowArgs} args - Arguments to find a VacationDefinitionDetails
     * @example
     * // Get one VacationDefinitionDetails
     * const vacationDefinitionDetails = await prisma.vacationDefinitionDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VacationDefinitionDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, VacationDefinitionDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VacationDefinitionDetailsClient<$Result.GetResult<Prisma.$VacationDefinitionDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VacationDefinitionDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationDefinitionDetailsFindFirstArgs} args - Arguments to find a VacationDefinitionDetails
     * @example
     * // Get one VacationDefinitionDetails
     * const vacationDefinitionDetails = await prisma.vacationDefinitionDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VacationDefinitionDetailsFindFirstArgs>(args?: SelectSubset<T, VacationDefinitionDetailsFindFirstArgs<ExtArgs>>): Prisma__VacationDefinitionDetailsClient<$Result.GetResult<Prisma.$VacationDefinitionDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VacationDefinitionDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationDefinitionDetailsFindFirstOrThrowArgs} args - Arguments to find a VacationDefinitionDetails
     * @example
     * // Get one VacationDefinitionDetails
     * const vacationDefinitionDetails = await prisma.vacationDefinitionDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VacationDefinitionDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, VacationDefinitionDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VacationDefinitionDetailsClient<$Result.GetResult<Prisma.$VacationDefinitionDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VacationDefinitionDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationDefinitionDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VacationDefinitionDetails
     * const vacationDefinitionDetails = await prisma.vacationDefinitionDetails.findMany()
     * 
     * // Get first 10 VacationDefinitionDetails
     * const vacationDefinitionDetails = await prisma.vacationDefinitionDetails.findMany({ take: 10 })
     * 
     * // Only select the `VacationlDefinitionDetaillID`
     * const vacationDefinitionDetailsWithVacationlDefinitionDetaillIDOnly = await prisma.vacationDefinitionDetails.findMany({ select: { VacationlDefinitionDetaillID: true } })
     * 
     */
    findMany<T extends VacationDefinitionDetailsFindManyArgs>(args?: SelectSubset<T, VacationDefinitionDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VacationDefinitionDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VacationDefinitionDetails.
     * @param {VacationDefinitionDetailsCreateArgs} args - Arguments to create a VacationDefinitionDetails.
     * @example
     * // Create one VacationDefinitionDetails
     * const VacationDefinitionDetails = await prisma.vacationDefinitionDetails.create({
     *   data: {
     *     // ... data to create a VacationDefinitionDetails
     *   }
     * })
     * 
     */
    create<T extends VacationDefinitionDetailsCreateArgs>(args: SelectSubset<T, VacationDefinitionDetailsCreateArgs<ExtArgs>>): Prisma__VacationDefinitionDetailsClient<$Result.GetResult<Prisma.$VacationDefinitionDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VacationDefinitionDetails.
     * @param {VacationDefinitionDetailsCreateManyArgs} args - Arguments to create many VacationDefinitionDetails.
     * @example
     * // Create many VacationDefinitionDetails
     * const vacationDefinitionDetails = await prisma.vacationDefinitionDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VacationDefinitionDetailsCreateManyArgs>(args?: SelectSubset<T, VacationDefinitionDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VacationDefinitionDetails.
     * @param {VacationDefinitionDetailsDeleteArgs} args - Arguments to delete one VacationDefinitionDetails.
     * @example
     * // Delete one VacationDefinitionDetails
     * const VacationDefinitionDetails = await prisma.vacationDefinitionDetails.delete({
     *   where: {
     *     // ... filter to delete one VacationDefinitionDetails
     *   }
     * })
     * 
     */
    delete<T extends VacationDefinitionDetailsDeleteArgs>(args: SelectSubset<T, VacationDefinitionDetailsDeleteArgs<ExtArgs>>): Prisma__VacationDefinitionDetailsClient<$Result.GetResult<Prisma.$VacationDefinitionDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VacationDefinitionDetails.
     * @param {VacationDefinitionDetailsUpdateArgs} args - Arguments to update one VacationDefinitionDetails.
     * @example
     * // Update one VacationDefinitionDetails
     * const vacationDefinitionDetails = await prisma.vacationDefinitionDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VacationDefinitionDetailsUpdateArgs>(args: SelectSubset<T, VacationDefinitionDetailsUpdateArgs<ExtArgs>>): Prisma__VacationDefinitionDetailsClient<$Result.GetResult<Prisma.$VacationDefinitionDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VacationDefinitionDetails.
     * @param {VacationDefinitionDetailsDeleteManyArgs} args - Arguments to filter VacationDefinitionDetails to delete.
     * @example
     * // Delete a few VacationDefinitionDetails
     * const { count } = await prisma.vacationDefinitionDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VacationDefinitionDetailsDeleteManyArgs>(args?: SelectSubset<T, VacationDefinitionDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VacationDefinitionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationDefinitionDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VacationDefinitionDetails
     * const vacationDefinitionDetails = await prisma.vacationDefinitionDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VacationDefinitionDetailsUpdateManyArgs>(args: SelectSubset<T, VacationDefinitionDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VacationDefinitionDetails.
     * @param {VacationDefinitionDetailsUpsertArgs} args - Arguments to update or create a VacationDefinitionDetails.
     * @example
     * // Update or create a VacationDefinitionDetails
     * const vacationDefinitionDetails = await prisma.vacationDefinitionDetails.upsert({
     *   create: {
     *     // ... data to create a VacationDefinitionDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VacationDefinitionDetails we want to update
     *   }
     * })
     */
    upsert<T extends VacationDefinitionDetailsUpsertArgs>(args: SelectSubset<T, VacationDefinitionDetailsUpsertArgs<ExtArgs>>): Prisma__VacationDefinitionDetailsClient<$Result.GetResult<Prisma.$VacationDefinitionDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VacationDefinitionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationDefinitionDetailsCountArgs} args - Arguments to filter VacationDefinitionDetails to count.
     * @example
     * // Count the number of VacationDefinitionDetails
     * const count = await prisma.vacationDefinitionDetails.count({
     *   where: {
     *     // ... the filter for the VacationDefinitionDetails we want to count
     *   }
     * })
    **/
    count<T extends VacationDefinitionDetailsCountArgs>(
      args?: Subset<T, VacationDefinitionDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VacationDefinitionDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VacationDefinitionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationDefinitionDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VacationDefinitionDetailsAggregateArgs>(args: Subset<T, VacationDefinitionDetailsAggregateArgs>): Prisma.PrismaPromise<GetVacationDefinitionDetailsAggregateType<T>>

    /**
     * Group by VacationDefinitionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationDefinitionDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VacationDefinitionDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VacationDefinitionDetailsGroupByArgs['orderBy'] }
        : { orderBy?: VacationDefinitionDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VacationDefinitionDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVacationDefinitionDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VacationDefinitionDetails model
   */
  readonly fields: VacationDefinitionDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VacationDefinitionDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VacationDefinitionDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VacationlDefinition<T extends VacationDefinitionDetails$VacationlDefinitionArgs<ExtArgs> = {}>(args?: Subset<T, VacationDefinitionDetails$VacationlDefinitionArgs<ExtArgs>>): Prisma__VacationlDefinitionClient<$Result.GetResult<Prisma.$VacationlDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VacationDefinitionDetails model
   */ 
  interface VacationDefinitionDetailsFieldRefs {
    readonly VacationlDefinitionDetaillID: FieldRef<"VacationDefinitionDetails", 'Int'>
    readonly VacationlDefinitionID: FieldRef<"VacationDefinitionDetails", 'Int'>
    readonly StartMonthReward: FieldRef<"VacationDefinitionDetails", 'Float'>
    readonly EndMonthrReward: FieldRef<"VacationDefinitionDetails", 'Float'>
    readonly DayQuantity6days: FieldRef<"VacationDefinitionDetails", 'Int'>
    readonly DayQuantity5days: FieldRef<"VacationDefinitionDetails", 'Int'>
    readonly SocialYearDescription: FieldRef<"VacationDefinitionDetails", 'String'>
    readonly DayQuantity: FieldRef<"VacationDefinitionDetails", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VacationDefinitionDetails findUnique
   */
  export type VacationDefinitionDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationDefinitionDetails
     */
    select?: VacationDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationDefinitionDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VacationDefinitionDetails to fetch.
     */
    where: VacationDefinitionDetailsWhereUniqueInput
  }

  /**
   * VacationDefinitionDetails findUniqueOrThrow
   */
  export type VacationDefinitionDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationDefinitionDetails
     */
    select?: VacationDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationDefinitionDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VacationDefinitionDetails to fetch.
     */
    where: VacationDefinitionDetailsWhereUniqueInput
  }

  /**
   * VacationDefinitionDetails findFirst
   */
  export type VacationDefinitionDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationDefinitionDetails
     */
    select?: VacationDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationDefinitionDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VacationDefinitionDetails to fetch.
     */
    where?: VacationDefinitionDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VacationDefinitionDetails to fetch.
     */
    orderBy?: VacationDefinitionDetailsOrderByWithRelationInput | VacationDefinitionDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VacationDefinitionDetails.
     */
    cursor?: VacationDefinitionDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VacationDefinitionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VacationDefinitionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VacationDefinitionDetails.
     */
    distinct?: VacationDefinitionDetailsScalarFieldEnum | VacationDefinitionDetailsScalarFieldEnum[]
  }

  /**
   * VacationDefinitionDetails findFirstOrThrow
   */
  export type VacationDefinitionDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationDefinitionDetails
     */
    select?: VacationDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationDefinitionDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VacationDefinitionDetails to fetch.
     */
    where?: VacationDefinitionDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VacationDefinitionDetails to fetch.
     */
    orderBy?: VacationDefinitionDetailsOrderByWithRelationInput | VacationDefinitionDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VacationDefinitionDetails.
     */
    cursor?: VacationDefinitionDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VacationDefinitionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VacationDefinitionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VacationDefinitionDetails.
     */
    distinct?: VacationDefinitionDetailsScalarFieldEnum | VacationDefinitionDetailsScalarFieldEnum[]
  }

  /**
   * VacationDefinitionDetails findMany
   */
  export type VacationDefinitionDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationDefinitionDetails
     */
    select?: VacationDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationDefinitionDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VacationDefinitionDetails to fetch.
     */
    where?: VacationDefinitionDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VacationDefinitionDetails to fetch.
     */
    orderBy?: VacationDefinitionDetailsOrderByWithRelationInput | VacationDefinitionDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VacationDefinitionDetails.
     */
    cursor?: VacationDefinitionDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VacationDefinitionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VacationDefinitionDetails.
     */
    skip?: number
    distinct?: VacationDefinitionDetailsScalarFieldEnum | VacationDefinitionDetailsScalarFieldEnum[]
  }

  /**
   * VacationDefinitionDetails create
   */
  export type VacationDefinitionDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationDefinitionDetails
     */
    select?: VacationDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationDefinitionDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a VacationDefinitionDetails.
     */
    data?: XOR<VacationDefinitionDetailsCreateInput, VacationDefinitionDetailsUncheckedCreateInput>
  }

  /**
   * VacationDefinitionDetails createMany
   */
  export type VacationDefinitionDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VacationDefinitionDetails.
     */
    data: VacationDefinitionDetailsCreateManyInput | VacationDefinitionDetailsCreateManyInput[]
  }

  /**
   * VacationDefinitionDetails update
   */
  export type VacationDefinitionDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationDefinitionDetails
     */
    select?: VacationDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationDefinitionDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a VacationDefinitionDetails.
     */
    data: XOR<VacationDefinitionDetailsUpdateInput, VacationDefinitionDetailsUncheckedUpdateInput>
    /**
     * Choose, which VacationDefinitionDetails to update.
     */
    where: VacationDefinitionDetailsWhereUniqueInput
  }

  /**
   * VacationDefinitionDetails updateMany
   */
  export type VacationDefinitionDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VacationDefinitionDetails.
     */
    data: XOR<VacationDefinitionDetailsUpdateManyMutationInput, VacationDefinitionDetailsUncheckedUpdateManyInput>
    /**
     * Filter which VacationDefinitionDetails to update
     */
    where?: VacationDefinitionDetailsWhereInput
  }

  /**
   * VacationDefinitionDetails upsert
   */
  export type VacationDefinitionDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationDefinitionDetails
     */
    select?: VacationDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationDefinitionDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the VacationDefinitionDetails to update in case it exists.
     */
    where: VacationDefinitionDetailsWhereUniqueInput
    /**
     * In case the VacationDefinitionDetails found by the `where` argument doesn't exist, create a new VacationDefinitionDetails with this data.
     */
    create: XOR<VacationDefinitionDetailsCreateInput, VacationDefinitionDetailsUncheckedCreateInput>
    /**
     * In case the VacationDefinitionDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VacationDefinitionDetailsUpdateInput, VacationDefinitionDetailsUncheckedUpdateInput>
  }

  /**
   * VacationDefinitionDetails delete
   */
  export type VacationDefinitionDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationDefinitionDetails
     */
    select?: VacationDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationDefinitionDetailsInclude<ExtArgs> | null
    /**
     * Filter which VacationDefinitionDetails to delete.
     */
    where: VacationDefinitionDetailsWhereUniqueInput
  }

  /**
   * VacationDefinitionDetails deleteMany
   */
  export type VacationDefinitionDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VacationDefinitionDetails to delete
     */
    where?: VacationDefinitionDetailsWhereInput
  }

  /**
   * VacationDefinitionDetails.VacationlDefinition
   */
  export type VacationDefinitionDetails$VacationlDefinitionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationlDefinition
     */
    select?: VacationlDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationlDefinitionInclude<ExtArgs> | null
    where?: VacationlDefinitionWhereInput
  }

  /**
   * VacationDefinitionDetails without action
   */
  export type VacationDefinitionDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationDefinitionDetails
     */
    select?: VacationDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationDefinitionDetailsInclude<ExtArgs> | null
  }


  /**
   * Model VacationlDefinition
   */

  export type AggregateVacationlDefinition = {
    _count: VacationlDefinitionCountAggregateOutputType | null
    _avg: VacationlDefinitionAvgAggregateOutputType | null
    _sum: VacationlDefinitionSumAggregateOutputType | null
    _min: VacationlDefinitionMinAggregateOutputType | null
    _max: VacationlDefinitionMaxAggregateOutputType | null
  }

  export type VacationlDefinitionAvgAggregateOutputType = {
    VacationlDefinitionID: number | null
  }

  export type VacationlDefinitionSumAggregateOutputType = {
    VacationlDefinitionID: number | null
  }

  export type VacationlDefinitionMinAggregateOutputType = {
    VacationlDefinitionID: number | null
    VacationlDefinitionName: string | null
  }

  export type VacationlDefinitionMaxAggregateOutputType = {
    VacationlDefinitionID: number | null
    VacationlDefinitionName: string | null
  }

  export type VacationlDefinitionCountAggregateOutputType = {
    VacationlDefinitionID: number
    VacationlDefinitionName: number
    _all: number
  }


  export type VacationlDefinitionAvgAggregateInputType = {
    VacationlDefinitionID?: true
  }

  export type VacationlDefinitionSumAggregateInputType = {
    VacationlDefinitionID?: true
  }

  export type VacationlDefinitionMinAggregateInputType = {
    VacationlDefinitionID?: true
    VacationlDefinitionName?: true
  }

  export type VacationlDefinitionMaxAggregateInputType = {
    VacationlDefinitionID?: true
    VacationlDefinitionName?: true
  }

  export type VacationlDefinitionCountAggregateInputType = {
    VacationlDefinitionID?: true
    VacationlDefinitionName?: true
    _all?: true
  }

  export type VacationlDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VacationlDefinition to aggregate.
     */
    where?: VacationlDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VacationlDefinitions to fetch.
     */
    orderBy?: VacationlDefinitionOrderByWithRelationInput | VacationlDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VacationlDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VacationlDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VacationlDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VacationlDefinitions
    **/
    _count?: true | VacationlDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VacationlDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VacationlDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VacationlDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VacationlDefinitionMaxAggregateInputType
  }

  export type GetVacationlDefinitionAggregateType<T extends VacationlDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateVacationlDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVacationlDefinition[P]>
      : GetScalarType<T[P], AggregateVacationlDefinition[P]>
  }




  export type VacationlDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VacationlDefinitionWhereInput
    orderBy?: VacationlDefinitionOrderByWithAggregationInput | VacationlDefinitionOrderByWithAggregationInput[]
    by: VacationlDefinitionScalarFieldEnum[] | VacationlDefinitionScalarFieldEnum
    having?: VacationlDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VacationlDefinitionCountAggregateInputType | true
    _avg?: VacationlDefinitionAvgAggregateInputType
    _sum?: VacationlDefinitionSumAggregateInputType
    _min?: VacationlDefinitionMinAggregateInputType
    _max?: VacationlDefinitionMaxAggregateInputType
  }

  export type VacationlDefinitionGroupByOutputType = {
    VacationlDefinitionID: number
    VacationlDefinitionName: string
    _count: VacationlDefinitionCountAggregateOutputType | null
    _avg: VacationlDefinitionAvgAggregateOutputType | null
    _sum: VacationlDefinitionSumAggregateOutputType | null
    _min: VacationlDefinitionMinAggregateOutputType | null
    _max: VacationlDefinitionMaxAggregateOutputType | null
  }

  type GetVacationlDefinitionGroupByPayload<T extends VacationlDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VacationlDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VacationlDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VacationlDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], VacationlDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type VacationlDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    VacationlDefinitionID?: boolean
    VacationlDefinitionName?: boolean
    VacationDefinitionDetails?: boolean | VacationlDefinition$VacationDefinitionDetailsArgs<ExtArgs>
    _count?: boolean | VacationlDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vacationlDefinition"]>


  export type VacationlDefinitionSelectScalar = {
    VacationlDefinitionID?: boolean
    VacationlDefinitionName?: boolean
  }

  export type VacationlDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VacationDefinitionDetails?: boolean | VacationlDefinition$VacationDefinitionDetailsArgs<ExtArgs>
    _count?: boolean | VacationlDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VacationlDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VacationlDefinition"
    objects: {
      VacationDefinitionDetails: Prisma.$VacationDefinitionDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      VacationlDefinitionID: number
      VacationlDefinitionName: string
    }, ExtArgs["result"]["vacationlDefinition"]>
    composites: {}
  }

  type VacationlDefinitionGetPayload<S extends boolean | null | undefined | VacationlDefinitionDefaultArgs> = $Result.GetResult<Prisma.$VacationlDefinitionPayload, S>

  type VacationlDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VacationlDefinitionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VacationlDefinitionCountAggregateInputType | true
    }

  export interface VacationlDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VacationlDefinition'], meta: { name: 'VacationlDefinition' } }
    /**
     * Find zero or one VacationlDefinition that matches the filter.
     * @param {VacationlDefinitionFindUniqueArgs} args - Arguments to find a VacationlDefinition
     * @example
     * // Get one VacationlDefinition
     * const vacationlDefinition = await prisma.vacationlDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VacationlDefinitionFindUniqueArgs>(args: SelectSubset<T, VacationlDefinitionFindUniqueArgs<ExtArgs>>): Prisma__VacationlDefinitionClient<$Result.GetResult<Prisma.$VacationlDefinitionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VacationlDefinition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VacationlDefinitionFindUniqueOrThrowArgs} args - Arguments to find a VacationlDefinition
     * @example
     * // Get one VacationlDefinition
     * const vacationlDefinition = await prisma.vacationlDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VacationlDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, VacationlDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VacationlDefinitionClient<$Result.GetResult<Prisma.$VacationlDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VacationlDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationlDefinitionFindFirstArgs} args - Arguments to find a VacationlDefinition
     * @example
     * // Get one VacationlDefinition
     * const vacationlDefinition = await prisma.vacationlDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VacationlDefinitionFindFirstArgs>(args?: SelectSubset<T, VacationlDefinitionFindFirstArgs<ExtArgs>>): Prisma__VacationlDefinitionClient<$Result.GetResult<Prisma.$VacationlDefinitionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VacationlDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationlDefinitionFindFirstOrThrowArgs} args - Arguments to find a VacationlDefinition
     * @example
     * // Get one VacationlDefinition
     * const vacationlDefinition = await prisma.vacationlDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VacationlDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, VacationlDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VacationlDefinitionClient<$Result.GetResult<Prisma.$VacationlDefinitionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VacationlDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationlDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VacationlDefinitions
     * const vacationlDefinitions = await prisma.vacationlDefinition.findMany()
     * 
     * // Get first 10 VacationlDefinitions
     * const vacationlDefinitions = await prisma.vacationlDefinition.findMany({ take: 10 })
     * 
     * // Only select the `VacationlDefinitionID`
     * const vacationlDefinitionWithVacationlDefinitionIDOnly = await prisma.vacationlDefinition.findMany({ select: { VacationlDefinitionID: true } })
     * 
     */
    findMany<T extends VacationlDefinitionFindManyArgs>(args?: SelectSubset<T, VacationlDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VacationlDefinitionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VacationlDefinition.
     * @param {VacationlDefinitionCreateArgs} args - Arguments to create a VacationlDefinition.
     * @example
     * // Create one VacationlDefinition
     * const VacationlDefinition = await prisma.vacationlDefinition.create({
     *   data: {
     *     // ... data to create a VacationlDefinition
     *   }
     * })
     * 
     */
    create<T extends VacationlDefinitionCreateArgs>(args: SelectSubset<T, VacationlDefinitionCreateArgs<ExtArgs>>): Prisma__VacationlDefinitionClient<$Result.GetResult<Prisma.$VacationlDefinitionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VacationlDefinitions.
     * @param {VacationlDefinitionCreateManyArgs} args - Arguments to create many VacationlDefinitions.
     * @example
     * // Create many VacationlDefinitions
     * const vacationlDefinition = await prisma.vacationlDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VacationlDefinitionCreateManyArgs>(args?: SelectSubset<T, VacationlDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VacationlDefinition.
     * @param {VacationlDefinitionDeleteArgs} args - Arguments to delete one VacationlDefinition.
     * @example
     * // Delete one VacationlDefinition
     * const VacationlDefinition = await prisma.vacationlDefinition.delete({
     *   where: {
     *     // ... filter to delete one VacationlDefinition
     *   }
     * })
     * 
     */
    delete<T extends VacationlDefinitionDeleteArgs>(args: SelectSubset<T, VacationlDefinitionDeleteArgs<ExtArgs>>): Prisma__VacationlDefinitionClient<$Result.GetResult<Prisma.$VacationlDefinitionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VacationlDefinition.
     * @param {VacationlDefinitionUpdateArgs} args - Arguments to update one VacationlDefinition.
     * @example
     * // Update one VacationlDefinition
     * const vacationlDefinition = await prisma.vacationlDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VacationlDefinitionUpdateArgs>(args: SelectSubset<T, VacationlDefinitionUpdateArgs<ExtArgs>>): Prisma__VacationlDefinitionClient<$Result.GetResult<Prisma.$VacationlDefinitionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VacationlDefinitions.
     * @param {VacationlDefinitionDeleteManyArgs} args - Arguments to filter VacationlDefinitions to delete.
     * @example
     * // Delete a few VacationlDefinitions
     * const { count } = await prisma.vacationlDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VacationlDefinitionDeleteManyArgs>(args?: SelectSubset<T, VacationlDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VacationlDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationlDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VacationlDefinitions
     * const vacationlDefinition = await prisma.vacationlDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VacationlDefinitionUpdateManyArgs>(args: SelectSubset<T, VacationlDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VacationlDefinition.
     * @param {VacationlDefinitionUpsertArgs} args - Arguments to update or create a VacationlDefinition.
     * @example
     * // Update or create a VacationlDefinition
     * const vacationlDefinition = await prisma.vacationlDefinition.upsert({
     *   create: {
     *     // ... data to create a VacationlDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VacationlDefinition we want to update
     *   }
     * })
     */
    upsert<T extends VacationlDefinitionUpsertArgs>(args: SelectSubset<T, VacationlDefinitionUpsertArgs<ExtArgs>>): Prisma__VacationlDefinitionClient<$Result.GetResult<Prisma.$VacationlDefinitionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VacationlDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationlDefinitionCountArgs} args - Arguments to filter VacationlDefinitions to count.
     * @example
     * // Count the number of VacationlDefinitions
     * const count = await prisma.vacationlDefinition.count({
     *   where: {
     *     // ... the filter for the VacationlDefinitions we want to count
     *   }
     * })
    **/
    count<T extends VacationlDefinitionCountArgs>(
      args?: Subset<T, VacationlDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VacationlDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VacationlDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationlDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VacationlDefinitionAggregateArgs>(args: Subset<T, VacationlDefinitionAggregateArgs>): Prisma.PrismaPromise<GetVacationlDefinitionAggregateType<T>>

    /**
     * Group by VacationlDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationlDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VacationlDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VacationlDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: VacationlDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VacationlDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVacationlDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VacationlDefinition model
   */
  readonly fields: VacationlDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VacationlDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VacationlDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VacationDefinitionDetails<T extends VacationlDefinition$VacationDefinitionDetailsArgs<ExtArgs> = {}>(args?: Subset<T, VacationlDefinition$VacationDefinitionDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VacationDefinitionDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VacationlDefinition model
   */ 
  interface VacationlDefinitionFieldRefs {
    readonly VacationlDefinitionID: FieldRef<"VacationlDefinition", 'Int'>
    readonly VacationlDefinitionName: FieldRef<"VacationlDefinition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VacationlDefinition findUnique
   */
  export type VacationlDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationlDefinition
     */
    select?: VacationlDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationlDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which VacationlDefinition to fetch.
     */
    where: VacationlDefinitionWhereUniqueInput
  }

  /**
   * VacationlDefinition findUniqueOrThrow
   */
  export type VacationlDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationlDefinition
     */
    select?: VacationlDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationlDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which VacationlDefinition to fetch.
     */
    where: VacationlDefinitionWhereUniqueInput
  }

  /**
   * VacationlDefinition findFirst
   */
  export type VacationlDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationlDefinition
     */
    select?: VacationlDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationlDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which VacationlDefinition to fetch.
     */
    where?: VacationlDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VacationlDefinitions to fetch.
     */
    orderBy?: VacationlDefinitionOrderByWithRelationInput | VacationlDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VacationlDefinitions.
     */
    cursor?: VacationlDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VacationlDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VacationlDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VacationlDefinitions.
     */
    distinct?: VacationlDefinitionScalarFieldEnum | VacationlDefinitionScalarFieldEnum[]
  }

  /**
   * VacationlDefinition findFirstOrThrow
   */
  export type VacationlDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationlDefinition
     */
    select?: VacationlDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationlDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which VacationlDefinition to fetch.
     */
    where?: VacationlDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VacationlDefinitions to fetch.
     */
    orderBy?: VacationlDefinitionOrderByWithRelationInput | VacationlDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VacationlDefinitions.
     */
    cursor?: VacationlDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VacationlDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VacationlDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VacationlDefinitions.
     */
    distinct?: VacationlDefinitionScalarFieldEnum | VacationlDefinitionScalarFieldEnum[]
  }

  /**
   * VacationlDefinition findMany
   */
  export type VacationlDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationlDefinition
     */
    select?: VacationlDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationlDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which VacationlDefinitions to fetch.
     */
    where?: VacationlDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VacationlDefinitions to fetch.
     */
    orderBy?: VacationlDefinitionOrderByWithRelationInput | VacationlDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VacationlDefinitions.
     */
    cursor?: VacationlDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VacationlDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VacationlDefinitions.
     */
    skip?: number
    distinct?: VacationlDefinitionScalarFieldEnum | VacationlDefinitionScalarFieldEnum[]
  }

  /**
   * VacationlDefinition create
   */
  export type VacationlDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationlDefinition
     */
    select?: VacationlDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationlDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a VacationlDefinition.
     */
    data: XOR<VacationlDefinitionCreateInput, VacationlDefinitionUncheckedCreateInput>
  }

  /**
   * VacationlDefinition createMany
   */
  export type VacationlDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VacationlDefinitions.
     */
    data: VacationlDefinitionCreateManyInput | VacationlDefinitionCreateManyInput[]
  }

  /**
   * VacationlDefinition update
   */
  export type VacationlDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationlDefinition
     */
    select?: VacationlDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationlDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a VacationlDefinition.
     */
    data: XOR<VacationlDefinitionUpdateInput, VacationlDefinitionUncheckedUpdateInput>
    /**
     * Choose, which VacationlDefinition to update.
     */
    where: VacationlDefinitionWhereUniqueInput
  }

  /**
   * VacationlDefinition updateMany
   */
  export type VacationlDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VacationlDefinitions.
     */
    data: XOR<VacationlDefinitionUpdateManyMutationInput, VacationlDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which VacationlDefinitions to update
     */
    where?: VacationlDefinitionWhereInput
  }

  /**
   * VacationlDefinition upsert
   */
  export type VacationlDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationlDefinition
     */
    select?: VacationlDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationlDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the VacationlDefinition to update in case it exists.
     */
    where: VacationlDefinitionWhereUniqueInput
    /**
     * In case the VacationlDefinition found by the `where` argument doesn't exist, create a new VacationlDefinition with this data.
     */
    create: XOR<VacationlDefinitionCreateInput, VacationlDefinitionUncheckedCreateInput>
    /**
     * In case the VacationlDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VacationlDefinitionUpdateInput, VacationlDefinitionUncheckedUpdateInput>
  }

  /**
   * VacationlDefinition delete
   */
  export type VacationlDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationlDefinition
     */
    select?: VacationlDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationlDefinitionInclude<ExtArgs> | null
    /**
     * Filter which VacationlDefinition to delete.
     */
    where: VacationlDefinitionWhereUniqueInput
  }

  /**
   * VacationlDefinition deleteMany
   */
  export type VacationlDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VacationlDefinitions to delete
     */
    where?: VacationlDefinitionWhereInput
  }

  /**
   * VacationlDefinition.VacationDefinitionDetails
   */
  export type VacationlDefinition$VacationDefinitionDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationDefinitionDetails
     */
    select?: VacationDefinitionDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationDefinitionDetailsInclude<ExtArgs> | null
    where?: VacationDefinitionDetailsWhereInput
    orderBy?: VacationDefinitionDetailsOrderByWithRelationInput | VacationDefinitionDetailsOrderByWithRelationInput[]
    cursor?: VacationDefinitionDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VacationDefinitionDetailsScalarFieldEnum | VacationDefinitionDetailsScalarFieldEnum[]
  }

  /**
   * VacationlDefinition without action
   */
  export type VacationlDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationlDefinition
     */
    select?: VacationlDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VacationlDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model ValueOfVehicleUse
   */

  export type AggregateValueOfVehicleUse = {
    _count: ValueOfVehicleUseCountAggregateOutputType | null
    _avg: ValueOfVehicleUseAvgAggregateOutputType | null
    _sum: ValueOfVehicleUseSumAggregateOutputType | null
    _min: ValueOfVehicleUseMinAggregateOutputType | null
    _max: ValueOfVehicleUseMaxAggregateOutputType | null
  }

  export type ValueOfVehicleUseAvgAggregateOutputType = {
    ValueOfVehicleUselID: number | null
    Year: number | null
    Month: number | null
    GroupOfVehicle: number | null
    Value: number | null
  }

  export type ValueOfVehicleUseSumAggregateOutputType = {
    ValueOfVehicleUselID: number | null
    Year: number | null
    Month: number | null
    GroupOfVehicle: number | null
    Value: number | null
  }

  export type ValueOfVehicleUseMinAggregateOutputType = {
    ValueOfVehicleUselID: number | null
    Year: number | null
    Month: number | null
    GroupOfVehicle: number | null
    Value: number | null
  }

  export type ValueOfVehicleUseMaxAggregateOutputType = {
    ValueOfVehicleUselID: number | null
    Year: number | null
    Month: number | null
    GroupOfVehicle: number | null
    Value: number | null
  }

  export type ValueOfVehicleUseCountAggregateOutputType = {
    ValueOfVehicleUselID: number
    Year: number
    Month: number
    GroupOfVehicle: number
    Value: number
    _all: number
  }


  export type ValueOfVehicleUseAvgAggregateInputType = {
    ValueOfVehicleUselID?: true
    Year?: true
    Month?: true
    GroupOfVehicle?: true
    Value?: true
  }

  export type ValueOfVehicleUseSumAggregateInputType = {
    ValueOfVehicleUselID?: true
    Year?: true
    Month?: true
    GroupOfVehicle?: true
    Value?: true
  }

  export type ValueOfVehicleUseMinAggregateInputType = {
    ValueOfVehicleUselID?: true
    Year?: true
    Month?: true
    GroupOfVehicle?: true
    Value?: true
  }

  export type ValueOfVehicleUseMaxAggregateInputType = {
    ValueOfVehicleUselID?: true
    Year?: true
    Month?: true
    GroupOfVehicle?: true
    Value?: true
  }

  export type ValueOfVehicleUseCountAggregateInputType = {
    ValueOfVehicleUselID?: true
    Year?: true
    Month?: true
    GroupOfVehicle?: true
    Value?: true
    _all?: true
  }

  export type ValueOfVehicleUseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ValueOfVehicleUse to aggregate.
     */
    where?: ValueOfVehicleUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValueOfVehicleUses to fetch.
     */
    orderBy?: ValueOfVehicleUseOrderByWithRelationInput | ValueOfVehicleUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ValueOfVehicleUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValueOfVehicleUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValueOfVehicleUses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ValueOfVehicleUses
    **/
    _count?: true | ValueOfVehicleUseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ValueOfVehicleUseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ValueOfVehicleUseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ValueOfVehicleUseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ValueOfVehicleUseMaxAggregateInputType
  }

  export type GetValueOfVehicleUseAggregateType<T extends ValueOfVehicleUseAggregateArgs> = {
        [P in keyof T & keyof AggregateValueOfVehicleUse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateValueOfVehicleUse[P]>
      : GetScalarType<T[P], AggregateValueOfVehicleUse[P]>
  }




  export type ValueOfVehicleUseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValueOfVehicleUseWhereInput
    orderBy?: ValueOfVehicleUseOrderByWithAggregationInput | ValueOfVehicleUseOrderByWithAggregationInput[]
    by: ValueOfVehicleUseScalarFieldEnum[] | ValueOfVehicleUseScalarFieldEnum
    having?: ValueOfVehicleUseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ValueOfVehicleUseCountAggregateInputType | true
    _avg?: ValueOfVehicleUseAvgAggregateInputType
    _sum?: ValueOfVehicleUseSumAggregateInputType
    _min?: ValueOfVehicleUseMinAggregateInputType
    _max?: ValueOfVehicleUseMaxAggregateInputType
  }

  export type ValueOfVehicleUseGroupByOutputType = {
    ValueOfVehicleUselID: number
    Year: number | null
    Month: number | null
    GroupOfVehicle: number
    Value: number | null
    _count: ValueOfVehicleUseCountAggregateOutputType | null
    _avg: ValueOfVehicleUseAvgAggregateOutputType | null
    _sum: ValueOfVehicleUseSumAggregateOutputType | null
    _min: ValueOfVehicleUseMinAggregateOutputType | null
    _max: ValueOfVehicleUseMaxAggregateOutputType | null
  }

  type GetValueOfVehicleUseGroupByPayload<T extends ValueOfVehicleUseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ValueOfVehicleUseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ValueOfVehicleUseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ValueOfVehicleUseGroupByOutputType[P]>
            : GetScalarType<T[P], ValueOfVehicleUseGroupByOutputType[P]>
        }
      >
    >


  export type ValueOfVehicleUseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ValueOfVehicleUselID?: boolean
    Year?: boolean
    Month?: boolean
    GroupOfVehicle?: boolean
    Value?: boolean
  }, ExtArgs["result"]["valueOfVehicleUse"]>


  export type ValueOfVehicleUseSelectScalar = {
    ValueOfVehicleUselID?: boolean
    Year?: boolean
    Month?: boolean
    GroupOfVehicle?: boolean
    Value?: boolean
  }


  export type $ValueOfVehicleUsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ValueOfVehicleUse"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ValueOfVehicleUselID: number
      Year: number | null
      Month: number | null
      GroupOfVehicle: number
      Value: number | null
    }, ExtArgs["result"]["valueOfVehicleUse"]>
    composites: {}
  }

  type ValueOfVehicleUseGetPayload<S extends boolean | null | undefined | ValueOfVehicleUseDefaultArgs> = $Result.GetResult<Prisma.$ValueOfVehicleUsePayload, S>

  type ValueOfVehicleUseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ValueOfVehicleUseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ValueOfVehicleUseCountAggregateInputType | true
    }

  export interface ValueOfVehicleUseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ValueOfVehicleUse'], meta: { name: 'ValueOfVehicleUse' } }
    /**
     * Find zero or one ValueOfVehicleUse that matches the filter.
     * @param {ValueOfVehicleUseFindUniqueArgs} args - Arguments to find a ValueOfVehicleUse
     * @example
     * // Get one ValueOfVehicleUse
     * const valueOfVehicleUse = await prisma.valueOfVehicleUse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ValueOfVehicleUseFindUniqueArgs>(args: SelectSubset<T, ValueOfVehicleUseFindUniqueArgs<ExtArgs>>): Prisma__ValueOfVehicleUseClient<$Result.GetResult<Prisma.$ValueOfVehicleUsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ValueOfVehicleUse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ValueOfVehicleUseFindUniqueOrThrowArgs} args - Arguments to find a ValueOfVehicleUse
     * @example
     * // Get one ValueOfVehicleUse
     * const valueOfVehicleUse = await prisma.valueOfVehicleUse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ValueOfVehicleUseFindUniqueOrThrowArgs>(args: SelectSubset<T, ValueOfVehicleUseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ValueOfVehicleUseClient<$Result.GetResult<Prisma.$ValueOfVehicleUsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ValueOfVehicleUse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseFindFirstArgs} args - Arguments to find a ValueOfVehicleUse
     * @example
     * // Get one ValueOfVehicleUse
     * const valueOfVehicleUse = await prisma.valueOfVehicleUse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ValueOfVehicleUseFindFirstArgs>(args?: SelectSubset<T, ValueOfVehicleUseFindFirstArgs<ExtArgs>>): Prisma__ValueOfVehicleUseClient<$Result.GetResult<Prisma.$ValueOfVehicleUsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ValueOfVehicleUse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseFindFirstOrThrowArgs} args - Arguments to find a ValueOfVehicleUse
     * @example
     * // Get one ValueOfVehicleUse
     * const valueOfVehicleUse = await prisma.valueOfVehicleUse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ValueOfVehicleUseFindFirstOrThrowArgs>(args?: SelectSubset<T, ValueOfVehicleUseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ValueOfVehicleUseClient<$Result.GetResult<Prisma.$ValueOfVehicleUsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ValueOfVehicleUses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ValueOfVehicleUses
     * const valueOfVehicleUses = await prisma.valueOfVehicleUse.findMany()
     * 
     * // Get first 10 ValueOfVehicleUses
     * const valueOfVehicleUses = await prisma.valueOfVehicleUse.findMany({ take: 10 })
     * 
     * // Only select the `ValueOfVehicleUselID`
     * const valueOfVehicleUseWithValueOfVehicleUselIDOnly = await prisma.valueOfVehicleUse.findMany({ select: { ValueOfVehicleUselID: true } })
     * 
     */
    findMany<T extends ValueOfVehicleUseFindManyArgs>(args?: SelectSubset<T, ValueOfVehicleUseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValueOfVehicleUsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ValueOfVehicleUse.
     * @param {ValueOfVehicleUseCreateArgs} args - Arguments to create a ValueOfVehicleUse.
     * @example
     * // Create one ValueOfVehicleUse
     * const ValueOfVehicleUse = await prisma.valueOfVehicleUse.create({
     *   data: {
     *     // ... data to create a ValueOfVehicleUse
     *   }
     * })
     * 
     */
    create<T extends ValueOfVehicleUseCreateArgs>(args: SelectSubset<T, ValueOfVehicleUseCreateArgs<ExtArgs>>): Prisma__ValueOfVehicleUseClient<$Result.GetResult<Prisma.$ValueOfVehicleUsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ValueOfVehicleUses.
     * @param {ValueOfVehicleUseCreateManyArgs} args - Arguments to create many ValueOfVehicleUses.
     * @example
     * // Create many ValueOfVehicleUses
     * const valueOfVehicleUse = await prisma.valueOfVehicleUse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ValueOfVehicleUseCreateManyArgs>(args?: SelectSubset<T, ValueOfVehicleUseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ValueOfVehicleUse.
     * @param {ValueOfVehicleUseDeleteArgs} args - Arguments to delete one ValueOfVehicleUse.
     * @example
     * // Delete one ValueOfVehicleUse
     * const ValueOfVehicleUse = await prisma.valueOfVehicleUse.delete({
     *   where: {
     *     // ... filter to delete one ValueOfVehicleUse
     *   }
     * })
     * 
     */
    delete<T extends ValueOfVehicleUseDeleteArgs>(args: SelectSubset<T, ValueOfVehicleUseDeleteArgs<ExtArgs>>): Prisma__ValueOfVehicleUseClient<$Result.GetResult<Prisma.$ValueOfVehicleUsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ValueOfVehicleUse.
     * @param {ValueOfVehicleUseUpdateArgs} args - Arguments to update one ValueOfVehicleUse.
     * @example
     * // Update one ValueOfVehicleUse
     * const valueOfVehicleUse = await prisma.valueOfVehicleUse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ValueOfVehicleUseUpdateArgs>(args: SelectSubset<T, ValueOfVehicleUseUpdateArgs<ExtArgs>>): Prisma__ValueOfVehicleUseClient<$Result.GetResult<Prisma.$ValueOfVehicleUsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ValueOfVehicleUses.
     * @param {ValueOfVehicleUseDeleteManyArgs} args - Arguments to filter ValueOfVehicleUses to delete.
     * @example
     * // Delete a few ValueOfVehicleUses
     * const { count } = await prisma.valueOfVehicleUse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ValueOfVehicleUseDeleteManyArgs>(args?: SelectSubset<T, ValueOfVehicleUseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ValueOfVehicleUses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ValueOfVehicleUses
     * const valueOfVehicleUse = await prisma.valueOfVehicleUse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ValueOfVehicleUseUpdateManyArgs>(args: SelectSubset<T, ValueOfVehicleUseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ValueOfVehicleUse.
     * @param {ValueOfVehicleUseUpsertArgs} args - Arguments to update or create a ValueOfVehicleUse.
     * @example
     * // Update or create a ValueOfVehicleUse
     * const valueOfVehicleUse = await prisma.valueOfVehicleUse.upsert({
     *   create: {
     *     // ... data to create a ValueOfVehicleUse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ValueOfVehicleUse we want to update
     *   }
     * })
     */
    upsert<T extends ValueOfVehicleUseUpsertArgs>(args: SelectSubset<T, ValueOfVehicleUseUpsertArgs<ExtArgs>>): Prisma__ValueOfVehicleUseClient<$Result.GetResult<Prisma.$ValueOfVehicleUsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ValueOfVehicleUses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseCountArgs} args - Arguments to filter ValueOfVehicleUses to count.
     * @example
     * // Count the number of ValueOfVehicleUses
     * const count = await prisma.valueOfVehicleUse.count({
     *   where: {
     *     // ... the filter for the ValueOfVehicleUses we want to count
     *   }
     * })
    **/
    count<T extends ValueOfVehicleUseCountArgs>(
      args?: Subset<T, ValueOfVehicleUseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ValueOfVehicleUseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ValueOfVehicleUse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ValueOfVehicleUseAggregateArgs>(args: Subset<T, ValueOfVehicleUseAggregateArgs>): Prisma.PrismaPromise<GetValueOfVehicleUseAggregateType<T>>

    /**
     * Group by ValueOfVehicleUse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ValueOfVehicleUseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ValueOfVehicleUseGroupByArgs['orderBy'] }
        : { orderBy?: ValueOfVehicleUseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ValueOfVehicleUseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetValueOfVehicleUseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ValueOfVehicleUse model
   */
  readonly fields: ValueOfVehicleUseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ValueOfVehicleUse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ValueOfVehicleUseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ValueOfVehicleUse model
   */ 
  interface ValueOfVehicleUseFieldRefs {
    readonly ValueOfVehicleUselID: FieldRef<"ValueOfVehicleUse", 'Int'>
    readonly Year: FieldRef<"ValueOfVehicleUse", 'Int'>
    readonly Month: FieldRef<"ValueOfVehicleUse", 'Int'>
    readonly GroupOfVehicle: FieldRef<"ValueOfVehicleUse", 'Int'>
    readonly Value: FieldRef<"ValueOfVehicleUse", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ValueOfVehicleUse findUnique
   */
  export type ValueOfVehicleUseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUse
     */
    select?: ValueOfVehicleUseSelect<ExtArgs> | null
    /**
     * Filter, which ValueOfVehicleUse to fetch.
     */
    where: ValueOfVehicleUseWhereUniqueInput
  }

  /**
   * ValueOfVehicleUse findUniqueOrThrow
   */
  export type ValueOfVehicleUseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUse
     */
    select?: ValueOfVehicleUseSelect<ExtArgs> | null
    /**
     * Filter, which ValueOfVehicleUse to fetch.
     */
    where: ValueOfVehicleUseWhereUniqueInput
  }

  /**
   * ValueOfVehicleUse findFirst
   */
  export type ValueOfVehicleUseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUse
     */
    select?: ValueOfVehicleUseSelect<ExtArgs> | null
    /**
     * Filter, which ValueOfVehicleUse to fetch.
     */
    where?: ValueOfVehicleUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValueOfVehicleUses to fetch.
     */
    orderBy?: ValueOfVehicleUseOrderByWithRelationInput | ValueOfVehicleUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ValueOfVehicleUses.
     */
    cursor?: ValueOfVehicleUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValueOfVehicleUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValueOfVehicleUses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ValueOfVehicleUses.
     */
    distinct?: ValueOfVehicleUseScalarFieldEnum | ValueOfVehicleUseScalarFieldEnum[]
  }

  /**
   * ValueOfVehicleUse findFirstOrThrow
   */
  export type ValueOfVehicleUseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUse
     */
    select?: ValueOfVehicleUseSelect<ExtArgs> | null
    /**
     * Filter, which ValueOfVehicleUse to fetch.
     */
    where?: ValueOfVehicleUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValueOfVehicleUses to fetch.
     */
    orderBy?: ValueOfVehicleUseOrderByWithRelationInput | ValueOfVehicleUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ValueOfVehicleUses.
     */
    cursor?: ValueOfVehicleUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValueOfVehicleUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValueOfVehicleUses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ValueOfVehicleUses.
     */
    distinct?: ValueOfVehicleUseScalarFieldEnum | ValueOfVehicleUseScalarFieldEnum[]
  }

  /**
   * ValueOfVehicleUse findMany
   */
  export type ValueOfVehicleUseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUse
     */
    select?: ValueOfVehicleUseSelect<ExtArgs> | null
    /**
     * Filter, which ValueOfVehicleUses to fetch.
     */
    where?: ValueOfVehicleUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValueOfVehicleUses to fetch.
     */
    orderBy?: ValueOfVehicleUseOrderByWithRelationInput | ValueOfVehicleUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ValueOfVehicleUses.
     */
    cursor?: ValueOfVehicleUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValueOfVehicleUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValueOfVehicleUses.
     */
    skip?: number
    distinct?: ValueOfVehicleUseScalarFieldEnum | ValueOfVehicleUseScalarFieldEnum[]
  }

  /**
   * ValueOfVehicleUse create
   */
  export type ValueOfVehicleUseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUse
     */
    select?: ValueOfVehicleUseSelect<ExtArgs> | null
    /**
     * The data needed to create a ValueOfVehicleUse.
     */
    data: XOR<ValueOfVehicleUseCreateInput, ValueOfVehicleUseUncheckedCreateInput>
  }

  /**
   * ValueOfVehicleUse createMany
   */
  export type ValueOfVehicleUseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ValueOfVehicleUses.
     */
    data: ValueOfVehicleUseCreateManyInput | ValueOfVehicleUseCreateManyInput[]
  }

  /**
   * ValueOfVehicleUse update
   */
  export type ValueOfVehicleUseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUse
     */
    select?: ValueOfVehicleUseSelect<ExtArgs> | null
    /**
     * The data needed to update a ValueOfVehicleUse.
     */
    data: XOR<ValueOfVehicleUseUpdateInput, ValueOfVehicleUseUncheckedUpdateInput>
    /**
     * Choose, which ValueOfVehicleUse to update.
     */
    where: ValueOfVehicleUseWhereUniqueInput
  }

  /**
   * ValueOfVehicleUse updateMany
   */
  export type ValueOfVehicleUseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ValueOfVehicleUses.
     */
    data: XOR<ValueOfVehicleUseUpdateManyMutationInput, ValueOfVehicleUseUncheckedUpdateManyInput>
    /**
     * Filter which ValueOfVehicleUses to update
     */
    where?: ValueOfVehicleUseWhereInput
  }

  /**
   * ValueOfVehicleUse upsert
   */
  export type ValueOfVehicleUseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUse
     */
    select?: ValueOfVehicleUseSelect<ExtArgs> | null
    /**
     * The filter to search for the ValueOfVehicleUse to update in case it exists.
     */
    where: ValueOfVehicleUseWhereUniqueInput
    /**
     * In case the ValueOfVehicleUse found by the `where` argument doesn't exist, create a new ValueOfVehicleUse with this data.
     */
    create: XOR<ValueOfVehicleUseCreateInput, ValueOfVehicleUseUncheckedCreateInput>
    /**
     * In case the ValueOfVehicleUse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ValueOfVehicleUseUpdateInput, ValueOfVehicleUseUncheckedUpdateInput>
  }

  /**
   * ValueOfVehicleUse delete
   */
  export type ValueOfVehicleUseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUse
     */
    select?: ValueOfVehicleUseSelect<ExtArgs> | null
    /**
     * Filter which ValueOfVehicleUse to delete.
     */
    where: ValueOfVehicleUseWhereUniqueInput
  }

  /**
   * ValueOfVehicleUse deleteMany
   */
  export type ValueOfVehicleUseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ValueOfVehicleUses to delete
     */
    where?: ValueOfVehicleUseWhereInput
  }

  /**
   * ValueOfVehicleUse without action
   */
  export type ValueOfVehicleUseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUse
     */
    select?: ValueOfVehicleUseSelect<ExtArgs> | null
  }


  /**
   * Model ValueOfVehicleUseByDetile
   */

  export type AggregateValueOfVehicleUseByDetile = {
    _count: ValueOfVehicleUseByDetileCountAggregateOutputType | null
    _avg: ValueOfVehicleUseByDetileAvgAggregateOutputType | null
    _sum: ValueOfVehicleUseByDetileSumAggregateOutputType | null
    _min: ValueOfVehicleUseByDetileMinAggregateOutputType | null
    _max: ValueOfVehicleUseByDetileMaxAggregateOutputType | null
  }

  export type ValueOfVehicleUseByDetileAvgAggregateOutputType = {
    ID: number | null
    Year: number | null
    RegistryYear: number | null
    VehicleCode: number | null
    ProductCode: number | null
    ModelCode: number | null
    FuelType: number | null
    Automatic: number | null
    Hybrid: number | null
    GreenGrade: number | null
    PolutionGrade: number | null
    EngineVolume: number | null
    Weight: number | null
    ListPrice: number | null
    AjustedPrice: number | null
    Value: number | null
  }

  export type ValueOfVehicleUseByDetileSumAggregateOutputType = {
    ID: number | null
    Year: number | null
    RegistryYear: number | null
    VehicleCode: number | null
    ProductCode: number | null
    ModelCode: number | null
    FuelType: number | null
    Automatic: number | null
    Hybrid: number | null
    GreenGrade: number | null
    PolutionGrade: number | null
    EngineVolume: number | null
    Weight: number | null
    ListPrice: number | null
    AjustedPrice: number | null
    Value: number | null
  }

  export type ValueOfVehicleUseByDetileMinAggregateOutputType = {
    ID: number | null
    Year: number | null
    RegistryYear: number | null
    VehicleCode: number | null
    ProductCode: number | null
    ProductName: string | null
    ModelCode: number | null
    ModelName: string | null
    FuelType: number | null
    CommercialName: string | null
    Automatic: number | null
    Hybrid: number | null
    GreenGrade: number | null
    PolutionGrade: number | null
    EngineVolume: number | null
    Weight: number | null
    BeginDate: Date | null
    ListPrice: number | null
    AjustedPrice: number | null
    Value: number | null
  }

  export type ValueOfVehicleUseByDetileMaxAggregateOutputType = {
    ID: number | null
    Year: number | null
    RegistryYear: number | null
    VehicleCode: number | null
    ProductCode: number | null
    ProductName: string | null
    ModelCode: number | null
    ModelName: string | null
    FuelType: number | null
    CommercialName: string | null
    Automatic: number | null
    Hybrid: number | null
    GreenGrade: number | null
    PolutionGrade: number | null
    EngineVolume: number | null
    Weight: number | null
    BeginDate: Date | null
    ListPrice: number | null
    AjustedPrice: number | null
    Value: number | null
  }

  export type ValueOfVehicleUseByDetileCountAggregateOutputType = {
    ID: number
    Year: number
    RegistryYear: number
    VehicleCode: number
    ProductCode: number
    ProductName: number
    ModelCode: number
    ModelName: number
    FuelType: number
    CommercialName: number
    Automatic: number
    Hybrid: number
    GreenGrade: number
    PolutionGrade: number
    EngineVolume: number
    Weight: number
    BeginDate: number
    ListPrice: number
    AjustedPrice: number
    Value: number
    _all: number
  }


  export type ValueOfVehicleUseByDetileAvgAggregateInputType = {
    ID?: true
    Year?: true
    RegistryYear?: true
    VehicleCode?: true
    ProductCode?: true
    ModelCode?: true
    FuelType?: true
    Automatic?: true
    Hybrid?: true
    GreenGrade?: true
    PolutionGrade?: true
    EngineVolume?: true
    Weight?: true
    ListPrice?: true
    AjustedPrice?: true
    Value?: true
  }

  export type ValueOfVehicleUseByDetileSumAggregateInputType = {
    ID?: true
    Year?: true
    RegistryYear?: true
    VehicleCode?: true
    ProductCode?: true
    ModelCode?: true
    FuelType?: true
    Automatic?: true
    Hybrid?: true
    GreenGrade?: true
    PolutionGrade?: true
    EngineVolume?: true
    Weight?: true
    ListPrice?: true
    AjustedPrice?: true
    Value?: true
  }

  export type ValueOfVehicleUseByDetileMinAggregateInputType = {
    ID?: true
    Year?: true
    RegistryYear?: true
    VehicleCode?: true
    ProductCode?: true
    ProductName?: true
    ModelCode?: true
    ModelName?: true
    FuelType?: true
    CommercialName?: true
    Automatic?: true
    Hybrid?: true
    GreenGrade?: true
    PolutionGrade?: true
    EngineVolume?: true
    Weight?: true
    BeginDate?: true
    ListPrice?: true
    AjustedPrice?: true
    Value?: true
  }

  export type ValueOfVehicleUseByDetileMaxAggregateInputType = {
    ID?: true
    Year?: true
    RegistryYear?: true
    VehicleCode?: true
    ProductCode?: true
    ProductName?: true
    ModelCode?: true
    ModelName?: true
    FuelType?: true
    CommercialName?: true
    Automatic?: true
    Hybrid?: true
    GreenGrade?: true
    PolutionGrade?: true
    EngineVolume?: true
    Weight?: true
    BeginDate?: true
    ListPrice?: true
    AjustedPrice?: true
    Value?: true
  }

  export type ValueOfVehicleUseByDetileCountAggregateInputType = {
    ID?: true
    Year?: true
    RegistryYear?: true
    VehicleCode?: true
    ProductCode?: true
    ProductName?: true
    ModelCode?: true
    ModelName?: true
    FuelType?: true
    CommercialName?: true
    Automatic?: true
    Hybrid?: true
    GreenGrade?: true
    PolutionGrade?: true
    EngineVolume?: true
    Weight?: true
    BeginDate?: true
    ListPrice?: true
    AjustedPrice?: true
    Value?: true
    _all?: true
  }

  export type ValueOfVehicleUseByDetileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ValueOfVehicleUseByDetile to aggregate.
     */
    where?: ValueOfVehicleUseByDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValueOfVehicleUseByDetiles to fetch.
     */
    orderBy?: ValueOfVehicleUseByDetileOrderByWithRelationInput | ValueOfVehicleUseByDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ValueOfVehicleUseByDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValueOfVehicleUseByDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValueOfVehicleUseByDetiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ValueOfVehicleUseByDetiles
    **/
    _count?: true | ValueOfVehicleUseByDetileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ValueOfVehicleUseByDetileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ValueOfVehicleUseByDetileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ValueOfVehicleUseByDetileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ValueOfVehicleUseByDetileMaxAggregateInputType
  }

  export type GetValueOfVehicleUseByDetileAggregateType<T extends ValueOfVehicleUseByDetileAggregateArgs> = {
        [P in keyof T & keyof AggregateValueOfVehicleUseByDetile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateValueOfVehicleUseByDetile[P]>
      : GetScalarType<T[P], AggregateValueOfVehicleUseByDetile[P]>
  }




  export type ValueOfVehicleUseByDetileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValueOfVehicleUseByDetileWhereInput
    orderBy?: ValueOfVehicleUseByDetileOrderByWithAggregationInput | ValueOfVehicleUseByDetileOrderByWithAggregationInput[]
    by: ValueOfVehicleUseByDetileScalarFieldEnum[] | ValueOfVehicleUseByDetileScalarFieldEnum
    having?: ValueOfVehicleUseByDetileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ValueOfVehicleUseByDetileCountAggregateInputType | true
    _avg?: ValueOfVehicleUseByDetileAvgAggregateInputType
    _sum?: ValueOfVehicleUseByDetileSumAggregateInputType
    _min?: ValueOfVehicleUseByDetileMinAggregateInputType
    _max?: ValueOfVehicleUseByDetileMaxAggregateInputType
  }

  export type ValueOfVehicleUseByDetileGroupByOutputType = {
    ID: number
    Year: number
    RegistryYear: number
    VehicleCode: number
    ProductCode: number
    ProductName: string
    ModelCode: number
    ModelName: string
    FuelType: number | null
    CommercialName: string | null
    Automatic: number | null
    Hybrid: number | null
    GreenGrade: number | null
    PolutionGrade: number | null
    EngineVolume: number | null
    Weight: number | null
    BeginDate: Date | null
    ListPrice: number | null
    AjustedPrice: number | null
    Value: number | null
    _count: ValueOfVehicleUseByDetileCountAggregateOutputType | null
    _avg: ValueOfVehicleUseByDetileAvgAggregateOutputType | null
    _sum: ValueOfVehicleUseByDetileSumAggregateOutputType | null
    _min: ValueOfVehicleUseByDetileMinAggregateOutputType | null
    _max: ValueOfVehicleUseByDetileMaxAggregateOutputType | null
  }

  type GetValueOfVehicleUseByDetileGroupByPayload<T extends ValueOfVehicleUseByDetileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ValueOfVehicleUseByDetileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ValueOfVehicleUseByDetileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ValueOfVehicleUseByDetileGroupByOutputType[P]>
            : GetScalarType<T[P], ValueOfVehicleUseByDetileGroupByOutputType[P]>
        }
      >
    >


  export type ValueOfVehicleUseByDetileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Year?: boolean
    RegistryYear?: boolean
    VehicleCode?: boolean
    ProductCode?: boolean
    ProductName?: boolean
    ModelCode?: boolean
    ModelName?: boolean
    FuelType?: boolean
    CommercialName?: boolean
    Automatic?: boolean
    Hybrid?: boolean
    GreenGrade?: boolean
    PolutionGrade?: boolean
    EngineVolume?: boolean
    Weight?: boolean
    BeginDate?: boolean
    ListPrice?: boolean
    AjustedPrice?: boolean
    Value?: boolean
  }, ExtArgs["result"]["valueOfVehicleUseByDetile"]>


  export type ValueOfVehicleUseByDetileSelectScalar = {
    ID?: boolean
    Year?: boolean
    RegistryYear?: boolean
    VehicleCode?: boolean
    ProductCode?: boolean
    ProductName?: boolean
    ModelCode?: boolean
    ModelName?: boolean
    FuelType?: boolean
    CommercialName?: boolean
    Automatic?: boolean
    Hybrid?: boolean
    GreenGrade?: boolean
    PolutionGrade?: boolean
    EngineVolume?: boolean
    Weight?: boolean
    BeginDate?: boolean
    ListPrice?: boolean
    AjustedPrice?: boolean
    Value?: boolean
  }


  export type $ValueOfVehicleUseByDetilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ValueOfVehicleUseByDetile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Year: number
      RegistryYear: number
      VehicleCode: number
      ProductCode: number
      ProductName: string
      ModelCode: number
      ModelName: string
      FuelType: number | null
      CommercialName: string | null
      Automatic: number | null
      Hybrid: number | null
      GreenGrade: number | null
      PolutionGrade: number | null
      EngineVolume: number | null
      Weight: number | null
      BeginDate: Date | null
      ListPrice: number | null
      AjustedPrice: number | null
      Value: number | null
    }, ExtArgs["result"]["valueOfVehicleUseByDetile"]>
    composites: {}
  }

  type ValueOfVehicleUseByDetileGetPayload<S extends boolean | null | undefined | ValueOfVehicleUseByDetileDefaultArgs> = $Result.GetResult<Prisma.$ValueOfVehicleUseByDetilePayload, S>

  type ValueOfVehicleUseByDetileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ValueOfVehicleUseByDetileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ValueOfVehicleUseByDetileCountAggregateInputType | true
    }

  export interface ValueOfVehicleUseByDetileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ValueOfVehicleUseByDetile'], meta: { name: 'ValueOfVehicleUseByDetile' } }
    /**
     * Find zero or one ValueOfVehicleUseByDetile that matches the filter.
     * @param {ValueOfVehicleUseByDetileFindUniqueArgs} args - Arguments to find a ValueOfVehicleUseByDetile
     * @example
     * // Get one ValueOfVehicleUseByDetile
     * const valueOfVehicleUseByDetile = await prisma.valueOfVehicleUseByDetile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ValueOfVehicleUseByDetileFindUniqueArgs>(args: SelectSubset<T, ValueOfVehicleUseByDetileFindUniqueArgs<ExtArgs>>): Prisma__ValueOfVehicleUseByDetileClient<$Result.GetResult<Prisma.$ValueOfVehicleUseByDetilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ValueOfVehicleUseByDetile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ValueOfVehicleUseByDetileFindUniqueOrThrowArgs} args - Arguments to find a ValueOfVehicleUseByDetile
     * @example
     * // Get one ValueOfVehicleUseByDetile
     * const valueOfVehicleUseByDetile = await prisma.valueOfVehicleUseByDetile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ValueOfVehicleUseByDetileFindUniqueOrThrowArgs>(args: SelectSubset<T, ValueOfVehicleUseByDetileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ValueOfVehicleUseByDetileClient<$Result.GetResult<Prisma.$ValueOfVehicleUseByDetilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ValueOfVehicleUseByDetile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseByDetileFindFirstArgs} args - Arguments to find a ValueOfVehicleUseByDetile
     * @example
     * // Get one ValueOfVehicleUseByDetile
     * const valueOfVehicleUseByDetile = await prisma.valueOfVehicleUseByDetile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ValueOfVehicleUseByDetileFindFirstArgs>(args?: SelectSubset<T, ValueOfVehicleUseByDetileFindFirstArgs<ExtArgs>>): Prisma__ValueOfVehicleUseByDetileClient<$Result.GetResult<Prisma.$ValueOfVehicleUseByDetilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ValueOfVehicleUseByDetile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseByDetileFindFirstOrThrowArgs} args - Arguments to find a ValueOfVehicleUseByDetile
     * @example
     * // Get one ValueOfVehicleUseByDetile
     * const valueOfVehicleUseByDetile = await prisma.valueOfVehicleUseByDetile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ValueOfVehicleUseByDetileFindFirstOrThrowArgs>(args?: SelectSubset<T, ValueOfVehicleUseByDetileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ValueOfVehicleUseByDetileClient<$Result.GetResult<Prisma.$ValueOfVehicleUseByDetilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ValueOfVehicleUseByDetiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseByDetileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ValueOfVehicleUseByDetiles
     * const valueOfVehicleUseByDetiles = await prisma.valueOfVehicleUseByDetile.findMany()
     * 
     * // Get first 10 ValueOfVehicleUseByDetiles
     * const valueOfVehicleUseByDetiles = await prisma.valueOfVehicleUseByDetile.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const valueOfVehicleUseByDetileWithIDOnly = await prisma.valueOfVehicleUseByDetile.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends ValueOfVehicleUseByDetileFindManyArgs>(args?: SelectSubset<T, ValueOfVehicleUseByDetileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValueOfVehicleUseByDetilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ValueOfVehicleUseByDetile.
     * @param {ValueOfVehicleUseByDetileCreateArgs} args - Arguments to create a ValueOfVehicleUseByDetile.
     * @example
     * // Create one ValueOfVehicleUseByDetile
     * const ValueOfVehicleUseByDetile = await prisma.valueOfVehicleUseByDetile.create({
     *   data: {
     *     // ... data to create a ValueOfVehicleUseByDetile
     *   }
     * })
     * 
     */
    create<T extends ValueOfVehicleUseByDetileCreateArgs>(args: SelectSubset<T, ValueOfVehicleUseByDetileCreateArgs<ExtArgs>>): Prisma__ValueOfVehicleUseByDetileClient<$Result.GetResult<Prisma.$ValueOfVehicleUseByDetilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ValueOfVehicleUseByDetiles.
     * @param {ValueOfVehicleUseByDetileCreateManyArgs} args - Arguments to create many ValueOfVehicleUseByDetiles.
     * @example
     * // Create many ValueOfVehicleUseByDetiles
     * const valueOfVehicleUseByDetile = await prisma.valueOfVehicleUseByDetile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ValueOfVehicleUseByDetileCreateManyArgs>(args?: SelectSubset<T, ValueOfVehicleUseByDetileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ValueOfVehicleUseByDetile.
     * @param {ValueOfVehicleUseByDetileDeleteArgs} args - Arguments to delete one ValueOfVehicleUseByDetile.
     * @example
     * // Delete one ValueOfVehicleUseByDetile
     * const ValueOfVehicleUseByDetile = await prisma.valueOfVehicleUseByDetile.delete({
     *   where: {
     *     // ... filter to delete one ValueOfVehicleUseByDetile
     *   }
     * })
     * 
     */
    delete<T extends ValueOfVehicleUseByDetileDeleteArgs>(args: SelectSubset<T, ValueOfVehicleUseByDetileDeleteArgs<ExtArgs>>): Prisma__ValueOfVehicleUseByDetileClient<$Result.GetResult<Prisma.$ValueOfVehicleUseByDetilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ValueOfVehicleUseByDetile.
     * @param {ValueOfVehicleUseByDetileUpdateArgs} args - Arguments to update one ValueOfVehicleUseByDetile.
     * @example
     * // Update one ValueOfVehicleUseByDetile
     * const valueOfVehicleUseByDetile = await prisma.valueOfVehicleUseByDetile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ValueOfVehicleUseByDetileUpdateArgs>(args: SelectSubset<T, ValueOfVehicleUseByDetileUpdateArgs<ExtArgs>>): Prisma__ValueOfVehicleUseByDetileClient<$Result.GetResult<Prisma.$ValueOfVehicleUseByDetilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ValueOfVehicleUseByDetiles.
     * @param {ValueOfVehicleUseByDetileDeleteManyArgs} args - Arguments to filter ValueOfVehicleUseByDetiles to delete.
     * @example
     * // Delete a few ValueOfVehicleUseByDetiles
     * const { count } = await prisma.valueOfVehicleUseByDetile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ValueOfVehicleUseByDetileDeleteManyArgs>(args?: SelectSubset<T, ValueOfVehicleUseByDetileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ValueOfVehicleUseByDetiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseByDetileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ValueOfVehicleUseByDetiles
     * const valueOfVehicleUseByDetile = await prisma.valueOfVehicleUseByDetile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ValueOfVehicleUseByDetileUpdateManyArgs>(args: SelectSubset<T, ValueOfVehicleUseByDetileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ValueOfVehicleUseByDetile.
     * @param {ValueOfVehicleUseByDetileUpsertArgs} args - Arguments to update or create a ValueOfVehicleUseByDetile.
     * @example
     * // Update or create a ValueOfVehicleUseByDetile
     * const valueOfVehicleUseByDetile = await prisma.valueOfVehicleUseByDetile.upsert({
     *   create: {
     *     // ... data to create a ValueOfVehicleUseByDetile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ValueOfVehicleUseByDetile we want to update
     *   }
     * })
     */
    upsert<T extends ValueOfVehicleUseByDetileUpsertArgs>(args: SelectSubset<T, ValueOfVehicleUseByDetileUpsertArgs<ExtArgs>>): Prisma__ValueOfVehicleUseByDetileClient<$Result.GetResult<Prisma.$ValueOfVehicleUseByDetilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ValueOfVehicleUseByDetiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseByDetileCountArgs} args - Arguments to filter ValueOfVehicleUseByDetiles to count.
     * @example
     * // Count the number of ValueOfVehicleUseByDetiles
     * const count = await prisma.valueOfVehicleUseByDetile.count({
     *   where: {
     *     // ... the filter for the ValueOfVehicleUseByDetiles we want to count
     *   }
     * })
    **/
    count<T extends ValueOfVehicleUseByDetileCountArgs>(
      args?: Subset<T, ValueOfVehicleUseByDetileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ValueOfVehicleUseByDetileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ValueOfVehicleUseByDetile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseByDetileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ValueOfVehicleUseByDetileAggregateArgs>(args: Subset<T, ValueOfVehicleUseByDetileAggregateArgs>): Prisma.PrismaPromise<GetValueOfVehicleUseByDetileAggregateType<T>>

    /**
     * Group by ValueOfVehicleUseByDetile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValueOfVehicleUseByDetileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ValueOfVehicleUseByDetileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ValueOfVehicleUseByDetileGroupByArgs['orderBy'] }
        : { orderBy?: ValueOfVehicleUseByDetileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ValueOfVehicleUseByDetileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetValueOfVehicleUseByDetileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ValueOfVehicleUseByDetile model
   */
  readonly fields: ValueOfVehicleUseByDetileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ValueOfVehicleUseByDetile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ValueOfVehicleUseByDetileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ValueOfVehicleUseByDetile model
   */ 
  interface ValueOfVehicleUseByDetileFieldRefs {
    readonly ID: FieldRef<"ValueOfVehicleUseByDetile", 'Int'>
    readonly Year: FieldRef<"ValueOfVehicleUseByDetile", 'Float'>
    readonly RegistryYear: FieldRef<"ValueOfVehicleUseByDetile", 'Int'>
    readonly VehicleCode: FieldRef<"ValueOfVehicleUseByDetile", 'Int'>
    readonly ProductCode: FieldRef<"ValueOfVehicleUseByDetile", 'Int'>
    readonly ProductName: FieldRef<"ValueOfVehicleUseByDetile", 'String'>
    readonly ModelCode: FieldRef<"ValueOfVehicleUseByDetile", 'Int'>
    readonly ModelName: FieldRef<"ValueOfVehicleUseByDetile", 'String'>
    readonly FuelType: FieldRef<"ValueOfVehicleUseByDetile", 'Int'>
    readonly CommercialName: FieldRef<"ValueOfVehicleUseByDetile", 'String'>
    readonly Automatic: FieldRef<"ValueOfVehicleUseByDetile", 'Int'>
    readonly Hybrid: FieldRef<"ValueOfVehicleUseByDetile", 'Int'>
    readonly GreenGrade: FieldRef<"ValueOfVehicleUseByDetile", 'Int'>
    readonly PolutionGrade: FieldRef<"ValueOfVehicleUseByDetile", 'Int'>
    readonly EngineVolume: FieldRef<"ValueOfVehicleUseByDetile", 'Int'>
    readonly Weight: FieldRef<"ValueOfVehicleUseByDetile", 'Float'>
    readonly BeginDate: FieldRef<"ValueOfVehicleUseByDetile", 'DateTime'>
    readonly ListPrice: FieldRef<"ValueOfVehicleUseByDetile", 'Float'>
    readonly AjustedPrice: FieldRef<"ValueOfVehicleUseByDetile", 'Float'>
    readonly Value: FieldRef<"ValueOfVehicleUseByDetile", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ValueOfVehicleUseByDetile findUnique
   */
  export type ValueOfVehicleUseByDetileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUseByDetile
     */
    select?: ValueOfVehicleUseByDetileSelect<ExtArgs> | null
    /**
     * Filter, which ValueOfVehicleUseByDetile to fetch.
     */
    where: ValueOfVehicleUseByDetileWhereUniqueInput
  }

  /**
   * ValueOfVehicleUseByDetile findUniqueOrThrow
   */
  export type ValueOfVehicleUseByDetileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUseByDetile
     */
    select?: ValueOfVehicleUseByDetileSelect<ExtArgs> | null
    /**
     * Filter, which ValueOfVehicleUseByDetile to fetch.
     */
    where: ValueOfVehicleUseByDetileWhereUniqueInput
  }

  /**
   * ValueOfVehicleUseByDetile findFirst
   */
  export type ValueOfVehicleUseByDetileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUseByDetile
     */
    select?: ValueOfVehicleUseByDetileSelect<ExtArgs> | null
    /**
     * Filter, which ValueOfVehicleUseByDetile to fetch.
     */
    where?: ValueOfVehicleUseByDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValueOfVehicleUseByDetiles to fetch.
     */
    orderBy?: ValueOfVehicleUseByDetileOrderByWithRelationInput | ValueOfVehicleUseByDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ValueOfVehicleUseByDetiles.
     */
    cursor?: ValueOfVehicleUseByDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValueOfVehicleUseByDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValueOfVehicleUseByDetiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ValueOfVehicleUseByDetiles.
     */
    distinct?: ValueOfVehicleUseByDetileScalarFieldEnum | ValueOfVehicleUseByDetileScalarFieldEnum[]
  }

  /**
   * ValueOfVehicleUseByDetile findFirstOrThrow
   */
  export type ValueOfVehicleUseByDetileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUseByDetile
     */
    select?: ValueOfVehicleUseByDetileSelect<ExtArgs> | null
    /**
     * Filter, which ValueOfVehicleUseByDetile to fetch.
     */
    where?: ValueOfVehicleUseByDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValueOfVehicleUseByDetiles to fetch.
     */
    orderBy?: ValueOfVehicleUseByDetileOrderByWithRelationInput | ValueOfVehicleUseByDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ValueOfVehicleUseByDetiles.
     */
    cursor?: ValueOfVehicleUseByDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValueOfVehicleUseByDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValueOfVehicleUseByDetiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ValueOfVehicleUseByDetiles.
     */
    distinct?: ValueOfVehicleUseByDetileScalarFieldEnum | ValueOfVehicleUseByDetileScalarFieldEnum[]
  }

  /**
   * ValueOfVehicleUseByDetile findMany
   */
  export type ValueOfVehicleUseByDetileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUseByDetile
     */
    select?: ValueOfVehicleUseByDetileSelect<ExtArgs> | null
    /**
     * Filter, which ValueOfVehicleUseByDetiles to fetch.
     */
    where?: ValueOfVehicleUseByDetileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValueOfVehicleUseByDetiles to fetch.
     */
    orderBy?: ValueOfVehicleUseByDetileOrderByWithRelationInput | ValueOfVehicleUseByDetileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ValueOfVehicleUseByDetiles.
     */
    cursor?: ValueOfVehicleUseByDetileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValueOfVehicleUseByDetiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValueOfVehicleUseByDetiles.
     */
    skip?: number
    distinct?: ValueOfVehicleUseByDetileScalarFieldEnum | ValueOfVehicleUseByDetileScalarFieldEnum[]
  }

  /**
   * ValueOfVehicleUseByDetile create
   */
  export type ValueOfVehicleUseByDetileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUseByDetile
     */
    select?: ValueOfVehicleUseByDetileSelect<ExtArgs> | null
    /**
     * The data needed to create a ValueOfVehicleUseByDetile.
     */
    data: XOR<ValueOfVehicleUseByDetileCreateInput, ValueOfVehicleUseByDetileUncheckedCreateInput>
  }

  /**
   * ValueOfVehicleUseByDetile createMany
   */
  export type ValueOfVehicleUseByDetileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ValueOfVehicleUseByDetiles.
     */
    data: ValueOfVehicleUseByDetileCreateManyInput | ValueOfVehicleUseByDetileCreateManyInput[]
  }

  /**
   * ValueOfVehicleUseByDetile update
   */
  export type ValueOfVehicleUseByDetileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUseByDetile
     */
    select?: ValueOfVehicleUseByDetileSelect<ExtArgs> | null
    /**
     * The data needed to update a ValueOfVehicleUseByDetile.
     */
    data: XOR<ValueOfVehicleUseByDetileUpdateInput, ValueOfVehicleUseByDetileUncheckedUpdateInput>
    /**
     * Choose, which ValueOfVehicleUseByDetile to update.
     */
    where: ValueOfVehicleUseByDetileWhereUniqueInput
  }

  /**
   * ValueOfVehicleUseByDetile updateMany
   */
  export type ValueOfVehicleUseByDetileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ValueOfVehicleUseByDetiles.
     */
    data: XOR<ValueOfVehicleUseByDetileUpdateManyMutationInput, ValueOfVehicleUseByDetileUncheckedUpdateManyInput>
    /**
     * Filter which ValueOfVehicleUseByDetiles to update
     */
    where?: ValueOfVehicleUseByDetileWhereInput
  }

  /**
   * ValueOfVehicleUseByDetile upsert
   */
  export type ValueOfVehicleUseByDetileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUseByDetile
     */
    select?: ValueOfVehicleUseByDetileSelect<ExtArgs> | null
    /**
     * The filter to search for the ValueOfVehicleUseByDetile to update in case it exists.
     */
    where: ValueOfVehicleUseByDetileWhereUniqueInput
    /**
     * In case the ValueOfVehicleUseByDetile found by the `where` argument doesn't exist, create a new ValueOfVehicleUseByDetile with this data.
     */
    create: XOR<ValueOfVehicleUseByDetileCreateInput, ValueOfVehicleUseByDetileUncheckedCreateInput>
    /**
     * In case the ValueOfVehicleUseByDetile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ValueOfVehicleUseByDetileUpdateInput, ValueOfVehicleUseByDetileUncheckedUpdateInput>
  }

  /**
   * ValueOfVehicleUseByDetile delete
   */
  export type ValueOfVehicleUseByDetileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUseByDetile
     */
    select?: ValueOfVehicleUseByDetileSelect<ExtArgs> | null
    /**
     * Filter which ValueOfVehicleUseByDetile to delete.
     */
    where: ValueOfVehicleUseByDetileWhereUniqueInput
  }

  /**
   * ValueOfVehicleUseByDetile deleteMany
   */
  export type ValueOfVehicleUseByDetileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ValueOfVehicleUseByDetiles to delete
     */
    where?: ValueOfVehicleUseByDetileWhereInput
  }

  /**
   * ValueOfVehicleUseByDetile without action
   */
  export type ValueOfVehicleUseByDetileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValueOfVehicleUseByDetile
     */
    select?: ValueOfVehicleUseByDetileSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdvanceNoticeScalarFieldEnum: {
    AdvanceNoticeID: 'AdvanceNoticeID',
    StartPeriod: 'StartPeriod',
    EndPeriod: 'EndPeriod',
    DaysOfNotice: 'DaysOfNotice'
  };

  export type AdvanceNoticeScalarFieldEnum = (typeof AdvanceNoticeScalarFieldEnum)[keyof typeof AdvanceNoticeScalarFieldEnum]


  export const AutoWordReportScalarFieldEnum: {
    ReportID: 'ReportID',
    ReportName: 'ReportName',
    ReportTemplateName: 'ReportTemplateName',
    IsEmployee: 'IsEmployee',
    IsCustomer: 'IsCustomer',
    StrSQL: 'StrSQL',
    IsChossCustomerOrEmployee: 'IsChossCustomerOrEmployee',
    SaveInArchive: 'SaveInArchive',
    IsView: 'IsView'
  };

  export type AutoWordReportScalarFieldEnum = (typeof AutoWordReportScalarFieldEnum)[keyof typeof AutoWordReportScalarFieldEnum]


  export const AutoWordReportSubScalarFieldEnum: {
    ReportSubID: 'ReportSubID',
    ReportID: 'ReportID',
    FieldNameTB: 'FieldNameTB',
    FieldNameReport: 'FieldNameReport'
  };

  export type AutoWordReportSubScalarFieldEnum = (typeof AutoWordReportSubScalarFieldEnum)[keyof typeof AutoWordReportSubScalarFieldEnum]


  export const ChangeHistoryScalarFieldEnum: {
    ChangeHistoryID: 'ChangeHistoryID',
    Application_Name: 'Application_Name',
    ChangeDate: 'ChangeDate',
    Version_Number: 'Version_Number',
    ChangeDescription: 'ChangeDescription',
    ConvertDatabase: 'ConvertDatabase'
  };

  export type ChangeHistoryScalarFieldEnum = (typeof ChangeHistoryScalarFieldEnum)[keyof typeof ChangeHistoryScalarFieldEnum]


  export const CitysIncomeTaxDiscountScalarFieldEnum: {
    ID: 'ID',
    Year: 'Year',
    GroupCode: 'GroupCode',
    CityName: 'CityName',
    DiscountPercent: 'DiscountPercent',
    MaximumIncome: 'MaximumIncome',
    MaximumIncomePerMonth: 'MaximumIncomePerMonth'
  };

  export type CitysIncomeTaxDiscountScalarFieldEnum = (typeof CitysIncomeTaxDiscountScalarFieldEnum)[keyof typeof CitysIncomeTaxDiscountScalarFieldEnum]


  export const CompaniesScalarFieldEnum: {
    CompanyID: 'CompanyID',
    CompanyID_OLD: 'CompanyID_OLD',
    CompanyNumber: 'CompanyNumber',
    DeductionsNumber: 'DeductionsNumber',
    AgencyNumber: 'AgencyNumber',
    CompanyName: 'CompanyName',
    CompanyNameEng: 'CompanyNameEng',
    Address: 'Address',
    CityID: 'CityID',
    ZipCode: 'ZipCode',
    POB: 'POB',
    POB_ZipCode: 'POB_ZipCode',
    Email: 'Email',
    WebSite: 'WebSite',
    Phone: 'Phone',
    Fax: 'Fax',
    NumOfPaySlipDisplay: 'NumOfPaySlipDisplay',
    PaySlipDefinitionID: 'PaySlipDefinitionID',
    DbPathOnCloud: 'DbPathOnCloud',
    DocFilesPathOnCloud: 'DocFilesPathOnCloud',
    DbPathAgricultureCRM: 'DbPathAgricultureCRM',
    DisplayTypeID: 'DisplayTypeID',
    IsSuperAdminCompany: 'IsSuperAdminCompany',
    IsActive: 'IsActive',
    IsExportAccounts: 'IsExportAccounts',
    TaxAccountsToken: 'TaxAccountsToken',
    IsGetTaxAccountsCode: 'IsGetTaxAccountsCode',
    CompanyTaxAutoLink: 'CompanyTaxAutoLink',
    UserId: 'UserId',
    CompanyTypeID: 'CompanyTypeID'
  };

  export type CompaniesScalarFieldEnum = (typeof CompaniesScalarFieldEnum)[keyof typeof CompaniesScalarFieldEnum]


  export const CompaniesProductsScalarFieldEnum: {
    CompaniesProductsId: 'CompaniesProductsId',
    CreatedAt: 'CreatedAt',
    ProductId: 'ProductId',
    CompanyID: 'CompanyID',
    UserId: 'UserId',
    LastVersionDate_Salary: 'LastVersionDate_Salary',
    LastVersionDate_ManPower: 'LastVersionDate_ManPower'
  };

  export type CompaniesProductsScalarFieldEnum = (typeof CompaniesProductsScalarFieldEnum)[keyof typeof CompaniesProductsScalarFieldEnum]


  export const CompaniesProductsExpireDatesScalarFieldEnum: {
    CompaniesProductsExpireDateId: 'CompaniesProductsExpireDateId',
    CreatedAt: 'CreatedAt',
    ProductId: 'ProductId',
    CompanyID: 'CompanyID',
    StartDate: 'StartDate',
    EndDate: 'EndDate',
    Comments: 'Comments',
    UserId: 'UserId'
  };

  export type CompaniesProductsExpireDatesScalarFieldEnum = (typeof CompaniesProductsExpireDatesScalarFieldEnum)[keyof typeof CompaniesProductsExpireDatesScalarFieldEnum]


  export const CompaniesTypeScalarFieldEnum: {
    CompaniesTypeID: 'CompaniesTypeID',
    CompaniesType: 'CompaniesType'
  };

  export type CompaniesTypeScalarFieldEnum = (typeof CompaniesTypeScalarFieldEnum)[keyof typeof CompaniesTypeScalarFieldEnum]


  export const CompaniesUsersScalarFieldEnum: {
    CompaniesUsersID: 'CompaniesUsersID',
    CompanyID: 'CompanyID',
    CompanyID_OLD: 'CompanyID_OLD',
    EmployeeIdentity: 'EmployeeIdentity',
    BirthDate: 'BirthDate',
    LastName: 'LastName',
    FirstName: 'FirstName',
    JobsID: 'JobsID',
    Gender: 'Gender',
    MobileNumber: 'MobileNumber',
    Phone: 'Phone',
    Fax: 'Fax',
    Email: 'Email',
    UserName: 'UserName',
    Password: 'Password',
    AreaMan: 'AreaMan',
    IsAdmin: 'IsAdmin',
    LastEntry: 'LastEntry',
    IsAllowAccess2WebSite: 'IsAllowAccess2WebSite',
    UserId: 'UserId',
    CreatedAt: 'CreatedAt',
    TwoFactorBase32Secret: 'TwoFactorBase32Secret',
    DeviceData: 'DeviceData'
  };

  export type CompaniesUsersScalarFieldEnum = (typeof CompaniesUsersScalarFieldEnum)[keyof typeof CompaniesUsersScalarFieldEnum]


  export const CompaniesUsersProductsExpireDatesScalarFieldEnum: {
    CompaniesUsersProductsExpireDateId: 'CompaniesUsersProductsExpireDateId',
    CreatedAt: 'CreatedAt',
    ProductId: 'ProductId',
    CompanyID: 'CompanyID',
    CompaniesUsersID: 'CompaniesUsersID',
    StartDate: 'StartDate',
    EndDate: 'EndDate',
    UserId: 'UserId',
    Comments: 'Comments'
  };

  export type CompaniesUsersProductsExpireDatesScalarFieldEnum = (typeof CompaniesUsersProductsExpireDatesScalarFieldEnum)[keyof typeof CompaniesUsersProductsExpireDatesScalarFieldEnum]


  export const CopyrightScalarFieldEnum: {
    CopyrightID: 'CopyrightID',
    Copyright: 'Copyright',
    DbGeneralVer: 'DbGeneralVer'
  };

  export type CopyrightScalarFieldEnum = (typeof CopyrightScalarFieldEnum)[keyof typeof CopyrightScalarFieldEnum]


  export const CountriesScalarFieldEnum: {
    CountryID: 'CountryID',
    CountryCode: 'CountryCode',
    CountryName: 'CountryName',
    CountryNameEnglish: 'CountryNameEnglish',
    MultipleSelect: 'MultipleSelect',
    CommentPayslip: 'CommentPayslip',
    CommentHour: 'CommentHour',
    DefaultLanguageCol: 'DefaultLanguageCol'
  };

  export type CountriesScalarFieldEnum = (typeof CountriesScalarFieldEnum)[keyof typeof CountriesScalarFieldEnum]


  export const CreditShiftScalarFieldEnum: {
    CreditShiftID: 'CreditShiftID',
    CreditShiftDate: 'CreditShiftDate',
    MaxCreditShiftPrecent: 'MaxCreditShiftPrecent',
    MaxCreditShiftLimit: 'MaxCreditShiftLimit',
    CreditPrecent: 'CreditPrecent'
  };

  export type CreditShiftScalarFieldEnum = (typeof CreditShiftScalarFieldEnum)[keyof typeof CreditShiftScalarFieldEnum]


  export const DaysInMonthScalarFieldEnum: {
    DateManagedID: 'DateManagedID',
    DateManaged: 'DateManaged',
    YearManaged: 'YearManaged',
    MonthManaged: 'MonthManaged',
    DayInMonth: 'DayInMonth',
    DayInWeek: 'DayInWeek',
    WeekInYear: 'WeekInYear',
    WeekInMonth: 'WeekInMonth',
    DayTypeID: 'DayTypeID',
    StartEndTimeSabat: 'StartEndTimeSabat',
    HolidayName: 'HolidayName'
  };

  export type DaysInMonthScalarFieldEnum = (typeof DaysInMonthScalarFieldEnum)[keyof typeof DaysInMonthScalarFieldEnum]


  export const DaysInMonth_NewYearScalarFieldEnum: {
    DateManagedID: 'DateManagedID',
    DateManaged: 'DateManaged',
    YearManaged: 'YearManaged',
    MonthManaged: 'MonthManaged',
    DayInMonth: 'DayInMonth',
    DayInWeek: 'DayInWeek',
    WeekInYear: 'WeekInYear',
    WeekInMonth: 'WeekInMonth',
    DayTypeID: 'DayTypeID',
    StartEndTimeSabat: 'StartEndTimeSabat',
    HolidayName: 'HolidayName'
  };

  export type DaysInMonth_NewYearScalarFieldEnum = (typeof DaysInMonth_NewYearScalarFieldEnum)[keyof typeof DaysInMonth_NewYearScalarFieldEnum]


  export const DayTypeScalarFieldEnum: {
    DayTypeID: 'DayTypeID',
    DayTypeName: 'DayTypeName',
    SetOrder: 'SetOrder'
  };

  export type DayTypeScalarFieldEnum = (typeof DayTypeScalarFieldEnum)[keyof typeof DayTypeScalarFieldEnum]


  export const DisplayTypeScalarFieldEnum: {
    DisplayTypeID: 'DisplayTypeID',
    DisplayType: 'DisplayType',
    URL: 'URL',
    IsShowInDanzarCRM: 'IsShowInDanzarCRM'
  };

  export type DisplayTypeScalarFieldEnum = (typeof DisplayTypeScalarFieldEnum)[keyof typeof DisplayTypeScalarFieldEnum]


  export const HashIndexGeneralScalarFieldEnum: {
    HashCode: 'HashCode',
    HashName: 'HashName'
  };

  export type HashIndexGeneralScalarFieldEnum = (typeof HashIndexGeneralScalarFieldEnum)[keyof typeof HashIndexGeneralScalarFieldEnum]


  export const HashSecurityScalarFieldEnum: {
    HashID: 'HashID',
    HashCode: 'HashCode',
    IsUse: 'IsUse'
  };

  export type HashSecurityScalarFieldEnum = (typeof HashSecurityScalarFieldEnum)[keyof typeof HashSecurityScalarFieldEnum]


  export const JobsScalarFieldEnum: {
    JobsID: 'JobsID',
    JobTitle: 'JobTitle'
  };

  export type JobsScalarFieldEnum = (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum]


  export const KupaGemelScalarFieldEnum: {
    KupaID: 'KupaID',
    KupaName: 'KupaName',
    AllowanceEmployeePercent: 'AllowanceEmployeePercent',
    AllowanceEmployerPercent: 'AllowanceEmployerPercent',
    AllowanceCompensationPercen: 'AllowanceCompensationPercen',
    IsAndromedaRecord: 'IsAndromedaRecord',
    EducationFundPercentEmp: 'EducationFundPercentEmp',
    EducationFundPercentEmpoyer: 'EducationFundPercentEmpoyer'
  };

  export type KupaGemelScalarFieldEnum = (typeof KupaGemelScalarFieldEnum)[keyof typeof KupaGemelScalarFieldEnum]


  export const LandPagesScalarFieldEnum: {
    LandPageRowId: 'LandPageRowId',
    CompanyID: 'CompanyID',
    CreatedAt: 'CreatedAt',
    JsonData: 'JsonData',
    ViewDate: 'ViewDate',
    CompletedDate: 'CompletedDate'
  };

  export type LandPagesScalarFieldEnum = (typeof LandPagesScalarFieldEnum)[keyof typeof LandPagesScalarFieldEnum]


  export const LanguageDefinitionScalarFieldEnum: {
    LanguageDefinitionID: 'LanguageDefinitionID',
    ObjectName: 'ObjectName',
    ControlTypeID: 'ControlTypeID',
    ControlName: 'ControlName',
    CaptionEnglish: 'CaptionEnglish',
    CaptionHebrow: 'CaptionHebrow',
    CaptionRomanian: 'CaptionRomanian',
    CaptionRussian: 'CaptionRussian',
    CaptionChinese: 'CaptionChinese',
    CaptionTurkish: 'CaptionTurkish'
  };

  export type LanguageDefinitionScalarFieldEnum = (typeof LanguageDefinitionScalarFieldEnum)[keyof typeof LanguageDefinitionScalarFieldEnum]


  export const Lkup_AreaScalarFieldEnum: {
    AreaID: 'AreaID',
    AreaCode: 'AreaCode',
    AreaName: 'AreaName',
    Amount: 'Amount'
  };

  export type Lkup_AreaScalarFieldEnum = (typeof Lkup_AreaScalarFieldEnum)[keyof typeof Lkup_AreaScalarFieldEnum]


  export const Lkup_BanksScalarFieldEnum: {
    BankID: 'BankID',
    BankName: 'BankName',
    BankNumber: 'BankNumber',
    CountryID: 'CountryID'
  };

  export type Lkup_BanksScalarFieldEnum = (typeof Lkup_BanksScalarFieldEnum)[keyof typeof Lkup_BanksScalarFieldEnum]


  export const Lkup_BanksVerBranchScalarFieldEnum: {
    BranchID: 'BranchID',
    BankID: 'BankID',
    BranchName: 'BranchName',
    BranchCode: 'BranchCode',
    Address: 'Address',
    SortCode: 'SortCode',
    Phone_1: 'Phone_1',
    Phone_2: 'Phone_2',
    FaxNumber: 'FaxNumber',
    EMail: 'EMail',
    Comment: 'Comment'
  };

  export type Lkup_BanksVerBranchScalarFieldEnum = (typeof Lkup_BanksVerBranchScalarFieldEnum)[keyof typeof Lkup_BanksVerBranchScalarFieldEnum]


  export const Lkup_CityScalarFieldEnum: {
    CityID: 'CityID',
    CityCode: 'CityCode',
    CityName: 'CityName',
    CityNameEng: 'CityNameEng'
  };

  export type Lkup_CityScalarFieldEnum = (typeof Lkup_CityScalarFieldEnum)[keyof typeof Lkup_CityScalarFieldEnum]


  export const Lkup_CorporationScalarFieldEnum: {
    CorporationID: 'CorporationID',
    CorporationName: 'CorporationName',
    IsActive: 'IsActive',
    CorporationNumber: 'CorporationNumber',
    Address: 'Address',
    Email: 'Email',
    Phone: 'Phone',
    Cfo_email: 'Cfo_email',
    Contact_name: 'Contact_name',
    Contact_phone: 'Contact_phone',
    Ops_email: 'Ops_email',
    SoftTalkTaxToken: 'SoftTalkTaxToken',
    CorporationAutoLink: 'CorporationAutoLink'
  };

  export type Lkup_CorporationScalarFieldEnum = (typeof Lkup_CorporationScalarFieldEnum)[keyof typeof Lkup_CorporationScalarFieldEnum]


  export const Lkup_CountryScalarFieldEnum: {
    CountryID: 'CountryID',
    CountryCode: 'CountryCode',
    CountryName: 'CountryName',
    CountryNameEnglish: 'CountryNameEnglish',
    MultipleSelect: 'MultipleSelect'
  };

  export type Lkup_CountryScalarFieldEnum = (typeof Lkup_CountryScalarFieldEnum)[keyof typeof Lkup_CountryScalarFieldEnum]


  export const Lkup_CreaditCardScalarFieldEnum: {
    CardID: 'CardID',
    CardName: 'CardName',
    CardCode: 'CardCode'
  };

  export type Lkup_CreaditCardScalarFieldEnum = (typeof Lkup_CreaditCardScalarFieldEnum)[keyof typeof Lkup_CreaditCardScalarFieldEnum]


  export const Lkup_EmployeesTypeScalarFieldEnum: {
    TypeID: 'TypeID',
    TypeName: 'TypeName'
  };

  export type Lkup_EmployeesTypeScalarFieldEnum = (typeof Lkup_EmployeesTypeScalarFieldEnum)[keyof typeof Lkup_EmployeesTypeScalarFieldEnum]


  export const Lkup_LanguageScalarFieldEnum: {
    LanguageID: 'LanguageID',
    LanguageName: 'LanguageName'
  };

  export type Lkup_LanguageScalarFieldEnum = (typeof Lkup_LanguageScalarFieldEnum)[keyof typeof Lkup_LanguageScalarFieldEnum]


  export const Lkup_PaySlipScalarFieldEnum: {
    PaySlipCode: 'PaySlipCode',
    PaySlipName: 'PaySlipName',
    PaySlipNameSource: 'PaySlipNameSource',
    IsTytle: 'IsTytle'
  };

  export type Lkup_PaySlipScalarFieldEnum = (typeof Lkup_PaySlipScalarFieldEnum)[keyof typeof Lkup_PaySlipScalarFieldEnum]


  export const Lkup_SectorScalarFieldEnum: {
    SectorID: 'SectorID',
    SectorCode: 'SectorCode',
    SectorName: 'SectorName'
  };

  export type Lkup_SectorScalarFieldEnum = (typeof Lkup_SectorScalarFieldEnum)[keyof typeof Lkup_SectorScalarFieldEnum]


  export const Lkup_SocialSecuritySectorScalarFieldEnum: {
    SocialSecurityID: 'SocialSecurityID',
    SocialSecurityCode: 'SocialSecurityCode',
    SocialSecurityName: 'SocialSecurityName'
  };

  export type Lkup_SocialSecuritySectorScalarFieldEnum = (typeof Lkup_SocialSecuritySectorScalarFieldEnum)[keyof typeof Lkup_SocialSecuritySectorScalarFieldEnum]


  export const Lkup_streetScalarFieldEnum: {
    StrretID: 'StrretID',
    StreetName: 'StreetName',
    StreetCode: 'StreetCode',
    Citycode: 'Citycode',
    StreetNameEng: 'StreetNameEng'
  };

  export type Lkup_streetScalarFieldEnum = (typeof Lkup_streetScalarFieldEnum)[keyof typeof Lkup_streetScalarFieldEnum]


  export const PensionDetailScalarFieldEnum: {
    PensionDetailID: 'PensionDetailID',
    TypePension: 'TypePension',
    StartYearPension: 'StartYearPension',
    EmployerRate: 'EmployerRate',
    EmployeeRate: 'EmployeeRate',
    EmployerCompensationRate: 'EmployerCompensationRate',
    TotalPensionRate: 'TotalPensionRate',
    AvarageSalaryPension: 'AvarageSalaryPension',
    Deposit: 'Deposit'
  };

  export type PensionDetailScalarFieldEnum = (typeof PensionDetailScalarFieldEnum)[keyof typeof PensionDetailScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    ProductsId: 'ProductsId',
    ProductName: 'ProductName',
    ProductDescription: 'ProductDescription'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const RankScalarFieldEnum: {
    RankID: 'RankID',
    SectorCode: 'SectorCode',
    RankYear: 'RankYear',
    RankMonth: 'RankMonth',
    RankCode: 'RankCode',
    RankName: 'RankName',
    Salary: 'Salary',
    RankNumber: 'RankNumber'
  };

  export type RankScalarFieldEnum = (typeof RankScalarFieldEnum)[keyof typeof RankScalarFieldEnum]


  export const RecoveryDefinitionScalarFieldEnum: {
    RecoveryDefinitionID: 'RecoveryDefinitionID',
    RecoveryDefinitionName: 'RecoveryDefinitionName',
    RecoveryYear: 'RecoveryYear'
  };

  export type RecoveryDefinitionScalarFieldEnum = (typeof RecoveryDefinitionScalarFieldEnum)[keyof typeof RecoveryDefinitionScalarFieldEnum]


  export const RecoveryDefinitionDetailsScalarFieldEnum: {
    RewardRecoveryVectorID: 'RewardRecoveryVectorID',
    RecoveryDefinitionID: 'RecoveryDefinitionID',
    StartYearRewardRecovery: 'StartYearRewardRecovery',
    EndYearRewardRecovery: 'EndYearRewardRecovery',
    RecoveryDayQuantity: 'RecoveryDayQuantity',
    RecoveryYearDescription: 'RecoveryYearDescription'
  };

  export type RecoveryDefinitionDetailsScalarFieldEnum = (typeof RecoveryDefinitionDetailsScalarFieldEnum)[keyof typeof RecoveryDefinitionDetailsScalarFieldEnum]


  export const RecoveryDefinitionRateDetailsScalarFieldEnum: {
    RecoveryRewardID: 'RecoveryRewardID',
    RecoveryDefinitionID: 'RecoveryDefinitionID',
    RewardYearMonth: 'RewardYearMonth',
    RecoveryRewardRatePerDay: 'RecoveryRewardRatePerDay'
  };

  export type RecoveryDefinitionRateDetailsScalarFieldEnum = (typeof RecoveryDefinitionRateDetailsScalarFieldEnum)[keyof typeof RecoveryDefinitionRateDetailsScalarFieldEnum]


  export const ReportDefinitionsScalarFieldEnum: {
    ReportID: 'ReportID',
    ReportName: 'ReportName',
    OrderBy: 'OrderBy',
    FieldName: 'FieldName',
    Caption: 'Caption',
    Color: 'Color',
    Background: 'Background',
    ColumnWidth: 'ColumnWidth',
    FontStyle: 'FontStyle',
    FontSize: 'FontSize',
    ReportTitle: 'ReportTitle',
    IsSum: 'IsSum',
    ColorIndex: 'ColorIndex'
  };

  export type ReportDefinitionsScalarFieldEnum = (typeof ReportDefinitionsScalarFieldEnum)[keyof typeof ReportDefinitionsScalarFieldEnum]


  export const RewardRecoveryRateScalarFieldEnum: {
    RecoveryRewardID: 'RecoveryRewardID',
    RewardYear: 'RewardYear',
    RecoveryRewardRatePerDay: 'RecoveryRewardRatePerDay'
  };

  export type RewardRecoveryRateScalarFieldEnum = (typeof RewardRecoveryRateScalarFieldEnum)[keyof typeof RewardRecoveryRateScalarFieldEnum]


  export const RewardRecoveryVectorScalarFieldEnum: {
    RewardRecoveryVectorID: 'RewardRecoveryVectorID',
    StartYearRewardRecovery: 'StartYearRewardRecovery',
    EndYearRewardRecovery: 'EndYearRewardRecovery',
    RecoveryDayQuantity: 'RecoveryDayQuantity'
  };

  export type RewardRecoveryVectorScalarFieldEnum = (typeof RewardRecoveryVectorScalarFieldEnum)[keyof typeof RewardRecoveryVectorScalarFieldEnum]


  export const RewardSickVectorScalarFieldEnum: {
    RewardSickVectorID: 'RewardSickVectorID',
    StartYearRewardSick: 'StartYearRewardSick',
    EndYearRewardSick: 'EndYearRewardSick',
    SickDayQuantity: 'SickDayQuantity'
  };

  export type RewardSickVectorScalarFieldEnum = (typeof RewardSickVectorScalarFieldEnum)[keyof typeof RewardSickVectorScalarFieldEnum]


  export const RewardVacationVectorScalarFieldEnum: {
    RewardVocationVectorID: 'RewardVocationVectorID',
    StartYearRewardVocation: 'StartYearRewardVocation',
    EndYearRewardVocation: 'EndYearRewardVocation',
    VocationDayQuantity6days: 'VocationDayQuantity6days',
    VocationDayQuantity5days: 'VocationDayQuantity5days'
  };

  export type RewardVacationVectorScalarFieldEnum = (typeof RewardVacationVectorScalarFieldEnum)[keyof typeof RewardVacationVectorScalarFieldEnum]


  export const SickDefinitionScalarFieldEnum: {
    SickDefinitionID: 'SickDefinitionID',
    SickDescription: 'SickDescription'
  };

  export type SickDefinitionScalarFieldEnum = (typeof SickDefinitionScalarFieldEnum)[keyof typeof SickDefinitionScalarFieldEnum]


  export const SickDefinitionDetailScalarFieldEnum: {
    RewardSickVectorID: 'RewardSickVectorID',
    SickDefinitionID: 'SickDefinitionID',
    StartYearRewardSick: 'StartYearRewardSick',
    EndYearRewardSick: 'EndYearRewardSick',
    SickDayQuantity: 'SickDayQuantity',
    SocialYearDescription: 'SocialYearDescription'
  };

  export type SickDefinitionDetailScalarFieldEnum = (typeof SickDefinitionDetailScalarFieldEnum)[keyof typeof SickDefinitionDetailScalarFieldEnum]


  export const SocialSecurityScalarFieldEnum: {
    SocialSecurityID: 'SocialSecurityID',
    SocialSecurityYear: 'SocialSecurityYear',
    SocialSecurityMonth: 'SocialSecurityMonth',
    CurrentSocialSecurity: 'CurrentSocialSecurity',
    MinAccountTotalForDivuach: 'MinAccountTotalForDivuach'
  };

  export type SocialSecurityScalarFieldEnum = (typeof SocialSecurityScalarFieldEnum)[keyof typeof SocialSecurityScalarFieldEnum]


  export const SocialSecurityDetileScalarFieldEnum: {
    SocialSecurityDetailID: 'SocialSecurityDetailID',
    SocialSecurityID: 'SocialSecurityID',
    SocialYear: 'SocialYear',
    SocialMonth: 'SocialMonth',
    Sector: 'Sector',
    SocialSecurityCode: 'SocialSecurityCode',
    AverageSalary: 'AverageSalary',
    MinNationalInsByMony: 'MinNationalInsByMony',
    MaxNationalInsByMony: 'MaxNationalInsByMony',
    MinDeductionNationalInsByMony: 'MinDeductionNationalInsByMony',
    MinNationalInsByEmployee: 'MinNationalInsByEmployee',
    MaxNationalInsByEmployee: 'MaxNationalInsByEmployee',
    MinNationalInsByEmployer: 'MinNationalInsByEmployer',
    MaxNationalInsByEmployer: 'MaxNationalInsByEmployer',
    MaxNationalInsByMonyEmployee: 'MaxNationalInsByMonyEmployee',
    AverageEmbodiment: 'AverageEmbodiment',
    DeductionMax: 'DeductionMax',
    DeductionPercent: 'DeductionPercent',
    CreditPoint: 'CreditPoint',
    FactorToReduction: 'FactorToReduction',
    MinHoursToPay: 'MinHoursToPay',
    MinimumPayFor5Day: 'MinimumPayFor5Day',
    MinimumPayFor6Day: 'MinimumPayFor6Day',
    MaxPrecentReduction: 'MaxPrecentReduction',
    hourPerDayfor5: 'hourPerDayfor5',
    hourPerDayfor6: 'hourPerDayfor6',
    hourInfridayDay: 'hourInfridayDay',
    TaxPrecent: 'TaxPrecent',
    EmployerTax: 'EmployerTax',
    DiscountInTaxInEilat: 'DiscountInTaxInEilat',
    TaxUnitNumber: 'TaxUnitNumber',
    FundPercentConstruction: 'FundPercentConstruction',
    Hour100: 'Hour100',
    Hour125: 'Hour125',
    Hour150: 'Hour150',
    Hour175: 'Hour175',
    Hour200: 'Hour200',
    CreditCardMan: 'CreditCardMan',
    CreditCardWoman: 'CreditCardWoman',
    CreditCardChild: 'CreditCardChild',
    CreditCardBaby: 'CreditCardBaby',
    CreditCardInAddition: 'CreditCardInAddition',
    CreditCardLackMobilityChild: 'CreditCardLackMobilityChild',
    CreditCardImmigrant18: 'CreditCardImmigrant18',
    ControlingShareholder: 'ControlingShareholder',
    HealthInsuranceEmployeeLow: 'HealthInsuranceEmployeeLow',
    HealthInsuranceEmployeeAbove: 'HealthInsuranceEmployeeAbove',
    HealthInsuranceEmployerLow: 'HealthInsuranceEmployerLow',
    HealthInsuranceEmployerAbove: 'HealthInsuranceEmployerAbove',
    ValueOfVehicleUseHibberdDiscount: 'ValueOfVehicleUseHibberdDiscount',
    Deposit: 'Deposit',
    ValueOfMobileUse: 'ValueOfMobileUse',
    PensionCeiling: 'PensionCeiling',
    PensionCredit: 'PensionCredit',
    DepositEmployerPrecent: 'DepositEmployerPrecent',
    DepositEmployeePrecent: 'DepositEmployeePrecent',
    TotalHourPerWeek: 'TotalHourPerWeek',
    CreditCardAdultChild: 'CreditCardAdultChild',
    CreditCardChild1_5: 'CreditCardChild1_5',
    DepositEmployeePrecentExecption: 'DepositEmployeePrecentExecption'
  };

  export type SocialSecurityDetileScalarFieldEnum = (typeof SocialSecurityDetileScalarFieldEnum)[keyof typeof SocialSecurityDetileScalarFieldEnum]


  export const SysdiagramsScalarFieldEnum: {
    name: 'name',
    principal_id: 'principal_id',
    diagram_id: 'diagram_id',
    version: 'version',
    definition: 'definition'
  };

  export type SysdiagramsScalarFieldEnum = (typeof SysdiagramsScalarFieldEnum)[keyof typeof SysdiagramsScalarFieldEnum]


  export const SystemDefinitionScalarFieldEnum: {
    SystemDefinitionId: 'SystemDefinitionId',
    CreatedAt: 'CreatedAt',
    FieldDescription: 'FieldDescription',
    FieldValue: 'FieldValue'
  };

  export type SystemDefinitionScalarFieldEnum = (typeof SystemDefinitionScalarFieldEnum)[keyof typeof SystemDefinitionScalarFieldEnum]


  export const SystemMaintenancScalarFieldEnum: {
    SystemMaintenancID: 'SystemMaintenancID',
    UserMsg: 'UserMsg',
    LogOutFrequency: 'LogOutFrequency',
    SystemMaintenanc: 'SystemMaintenanc'
  };

  export type SystemMaintenancScalarFieldEnum = (typeof SystemMaintenancScalarFieldEnum)[keyof typeof SystemMaintenancScalarFieldEnum]


  export const TaxStepDetileScalarFieldEnum: {
    TaxStepDetileID: 'TaxStepDetileID',
    TaxStapID: 'TaxStapID',
    TaxYear: 'TaxYear',
    TaxMonth: 'TaxMonth',
    StepNumber: 'StepNumber',
    TaxStap: 'TaxStap',
    TaxStapPercent: 'TaxStapPercent'
  };

  export type TaxStepDetileScalarFieldEnum = (typeof TaxStepDetileScalarFieldEnum)[keyof typeof TaxStepDetileScalarFieldEnum]


  export const TaxStepsScalarFieldEnum: {
    TaxStapID: 'TaxStapID',
    TaxMonth: 'TaxMonth',
    TaxYear: 'TaxYear',
    CurrentTaxStep: 'CurrentTaxStep'
  };

  export type TaxStepsScalarFieldEnum = (typeof TaxStepsScalarFieldEnum)[keyof typeof TaxStepsScalarFieldEnum]


  export const UnionFeeScalarFieldEnum: {
    ID: 'ID',
    UnionCode: 'UnionCode',
    UnionName: 'UnionName'
  };

  export type UnionFeeScalarFieldEnum = (typeof UnionFeeScalarFieldEnum)[keyof typeof UnionFeeScalarFieldEnum]


  export const UnionFeeDetileScalarFieldEnum: {
    ID: 'ID',
    UnionCode: 'UnionCode',
    SocialYear: 'SocialYear',
    SocialMonth: 'SocialMonth',
    FeePercentage_No: 'FeePercentage_No',
    FeePercentage_Yes: 'FeePercentage_Yes',
    MaxFee: 'MaxFee',
    MaxAdminFee: 'MaxAdminFee'
  };

  export type UnionFeeDetileScalarFieldEnum = (typeof UnionFeeDetileScalarFieldEnum)[keyof typeof UnionFeeDetileScalarFieldEnum]


  export const VacationDefinitionDetailsScalarFieldEnum: {
    VacationlDefinitionDetaillID: 'VacationlDefinitionDetaillID',
    VacationlDefinitionID: 'VacationlDefinitionID',
    StartMonthReward: 'StartMonthReward',
    EndMonthrReward: 'EndMonthrReward',
    DayQuantity6days: 'DayQuantity6days',
    DayQuantity5days: 'DayQuantity5days',
    SocialYearDescription: 'SocialYearDescription',
    DayQuantity: 'DayQuantity'
  };

  export type VacationDefinitionDetailsScalarFieldEnum = (typeof VacationDefinitionDetailsScalarFieldEnum)[keyof typeof VacationDefinitionDetailsScalarFieldEnum]


  export const VacationlDefinitionScalarFieldEnum: {
    VacationlDefinitionID: 'VacationlDefinitionID',
    VacationlDefinitionName: 'VacationlDefinitionName'
  };

  export type VacationlDefinitionScalarFieldEnum = (typeof VacationlDefinitionScalarFieldEnum)[keyof typeof VacationlDefinitionScalarFieldEnum]


  export const ValueOfVehicleUseScalarFieldEnum: {
    ValueOfVehicleUselID: 'ValueOfVehicleUselID',
    Year: 'Year',
    Month: 'Month',
    GroupOfVehicle: 'GroupOfVehicle',
    Value: 'Value'
  };

  export type ValueOfVehicleUseScalarFieldEnum = (typeof ValueOfVehicleUseScalarFieldEnum)[keyof typeof ValueOfVehicleUseScalarFieldEnum]


  export const ValueOfVehicleUseByDetileScalarFieldEnum: {
    ID: 'ID',
    Year: 'Year',
    RegistryYear: 'RegistryYear',
    VehicleCode: 'VehicleCode',
    ProductCode: 'ProductCode',
    ProductName: 'ProductName',
    ModelCode: 'ModelCode',
    ModelName: 'ModelName',
    FuelType: 'FuelType',
    CommercialName: 'CommercialName',
    Automatic: 'Automatic',
    Hybrid: 'Hybrid',
    GreenGrade: 'GreenGrade',
    PolutionGrade: 'PolutionGrade',
    EngineVolume: 'EngineVolume',
    Weight: 'Weight',
    BeginDate: 'BeginDate',
    ListPrice: 'ListPrice',
    AjustedPrice: 'AjustedPrice',
    Value: 'Value'
  };

  export type ValueOfVehicleUseByDetileScalarFieldEnum = (typeof ValueOfVehicleUseByDetileScalarFieldEnum)[keyof typeof ValueOfVehicleUseByDetileScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    
  /**
   * Deep Input Types
   */


  export type AdvanceNoticeWhereInput = {
    AND?: AdvanceNoticeWhereInput | AdvanceNoticeWhereInput[]
    OR?: AdvanceNoticeWhereInput[]
    NOT?: AdvanceNoticeWhereInput | AdvanceNoticeWhereInput[]
    AdvanceNoticeID?: IntFilter<"AdvanceNotice"> | number
    StartPeriod?: FloatNullableFilter<"AdvanceNotice"> | number | null
    EndPeriod?: FloatNullableFilter<"AdvanceNotice"> | number | null
    DaysOfNotice?: FloatNullableFilter<"AdvanceNotice"> | number | null
  }

  export type AdvanceNoticeOrderByWithRelationInput = {
    AdvanceNoticeID?: SortOrder
    StartPeriod?: SortOrderInput | SortOrder
    EndPeriod?: SortOrderInput | SortOrder
    DaysOfNotice?: SortOrderInput | SortOrder
  }

  export type AdvanceNoticeWhereUniqueInput = Prisma.AtLeast<{
    AdvanceNoticeID?: number
    AND?: AdvanceNoticeWhereInput | AdvanceNoticeWhereInput[]
    OR?: AdvanceNoticeWhereInput[]
    NOT?: AdvanceNoticeWhereInput | AdvanceNoticeWhereInput[]
    StartPeriod?: FloatNullableFilter<"AdvanceNotice"> | number | null
    EndPeriod?: FloatNullableFilter<"AdvanceNotice"> | number | null
    DaysOfNotice?: FloatNullableFilter<"AdvanceNotice"> | number | null
  }, "AdvanceNoticeID">

  export type AdvanceNoticeOrderByWithAggregationInput = {
    AdvanceNoticeID?: SortOrder
    StartPeriod?: SortOrderInput | SortOrder
    EndPeriod?: SortOrderInput | SortOrder
    DaysOfNotice?: SortOrderInput | SortOrder
    _count?: AdvanceNoticeCountOrderByAggregateInput
    _avg?: AdvanceNoticeAvgOrderByAggregateInput
    _max?: AdvanceNoticeMaxOrderByAggregateInput
    _min?: AdvanceNoticeMinOrderByAggregateInput
    _sum?: AdvanceNoticeSumOrderByAggregateInput
  }

  export type AdvanceNoticeScalarWhereWithAggregatesInput = {
    AND?: AdvanceNoticeScalarWhereWithAggregatesInput | AdvanceNoticeScalarWhereWithAggregatesInput[]
    OR?: AdvanceNoticeScalarWhereWithAggregatesInput[]
    NOT?: AdvanceNoticeScalarWhereWithAggregatesInput | AdvanceNoticeScalarWhereWithAggregatesInput[]
    AdvanceNoticeID?: IntWithAggregatesFilter<"AdvanceNotice"> | number
    StartPeriod?: FloatNullableWithAggregatesFilter<"AdvanceNotice"> | number | null
    EndPeriod?: FloatNullableWithAggregatesFilter<"AdvanceNotice"> | number | null
    DaysOfNotice?: FloatNullableWithAggregatesFilter<"AdvanceNotice"> | number | null
  }

  export type AutoWordReportWhereInput = {
    AND?: AutoWordReportWhereInput | AutoWordReportWhereInput[]
    OR?: AutoWordReportWhereInput[]
    NOT?: AutoWordReportWhereInput | AutoWordReportWhereInput[]
    ReportID?: IntFilter<"AutoWordReport"> | number
    ReportName?: StringNullableFilter<"AutoWordReport"> | string | null
    ReportTemplateName?: StringNullableFilter<"AutoWordReport"> | string | null
    IsEmployee?: BoolFilter<"AutoWordReport"> | boolean
    IsCustomer?: BoolFilter<"AutoWordReport"> | boolean
    StrSQL?: StringNullableFilter<"AutoWordReport"> | string | null
    IsChossCustomerOrEmployee?: BoolFilter<"AutoWordReport"> | boolean
    SaveInArchive?: IntNullableFilter<"AutoWordReport"> | number | null
    IsView?: BoolFilter<"AutoWordReport"> | boolean
    AutoWordReportSub?: AutoWordReportSubListRelationFilter
  }

  export type AutoWordReportOrderByWithRelationInput = {
    ReportID?: SortOrder
    ReportName?: SortOrderInput | SortOrder
    ReportTemplateName?: SortOrderInput | SortOrder
    IsEmployee?: SortOrder
    IsCustomer?: SortOrder
    StrSQL?: SortOrderInput | SortOrder
    IsChossCustomerOrEmployee?: SortOrder
    SaveInArchive?: SortOrderInput | SortOrder
    IsView?: SortOrder
    AutoWordReportSub?: AutoWordReportSubOrderByRelationAggregateInput
  }

  export type AutoWordReportWhereUniqueInput = Prisma.AtLeast<{
    ReportID?: number
    AND?: AutoWordReportWhereInput | AutoWordReportWhereInput[]
    OR?: AutoWordReportWhereInput[]
    NOT?: AutoWordReportWhereInput | AutoWordReportWhereInput[]
    ReportName?: StringNullableFilter<"AutoWordReport"> | string | null
    ReportTemplateName?: StringNullableFilter<"AutoWordReport"> | string | null
    IsEmployee?: BoolFilter<"AutoWordReport"> | boolean
    IsCustomer?: BoolFilter<"AutoWordReport"> | boolean
    StrSQL?: StringNullableFilter<"AutoWordReport"> | string | null
    IsChossCustomerOrEmployee?: BoolFilter<"AutoWordReport"> | boolean
    SaveInArchive?: IntNullableFilter<"AutoWordReport"> | number | null
    IsView?: BoolFilter<"AutoWordReport"> | boolean
    AutoWordReportSub?: AutoWordReportSubListRelationFilter
  }, "ReportID">

  export type AutoWordReportOrderByWithAggregationInput = {
    ReportID?: SortOrder
    ReportName?: SortOrderInput | SortOrder
    ReportTemplateName?: SortOrderInput | SortOrder
    IsEmployee?: SortOrder
    IsCustomer?: SortOrder
    StrSQL?: SortOrderInput | SortOrder
    IsChossCustomerOrEmployee?: SortOrder
    SaveInArchive?: SortOrderInput | SortOrder
    IsView?: SortOrder
    _count?: AutoWordReportCountOrderByAggregateInput
    _avg?: AutoWordReportAvgOrderByAggregateInput
    _max?: AutoWordReportMaxOrderByAggregateInput
    _min?: AutoWordReportMinOrderByAggregateInput
    _sum?: AutoWordReportSumOrderByAggregateInput
  }

  export type AutoWordReportScalarWhereWithAggregatesInput = {
    AND?: AutoWordReportScalarWhereWithAggregatesInput | AutoWordReportScalarWhereWithAggregatesInput[]
    OR?: AutoWordReportScalarWhereWithAggregatesInput[]
    NOT?: AutoWordReportScalarWhereWithAggregatesInput | AutoWordReportScalarWhereWithAggregatesInput[]
    ReportID?: IntWithAggregatesFilter<"AutoWordReport"> | number
    ReportName?: StringNullableWithAggregatesFilter<"AutoWordReport"> | string | null
    ReportTemplateName?: StringNullableWithAggregatesFilter<"AutoWordReport"> | string | null
    IsEmployee?: BoolWithAggregatesFilter<"AutoWordReport"> | boolean
    IsCustomer?: BoolWithAggregatesFilter<"AutoWordReport"> | boolean
    StrSQL?: StringNullableWithAggregatesFilter<"AutoWordReport"> | string | null
    IsChossCustomerOrEmployee?: BoolWithAggregatesFilter<"AutoWordReport"> | boolean
    SaveInArchive?: IntNullableWithAggregatesFilter<"AutoWordReport"> | number | null
    IsView?: BoolWithAggregatesFilter<"AutoWordReport"> | boolean
  }

  export type AutoWordReportSubWhereInput = {
    AND?: AutoWordReportSubWhereInput | AutoWordReportSubWhereInput[]
    OR?: AutoWordReportSubWhereInput[]
    NOT?: AutoWordReportSubWhereInput | AutoWordReportSubWhereInput[]
    ReportSubID?: IntFilter<"AutoWordReportSub"> | number
    ReportID?: IntNullableFilter<"AutoWordReportSub"> | number | null
    FieldNameTB?: StringNullableFilter<"AutoWordReportSub"> | string | null
    FieldNameReport?: StringNullableFilter<"AutoWordReportSub"> | string | null
    AutoWordReport?: XOR<AutoWordReportNullableScalarRelationFilter, AutoWordReportWhereInput> | null
  }

  export type AutoWordReportSubOrderByWithRelationInput = {
    ReportSubID?: SortOrder
    ReportID?: SortOrderInput | SortOrder
    FieldNameTB?: SortOrderInput | SortOrder
    FieldNameReport?: SortOrderInput | SortOrder
    AutoWordReport?: AutoWordReportOrderByWithRelationInput
  }

  export type AutoWordReportSubWhereUniqueInput = Prisma.AtLeast<{
    ReportSubID?: number
    AND?: AutoWordReportSubWhereInput | AutoWordReportSubWhereInput[]
    OR?: AutoWordReportSubWhereInput[]
    NOT?: AutoWordReportSubWhereInput | AutoWordReportSubWhereInput[]
    ReportID?: IntNullableFilter<"AutoWordReportSub"> | number | null
    FieldNameTB?: StringNullableFilter<"AutoWordReportSub"> | string | null
    FieldNameReport?: StringNullableFilter<"AutoWordReportSub"> | string | null
    AutoWordReport?: XOR<AutoWordReportNullableScalarRelationFilter, AutoWordReportWhereInput> | null
  }, "ReportSubID">

  export type AutoWordReportSubOrderByWithAggregationInput = {
    ReportSubID?: SortOrder
    ReportID?: SortOrderInput | SortOrder
    FieldNameTB?: SortOrderInput | SortOrder
    FieldNameReport?: SortOrderInput | SortOrder
    _count?: AutoWordReportSubCountOrderByAggregateInput
    _avg?: AutoWordReportSubAvgOrderByAggregateInput
    _max?: AutoWordReportSubMaxOrderByAggregateInput
    _min?: AutoWordReportSubMinOrderByAggregateInput
    _sum?: AutoWordReportSubSumOrderByAggregateInput
  }

  export type AutoWordReportSubScalarWhereWithAggregatesInput = {
    AND?: AutoWordReportSubScalarWhereWithAggregatesInput | AutoWordReportSubScalarWhereWithAggregatesInput[]
    OR?: AutoWordReportSubScalarWhereWithAggregatesInput[]
    NOT?: AutoWordReportSubScalarWhereWithAggregatesInput | AutoWordReportSubScalarWhereWithAggregatesInput[]
    ReportSubID?: IntWithAggregatesFilter<"AutoWordReportSub"> | number
    ReportID?: IntNullableWithAggregatesFilter<"AutoWordReportSub"> | number | null
    FieldNameTB?: StringNullableWithAggregatesFilter<"AutoWordReportSub"> | string | null
    FieldNameReport?: StringNullableWithAggregatesFilter<"AutoWordReportSub"> | string | null
  }

  export type ChangeHistoryWhereInput = {
    AND?: ChangeHistoryWhereInput | ChangeHistoryWhereInput[]
    OR?: ChangeHistoryWhereInput[]
    NOT?: ChangeHistoryWhereInput | ChangeHistoryWhereInput[]
    ChangeHistoryID?: IntFilter<"ChangeHistory"> | number
    Application_Name?: StringNullableFilter<"ChangeHistory"> | string | null
    ChangeDate?: DateTimeNullableFilter<"ChangeHistory"> | Date | string | null
    Version_Number?: StringNullableFilter<"ChangeHistory"> | string | null
    ChangeDescription?: StringNullableFilter<"ChangeHistory"> | string | null
    ConvertDatabase?: BoolFilter<"ChangeHistory"> | boolean
  }

  export type ChangeHistoryOrderByWithRelationInput = {
    ChangeHistoryID?: SortOrder
    Application_Name?: SortOrderInput | SortOrder
    ChangeDate?: SortOrderInput | SortOrder
    Version_Number?: SortOrderInput | SortOrder
    ChangeDescription?: SortOrderInput | SortOrder
    ConvertDatabase?: SortOrder
  }

  export type ChangeHistoryWhereUniqueInput = Prisma.AtLeast<{
    ChangeHistoryID?: number
    AND?: ChangeHistoryWhereInput | ChangeHistoryWhereInput[]
    OR?: ChangeHistoryWhereInput[]
    NOT?: ChangeHistoryWhereInput | ChangeHistoryWhereInput[]
    Application_Name?: StringNullableFilter<"ChangeHistory"> | string | null
    ChangeDate?: DateTimeNullableFilter<"ChangeHistory"> | Date | string | null
    Version_Number?: StringNullableFilter<"ChangeHistory"> | string | null
    ChangeDescription?: StringNullableFilter<"ChangeHistory"> | string | null
    ConvertDatabase?: BoolFilter<"ChangeHistory"> | boolean
  }, "ChangeHistoryID">

  export type ChangeHistoryOrderByWithAggregationInput = {
    ChangeHistoryID?: SortOrder
    Application_Name?: SortOrderInput | SortOrder
    ChangeDate?: SortOrderInput | SortOrder
    Version_Number?: SortOrderInput | SortOrder
    ChangeDescription?: SortOrderInput | SortOrder
    ConvertDatabase?: SortOrder
    _count?: ChangeHistoryCountOrderByAggregateInput
    _avg?: ChangeHistoryAvgOrderByAggregateInput
    _max?: ChangeHistoryMaxOrderByAggregateInput
    _min?: ChangeHistoryMinOrderByAggregateInput
    _sum?: ChangeHistorySumOrderByAggregateInput
  }

  export type ChangeHistoryScalarWhereWithAggregatesInput = {
    AND?: ChangeHistoryScalarWhereWithAggregatesInput | ChangeHistoryScalarWhereWithAggregatesInput[]
    OR?: ChangeHistoryScalarWhereWithAggregatesInput[]
    NOT?: ChangeHistoryScalarWhereWithAggregatesInput | ChangeHistoryScalarWhereWithAggregatesInput[]
    ChangeHistoryID?: IntWithAggregatesFilter<"ChangeHistory"> | number
    Application_Name?: StringNullableWithAggregatesFilter<"ChangeHistory"> | string | null
    ChangeDate?: DateTimeNullableWithAggregatesFilter<"ChangeHistory"> | Date | string | null
    Version_Number?: StringNullableWithAggregatesFilter<"ChangeHistory"> | string | null
    ChangeDescription?: StringNullableWithAggregatesFilter<"ChangeHistory"> | string | null
    ConvertDatabase?: BoolWithAggregatesFilter<"ChangeHistory"> | boolean
  }

  export type CitysIncomeTaxDiscountWhereInput = {
    AND?: CitysIncomeTaxDiscountWhereInput | CitysIncomeTaxDiscountWhereInput[]
    OR?: CitysIncomeTaxDiscountWhereInput[]
    NOT?: CitysIncomeTaxDiscountWhereInput | CitysIncomeTaxDiscountWhereInput[]
    ID?: IntFilter<"CitysIncomeTaxDiscount"> | number
    Year?: FloatFilter<"CitysIncomeTaxDiscount"> | number
    GroupCode?: IntFilter<"CitysIncomeTaxDiscount"> | number
    CityName?: StringFilter<"CitysIncomeTaxDiscount"> | string
    DiscountPercent?: IntNullableFilter<"CitysIncomeTaxDiscount"> | number | null
    MaximumIncome?: FloatNullableFilter<"CitysIncomeTaxDiscount"> | number | null
    MaximumIncomePerMonth?: FloatNullableFilter<"CitysIncomeTaxDiscount"> | number | null
  }

  export type CitysIncomeTaxDiscountOrderByWithRelationInput = {
    ID?: SortOrder
    Year?: SortOrder
    GroupCode?: SortOrder
    CityName?: SortOrder
    DiscountPercent?: SortOrderInput | SortOrder
    MaximumIncome?: SortOrderInput | SortOrder
    MaximumIncomePerMonth?: SortOrderInput | SortOrder
  }

  export type CitysIncomeTaxDiscountWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: CitysIncomeTaxDiscountWhereInput | CitysIncomeTaxDiscountWhereInput[]
    OR?: CitysIncomeTaxDiscountWhereInput[]
    NOT?: CitysIncomeTaxDiscountWhereInput | CitysIncomeTaxDiscountWhereInput[]
    Year?: FloatFilter<"CitysIncomeTaxDiscount"> | number
    GroupCode?: IntFilter<"CitysIncomeTaxDiscount"> | number
    CityName?: StringFilter<"CitysIncomeTaxDiscount"> | string
    DiscountPercent?: IntNullableFilter<"CitysIncomeTaxDiscount"> | number | null
    MaximumIncome?: FloatNullableFilter<"CitysIncomeTaxDiscount"> | number | null
    MaximumIncomePerMonth?: FloatNullableFilter<"CitysIncomeTaxDiscount"> | number | null
  }, "ID">

  export type CitysIncomeTaxDiscountOrderByWithAggregationInput = {
    ID?: SortOrder
    Year?: SortOrder
    GroupCode?: SortOrder
    CityName?: SortOrder
    DiscountPercent?: SortOrderInput | SortOrder
    MaximumIncome?: SortOrderInput | SortOrder
    MaximumIncomePerMonth?: SortOrderInput | SortOrder
    _count?: CitysIncomeTaxDiscountCountOrderByAggregateInput
    _avg?: CitysIncomeTaxDiscountAvgOrderByAggregateInput
    _max?: CitysIncomeTaxDiscountMaxOrderByAggregateInput
    _min?: CitysIncomeTaxDiscountMinOrderByAggregateInput
    _sum?: CitysIncomeTaxDiscountSumOrderByAggregateInput
  }

  export type CitysIncomeTaxDiscountScalarWhereWithAggregatesInput = {
    AND?: CitysIncomeTaxDiscountScalarWhereWithAggregatesInput | CitysIncomeTaxDiscountScalarWhereWithAggregatesInput[]
    OR?: CitysIncomeTaxDiscountScalarWhereWithAggregatesInput[]
    NOT?: CitysIncomeTaxDiscountScalarWhereWithAggregatesInput | CitysIncomeTaxDiscountScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"CitysIncomeTaxDiscount"> | number
    Year?: FloatWithAggregatesFilter<"CitysIncomeTaxDiscount"> | number
    GroupCode?: IntWithAggregatesFilter<"CitysIncomeTaxDiscount"> | number
    CityName?: StringWithAggregatesFilter<"CitysIncomeTaxDiscount"> | string
    DiscountPercent?: IntNullableWithAggregatesFilter<"CitysIncomeTaxDiscount"> | number | null
    MaximumIncome?: FloatNullableWithAggregatesFilter<"CitysIncomeTaxDiscount"> | number | null
    MaximumIncomePerMonth?: FloatNullableWithAggregatesFilter<"CitysIncomeTaxDiscount"> | number | null
  }

  export type CompaniesWhereInput = {
    AND?: CompaniesWhereInput | CompaniesWhereInput[]
    OR?: CompaniesWhereInput[]
    NOT?: CompaniesWhereInput | CompaniesWhereInput[]
    CompanyID?: StringFilter<"Companies"> | string
    CompanyID_OLD?: IntFilter<"Companies"> | number
    CompanyNumber?: IntFilter<"Companies"> | number
    DeductionsNumber?: IntNullableFilter<"Companies"> | number | null
    AgencyNumber?: IntNullableFilter<"Companies"> | number | null
    CompanyName?: StringFilter<"Companies"> | string
    CompanyNameEng?: StringNullableFilter<"Companies"> | string | null
    Address?: StringNullableFilter<"Companies"> | string | null
    CityID?: IntNullableFilter<"Companies"> | number | null
    ZipCode?: StringNullableFilter<"Companies"> | string | null
    POB?: StringNullableFilter<"Companies"> | string | null
    POB_ZipCode?: StringNullableFilter<"Companies"> | string | null
    Email?: StringNullableFilter<"Companies"> | string | null
    WebSite?: StringNullableFilter<"Companies"> | string | null
    Phone?: StringNullableFilter<"Companies"> | string | null
    Fax?: StringNullableFilter<"Companies"> | string | null
    NumOfPaySlipDisplay?: IntFilter<"Companies"> | number
    PaySlipDefinitionID?: IntNullableFilter<"Companies"> | number | null
    DbPathOnCloud?: StringNullableFilter<"Companies"> | string | null
    DocFilesPathOnCloud?: StringNullableFilter<"Companies"> | string | null
    DbPathAgricultureCRM?: StringNullableFilter<"Companies"> | string | null
    DisplayTypeID?: IntFilter<"Companies"> | number
    IsSuperAdminCompany?: IntNullableFilter<"Companies"> | number | null
    IsActive?: IntNullableFilter<"Companies"> | number | null
    IsExportAccounts?: IntNullableFilter<"Companies"> | number | null
    TaxAccountsToken?: StringNullableFilter<"Companies"> | string | null
    IsGetTaxAccountsCode?: IntNullableFilter<"Companies"> | number | null
    CompanyTaxAutoLink?: StringNullableFilter<"Companies"> | string | null
    UserId?: StringNullableFilter<"Companies"> | string | null
    CompanyTypeID?: StringFilter<"Companies"> | string
    CompaniesType?: XOR<CompaniesTypeScalarRelationFilter, CompaniesTypeWhereInput>
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: XOR<CompaniesUsersNullableScalarRelationFilter, CompaniesUsersWhereInput> | null
    CompaniesProducts?: CompaniesProductsListRelationFilter
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesListRelationFilter
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersListRelationFilter
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesListRelationFilter
    LandPages?: XOR<LandPagesNullableScalarRelationFilter, LandPagesWhereInput> | null
  }

  export type CompaniesOrderByWithRelationInput = {
    CompanyID?: SortOrder
    CompanyID_OLD?: SortOrder
    CompanyNumber?: SortOrder
    DeductionsNumber?: SortOrderInput | SortOrder
    AgencyNumber?: SortOrderInput | SortOrder
    CompanyName?: SortOrder
    CompanyNameEng?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    CityID?: SortOrderInput | SortOrder
    ZipCode?: SortOrderInput | SortOrder
    POB?: SortOrderInput | SortOrder
    POB_ZipCode?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    WebSite?: SortOrderInput | SortOrder
    Phone?: SortOrderInput | SortOrder
    Fax?: SortOrderInput | SortOrder
    NumOfPaySlipDisplay?: SortOrder
    PaySlipDefinitionID?: SortOrderInput | SortOrder
    DbPathOnCloud?: SortOrderInput | SortOrder
    DocFilesPathOnCloud?: SortOrderInput | SortOrder
    DbPathAgricultureCRM?: SortOrderInput | SortOrder
    DisplayTypeID?: SortOrder
    IsSuperAdminCompany?: SortOrderInput | SortOrder
    IsActive?: SortOrderInput | SortOrder
    IsExportAccounts?: SortOrderInput | SortOrder
    TaxAccountsToken?: SortOrderInput | SortOrder
    IsGetTaxAccountsCode?: SortOrderInput | SortOrder
    CompanyTaxAutoLink?: SortOrderInput | SortOrder
    UserId?: SortOrderInput | SortOrder
    CompanyTypeID?: SortOrder
    CompaniesType?: CompaniesTypeOrderByWithRelationInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersOrderByWithRelationInput
    CompaniesProducts?: CompaniesProductsOrderByRelationAggregateInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesOrderByRelationAggregateInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersOrderByRelationAggregateInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesOrderByRelationAggregateInput
    LandPages?: LandPagesOrderByWithRelationInput
  }

  export type CompaniesWhereUniqueInput = Prisma.AtLeast<{
    CompanyID?: string
    CompanyNumber?: number
    CompanyName?: string
    AND?: CompaniesWhereInput | CompaniesWhereInput[]
    OR?: CompaniesWhereInput[]
    NOT?: CompaniesWhereInput | CompaniesWhereInput[]
    CompanyID_OLD?: IntFilter<"Companies"> | number
    DeductionsNumber?: IntNullableFilter<"Companies"> | number | null
    AgencyNumber?: IntNullableFilter<"Companies"> | number | null
    CompanyNameEng?: StringNullableFilter<"Companies"> | string | null
    Address?: StringNullableFilter<"Companies"> | string | null
    CityID?: IntNullableFilter<"Companies"> | number | null
    ZipCode?: StringNullableFilter<"Companies"> | string | null
    POB?: StringNullableFilter<"Companies"> | string | null
    POB_ZipCode?: StringNullableFilter<"Companies"> | string | null
    Email?: StringNullableFilter<"Companies"> | string | null
    WebSite?: StringNullableFilter<"Companies"> | string | null
    Phone?: StringNullableFilter<"Companies"> | string | null
    Fax?: StringNullableFilter<"Companies"> | string | null
    NumOfPaySlipDisplay?: IntFilter<"Companies"> | number
    PaySlipDefinitionID?: IntNullableFilter<"Companies"> | number | null
    DbPathOnCloud?: StringNullableFilter<"Companies"> | string | null
    DocFilesPathOnCloud?: StringNullableFilter<"Companies"> | string | null
    DbPathAgricultureCRM?: StringNullableFilter<"Companies"> | string | null
    DisplayTypeID?: IntFilter<"Companies"> | number
    IsSuperAdminCompany?: IntNullableFilter<"Companies"> | number | null
    IsActive?: IntNullableFilter<"Companies"> | number | null
    IsExportAccounts?: IntNullableFilter<"Companies"> | number | null
    TaxAccountsToken?: StringNullableFilter<"Companies"> | string | null
    IsGetTaxAccountsCode?: IntNullableFilter<"Companies"> | number | null
    CompanyTaxAutoLink?: StringNullableFilter<"Companies"> | string | null
    UserId?: StringNullableFilter<"Companies"> | string | null
    CompanyTypeID?: StringFilter<"Companies"> | string
    CompaniesType?: XOR<CompaniesTypeScalarRelationFilter, CompaniesTypeWhereInput>
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: XOR<CompaniesUsersNullableScalarRelationFilter, CompaniesUsersWhereInput> | null
    CompaniesProducts?: CompaniesProductsListRelationFilter
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesListRelationFilter
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersListRelationFilter
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesListRelationFilter
    LandPages?: XOR<LandPagesNullableScalarRelationFilter, LandPagesWhereInput> | null
  }, "CompanyID" | "CompanyNumber" | "CompanyName">

  export type CompaniesOrderByWithAggregationInput = {
    CompanyID?: SortOrder
    CompanyID_OLD?: SortOrder
    CompanyNumber?: SortOrder
    DeductionsNumber?: SortOrderInput | SortOrder
    AgencyNumber?: SortOrderInput | SortOrder
    CompanyName?: SortOrder
    CompanyNameEng?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    CityID?: SortOrderInput | SortOrder
    ZipCode?: SortOrderInput | SortOrder
    POB?: SortOrderInput | SortOrder
    POB_ZipCode?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    WebSite?: SortOrderInput | SortOrder
    Phone?: SortOrderInput | SortOrder
    Fax?: SortOrderInput | SortOrder
    NumOfPaySlipDisplay?: SortOrder
    PaySlipDefinitionID?: SortOrderInput | SortOrder
    DbPathOnCloud?: SortOrderInput | SortOrder
    DocFilesPathOnCloud?: SortOrderInput | SortOrder
    DbPathAgricultureCRM?: SortOrderInput | SortOrder
    DisplayTypeID?: SortOrder
    IsSuperAdminCompany?: SortOrderInput | SortOrder
    IsActive?: SortOrderInput | SortOrder
    IsExportAccounts?: SortOrderInput | SortOrder
    TaxAccountsToken?: SortOrderInput | SortOrder
    IsGetTaxAccountsCode?: SortOrderInput | SortOrder
    CompanyTaxAutoLink?: SortOrderInput | SortOrder
    UserId?: SortOrderInput | SortOrder
    CompanyTypeID?: SortOrder
    _count?: CompaniesCountOrderByAggregateInput
    _avg?: CompaniesAvgOrderByAggregateInput
    _max?: CompaniesMaxOrderByAggregateInput
    _min?: CompaniesMinOrderByAggregateInput
    _sum?: CompaniesSumOrderByAggregateInput
  }

  export type CompaniesScalarWhereWithAggregatesInput = {
    AND?: CompaniesScalarWhereWithAggregatesInput | CompaniesScalarWhereWithAggregatesInput[]
    OR?: CompaniesScalarWhereWithAggregatesInput[]
    NOT?: CompaniesScalarWhereWithAggregatesInput | CompaniesScalarWhereWithAggregatesInput[]
    CompanyID?: StringWithAggregatesFilter<"Companies"> | string
    CompanyID_OLD?: IntWithAggregatesFilter<"Companies"> | number
    CompanyNumber?: IntWithAggregatesFilter<"Companies"> | number
    DeductionsNumber?: IntNullableWithAggregatesFilter<"Companies"> | number | null
    AgencyNumber?: IntNullableWithAggregatesFilter<"Companies"> | number | null
    CompanyName?: StringWithAggregatesFilter<"Companies"> | string
    CompanyNameEng?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    Address?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    CityID?: IntNullableWithAggregatesFilter<"Companies"> | number | null
    ZipCode?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    POB?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    POB_ZipCode?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    Email?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    WebSite?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    Phone?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    Fax?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    NumOfPaySlipDisplay?: IntWithAggregatesFilter<"Companies"> | number
    PaySlipDefinitionID?: IntNullableWithAggregatesFilter<"Companies"> | number | null
    DbPathOnCloud?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    DocFilesPathOnCloud?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    DbPathAgricultureCRM?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    DisplayTypeID?: IntWithAggregatesFilter<"Companies"> | number
    IsSuperAdminCompany?: IntNullableWithAggregatesFilter<"Companies"> | number | null
    IsActive?: IntNullableWithAggregatesFilter<"Companies"> | number | null
    IsExportAccounts?: IntNullableWithAggregatesFilter<"Companies"> | number | null
    TaxAccountsToken?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    IsGetTaxAccountsCode?: IntNullableWithAggregatesFilter<"Companies"> | number | null
    CompanyTaxAutoLink?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    UserId?: StringNullableWithAggregatesFilter<"Companies"> | string | null
    CompanyTypeID?: StringWithAggregatesFilter<"Companies"> | string
  }

  export type CompaniesProductsWhereInput = {
    AND?: CompaniesProductsWhereInput | CompaniesProductsWhereInput[]
    OR?: CompaniesProductsWhereInput[]
    NOT?: CompaniesProductsWhereInput | CompaniesProductsWhereInput[]
    CompaniesProductsId?: StringFilter<"CompaniesProducts"> | string
    CreatedAt?: DateTimeNullableFilter<"CompaniesProducts"> | Date | string | null
    ProductId?: StringFilter<"CompaniesProducts"> | string
    CompanyID?: StringFilter<"CompaniesProducts"> | string
    UserId?: StringNullableFilter<"CompaniesProducts"> | string | null
    LastVersionDate_Salary?: DateTimeNullableFilter<"CompaniesProducts"> | Date | string | null
    LastVersionDate_ManPower?: DateTimeNullableFilter<"CompaniesProducts"> | Date | string | null
    CompaniesUsers?: XOR<CompaniesUsersNullableScalarRelationFilter, CompaniesUsersWhereInput> | null
    Companies?: XOR<CompaniesScalarRelationFilter, CompaniesWhereInput>
    Products?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
  }

  export type CompaniesProductsOrderByWithRelationInput = {
    CompaniesProductsId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    UserId?: SortOrderInput | SortOrder
    LastVersionDate_Salary?: SortOrderInput | SortOrder
    LastVersionDate_ManPower?: SortOrderInput | SortOrder
    CompaniesUsers?: CompaniesUsersOrderByWithRelationInput
    Companies?: CompaniesOrderByWithRelationInput
    Products?: ProductsOrderByWithRelationInput
  }

  export type CompaniesProductsWhereUniqueInput = Prisma.AtLeast<{
    CompaniesProductsId?: string
    AND?: CompaniesProductsWhereInput | CompaniesProductsWhereInput[]
    OR?: CompaniesProductsWhereInput[]
    NOT?: CompaniesProductsWhereInput | CompaniesProductsWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"CompaniesProducts"> | Date | string | null
    ProductId?: StringFilter<"CompaniesProducts"> | string
    CompanyID?: StringFilter<"CompaniesProducts"> | string
    UserId?: StringNullableFilter<"CompaniesProducts"> | string | null
    LastVersionDate_Salary?: DateTimeNullableFilter<"CompaniesProducts"> | Date | string | null
    LastVersionDate_ManPower?: DateTimeNullableFilter<"CompaniesProducts"> | Date | string | null
    CompaniesUsers?: XOR<CompaniesUsersNullableScalarRelationFilter, CompaniesUsersWhereInput> | null
    Companies?: XOR<CompaniesScalarRelationFilter, CompaniesWhereInput>
    Products?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
  }, "CompaniesProductsId">

  export type CompaniesProductsOrderByWithAggregationInput = {
    CompaniesProductsId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    UserId?: SortOrderInput | SortOrder
    LastVersionDate_Salary?: SortOrderInput | SortOrder
    LastVersionDate_ManPower?: SortOrderInput | SortOrder
    _count?: CompaniesProductsCountOrderByAggregateInput
    _max?: CompaniesProductsMaxOrderByAggregateInput
    _min?: CompaniesProductsMinOrderByAggregateInput
  }

  export type CompaniesProductsScalarWhereWithAggregatesInput = {
    AND?: CompaniesProductsScalarWhereWithAggregatesInput | CompaniesProductsScalarWhereWithAggregatesInput[]
    OR?: CompaniesProductsScalarWhereWithAggregatesInput[]
    NOT?: CompaniesProductsScalarWhereWithAggregatesInput | CompaniesProductsScalarWhereWithAggregatesInput[]
    CompaniesProductsId?: StringWithAggregatesFilter<"CompaniesProducts"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"CompaniesProducts"> | Date | string | null
    ProductId?: StringWithAggregatesFilter<"CompaniesProducts"> | string
    CompanyID?: StringWithAggregatesFilter<"CompaniesProducts"> | string
    UserId?: StringNullableWithAggregatesFilter<"CompaniesProducts"> | string | null
    LastVersionDate_Salary?: DateTimeNullableWithAggregatesFilter<"CompaniesProducts"> | Date | string | null
    LastVersionDate_ManPower?: DateTimeNullableWithAggregatesFilter<"CompaniesProducts"> | Date | string | null
  }

  export type CompaniesProductsExpireDatesWhereInput = {
    AND?: CompaniesProductsExpireDatesWhereInput | CompaniesProductsExpireDatesWhereInput[]
    OR?: CompaniesProductsExpireDatesWhereInput[]
    NOT?: CompaniesProductsExpireDatesWhereInput | CompaniesProductsExpireDatesWhereInput[]
    CompaniesProductsExpireDateId?: StringFilter<"CompaniesProductsExpireDates"> | string
    CreatedAt?: DateTimeNullableFilter<"CompaniesProductsExpireDates"> | Date | string | null
    ProductId?: StringFilter<"CompaniesProductsExpireDates"> | string
    CompanyID?: StringFilter<"CompaniesProductsExpireDates"> | string
    StartDate?: DateTimeFilter<"CompaniesProductsExpireDates"> | Date | string
    EndDate?: DateTimeFilter<"CompaniesProductsExpireDates"> | Date | string
    Comments?: StringNullableFilter<"CompaniesProductsExpireDates"> | string | null
    UserId?: StringNullableFilter<"CompaniesProductsExpireDates"> | string | null
    CompaniesUsers?: XOR<CompaniesUsersNullableScalarRelationFilter, CompaniesUsersWhereInput> | null
    Companies?: XOR<CompaniesScalarRelationFilter, CompaniesWhereInput>
    Products?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
  }

  export type CompaniesProductsExpireDatesOrderByWithRelationInput = {
    CompaniesProductsExpireDateId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Comments?: SortOrderInput | SortOrder
    UserId?: SortOrderInput | SortOrder
    CompaniesUsers?: CompaniesUsersOrderByWithRelationInput
    Companies?: CompaniesOrderByWithRelationInput
    Products?: ProductsOrderByWithRelationInput
  }

  export type CompaniesProductsExpireDatesWhereUniqueInput = Prisma.AtLeast<{
    CompaniesProductsExpireDateId?: string
    AND?: CompaniesProductsExpireDatesWhereInput | CompaniesProductsExpireDatesWhereInput[]
    OR?: CompaniesProductsExpireDatesWhereInput[]
    NOT?: CompaniesProductsExpireDatesWhereInput | CompaniesProductsExpireDatesWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"CompaniesProductsExpireDates"> | Date | string | null
    ProductId?: StringFilter<"CompaniesProductsExpireDates"> | string
    CompanyID?: StringFilter<"CompaniesProductsExpireDates"> | string
    StartDate?: DateTimeFilter<"CompaniesProductsExpireDates"> | Date | string
    EndDate?: DateTimeFilter<"CompaniesProductsExpireDates"> | Date | string
    Comments?: StringNullableFilter<"CompaniesProductsExpireDates"> | string | null
    UserId?: StringNullableFilter<"CompaniesProductsExpireDates"> | string | null
    CompaniesUsers?: XOR<CompaniesUsersNullableScalarRelationFilter, CompaniesUsersWhereInput> | null
    Companies?: XOR<CompaniesScalarRelationFilter, CompaniesWhereInput>
    Products?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
  }, "CompaniesProductsExpireDateId">

  export type CompaniesProductsExpireDatesOrderByWithAggregationInput = {
    CompaniesProductsExpireDateId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Comments?: SortOrderInput | SortOrder
    UserId?: SortOrderInput | SortOrder
    _count?: CompaniesProductsExpireDatesCountOrderByAggregateInput
    _max?: CompaniesProductsExpireDatesMaxOrderByAggregateInput
    _min?: CompaniesProductsExpireDatesMinOrderByAggregateInput
  }

  export type CompaniesProductsExpireDatesScalarWhereWithAggregatesInput = {
    AND?: CompaniesProductsExpireDatesScalarWhereWithAggregatesInput | CompaniesProductsExpireDatesScalarWhereWithAggregatesInput[]
    OR?: CompaniesProductsExpireDatesScalarWhereWithAggregatesInput[]
    NOT?: CompaniesProductsExpireDatesScalarWhereWithAggregatesInput | CompaniesProductsExpireDatesScalarWhereWithAggregatesInput[]
    CompaniesProductsExpireDateId?: StringWithAggregatesFilter<"CompaniesProductsExpireDates"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"CompaniesProductsExpireDates"> | Date | string | null
    ProductId?: StringWithAggregatesFilter<"CompaniesProductsExpireDates"> | string
    CompanyID?: StringWithAggregatesFilter<"CompaniesProductsExpireDates"> | string
    StartDate?: DateTimeWithAggregatesFilter<"CompaniesProductsExpireDates"> | Date | string
    EndDate?: DateTimeWithAggregatesFilter<"CompaniesProductsExpireDates"> | Date | string
    Comments?: StringNullableWithAggregatesFilter<"CompaniesProductsExpireDates"> | string | null
    UserId?: StringNullableWithAggregatesFilter<"CompaniesProductsExpireDates"> | string | null
  }

  export type CompaniesTypeWhereInput = {
    AND?: CompaniesTypeWhereInput | CompaniesTypeWhereInput[]
    OR?: CompaniesTypeWhereInput[]
    NOT?: CompaniesTypeWhereInput | CompaniesTypeWhereInput[]
    CompaniesTypeID?: StringFilter<"CompaniesType"> | string
    CompaniesType?: StringFilter<"CompaniesType"> | string
    Companies?: CompaniesListRelationFilter
  }

  export type CompaniesTypeOrderByWithRelationInput = {
    CompaniesTypeID?: SortOrder
    CompaniesType?: SortOrder
    Companies?: CompaniesOrderByRelationAggregateInput
  }

  export type CompaniesTypeWhereUniqueInput = Prisma.AtLeast<{
    CompaniesTypeID?: string
    AND?: CompaniesTypeWhereInput | CompaniesTypeWhereInput[]
    OR?: CompaniesTypeWhereInput[]
    NOT?: CompaniesTypeWhereInput | CompaniesTypeWhereInput[]
    CompaniesType?: StringFilter<"CompaniesType"> | string
    Companies?: CompaniesListRelationFilter
  }, "CompaniesTypeID">

  export type CompaniesTypeOrderByWithAggregationInput = {
    CompaniesTypeID?: SortOrder
    CompaniesType?: SortOrder
    _count?: CompaniesTypeCountOrderByAggregateInput
    _max?: CompaniesTypeMaxOrderByAggregateInput
    _min?: CompaniesTypeMinOrderByAggregateInput
  }

  export type CompaniesTypeScalarWhereWithAggregatesInput = {
    AND?: CompaniesTypeScalarWhereWithAggregatesInput | CompaniesTypeScalarWhereWithAggregatesInput[]
    OR?: CompaniesTypeScalarWhereWithAggregatesInput[]
    NOT?: CompaniesTypeScalarWhereWithAggregatesInput | CompaniesTypeScalarWhereWithAggregatesInput[]
    CompaniesTypeID?: StringWithAggregatesFilter<"CompaniesType"> | string
    CompaniesType?: StringWithAggregatesFilter<"CompaniesType"> | string
  }

  export type CompaniesUsersWhereInput = {
    AND?: CompaniesUsersWhereInput | CompaniesUsersWhereInput[]
    OR?: CompaniesUsersWhereInput[]
    NOT?: CompaniesUsersWhereInput | CompaniesUsersWhereInput[]
    CompaniesUsersID?: StringFilter<"CompaniesUsers"> | string
    CompanyID?: StringFilter<"CompaniesUsers"> | string
    CompanyID_OLD?: IntFilter<"CompaniesUsers"> | number
    EmployeeIdentity?: StringFilter<"CompaniesUsers"> | string
    BirthDate?: DateTimeNullableFilter<"CompaniesUsers"> | Date | string | null
    LastName?: StringFilter<"CompaniesUsers"> | string
    FirstName?: StringFilter<"CompaniesUsers"> | string
    JobsID?: IntFilter<"CompaniesUsers"> | number
    Gender?: IntFilter<"CompaniesUsers"> | number
    MobileNumber?: StringFilter<"CompaniesUsers"> | string
    Phone?: StringNullableFilter<"CompaniesUsers"> | string | null
    Fax?: StringNullableFilter<"CompaniesUsers"> | string | null
    Email?: StringFilter<"CompaniesUsers"> | string
    UserName?: StringFilter<"CompaniesUsers"> | string
    Password?: StringFilter<"CompaniesUsers"> | string
    AreaMan?: StringNullableFilter<"CompaniesUsers"> | string | null
    IsAdmin?: IntFilter<"CompaniesUsers"> | number
    LastEntry?: DateTimeNullableFilter<"CompaniesUsers"> | Date | string | null
    IsAllowAccess2WebSite?: IntFilter<"CompaniesUsers"> | number
    UserId?: StringNullableFilter<"CompaniesUsers"> | string | null
    CreatedAt?: DateTimeNullableFilter<"CompaniesUsers"> | Date | string | null
    TwoFactorBase32Secret?: StringNullableFilter<"CompaniesUsers"> | string | null
    DeviceData?: StringNullableFilter<"CompaniesUsers"> | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesListRelationFilter
    CompaniesProducts?: CompaniesProductsListRelationFilter
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesListRelationFilter
    CompaniesUsers?: XOR<CompaniesUsersNullableScalarRelationFilter, CompaniesUsersWhereInput> | null
    other_CompaniesUsers?: CompaniesUsersListRelationFilter
    Companies_CompaniesUsers_CompanyIDToCompanies?: XOR<CompaniesScalarRelationFilter, CompaniesWhereInput>
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesListRelationFilter
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesListRelationFilter
  }

  export type CompaniesUsersOrderByWithRelationInput = {
    CompaniesUsersID?: SortOrder
    CompanyID?: SortOrder
    CompanyID_OLD?: SortOrder
    EmployeeIdentity?: SortOrder
    BirthDate?: SortOrderInput | SortOrder
    LastName?: SortOrder
    FirstName?: SortOrder
    JobsID?: SortOrder
    Gender?: SortOrder
    MobileNumber?: SortOrder
    Phone?: SortOrderInput | SortOrder
    Fax?: SortOrderInput | SortOrder
    Email?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    AreaMan?: SortOrderInput | SortOrder
    IsAdmin?: SortOrder
    LastEntry?: SortOrderInput | SortOrder
    IsAllowAccess2WebSite?: SortOrder
    UserId?: SortOrderInput | SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    TwoFactorBase32Secret?: SortOrderInput | SortOrder
    DeviceData?: SortOrderInput | SortOrder
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesOrderByRelationAggregateInput
    CompaniesProducts?: CompaniesProductsOrderByRelationAggregateInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesOrderByRelationAggregateInput
    CompaniesUsers?: CompaniesUsersOrderByWithRelationInput
    other_CompaniesUsers?: CompaniesUsersOrderByRelationAggregateInput
    Companies_CompaniesUsers_CompanyIDToCompanies?: CompaniesOrderByWithRelationInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesOrderByRelationAggregateInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesOrderByRelationAggregateInput
  }

  export type CompaniesUsersWhereUniqueInput = Prisma.AtLeast<{
    CompaniesUsersID?: string
    AND?: CompaniesUsersWhereInput | CompaniesUsersWhereInput[]
    OR?: CompaniesUsersWhereInput[]
    NOT?: CompaniesUsersWhereInput | CompaniesUsersWhereInput[]
    CompanyID?: StringFilter<"CompaniesUsers"> | string
    CompanyID_OLD?: IntFilter<"CompaniesUsers"> | number
    EmployeeIdentity?: StringFilter<"CompaniesUsers"> | string
    BirthDate?: DateTimeNullableFilter<"CompaniesUsers"> | Date | string | null
    LastName?: StringFilter<"CompaniesUsers"> | string
    FirstName?: StringFilter<"CompaniesUsers"> | string
    JobsID?: IntFilter<"CompaniesUsers"> | number
    Gender?: IntFilter<"CompaniesUsers"> | number
    MobileNumber?: StringFilter<"CompaniesUsers"> | string
    Phone?: StringNullableFilter<"CompaniesUsers"> | string | null
    Fax?: StringNullableFilter<"CompaniesUsers"> | string | null
    Email?: StringFilter<"CompaniesUsers"> | string
    UserName?: StringFilter<"CompaniesUsers"> | string
    Password?: StringFilter<"CompaniesUsers"> | string
    AreaMan?: StringNullableFilter<"CompaniesUsers"> | string | null
    IsAdmin?: IntFilter<"CompaniesUsers"> | number
    LastEntry?: DateTimeNullableFilter<"CompaniesUsers"> | Date | string | null
    IsAllowAccess2WebSite?: IntFilter<"CompaniesUsers"> | number
    UserId?: StringNullableFilter<"CompaniesUsers"> | string | null
    CreatedAt?: DateTimeNullableFilter<"CompaniesUsers"> | Date | string | null
    TwoFactorBase32Secret?: StringNullableFilter<"CompaniesUsers"> | string | null
    DeviceData?: StringNullableFilter<"CompaniesUsers"> | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesListRelationFilter
    CompaniesProducts?: CompaniesProductsListRelationFilter
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesListRelationFilter
    CompaniesUsers?: XOR<CompaniesUsersNullableScalarRelationFilter, CompaniesUsersWhereInput> | null
    other_CompaniesUsers?: CompaniesUsersListRelationFilter
    Companies_CompaniesUsers_CompanyIDToCompanies?: XOR<CompaniesScalarRelationFilter, CompaniesWhereInput>
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesListRelationFilter
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesListRelationFilter
  }, "CompaniesUsersID">

  export type CompaniesUsersOrderByWithAggregationInput = {
    CompaniesUsersID?: SortOrder
    CompanyID?: SortOrder
    CompanyID_OLD?: SortOrder
    EmployeeIdentity?: SortOrder
    BirthDate?: SortOrderInput | SortOrder
    LastName?: SortOrder
    FirstName?: SortOrder
    JobsID?: SortOrder
    Gender?: SortOrder
    MobileNumber?: SortOrder
    Phone?: SortOrderInput | SortOrder
    Fax?: SortOrderInput | SortOrder
    Email?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    AreaMan?: SortOrderInput | SortOrder
    IsAdmin?: SortOrder
    LastEntry?: SortOrderInput | SortOrder
    IsAllowAccess2WebSite?: SortOrder
    UserId?: SortOrderInput | SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    TwoFactorBase32Secret?: SortOrderInput | SortOrder
    DeviceData?: SortOrderInput | SortOrder
    _count?: CompaniesUsersCountOrderByAggregateInput
    _avg?: CompaniesUsersAvgOrderByAggregateInput
    _max?: CompaniesUsersMaxOrderByAggregateInput
    _min?: CompaniesUsersMinOrderByAggregateInput
    _sum?: CompaniesUsersSumOrderByAggregateInput
  }

  export type CompaniesUsersScalarWhereWithAggregatesInput = {
    AND?: CompaniesUsersScalarWhereWithAggregatesInput | CompaniesUsersScalarWhereWithAggregatesInput[]
    OR?: CompaniesUsersScalarWhereWithAggregatesInput[]
    NOT?: CompaniesUsersScalarWhereWithAggregatesInput | CompaniesUsersScalarWhereWithAggregatesInput[]
    CompaniesUsersID?: StringWithAggregatesFilter<"CompaniesUsers"> | string
    CompanyID?: StringWithAggregatesFilter<"CompaniesUsers"> | string
    CompanyID_OLD?: IntWithAggregatesFilter<"CompaniesUsers"> | number
    EmployeeIdentity?: StringWithAggregatesFilter<"CompaniesUsers"> | string
    BirthDate?: DateTimeNullableWithAggregatesFilter<"CompaniesUsers"> | Date | string | null
    LastName?: StringWithAggregatesFilter<"CompaniesUsers"> | string
    FirstName?: StringWithAggregatesFilter<"CompaniesUsers"> | string
    JobsID?: IntWithAggregatesFilter<"CompaniesUsers"> | number
    Gender?: IntWithAggregatesFilter<"CompaniesUsers"> | number
    MobileNumber?: StringWithAggregatesFilter<"CompaniesUsers"> | string
    Phone?: StringNullableWithAggregatesFilter<"CompaniesUsers"> | string | null
    Fax?: StringNullableWithAggregatesFilter<"CompaniesUsers"> | string | null
    Email?: StringWithAggregatesFilter<"CompaniesUsers"> | string
    UserName?: StringWithAggregatesFilter<"CompaniesUsers"> | string
    Password?: StringWithAggregatesFilter<"CompaniesUsers"> | string
    AreaMan?: StringNullableWithAggregatesFilter<"CompaniesUsers"> | string | null
    IsAdmin?: IntWithAggregatesFilter<"CompaniesUsers"> | number
    LastEntry?: DateTimeNullableWithAggregatesFilter<"CompaniesUsers"> | Date | string | null
    IsAllowAccess2WebSite?: IntWithAggregatesFilter<"CompaniesUsers"> | number
    UserId?: StringNullableWithAggregatesFilter<"CompaniesUsers"> | string | null
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"CompaniesUsers"> | Date | string | null
    TwoFactorBase32Secret?: StringNullableWithAggregatesFilter<"CompaniesUsers"> | string | null
    DeviceData?: StringNullableWithAggregatesFilter<"CompaniesUsers"> | string | null
  }

  export type CompaniesUsersProductsExpireDatesWhereInput = {
    AND?: CompaniesUsersProductsExpireDatesWhereInput | CompaniesUsersProductsExpireDatesWhereInput[]
    OR?: CompaniesUsersProductsExpireDatesWhereInput[]
    NOT?: CompaniesUsersProductsExpireDatesWhereInput | CompaniesUsersProductsExpireDatesWhereInput[]
    CompaniesUsersProductsExpireDateId?: StringFilter<"CompaniesUsersProductsExpireDates"> | string
    CreatedAt?: DateTimeNullableFilter<"CompaniesUsersProductsExpireDates"> | Date | string | null
    ProductId?: StringFilter<"CompaniesUsersProductsExpireDates"> | string
    CompanyID?: StringFilter<"CompaniesUsersProductsExpireDates"> | string
    CompaniesUsersID?: StringFilter<"CompaniesUsersProductsExpireDates"> | string
    StartDate?: DateTimeFilter<"CompaniesUsersProductsExpireDates"> | Date | string
    EndDate?: DateTimeFilter<"CompaniesUsersProductsExpireDates"> | Date | string
    UserId?: StringNullableFilter<"CompaniesUsersProductsExpireDates"> | string | null
    Comments?: StringNullableFilter<"CompaniesUsersProductsExpireDates"> | string | null
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: XOR<CompaniesUsersScalarRelationFilter, CompaniesUsersWhereInput>
    Companies?: XOR<CompaniesScalarRelationFilter, CompaniesWhereInput>
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: XOR<CompaniesUsersNullableScalarRelationFilter, CompaniesUsersWhereInput> | null
    Products?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
  }

  export type CompaniesUsersProductsExpireDatesOrderByWithRelationInput = {
    CompaniesUsersProductsExpireDateId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    CompaniesUsersID?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    UserId?: SortOrderInput | SortOrder
    Comments?: SortOrderInput | SortOrder
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersOrderByWithRelationInput
    Companies?: CompaniesOrderByWithRelationInput
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersOrderByWithRelationInput
    Products?: ProductsOrderByWithRelationInput
  }

  export type CompaniesUsersProductsExpireDatesWhereUniqueInput = Prisma.AtLeast<{
    CompaniesUsersProductsExpireDateId?: string
    AND?: CompaniesUsersProductsExpireDatesWhereInput | CompaniesUsersProductsExpireDatesWhereInput[]
    OR?: CompaniesUsersProductsExpireDatesWhereInput[]
    NOT?: CompaniesUsersProductsExpireDatesWhereInput | CompaniesUsersProductsExpireDatesWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"CompaniesUsersProductsExpireDates"> | Date | string | null
    ProductId?: StringFilter<"CompaniesUsersProductsExpireDates"> | string
    CompanyID?: StringFilter<"CompaniesUsersProductsExpireDates"> | string
    CompaniesUsersID?: StringFilter<"CompaniesUsersProductsExpireDates"> | string
    StartDate?: DateTimeFilter<"CompaniesUsersProductsExpireDates"> | Date | string
    EndDate?: DateTimeFilter<"CompaniesUsersProductsExpireDates"> | Date | string
    UserId?: StringNullableFilter<"CompaniesUsersProductsExpireDates"> | string | null
    Comments?: StringNullableFilter<"CompaniesUsersProductsExpireDates"> | string | null
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: XOR<CompaniesUsersScalarRelationFilter, CompaniesUsersWhereInput>
    Companies?: XOR<CompaniesScalarRelationFilter, CompaniesWhereInput>
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: XOR<CompaniesUsersNullableScalarRelationFilter, CompaniesUsersWhereInput> | null
    Products?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
  }, "CompaniesUsersProductsExpireDateId">

  export type CompaniesUsersProductsExpireDatesOrderByWithAggregationInput = {
    CompaniesUsersProductsExpireDateId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    CompaniesUsersID?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    UserId?: SortOrderInput | SortOrder
    Comments?: SortOrderInput | SortOrder
    _count?: CompaniesUsersProductsExpireDatesCountOrderByAggregateInput
    _max?: CompaniesUsersProductsExpireDatesMaxOrderByAggregateInput
    _min?: CompaniesUsersProductsExpireDatesMinOrderByAggregateInput
  }

  export type CompaniesUsersProductsExpireDatesScalarWhereWithAggregatesInput = {
    AND?: CompaniesUsersProductsExpireDatesScalarWhereWithAggregatesInput | CompaniesUsersProductsExpireDatesScalarWhereWithAggregatesInput[]
    OR?: CompaniesUsersProductsExpireDatesScalarWhereWithAggregatesInput[]
    NOT?: CompaniesUsersProductsExpireDatesScalarWhereWithAggregatesInput | CompaniesUsersProductsExpireDatesScalarWhereWithAggregatesInput[]
    CompaniesUsersProductsExpireDateId?: StringWithAggregatesFilter<"CompaniesUsersProductsExpireDates"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"CompaniesUsersProductsExpireDates"> | Date | string | null
    ProductId?: StringWithAggregatesFilter<"CompaniesUsersProductsExpireDates"> | string
    CompanyID?: StringWithAggregatesFilter<"CompaniesUsersProductsExpireDates"> | string
    CompaniesUsersID?: StringWithAggregatesFilter<"CompaniesUsersProductsExpireDates"> | string
    StartDate?: DateTimeWithAggregatesFilter<"CompaniesUsersProductsExpireDates"> | Date | string
    EndDate?: DateTimeWithAggregatesFilter<"CompaniesUsersProductsExpireDates"> | Date | string
    UserId?: StringNullableWithAggregatesFilter<"CompaniesUsersProductsExpireDates"> | string | null
    Comments?: StringNullableWithAggregatesFilter<"CompaniesUsersProductsExpireDates"> | string | null
  }

  export type CopyrightWhereInput = {
    AND?: CopyrightWhereInput | CopyrightWhereInput[]
    OR?: CopyrightWhereInput[]
    NOT?: CopyrightWhereInput | CopyrightWhereInput[]
    CopyrightID?: IntFilter<"Copyright"> | number
    Copyright?: StringFilter<"Copyright"> | string
    DbGeneralVer?: FloatFilter<"Copyright"> | number
  }

  export type CopyrightOrderByWithRelationInput = {
    CopyrightID?: SortOrder
    Copyright?: SortOrder
    DbGeneralVer?: SortOrder
  }

  export type CopyrightWhereUniqueInput = Prisma.AtLeast<{
    CopyrightID?: number
    AND?: CopyrightWhereInput | CopyrightWhereInput[]
    OR?: CopyrightWhereInput[]
    NOT?: CopyrightWhereInput | CopyrightWhereInput[]
    Copyright?: StringFilter<"Copyright"> | string
    DbGeneralVer?: FloatFilter<"Copyright"> | number
  }, "CopyrightID">

  export type CopyrightOrderByWithAggregationInput = {
    CopyrightID?: SortOrder
    Copyright?: SortOrder
    DbGeneralVer?: SortOrder
    _count?: CopyrightCountOrderByAggregateInput
    _avg?: CopyrightAvgOrderByAggregateInput
    _max?: CopyrightMaxOrderByAggregateInput
    _min?: CopyrightMinOrderByAggregateInput
    _sum?: CopyrightSumOrderByAggregateInput
  }

  export type CopyrightScalarWhereWithAggregatesInput = {
    AND?: CopyrightScalarWhereWithAggregatesInput | CopyrightScalarWhereWithAggregatesInput[]
    OR?: CopyrightScalarWhereWithAggregatesInput[]
    NOT?: CopyrightScalarWhereWithAggregatesInput | CopyrightScalarWhereWithAggregatesInput[]
    CopyrightID?: IntWithAggregatesFilter<"Copyright"> | number
    Copyright?: StringWithAggregatesFilter<"Copyright"> | string
    DbGeneralVer?: FloatWithAggregatesFilter<"Copyright"> | number
  }

  export type CountriesWhereInput = {
    AND?: CountriesWhereInput | CountriesWhereInput[]
    OR?: CountriesWhereInput[]
    NOT?: CountriesWhereInput | CountriesWhereInput[]
    CountryID?: IntFilter<"Countries"> | number
    CountryCode?: IntFilter<"Countries"> | number
    CountryName?: StringFilter<"Countries"> | string
    CountryNameEnglish?: StringFilter<"Countries"> | string
    MultipleSelect?: BoolNullableFilter<"Countries"> | boolean | null
    CommentPayslip?: StringNullableFilter<"Countries"> | string | null
    CommentHour?: StringNullableFilter<"Countries"> | string | null
    DefaultLanguageCol?: StringNullableFilter<"Countries"> | string | null
  }

  export type CountriesOrderByWithRelationInput = {
    CountryID?: SortOrder
    CountryCode?: SortOrder
    CountryName?: SortOrder
    CountryNameEnglish?: SortOrder
    MultipleSelect?: SortOrderInput | SortOrder
    CommentPayslip?: SortOrderInput | SortOrder
    CommentHour?: SortOrderInput | SortOrder
    DefaultLanguageCol?: SortOrderInput | SortOrder
  }

  export type CountriesWhereUniqueInput = Prisma.AtLeast<{
    CountryID?: number
    CountryCode?: number
    AND?: CountriesWhereInput | CountriesWhereInput[]
    OR?: CountriesWhereInput[]
    NOT?: CountriesWhereInput | CountriesWhereInput[]
    CountryName?: StringFilter<"Countries"> | string
    CountryNameEnglish?: StringFilter<"Countries"> | string
    MultipleSelect?: BoolNullableFilter<"Countries"> | boolean | null
    CommentPayslip?: StringNullableFilter<"Countries"> | string | null
    CommentHour?: StringNullableFilter<"Countries"> | string | null
    DefaultLanguageCol?: StringNullableFilter<"Countries"> | string | null
  }, "CountryID" | "CountryCode">

  export type CountriesOrderByWithAggregationInput = {
    CountryID?: SortOrder
    CountryCode?: SortOrder
    CountryName?: SortOrder
    CountryNameEnglish?: SortOrder
    MultipleSelect?: SortOrderInput | SortOrder
    CommentPayslip?: SortOrderInput | SortOrder
    CommentHour?: SortOrderInput | SortOrder
    DefaultLanguageCol?: SortOrderInput | SortOrder
    _count?: CountriesCountOrderByAggregateInput
    _avg?: CountriesAvgOrderByAggregateInput
    _max?: CountriesMaxOrderByAggregateInput
    _min?: CountriesMinOrderByAggregateInput
    _sum?: CountriesSumOrderByAggregateInput
  }

  export type CountriesScalarWhereWithAggregatesInput = {
    AND?: CountriesScalarWhereWithAggregatesInput | CountriesScalarWhereWithAggregatesInput[]
    OR?: CountriesScalarWhereWithAggregatesInput[]
    NOT?: CountriesScalarWhereWithAggregatesInput | CountriesScalarWhereWithAggregatesInput[]
    CountryID?: IntWithAggregatesFilter<"Countries"> | number
    CountryCode?: IntWithAggregatesFilter<"Countries"> | number
    CountryName?: StringWithAggregatesFilter<"Countries"> | string
    CountryNameEnglish?: StringWithAggregatesFilter<"Countries"> | string
    MultipleSelect?: BoolNullableWithAggregatesFilter<"Countries"> | boolean | null
    CommentPayslip?: StringNullableWithAggregatesFilter<"Countries"> | string | null
    CommentHour?: StringNullableWithAggregatesFilter<"Countries"> | string | null
    DefaultLanguageCol?: StringNullableWithAggregatesFilter<"Countries"> | string | null
  }

  export type CreditShiftWhereInput = {
    AND?: CreditShiftWhereInput | CreditShiftWhereInput[]
    OR?: CreditShiftWhereInput[]
    NOT?: CreditShiftWhereInput | CreditShiftWhereInput[]
    CreditShiftID?: IntFilter<"CreditShift"> | number
    CreditShiftDate?: DateTimeNullableFilter<"CreditShift"> | Date | string | null
    MaxCreditShiftPrecent?: FloatNullableFilter<"CreditShift"> | number | null
    MaxCreditShiftLimit?: FloatNullableFilter<"CreditShift"> | number | null
    CreditPrecent?: FloatNullableFilter<"CreditShift"> | number | null
  }

  export type CreditShiftOrderByWithRelationInput = {
    CreditShiftID?: SortOrder
    CreditShiftDate?: SortOrderInput | SortOrder
    MaxCreditShiftPrecent?: SortOrderInput | SortOrder
    MaxCreditShiftLimit?: SortOrderInput | SortOrder
    CreditPrecent?: SortOrderInput | SortOrder
  }

  export type CreditShiftWhereUniqueInput = Prisma.AtLeast<{
    CreditShiftID?: number
    AND?: CreditShiftWhereInput | CreditShiftWhereInput[]
    OR?: CreditShiftWhereInput[]
    NOT?: CreditShiftWhereInput | CreditShiftWhereInput[]
    CreditShiftDate?: DateTimeNullableFilter<"CreditShift"> | Date | string | null
    MaxCreditShiftPrecent?: FloatNullableFilter<"CreditShift"> | number | null
    MaxCreditShiftLimit?: FloatNullableFilter<"CreditShift"> | number | null
    CreditPrecent?: FloatNullableFilter<"CreditShift"> | number | null
  }, "CreditShiftID">

  export type CreditShiftOrderByWithAggregationInput = {
    CreditShiftID?: SortOrder
    CreditShiftDate?: SortOrderInput | SortOrder
    MaxCreditShiftPrecent?: SortOrderInput | SortOrder
    MaxCreditShiftLimit?: SortOrderInput | SortOrder
    CreditPrecent?: SortOrderInput | SortOrder
    _count?: CreditShiftCountOrderByAggregateInput
    _avg?: CreditShiftAvgOrderByAggregateInput
    _max?: CreditShiftMaxOrderByAggregateInput
    _min?: CreditShiftMinOrderByAggregateInput
    _sum?: CreditShiftSumOrderByAggregateInput
  }

  export type CreditShiftScalarWhereWithAggregatesInput = {
    AND?: CreditShiftScalarWhereWithAggregatesInput | CreditShiftScalarWhereWithAggregatesInput[]
    OR?: CreditShiftScalarWhereWithAggregatesInput[]
    NOT?: CreditShiftScalarWhereWithAggregatesInput | CreditShiftScalarWhereWithAggregatesInput[]
    CreditShiftID?: IntWithAggregatesFilter<"CreditShift"> | number
    CreditShiftDate?: DateTimeNullableWithAggregatesFilter<"CreditShift"> | Date | string | null
    MaxCreditShiftPrecent?: FloatNullableWithAggregatesFilter<"CreditShift"> | number | null
    MaxCreditShiftLimit?: FloatNullableWithAggregatesFilter<"CreditShift"> | number | null
    CreditPrecent?: FloatNullableWithAggregatesFilter<"CreditShift"> | number | null
  }

  export type DaysInMonthWhereInput = {
    AND?: DaysInMonthWhereInput | DaysInMonthWhereInput[]
    OR?: DaysInMonthWhereInput[]
    NOT?: DaysInMonthWhereInput | DaysInMonthWhereInput[]
    DateManagedID?: IntFilter<"DaysInMonth"> | number
    DateManaged?: DateTimeFilter<"DaysInMonth"> | Date | string
    YearManaged?: IntNullableFilter<"DaysInMonth"> | number | null
    MonthManaged?: IntNullableFilter<"DaysInMonth"> | number | null
    DayInMonth?: FloatNullableFilter<"DaysInMonth"> | number | null
    DayInWeek?: IntNullableFilter<"DaysInMonth"> | number | null
    WeekInYear?: IntNullableFilter<"DaysInMonth"> | number | null
    WeekInMonth?: IntNullableFilter<"DaysInMonth"> | number | null
    DayTypeID?: IntNullableFilter<"DaysInMonth"> | number | null
    StartEndTimeSabat?: DateTimeNullableFilter<"DaysInMonth"> | Date | string | null
    HolidayName?: StringNullableFilter<"DaysInMonth"> | string | null
  }

  export type DaysInMonthOrderByWithRelationInput = {
    DateManagedID?: SortOrder
    DateManaged?: SortOrder
    YearManaged?: SortOrderInput | SortOrder
    MonthManaged?: SortOrderInput | SortOrder
    DayInMonth?: SortOrderInput | SortOrder
    DayInWeek?: SortOrderInput | SortOrder
    WeekInYear?: SortOrderInput | SortOrder
    WeekInMonth?: SortOrderInput | SortOrder
    DayTypeID?: SortOrderInput | SortOrder
    StartEndTimeSabat?: SortOrderInput | SortOrder
    HolidayName?: SortOrderInput | SortOrder
  }

  export type DaysInMonthWhereUniqueInput = Prisma.AtLeast<{
    DateManagedID?: number
    DateManaged?: Date | string
    AND?: DaysInMonthWhereInput | DaysInMonthWhereInput[]
    OR?: DaysInMonthWhereInput[]
    NOT?: DaysInMonthWhereInput | DaysInMonthWhereInput[]
    YearManaged?: IntNullableFilter<"DaysInMonth"> | number | null
    MonthManaged?: IntNullableFilter<"DaysInMonth"> | number | null
    DayInMonth?: FloatNullableFilter<"DaysInMonth"> | number | null
    DayInWeek?: IntNullableFilter<"DaysInMonth"> | number | null
    WeekInYear?: IntNullableFilter<"DaysInMonth"> | number | null
    WeekInMonth?: IntNullableFilter<"DaysInMonth"> | number | null
    DayTypeID?: IntNullableFilter<"DaysInMonth"> | number | null
    StartEndTimeSabat?: DateTimeNullableFilter<"DaysInMonth"> | Date | string | null
    HolidayName?: StringNullableFilter<"DaysInMonth"> | string | null
  }, "DateManagedID" | "DateManaged">

  export type DaysInMonthOrderByWithAggregationInput = {
    DateManagedID?: SortOrder
    DateManaged?: SortOrder
    YearManaged?: SortOrderInput | SortOrder
    MonthManaged?: SortOrderInput | SortOrder
    DayInMonth?: SortOrderInput | SortOrder
    DayInWeek?: SortOrderInput | SortOrder
    WeekInYear?: SortOrderInput | SortOrder
    WeekInMonth?: SortOrderInput | SortOrder
    DayTypeID?: SortOrderInput | SortOrder
    StartEndTimeSabat?: SortOrderInput | SortOrder
    HolidayName?: SortOrderInput | SortOrder
    _count?: DaysInMonthCountOrderByAggregateInput
    _avg?: DaysInMonthAvgOrderByAggregateInput
    _max?: DaysInMonthMaxOrderByAggregateInput
    _min?: DaysInMonthMinOrderByAggregateInput
    _sum?: DaysInMonthSumOrderByAggregateInput
  }

  export type DaysInMonthScalarWhereWithAggregatesInput = {
    AND?: DaysInMonthScalarWhereWithAggregatesInput | DaysInMonthScalarWhereWithAggregatesInput[]
    OR?: DaysInMonthScalarWhereWithAggregatesInput[]
    NOT?: DaysInMonthScalarWhereWithAggregatesInput | DaysInMonthScalarWhereWithAggregatesInput[]
    DateManagedID?: IntWithAggregatesFilter<"DaysInMonth"> | number
    DateManaged?: DateTimeWithAggregatesFilter<"DaysInMonth"> | Date | string
    YearManaged?: IntNullableWithAggregatesFilter<"DaysInMonth"> | number | null
    MonthManaged?: IntNullableWithAggregatesFilter<"DaysInMonth"> | number | null
    DayInMonth?: FloatNullableWithAggregatesFilter<"DaysInMonth"> | number | null
    DayInWeek?: IntNullableWithAggregatesFilter<"DaysInMonth"> | number | null
    WeekInYear?: IntNullableWithAggregatesFilter<"DaysInMonth"> | number | null
    WeekInMonth?: IntNullableWithAggregatesFilter<"DaysInMonth"> | number | null
    DayTypeID?: IntNullableWithAggregatesFilter<"DaysInMonth"> | number | null
    StartEndTimeSabat?: DateTimeNullableWithAggregatesFilter<"DaysInMonth"> | Date | string | null
    HolidayName?: StringNullableWithAggregatesFilter<"DaysInMonth"> | string | null
  }

  export type DaysInMonth_NewYearWhereInput = {
    AND?: DaysInMonth_NewYearWhereInput | DaysInMonth_NewYearWhereInput[]
    OR?: DaysInMonth_NewYearWhereInput[]
    NOT?: DaysInMonth_NewYearWhereInput | DaysInMonth_NewYearWhereInput[]
    DateManagedID?: IntFilter<"DaysInMonth_NewYear"> | number
    DateManaged?: DateTimeFilter<"DaysInMonth_NewYear"> | Date | string
    YearManaged?: IntNullableFilter<"DaysInMonth_NewYear"> | number | null
    MonthManaged?: IntNullableFilter<"DaysInMonth_NewYear"> | number | null
    DayInMonth?: FloatNullableFilter<"DaysInMonth_NewYear"> | number | null
    DayInWeek?: IntNullableFilter<"DaysInMonth_NewYear"> | number | null
    WeekInYear?: IntNullableFilter<"DaysInMonth_NewYear"> | number | null
    WeekInMonth?: IntNullableFilter<"DaysInMonth_NewYear"> | number | null
    DayTypeID?: IntNullableFilter<"DaysInMonth_NewYear"> | number | null
    StartEndTimeSabat?: DateTimeNullableFilter<"DaysInMonth_NewYear"> | Date | string | null
    HolidayName?: StringNullableFilter<"DaysInMonth_NewYear"> | string | null
  }

  export type DaysInMonth_NewYearOrderByWithRelationInput = {
    DateManagedID?: SortOrder
    DateManaged?: SortOrder
    YearManaged?: SortOrderInput | SortOrder
    MonthManaged?: SortOrderInput | SortOrder
    DayInMonth?: SortOrderInput | SortOrder
    DayInWeek?: SortOrderInput | SortOrder
    WeekInYear?: SortOrderInput | SortOrder
    WeekInMonth?: SortOrderInput | SortOrder
    DayTypeID?: SortOrderInput | SortOrder
    StartEndTimeSabat?: SortOrderInput | SortOrder
    HolidayName?: SortOrderInput | SortOrder
  }

  export type DaysInMonth_NewYearWhereUniqueInput = Prisma.AtLeast<{
    DateManagedID?: number
    DateManaged?: Date | string
    AND?: DaysInMonth_NewYearWhereInput | DaysInMonth_NewYearWhereInput[]
    OR?: DaysInMonth_NewYearWhereInput[]
    NOT?: DaysInMonth_NewYearWhereInput | DaysInMonth_NewYearWhereInput[]
    YearManaged?: IntNullableFilter<"DaysInMonth_NewYear"> | number | null
    MonthManaged?: IntNullableFilter<"DaysInMonth_NewYear"> | number | null
    DayInMonth?: FloatNullableFilter<"DaysInMonth_NewYear"> | number | null
    DayInWeek?: IntNullableFilter<"DaysInMonth_NewYear"> | number | null
    WeekInYear?: IntNullableFilter<"DaysInMonth_NewYear"> | number | null
    WeekInMonth?: IntNullableFilter<"DaysInMonth_NewYear"> | number | null
    DayTypeID?: IntNullableFilter<"DaysInMonth_NewYear"> | number | null
    StartEndTimeSabat?: DateTimeNullableFilter<"DaysInMonth_NewYear"> | Date | string | null
    HolidayName?: StringNullableFilter<"DaysInMonth_NewYear"> | string | null
  }, "DateManagedID" | "DateManaged">

  export type DaysInMonth_NewYearOrderByWithAggregationInput = {
    DateManagedID?: SortOrder
    DateManaged?: SortOrder
    YearManaged?: SortOrderInput | SortOrder
    MonthManaged?: SortOrderInput | SortOrder
    DayInMonth?: SortOrderInput | SortOrder
    DayInWeek?: SortOrderInput | SortOrder
    WeekInYear?: SortOrderInput | SortOrder
    WeekInMonth?: SortOrderInput | SortOrder
    DayTypeID?: SortOrderInput | SortOrder
    StartEndTimeSabat?: SortOrderInput | SortOrder
    HolidayName?: SortOrderInput | SortOrder
    _count?: DaysInMonth_NewYearCountOrderByAggregateInput
    _avg?: DaysInMonth_NewYearAvgOrderByAggregateInput
    _max?: DaysInMonth_NewYearMaxOrderByAggregateInput
    _min?: DaysInMonth_NewYearMinOrderByAggregateInput
    _sum?: DaysInMonth_NewYearSumOrderByAggregateInput
  }

  export type DaysInMonth_NewYearScalarWhereWithAggregatesInput = {
    AND?: DaysInMonth_NewYearScalarWhereWithAggregatesInput | DaysInMonth_NewYearScalarWhereWithAggregatesInput[]
    OR?: DaysInMonth_NewYearScalarWhereWithAggregatesInput[]
    NOT?: DaysInMonth_NewYearScalarWhereWithAggregatesInput | DaysInMonth_NewYearScalarWhereWithAggregatesInput[]
    DateManagedID?: IntWithAggregatesFilter<"DaysInMonth_NewYear"> | number
    DateManaged?: DateTimeWithAggregatesFilter<"DaysInMonth_NewYear"> | Date | string
    YearManaged?: IntNullableWithAggregatesFilter<"DaysInMonth_NewYear"> | number | null
    MonthManaged?: IntNullableWithAggregatesFilter<"DaysInMonth_NewYear"> | number | null
    DayInMonth?: FloatNullableWithAggregatesFilter<"DaysInMonth_NewYear"> | number | null
    DayInWeek?: IntNullableWithAggregatesFilter<"DaysInMonth_NewYear"> | number | null
    WeekInYear?: IntNullableWithAggregatesFilter<"DaysInMonth_NewYear"> | number | null
    WeekInMonth?: IntNullableWithAggregatesFilter<"DaysInMonth_NewYear"> | number | null
    DayTypeID?: IntNullableWithAggregatesFilter<"DaysInMonth_NewYear"> | number | null
    StartEndTimeSabat?: DateTimeNullableWithAggregatesFilter<"DaysInMonth_NewYear"> | Date | string | null
    HolidayName?: StringNullableWithAggregatesFilter<"DaysInMonth_NewYear"> | string | null
  }

  export type DayTypeWhereInput = {
    AND?: DayTypeWhereInput | DayTypeWhereInput[]
    OR?: DayTypeWhereInput[]
    NOT?: DayTypeWhereInput | DayTypeWhereInput[]
    DayTypeID?: IntFilter<"DayType"> | number
    DayTypeName?: StringFilter<"DayType"> | string
    SetOrder?: IntFilter<"DayType"> | number
  }

  export type DayTypeOrderByWithRelationInput = {
    DayTypeID?: SortOrder
    DayTypeName?: SortOrder
    SetOrder?: SortOrder
  }

  export type DayTypeWhereUniqueInput = Prisma.AtLeast<{
    DayTypeID?: number
    AND?: DayTypeWhereInput | DayTypeWhereInput[]
    OR?: DayTypeWhereInput[]
    NOT?: DayTypeWhereInput | DayTypeWhereInput[]
    DayTypeName?: StringFilter<"DayType"> | string
    SetOrder?: IntFilter<"DayType"> | number
  }, "DayTypeID">

  export type DayTypeOrderByWithAggregationInput = {
    DayTypeID?: SortOrder
    DayTypeName?: SortOrder
    SetOrder?: SortOrder
    _count?: DayTypeCountOrderByAggregateInput
    _avg?: DayTypeAvgOrderByAggregateInput
    _max?: DayTypeMaxOrderByAggregateInput
    _min?: DayTypeMinOrderByAggregateInput
    _sum?: DayTypeSumOrderByAggregateInput
  }

  export type DayTypeScalarWhereWithAggregatesInput = {
    AND?: DayTypeScalarWhereWithAggregatesInput | DayTypeScalarWhereWithAggregatesInput[]
    OR?: DayTypeScalarWhereWithAggregatesInput[]
    NOT?: DayTypeScalarWhereWithAggregatesInput | DayTypeScalarWhereWithAggregatesInput[]
    DayTypeID?: IntWithAggregatesFilter<"DayType"> | number
    DayTypeName?: StringWithAggregatesFilter<"DayType"> | string
    SetOrder?: IntWithAggregatesFilter<"DayType"> | number
  }

  export type DisplayTypeWhereInput = {
    AND?: DisplayTypeWhereInput | DisplayTypeWhereInput[]
    OR?: DisplayTypeWhereInput[]
    NOT?: DisplayTypeWhereInput | DisplayTypeWhereInput[]
    DisplayTypeID?: IntFilter<"DisplayType"> | number
    DisplayType?: StringFilter<"DisplayType"> | string
    URL?: StringFilter<"DisplayType"> | string
    IsShowInDanzarCRM?: IntFilter<"DisplayType"> | number
  }

  export type DisplayTypeOrderByWithRelationInput = {
    DisplayTypeID?: SortOrder
    DisplayType?: SortOrder
    URL?: SortOrder
    IsShowInDanzarCRM?: SortOrder
  }

  export type DisplayTypeWhereUniqueInput = Prisma.AtLeast<{
    DisplayTypeID?: number
    AND?: DisplayTypeWhereInput | DisplayTypeWhereInput[]
    OR?: DisplayTypeWhereInput[]
    NOT?: DisplayTypeWhereInput | DisplayTypeWhereInput[]
    DisplayType?: StringFilter<"DisplayType"> | string
    URL?: StringFilter<"DisplayType"> | string
    IsShowInDanzarCRM?: IntFilter<"DisplayType"> | number
  }, "DisplayTypeID">

  export type DisplayTypeOrderByWithAggregationInput = {
    DisplayTypeID?: SortOrder
    DisplayType?: SortOrder
    URL?: SortOrder
    IsShowInDanzarCRM?: SortOrder
    _count?: DisplayTypeCountOrderByAggregateInput
    _avg?: DisplayTypeAvgOrderByAggregateInput
    _max?: DisplayTypeMaxOrderByAggregateInput
    _min?: DisplayTypeMinOrderByAggregateInput
    _sum?: DisplayTypeSumOrderByAggregateInput
  }

  export type DisplayTypeScalarWhereWithAggregatesInput = {
    AND?: DisplayTypeScalarWhereWithAggregatesInput | DisplayTypeScalarWhereWithAggregatesInput[]
    OR?: DisplayTypeScalarWhereWithAggregatesInput[]
    NOT?: DisplayTypeScalarWhereWithAggregatesInput | DisplayTypeScalarWhereWithAggregatesInput[]
    DisplayTypeID?: IntWithAggregatesFilter<"DisplayType"> | number
    DisplayType?: StringWithAggregatesFilter<"DisplayType"> | string
    URL?: StringWithAggregatesFilter<"DisplayType"> | string
    IsShowInDanzarCRM?: IntWithAggregatesFilter<"DisplayType"> | number
  }

  export type HashIndexGeneralWhereInput = {
    AND?: HashIndexGeneralWhereInput | HashIndexGeneralWhereInput[]
    OR?: HashIndexGeneralWhereInput[]
    NOT?: HashIndexGeneralWhereInput | HashIndexGeneralWhereInput[]
    HashCode?: IntFilter<"HashIndexGeneral"> | number
    HashName?: StringNullableFilter<"HashIndexGeneral"> | string | null
  }

  export type HashIndexGeneralOrderByWithRelationInput = {
    HashCode?: SortOrder
    HashName?: SortOrderInput | SortOrder
  }

  export type HashIndexGeneralWhereUniqueInput = Prisma.AtLeast<{
    HashCode?: number
    HashName?: string
    AND?: HashIndexGeneralWhereInput | HashIndexGeneralWhereInput[]
    OR?: HashIndexGeneralWhereInput[]
    NOT?: HashIndexGeneralWhereInput | HashIndexGeneralWhereInput[]
  }, "HashCode" | "HashName">

  export type HashIndexGeneralOrderByWithAggregationInput = {
    HashCode?: SortOrder
    HashName?: SortOrderInput | SortOrder
    _count?: HashIndexGeneralCountOrderByAggregateInput
    _avg?: HashIndexGeneralAvgOrderByAggregateInput
    _max?: HashIndexGeneralMaxOrderByAggregateInput
    _min?: HashIndexGeneralMinOrderByAggregateInput
    _sum?: HashIndexGeneralSumOrderByAggregateInput
  }

  export type HashIndexGeneralScalarWhereWithAggregatesInput = {
    AND?: HashIndexGeneralScalarWhereWithAggregatesInput | HashIndexGeneralScalarWhereWithAggregatesInput[]
    OR?: HashIndexGeneralScalarWhereWithAggregatesInput[]
    NOT?: HashIndexGeneralScalarWhereWithAggregatesInput | HashIndexGeneralScalarWhereWithAggregatesInput[]
    HashCode?: IntWithAggregatesFilter<"HashIndexGeneral"> | number
    HashName?: StringNullableWithAggregatesFilter<"HashIndexGeneral"> | string | null
  }

  export type HashSecurityWhereInput = {
    AND?: HashSecurityWhereInput | HashSecurityWhereInput[]
    OR?: HashSecurityWhereInput[]
    NOT?: HashSecurityWhereInput | HashSecurityWhereInput[]
    HashID?: StringFilter<"HashSecurity"> | string
    HashCode?: BigIntFilter<"HashSecurity"> | bigint | number
    IsUse?: IntFilter<"HashSecurity"> | number
  }

  export type HashSecurityOrderByWithRelationInput = {
    HashID?: SortOrder
    HashCode?: SortOrder
    IsUse?: SortOrder
  }

  export type HashSecurityWhereUniqueInput = Prisma.AtLeast<{
    HashID?: string
    AND?: HashSecurityWhereInput | HashSecurityWhereInput[]
    OR?: HashSecurityWhereInput[]
    NOT?: HashSecurityWhereInput | HashSecurityWhereInput[]
    HashCode?: BigIntFilter<"HashSecurity"> | bigint | number
    IsUse?: IntFilter<"HashSecurity"> | number
  }, "HashID">

  export type HashSecurityOrderByWithAggregationInput = {
    HashID?: SortOrder
    HashCode?: SortOrder
    IsUse?: SortOrder
    _count?: HashSecurityCountOrderByAggregateInput
    _avg?: HashSecurityAvgOrderByAggregateInput
    _max?: HashSecurityMaxOrderByAggregateInput
    _min?: HashSecurityMinOrderByAggregateInput
    _sum?: HashSecuritySumOrderByAggregateInput
  }

  export type HashSecurityScalarWhereWithAggregatesInput = {
    AND?: HashSecurityScalarWhereWithAggregatesInput | HashSecurityScalarWhereWithAggregatesInput[]
    OR?: HashSecurityScalarWhereWithAggregatesInput[]
    NOT?: HashSecurityScalarWhereWithAggregatesInput | HashSecurityScalarWhereWithAggregatesInput[]
    HashID?: StringWithAggregatesFilter<"HashSecurity"> | string
    HashCode?: BigIntWithAggregatesFilter<"HashSecurity"> | bigint | number
    IsUse?: IntWithAggregatesFilter<"HashSecurity"> | number
  }

  export type JobsWhereInput = {
    AND?: JobsWhereInput | JobsWhereInput[]
    OR?: JobsWhereInput[]
    NOT?: JobsWhereInput | JobsWhereInput[]
    JobsID?: IntFilter<"Jobs"> | number
    JobTitle?: StringFilter<"Jobs"> | string
  }

  export type JobsOrderByWithRelationInput = {
    JobsID?: SortOrder
    JobTitle?: SortOrder
  }

  export type JobsWhereUniqueInput = Prisma.AtLeast<{
    JobsID?: number
    JobTitle?: string
    AND?: JobsWhereInput | JobsWhereInput[]
    OR?: JobsWhereInput[]
    NOT?: JobsWhereInput | JobsWhereInput[]
  }, "JobsID" | "JobTitle">

  export type JobsOrderByWithAggregationInput = {
    JobsID?: SortOrder
    JobTitle?: SortOrder
    _count?: JobsCountOrderByAggregateInput
    _avg?: JobsAvgOrderByAggregateInput
    _max?: JobsMaxOrderByAggregateInput
    _min?: JobsMinOrderByAggregateInput
    _sum?: JobsSumOrderByAggregateInput
  }

  export type JobsScalarWhereWithAggregatesInput = {
    AND?: JobsScalarWhereWithAggregatesInput | JobsScalarWhereWithAggregatesInput[]
    OR?: JobsScalarWhereWithAggregatesInput[]
    NOT?: JobsScalarWhereWithAggregatesInput | JobsScalarWhereWithAggregatesInput[]
    JobsID?: IntWithAggregatesFilter<"Jobs"> | number
    JobTitle?: StringWithAggregatesFilter<"Jobs"> | string
  }

  export type KupaGemelWhereInput = {
    AND?: KupaGemelWhereInput | KupaGemelWhereInput[]
    OR?: KupaGemelWhereInput[]
    NOT?: KupaGemelWhereInput | KupaGemelWhereInput[]
    KupaID?: IntFilter<"KupaGemel"> | number
    KupaName?: StringNullableFilter<"KupaGemel"> | string | null
    AllowanceEmployeePercent?: FloatNullableFilter<"KupaGemel"> | number | null
    AllowanceEmployerPercent?: FloatNullableFilter<"KupaGemel"> | number | null
    AllowanceCompensationPercen?: FloatNullableFilter<"KupaGemel"> | number | null
    IsAndromedaRecord?: BoolFilter<"KupaGemel"> | boolean
    EducationFundPercentEmp?: FloatNullableFilter<"KupaGemel"> | number | null
    EducationFundPercentEmpoyer?: FloatNullableFilter<"KupaGemel"> | number | null
  }

  export type KupaGemelOrderByWithRelationInput = {
    KupaID?: SortOrder
    KupaName?: SortOrderInput | SortOrder
    AllowanceEmployeePercent?: SortOrderInput | SortOrder
    AllowanceEmployerPercent?: SortOrderInput | SortOrder
    AllowanceCompensationPercen?: SortOrderInput | SortOrder
    IsAndromedaRecord?: SortOrder
    EducationFundPercentEmp?: SortOrderInput | SortOrder
    EducationFundPercentEmpoyer?: SortOrderInput | SortOrder
  }

  export type KupaGemelWhereUniqueInput = Prisma.AtLeast<{
    KupaID?: number
    AND?: KupaGemelWhereInput | KupaGemelWhereInput[]
    OR?: KupaGemelWhereInput[]
    NOT?: KupaGemelWhereInput | KupaGemelWhereInput[]
    KupaName?: StringNullableFilter<"KupaGemel"> | string | null
    AllowanceEmployeePercent?: FloatNullableFilter<"KupaGemel"> | number | null
    AllowanceEmployerPercent?: FloatNullableFilter<"KupaGemel"> | number | null
    AllowanceCompensationPercen?: FloatNullableFilter<"KupaGemel"> | number | null
    IsAndromedaRecord?: BoolFilter<"KupaGemel"> | boolean
    EducationFundPercentEmp?: FloatNullableFilter<"KupaGemel"> | number | null
    EducationFundPercentEmpoyer?: FloatNullableFilter<"KupaGemel"> | number | null
  }, "KupaID">

  export type KupaGemelOrderByWithAggregationInput = {
    KupaID?: SortOrder
    KupaName?: SortOrderInput | SortOrder
    AllowanceEmployeePercent?: SortOrderInput | SortOrder
    AllowanceEmployerPercent?: SortOrderInput | SortOrder
    AllowanceCompensationPercen?: SortOrderInput | SortOrder
    IsAndromedaRecord?: SortOrder
    EducationFundPercentEmp?: SortOrderInput | SortOrder
    EducationFundPercentEmpoyer?: SortOrderInput | SortOrder
    _count?: KupaGemelCountOrderByAggregateInput
    _avg?: KupaGemelAvgOrderByAggregateInput
    _max?: KupaGemelMaxOrderByAggregateInput
    _min?: KupaGemelMinOrderByAggregateInput
    _sum?: KupaGemelSumOrderByAggregateInput
  }

  export type KupaGemelScalarWhereWithAggregatesInput = {
    AND?: KupaGemelScalarWhereWithAggregatesInput | KupaGemelScalarWhereWithAggregatesInput[]
    OR?: KupaGemelScalarWhereWithAggregatesInput[]
    NOT?: KupaGemelScalarWhereWithAggregatesInput | KupaGemelScalarWhereWithAggregatesInput[]
    KupaID?: IntWithAggregatesFilter<"KupaGemel"> | number
    KupaName?: StringNullableWithAggregatesFilter<"KupaGemel"> | string | null
    AllowanceEmployeePercent?: FloatNullableWithAggregatesFilter<"KupaGemel"> | number | null
    AllowanceEmployerPercent?: FloatNullableWithAggregatesFilter<"KupaGemel"> | number | null
    AllowanceCompensationPercen?: FloatNullableWithAggregatesFilter<"KupaGemel"> | number | null
    IsAndromedaRecord?: BoolWithAggregatesFilter<"KupaGemel"> | boolean
    EducationFundPercentEmp?: FloatNullableWithAggregatesFilter<"KupaGemel"> | number | null
    EducationFundPercentEmpoyer?: FloatNullableWithAggregatesFilter<"KupaGemel"> | number | null
  }

  export type LandPagesWhereInput = {
    AND?: LandPagesWhereInput | LandPagesWhereInput[]
    OR?: LandPagesWhereInput[]
    NOT?: LandPagesWhereInput | LandPagesWhereInput[]
    LandPageRowId?: StringFilter<"LandPages"> | string
    CompanyID?: StringFilter<"LandPages"> | string
    CreatedAt?: DateTimeNullableFilter<"LandPages"> | Date | string | null
    JsonData?: StringNullableFilter<"LandPages"> | string | null
    ViewDate?: DateTimeNullableFilter<"LandPages"> | Date | string | null
    CompletedDate?: DateTimeNullableFilter<"LandPages"> | Date | string | null
    Companies?: XOR<CompaniesScalarRelationFilter, CompaniesWhereInput>
  }

  export type LandPagesOrderByWithRelationInput = {
    LandPageRowId?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    JsonData?: SortOrderInput | SortOrder
    ViewDate?: SortOrderInput | SortOrder
    CompletedDate?: SortOrderInput | SortOrder
    Companies?: CompaniesOrderByWithRelationInput
  }

  export type LandPagesWhereUniqueInput = Prisma.AtLeast<{
    LandPageRowId?: string
    CompanyID?: string
    AND?: LandPagesWhereInput | LandPagesWhereInput[]
    OR?: LandPagesWhereInput[]
    NOT?: LandPagesWhereInput | LandPagesWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"LandPages"> | Date | string | null
    JsonData?: StringNullableFilter<"LandPages"> | string | null
    ViewDate?: DateTimeNullableFilter<"LandPages"> | Date | string | null
    CompletedDate?: DateTimeNullableFilter<"LandPages"> | Date | string | null
    Companies?: XOR<CompaniesScalarRelationFilter, CompaniesWhereInput>
  }, "LandPageRowId" | "CompanyID">

  export type LandPagesOrderByWithAggregationInput = {
    LandPageRowId?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    JsonData?: SortOrderInput | SortOrder
    ViewDate?: SortOrderInput | SortOrder
    CompletedDate?: SortOrderInput | SortOrder
    _count?: LandPagesCountOrderByAggregateInput
    _max?: LandPagesMaxOrderByAggregateInput
    _min?: LandPagesMinOrderByAggregateInput
  }

  export type LandPagesScalarWhereWithAggregatesInput = {
    AND?: LandPagesScalarWhereWithAggregatesInput | LandPagesScalarWhereWithAggregatesInput[]
    OR?: LandPagesScalarWhereWithAggregatesInput[]
    NOT?: LandPagesScalarWhereWithAggregatesInput | LandPagesScalarWhereWithAggregatesInput[]
    LandPageRowId?: StringWithAggregatesFilter<"LandPages"> | string
    CompanyID?: StringWithAggregatesFilter<"LandPages"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"LandPages"> | Date | string | null
    JsonData?: StringNullableWithAggregatesFilter<"LandPages"> | string | null
    ViewDate?: DateTimeNullableWithAggregatesFilter<"LandPages"> | Date | string | null
    CompletedDate?: DateTimeNullableWithAggregatesFilter<"LandPages"> | Date | string | null
  }

  export type LanguageDefinitionWhereInput = {
    AND?: LanguageDefinitionWhereInput | LanguageDefinitionWhereInput[]
    OR?: LanguageDefinitionWhereInput[]
    NOT?: LanguageDefinitionWhereInput | LanguageDefinitionWhereInput[]
    LanguageDefinitionID?: IntFilter<"LanguageDefinition"> | number
    ObjectName?: StringFilter<"LanguageDefinition"> | string
    ControlTypeID?: IntFilter<"LanguageDefinition"> | number
    ControlName?: StringFilter<"LanguageDefinition"> | string
    CaptionEnglish?: StringNullableFilter<"LanguageDefinition"> | string | null
    CaptionHebrow?: StringNullableFilter<"LanguageDefinition"> | string | null
    CaptionRomanian?: StringNullableFilter<"LanguageDefinition"> | string | null
    CaptionRussian?: StringNullableFilter<"LanguageDefinition"> | string | null
    CaptionChinese?: StringNullableFilter<"LanguageDefinition"> | string | null
    CaptionTurkish?: StringNullableFilter<"LanguageDefinition"> | string | null
  }

  export type LanguageDefinitionOrderByWithRelationInput = {
    LanguageDefinitionID?: SortOrder
    ObjectName?: SortOrder
    ControlTypeID?: SortOrder
    ControlName?: SortOrder
    CaptionEnglish?: SortOrderInput | SortOrder
    CaptionHebrow?: SortOrderInput | SortOrder
    CaptionRomanian?: SortOrderInput | SortOrder
    CaptionRussian?: SortOrderInput | SortOrder
    CaptionChinese?: SortOrderInput | SortOrder
    CaptionTurkish?: SortOrderInput | SortOrder
  }

  export type LanguageDefinitionWhereUniqueInput = Prisma.AtLeast<{
    LanguageDefinitionID?: number
    ControlName?: string
    AND?: LanguageDefinitionWhereInput | LanguageDefinitionWhereInput[]
    OR?: LanguageDefinitionWhereInput[]
    NOT?: LanguageDefinitionWhereInput | LanguageDefinitionWhereInput[]
    ObjectName?: StringFilter<"LanguageDefinition"> | string
    ControlTypeID?: IntFilter<"LanguageDefinition"> | number
    CaptionEnglish?: StringNullableFilter<"LanguageDefinition"> | string | null
    CaptionHebrow?: StringNullableFilter<"LanguageDefinition"> | string | null
    CaptionRomanian?: StringNullableFilter<"LanguageDefinition"> | string | null
    CaptionRussian?: StringNullableFilter<"LanguageDefinition"> | string | null
    CaptionChinese?: StringNullableFilter<"LanguageDefinition"> | string | null
    CaptionTurkish?: StringNullableFilter<"LanguageDefinition"> | string | null
  }, "LanguageDefinitionID" | "ControlName">

  export type LanguageDefinitionOrderByWithAggregationInput = {
    LanguageDefinitionID?: SortOrder
    ObjectName?: SortOrder
    ControlTypeID?: SortOrder
    ControlName?: SortOrder
    CaptionEnglish?: SortOrderInput | SortOrder
    CaptionHebrow?: SortOrderInput | SortOrder
    CaptionRomanian?: SortOrderInput | SortOrder
    CaptionRussian?: SortOrderInput | SortOrder
    CaptionChinese?: SortOrderInput | SortOrder
    CaptionTurkish?: SortOrderInput | SortOrder
    _count?: LanguageDefinitionCountOrderByAggregateInput
    _avg?: LanguageDefinitionAvgOrderByAggregateInput
    _max?: LanguageDefinitionMaxOrderByAggregateInput
    _min?: LanguageDefinitionMinOrderByAggregateInput
    _sum?: LanguageDefinitionSumOrderByAggregateInput
  }

  export type LanguageDefinitionScalarWhereWithAggregatesInput = {
    AND?: LanguageDefinitionScalarWhereWithAggregatesInput | LanguageDefinitionScalarWhereWithAggregatesInput[]
    OR?: LanguageDefinitionScalarWhereWithAggregatesInput[]
    NOT?: LanguageDefinitionScalarWhereWithAggregatesInput | LanguageDefinitionScalarWhereWithAggregatesInput[]
    LanguageDefinitionID?: IntWithAggregatesFilter<"LanguageDefinition"> | number
    ObjectName?: StringWithAggregatesFilter<"LanguageDefinition"> | string
    ControlTypeID?: IntWithAggregatesFilter<"LanguageDefinition"> | number
    ControlName?: StringWithAggregatesFilter<"LanguageDefinition"> | string
    CaptionEnglish?: StringNullableWithAggregatesFilter<"LanguageDefinition"> | string | null
    CaptionHebrow?: StringNullableWithAggregatesFilter<"LanguageDefinition"> | string | null
    CaptionRomanian?: StringNullableWithAggregatesFilter<"LanguageDefinition"> | string | null
    CaptionRussian?: StringNullableWithAggregatesFilter<"LanguageDefinition"> | string | null
    CaptionChinese?: StringNullableWithAggregatesFilter<"LanguageDefinition"> | string | null
    CaptionTurkish?: StringNullableWithAggregatesFilter<"LanguageDefinition"> | string | null
  }

  export type Lkup_AreaWhereInput = {
    AND?: Lkup_AreaWhereInput | Lkup_AreaWhereInput[]
    OR?: Lkup_AreaWhereInput[]
    NOT?: Lkup_AreaWhereInput | Lkup_AreaWhereInput[]
    AreaID?: IntFilter<"Lkup_Area"> | number
    AreaCode?: IntFilter<"Lkup_Area"> | number
    AreaName?: StringFilter<"Lkup_Area"> | string
    Amount?: FloatFilter<"Lkup_Area"> | number
  }

  export type Lkup_AreaOrderByWithRelationInput = {
    AreaID?: SortOrder
    AreaCode?: SortOrder
    AreaName?: SortOrder
    Amount?: SortOrder
  }

  export type Lkup_AreaWhereUniqueInput = Prisma.AtLeast<{
    AreaID?: number
    AreaCode?: number
    AreaName?: string
    AND?: Lkup_AreaWhereInput | Lkup_AreaWhereInput[]
    OR?: Lkup_AreaWhereInput[]
    NOT?: Lkup_AreaWhereInput | Lkup_AreaWhereInput[]
    Amount?: FloatFilter<"Lkup_Area"> | number
  }, "AreaID" | "AreaCode" | "AreaName">

  export type Lkup_AreaOrderByWithAggregationInput = {
    AreaID?: SortOrder
    AreaCode?: SortOrder
    AreaName?: SortOrder
    Amount?: SortOrder
    _count?: Lkup_AreaCountOrderByAggregateInput
    _avg?: Lkup_AreaAvgOrderByAggregateInput
    _max?: Lkup_AreaMaxOrderByAggregateInput
    _min?: Lkup_AreaMinOrderByAggregateInput
    _sum?: Lkup_AreaSumOrderByAggregateInput
  }

  export type Lkup_AreaScalarWhereWithAggregatesInput = {
    AND?: Lkup_AreaScalarWhereWithAggregatesInput | Lkup_AreaScalarWhereWithAggregatesInput[]
    OR?: Lkup_AreaScalarWhereWithAggregatesInput[]
    NOT?: Lkup_AreaScalarWhereWithAggregatesInput | Lkup_AreaScalarWhereWithAggregatesInput[]
    AreaID?: IntWithAggregatesFilter<"Lkup_Area"> | number
    AreaCode?: IntWithAggregatesFilter<"Lkup_Area"> | number
    AreaName?: StringWithAggregatesFilter<"Lkup_Area"> | string
    Amount?: FloatWithAggregatesFilter<"Lkup_Area"> | number
  }

  export type Lkup_BanksWhereInput = {
    AND?: Lkup_BanksWhereInput | Lkup_BanksWhereInput[]
    OR?: Lkup_BanksWhereInput[]
    NOT?: Lkup_BanksWhereInput | Lkup_BanksWhereInput[]
    BankID?: IntFilter<"Lkup_Banks"> | number
    BankName?: StringFilter<"Lkup_Banks"> | string
    BankNumber?: IntFilter<"Lkup_Banks"> | number
    CountryID?: IntNullableFilter<"Lkup_Banks"> | number | null
  }

  export type Lkup_BanksOrderByWithRelationInput = {
    BankID?: SortOrder
    BankName?: SortOrder
    BankNumber?: SortOrder
    CountryID?: SortOrderInput | SortOrder
  }

  export type Lkup_BanksWhereUniqueInput = Prisma.AtLeast<{
    BankID?: number
    BankNumber?: number
    AND?: Lkup_BanksWhereInput | Lkup_BanksWhereInput[]
    OR?: Lkup_BanksWhereInput[]
    NOT?: Lkup_BanksWhereInput | Lkup_BanksWhereInput[]
    BankName?: StringFilter<"Lkup_Banks"> | string
    CountryID?: IntNullableFilter<"Lkup_Banks"> | number | null
  }, "BankID" | "BankNumber">

  export type Lkup_BanksOrderByWithAggregationInput = {
    BankID?: SortOrder
    BankName?: SortOrder
    BankNumber?: SortOrder
    CountryID?: SortOrderInput | SortOrder
    _count?: Lkup_BanksCountOrderByAggregateInput
    _avg?: Lkup_BanksAvgOrderByAggregateInput
    _max?: Lkup_BanksMaxOrderByAggregateInput
    _min?: Lkup_BanksMinOrderByAggregateInput
    _sum?: Lkup_BanksSumOrderByAggregateInput
  }

  export type Lkup_BanksScalarWhereWithAggregatesInput = {
    AND?: Lkup_BanksScalarWhereWithAggregatesInput | Lkup_BanksScalarWhereWithAggregatesInput[]
    OR?: Lkup_BanksScalarWhereWithAggregatesInput[]
    NOT?: Lkup_BanksScalarWhereWithAggregatesInput | Lkup_BanksScalarWhereWithAggregatesInput[]
    BankID?: IntWithAggregatesFilter<"Lkup_Banks"> | number
    BankName?: StringWithAggregatesFilter<"Lkup_Banks"> | string
    BankNumber?: IntWithAggregatesFilter<"Lkup_Banks"> | number
    CountryID?: IntNullableWithAggregatesFilter<"Lkup_Banks"> | number | null
  }

  export type Lkup_BanksVerBranchWhereInput = {
    AND?: Lkup_BanksVerBranchWhereInput | Lkup_BanksVerBranchWhereInput[]
    OR?: Lkup_BanksVerBranchWhereInput[]
    NOT?: Lkup_BanksVerBranchWhereInput | Lkup_BanksVerBranchWhereInput[]
    BranchID?: IntFilter<"Lkup_BanksVerBranch"> | number
    BankID?: IntNullableFilter<"Lkup_BanksVerBranch"> | number | null
    BranchName?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    BranchCode?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    Address?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    SortCode?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    Phone_1?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    Phone_2?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    FaxNumber?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    EMail?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    Comment?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
  }

  export type Lkup_BanksVerBranchOrderByWithRelationInput = {
    BranchID?: SortOrder
    BankID?: SortOrderInput | SortOrder
    BranchName?: SortOrderInput | SortOrder
    BranchCode?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    SortCode?: SortOrderInput | SortOrder
    Phone_1?: SortOrderInput | SortOrder
    Phone_2?: SortOrderInput | SortOrder
    FaxNumber?: SortOrderInput | SortOrder
    EMail?: SortOrderInput | SortOrder
    Comment?: SortOrderInput | SortOrder
  }

  export type Lkup_BanksVerBranchWhereUniqueInput = Prisma.AtLeast<{
    BranchID?: number
    BranchCode_BankID?: Lkup_BanksVerBranchBranchCodeBankIDCompoundUniqueInput
    AND?: Lkup_BanksVerBranchWhereInput | Lkup_BanksVerBranchWhereInput[]
    OR?: Lkup_BanksVerBranchWhereInput[]
    NOT?: Lkup_BanksVerBranchWhereInput | Lkup_BanksVerBranchWhereInput[]
    BankID?: IntNullableFilter<"Lkup_BanksVerBranch"> | number | null
    BranchName?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    BranchCode?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    Address?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    SortCode?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    Phone_1?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    Phone_2?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    FaxNumber?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    EMail?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
    Comment?: StringNullableFilter<"Lkup_BanksVerBranch"> | string | null
  }, "BranchID" | "BranchCode_BankID">

  export type Lkup_BanksVerBranchOrderByWithAggregationInput = {
    BranchID?: SortOrder
    BankID?: SortOrderInput | SortOrder
    BranchName?: SortOrderInput | SortOrder
    BranchCode?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    SortCode?: SortOrderInput | SortOrder
    Phone_1?: SortOrderInput | SortOrder
    Phone_2?: SortOrderInput | SortOrder
    FaxNumber?: SortOrderInput | SortOrder
    EMail?: SortOrderInput | SortOrder
    Comment?: SortOrderInput | SortOrder
    _count?: Lkup_BanksVerBranchCountOrderByAggregateInput
    _avg?: Lkup_BanksVerBranchAvgOrderByAggregateInput
    _max?: Lkup_BanksVerBranchMaxOrderByAggregateInput
    _min?: Lkup_BanksVerBranchMinOrderByAggregateInput
    _sum?: Lkup_BanksVerBranchSumOrderByAggregateInput
  }

  export type Lkup_BanksVerBranchScalarWhereWithAggregatesInput = {
    AND?: Lkup_BanksVerBranchScalarWhereWithAggregatesInput | Lkup_BanksVerBranchScalarWhereWithAggregatesInput[]
    OR?: Lkup_BanksVerBranchScalarWhereWithAggregatesInput[]
    NOT?: Lkup_BanksVerBranchScalarWhereWithAggregatesInput | Lkup_BanksVerBranchScalarWhereWithAggregatesInput[]
    BranchID?: IntWithAggregatesFilter<"Lkup_BanksVerBranch"> | number
    BankID?: IntNullableWithAggregatesFilter<"Lkup_BanksVerBranch"> | number | null
    BranchName?: StringNullableWithAggregatesFilter<"Lkup_BanksVerBranch"> | string | null
    BranchCode?: StringNullableWithAggregatesFilter<"Lkup_BanksVerBranch"> | string | null
    Address?: StringNullableWithAggregatesFilter<"Lkup_BanksVerBranch"> | string | null
    SortCode?: StringNullableWithAggregatesFilter<"Lkup_BanksVerBranch"> | string | null
    Phone_1?: StringNullableWithAggregatesFilter<"Lkup_BanksVerBranch"> | string | null
    Phone_2?: StringNullableWithAggregatesFilter<"Lkup_BanksVerBranch"> | string | null
    FaxNumber?: StringNullableWithAggregatesFilter<"Lkup_BanksVerBranch"> | string | null
    EMail?: StringNullableWithAggregatesFilter<"Lkup_BanksVerBranch"> | string | null
    Comment?: StringNullableWithAggregatesFilter<"Lkup_BanksVerBranch"> | string | null
  }

  export type Lkup_CityWhereInput = {
    AND?: Lkup_CityWhereInput | Lkup_CityWhereInput[]
    OR?: Lkup_CityWhereInput[]
    NOT?: Lkup_CityWhereInput | Lkup_CityWhereInput[]
    CityID?: IntFilter<"Lkup_City"> | number
    CityCode?: IntFilter<"Lkup_City"> | number
    CityName?: StringFilter<"Lkup_City"> | string
    CityNameEng?: StringFilter<"Lkup_City"> | string
  }

  export type Lkup_CityOrderByWithRelationInput = {
    CityID?: SortOrder
    CityCode?: SortOrder
    CityName?: SortOrder
    CityNameEng?: SortOrder
  }

  export type Lkup_CityWhereUniqueInput = Prisma.AtLeast<{
    CityID?: number
    CityCode?: number
    AND?: Lkup_CityWhereInput | Lkup_CityWhereInput[]
    OR?: Lkup_CityWhereInput[]
    NOT?: Lkup_CityWhereInput | Lkup_CityWhereInput[]
    CityName?: StringFilter<"Lkup_City"> | string
    CityNameEng?: StringFilter<"Lkup_City"> | string
  }, "CityID" | "CityCode">

  export type Lkup_CityOrderByWithAggregationInput = {
    CityID?: SortOrder
    CityCode?: SortOrder
    CityName?: SortOrder
    CityNameEng?: SortOrder
    _count?: Lkup_CityCountOrderByAggregateInput
    _avg?: Lkup_CityAvgOrderByAggregateInput
    _max?: Lkup_CityMaxOrderByAggregateInput
    _min?: Lkup_CityMinOrderByAggregateInput
    _sum?: Lkup_CitySumOrderByAggregateInput
  }

  export type Lkup_CityScalarWhereWithAggregatesInput = {
    AND?: Lkup_CityScalarWhereWithAggregatesInput | Lkup_CityScalarWhereWithAggregatesInput[]
    OR?: Lkup_CityScalarWhereWithAggregatesInput[]
    NOT?: Lkup_CityScalarWhereWithAggregatesInput | Lkup_CityScalarWhereWithAggregatesInput[]
    CityID?: IntWithAggregatesFilter<"Lkup_City"> | number
    CityCode?: IntWithAggregatesFilter<"Lkup_City"> | number
    CityName?: StringWithAggregatesFilter<"Lkup_City"> | string
    CityNameEng?: StringWithAggregatesFilter<"Lkup_City"> | string
  }

  export type Lkup_CorporationWhereInput = {
    AND?: Lkup_CorporationWhereInput | Lkup_CorporationWhereInput[]
    OR?: Lkup_CorporationWhereInput[]
    NOT?: Lkup_CorporationWhereInput | Lkup_CorporationWhereInput[]
    CorporationID?: IntFilter<"Lkup_Corporation"> | number
    CorporationName?: StringFilter<"Lkup_Corporation"> | string
    IsActive?: IntFilter<"Lkup_Corporation"> | number
    CorporationNumber?: IntFilter<"Lkup_Corporation"> | number
    Address?: StringNullableFilter<"Lkup_Corporation"> | string | null
    Email?: StringNullableFilter<"Lkup_Corporation"> | string | null
    Phone?: StringNullableFilter<"Lkup_Corporation"> | string | null
    Cfo_email?: StringNullableFilter<"Lkup_Corporation"> | string | null
    Contact_name?: StringNullableFilter<"Lkup_Corporation"> | string | null
    Contact_phone?: StringNullableFilter<"Lkup_Corporation"> | string | null
    Ops_email?: StringNullableFilter<"Lkup_Corporation"> | string | null
    SoftTalkTaxToken?: StringNullableFilter<"Lkup_Corporation"> | string | null
    CorporationAutoLink?: StringNullableFilter<"Lkup_Corporation"> | string | null
  }

  export type Lkup_CorporationOrderByWithRelationInput = {
    CorporationID?: SortOrder
    CorporationName?: SortOrder
    IsActive?: SortOrder
    CorporationNumber?: SortOrder
    Address?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    Phone?: SortOrderInput | SortOrder
    Cfo_email?: SortOrderInput | SortOrder
    Contact_name?: SortOrderInput | SortOrder
    Contact_phone?: SortOrderInput | SortOrder
    Ops_email?: SortOrderInput | SortOrder
    SoftTalkTaxToken?: SortOrderInput | SortOrder
    CorporationAutoLink?: SortOrderInput | SortOrder
  }

  export type Lkup_CorporationWhereUniqueInput = Prisma.AtLeast<{
    CorporationID?: number
    CorporationName?: string
    CorporationNumber?: number
    AND?: Lkup_CorporationWhereInput | Lkup_CorporationWhereInput[]
    OR?: Lkup_CorporationWhereInput[]
    NOT?: Lkup_CorporationWhereInput | Lkup_CorporationWhereInput[]
    IsActive?: IntFilter<"Lkup_Corporation"> | number
    Address?: StringNullableFilter<"Lkup_Corporation"> | string | null
    Email?: StringNullableFilter<"Lkup_Corporation"> | string | null
    Phone?: StringNullableFilter<"Lkup_Corporation"> | string | null
    Cfo_email?: StringNullableFilter<"Lkup_Corporation"> | string | null
    Contact_name?: StringNullableFilter<"Lkup_Corporation"> | string | null
    Contact_phone?: StringNullableFilter<"Lkup_Corporation"> | string | null
    Ops_email?: StringNullableFilter<"Lkup_Corporation"> | string | null
    SoftTalkTaxToken?: StringNullableFilter<"Lkup_Corporation"> | string | null
    CorporationAutoLink?: StringNullableFilter<"Lkup_Corporation"> | string | null
  }, "CorporationID" | "CorporationName" | "CorporationNumber">

  export type Lkup_CorporationOrderByWithAggregationInput = {
    CorporationID?: SortOrder
    CorporationName?: SortOrder
    IsActive?: SortOrder
    CorporationNumber?: SortOrder
    Address?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    Phone?: SortOrderInput | SortOrder
    Cfo_email?: SortOrderInput | SortOrder
    Contact_name?: SortOrderInput | SortOrder
    Contact_phone?: SortOrderInput | SortOrder
    Ops_email?: SortOrderInput | SortOrder
    SoftTalkTaxToken?: SortOrderInput | SortOrder
    CorporationAutoLink?: SortOrderInput | SortOrder
    _count?: Lkup_CorporationCountOrderByAggregateInput
    _avg?: Lkup_CorporationAvgOrderByAggregateInput
    _max?: Lkup_CorporationMaxOrderByAggregateInput
    _min?: Lkup_CorporationMinOrderByAggregateInput
    _sum?: Lkup_CorporationSumOrderByAggregateInput
  }

  export type Lkup_CorporationScalarWhereWithAggregatesInput = {
    AND?: Lkup_CorporationScalarWhereWithAggregatesInput | Lkup_CorporationScalarWhereWithAggregatesInput[]
    OR?: Lkup_CorporationScalarWhereWithAggregatesInput[]
    NOT?: Lkup_CorporationScalarWhereWithAggregatesInput | Lkup_CorporationScalarWhereWithAggregatesInput[]
    CorporationID?: IntWithAggregatesFilter<"Lkup_Corporation"> | number
    CorporationName?: StringWithAggregatesFilter<"Lkup_Corporation"> | string
    IsActive?: IntWithAggregatesFilter<"Lkup_Corporation"> | number
    CorporationNumber?: IntWithAggregatesFilter<"Lkup_Corporation"> | number
    Address?: StringNullableWithAggregatesFilter<"Lkup_Corporation"> | string | null
    Email?: StringNullableWithAggregatesFilter<"Lkup_Corporation"> | string | null
    Phone?: StringNullableWithAggregatesFilter<"Lkup_Corporation"> | string | null
    Cfo_email?: StringNullableWithAggregatesFilter<"Lkup_Corporation"> | string | null
    Contact_name?: StringNullableWithAggregatesFilter<"Lkup_Corporation"> | string | null
    Contact_phone?: StringNullableWithAggregatesFilter<"Lkup_Corporation"> | string | null
    Ops_email?: StringNullableWithAggregatesFilter<"Lkup_Corporation"> | string | null
    SoftTalkTaxToken?: StringNullableWithAggregatesFilter<"Lkup_Corporation"> | string | null
    CorporationAutoLink?: StringNullableWithAggregatesFilter<"Lkup_Corporation"> | string | null
  }

  export type Lkup_CountryWhereInput = {
    AND?: Lkup_CountryWhereInput | Lkup_CountryWhereInput[]
    OR?: Lkup_CountryWhereInput[]
    NOT?: Lkup_CountryWhereInput | Lkup_CountryWhereInput[]
    CountryID?: IntFilter<"Lkup_Country"> | number
    CountryCode?: StringFilter<"Lkup_Country"> | string
    CountryName?: StringFilter<"Lkup_Country"> | string
    CountryNameEnglish?: StringNullableFilter<"Lkup_Country"> | string | null
    MultipleSelect?: IntFilter<"Lkup_Country"> | number
  }

  export type Lkup_CountryOrderByWithRelationInput = {
    CountryID?: SortOrder
    CountryCode?: SortOrder
    CountryName?: SortOrder
    CountryNameEnglish?: SortOrderInput | SortOrder
    MultipleSelect?: SortOrder
  }

  export type Lkup_CountryWhereUniqueInput = Prisma.AtLeast<{
    CountryID?: number
    CountryName?: string
    AND?: Lkup_CountryWhereInput | Lkup_CountryWhereInput[]
    OR?: Lkup_CountryWhereInput[]
    NOT?: Lkup_CountryWhereInput | Lkup_CountryWhereInput[]
    CountryCode?: StringFilter<"Lkup_Country"> | string
    CountryNameEnglish?: StringNullableFilter<"Lkup_Country"> | string | null
    MultipleSelect?: IntFilter<"Lkup_Country"> | number
  }, "CountryID" | "CountryName">

  export type Lkup_CountryOrderByWithAggregationInput = {
    CountryID?: SortOrder
    CountryCode?: SortOrder
    CountryName?: SortOrder
    CountryNameEnglish?: SortOrderInput | SortOrder
    MultipleSelect?: SortOrder
    _count?: Lkup_CountryCountOrderByAggregateInput
    _avg?: Lkup_CountryAvgOrderByAggregateInput
    _max?: Lkup_CountryMaxOrderByAggregateInput
    _min?: Lkup_CountryMinOrderByAggregateInput
    _sum?: Lkup_CountrySumOrderByAggregateInput
  }

  export type Lkup_CountryScalarWhereWithAggregatesInput = {
    AND?: Lkup_CountryScalarWhereWithAggregatesInput | Lkup_CountryScalarWhereWithAggregatesInput[]
    OR?: Lkup_CountryScalarWhereWithAggregatesInput[]
    NOT?: Lkup_CountryScalarWhereWithAggregatesInput | Lkup_CountryScalarWhereWithAggregatesInput[]
    CountryID?: IntWithAggregatesFilter<"Lkup_Country"> | number
    CountryCode?: StringWithAggregatesFilter<"Lkup_Country"> | string
    CountryName?: StringWithAggregatesFilter<"Lkup_Country"> | string
    CountryNameEnglish?: StringNullableWithAggregatesFilter<"Lkup_Country"> | string | null
    MultipleSelect?: IntWithAggregatesFilter<"Lkup_Country"> | number
  }

  export type Lkup_CreaditCardWhereInput = {
    AND?: Lkup_CreaditCardWhereInput | Lkup_CreaditCardWhereInput[]
    OR?: Lkup_CreaditCardWhereInput[]
    NOT?: Lkup_CreaditCardWhereInput | Lkup_CreaditCardWhereInput[]
    CardID?: IntFilter<"Lkup_CreaditCard"> | number
    CardName?: StringFilter<"Lkup_CreaditCard"> | string
    CardCode?: IntFilter<"Lkup_CreaditCard"> | number
  }

  export type Lkup_CreaditCardOrderByWithRelationInput = {
    CardID?: SortOrder
    CardName?: SortOrder
    CardCode?: SortOrder
  }

  export type Lkup_CreaditCardWhereUniqueInput = Prisma.AtLeast<{
    CardID?: number
    CardName?: string
    CardCode?: number
    AND?: Lkup_CreaditCardWhereInput | Lkup_CreaditCardWhereInput[]
    OR?: Lkup_CreaditCardWhereInput[]
    NOT?: Lkup_CreaditCardWhereInput | Lkup_CreaditCardWhereInput[]
  }, "CardID" | "CardName" | "CardCode">

  export type Lkup_CreaditCardOrderByWithAggregationInput = {
    CardID?: SortOrder
    CardName?: SortOrder
    CardCode?: SortOrder
    _count?: Lkup_CreaditCardCountOrderByAggregateInput
    _avg?: Lkup_CreaditCardAvgOrderByAggregateInput
    _max?: Lkup_CreaditCardMaxOrderByAggregateInput
    _min?: Lkup_CreaditCardMinOrderByAggregateInput
    _sum?: Lkup_CreaditCardSumOrderByAggregateInput
  }

  export type Lkup_CreaditCardScalarWhereWithAggregatesInput = {
    AND?: Lkup_CreaditCardScalarWhereWithAggregatesInput | Lkup_CreaditCardScalarWhereWithAggregatesInput[]
    OR?: Lkup_CreaditCardScalarWhereWithAggregatesInput[]
    NOT?: Lkup_CreaditCardScalarWhereWithAggregatesInput | Lkup_CreaditCardScalarWhereWithAggregatesInput[]
    CardID?: IntWithAggregatesFilter<"Lkup_CreaditCard"> | number
    CardName?: StringWithAggregatesFilter<"Lkup_CreaditCard"> | string
    CardCode?: IntWithAggregatesFilter<"Lkup_CreaditCard"> | number
  }

  export type Lkup_EmployeesTypeWhereInput = {
    AND?: Lkup_EmployeesTypeWhereInput | Lkup_EmployeesTypeWhereInput[]
    OR?: Lkup_EmployeesTypeWhereInput[]
    NOT?: Lkup_EmployeesTypeWhereInput | Lkup_EmployeesTypeWhereInput[]
    TypeID?: IntFilter<"Lkup_EmployeesType"> | number
    TypeName?: StringFilter<"Lkup_EmployeesType"> | string
  }

  export type Lkup_EmployeesTypeOrderByWithRelationInput = {
    TypeID?: SortOrder
    TypeName?: SortOrder
  }

  export type Lkup_EmployeesTypeWhereUniqueInput = Prisma.AtLeast<{
    TypeID?: number
    TypeName?: string
    AND?: Lkup_EmployeesTypeWhereInput | Lkup_EmployeesTypeWhereInput[]
    OR?: Lkup_EmployeesTypeWhereInput[]
    NOT?: Lkup_EmployeesTypeWhereInput | Lkup_EmployeesTypeWhereInput[]
  }, "TypeID" | "TypeName">

  export type Lkup_EmployeesTypeOrderByWithAggregationInput = {
    TypeID?: SortOrder
    TypeName?: SortOrder
    _count?: Lkup_EmployeesTypeCountOrderByAggregateInput
    _avg?: Lkup_EmployeesTypeAvgOrderByAggregateInput
    _max?: Lkup_EmployeesTypeMaxOrderByAggregateInput
    _min?: Lkup_EmployeesTypeMinOrderByAggregateInput
    _sum?: Lkup_EmployeesTypeSumOrderByAggregateInput
  }

  export type Lkup_EmployeesTypeScalarWhereWithAggregatesInput = {
    AND?: Lkup_EmployeesTypeScalarWhereWithAggregatesInput | Lkup_EmployeesTypeScalarWhereWithAggregatesInput[]
    OR?: Lkup_EmployeesTypeScalarWhereWithAggregatesInput[]
    NOT?: Lkup_EmployeesTypeScalarWhereWithAggregatesInput | Lkup_EmployeesTypeScalarWhereWithAggregatesInput[]
    TypeID?: IntWithAggregatesFilter<"Lkup_EmployeesType"> | number
    TypeName?: StringWithAggregatesFilter<"Lkup_EmployeesType"> | string
  }

  export type Lkup_LanguageWhereInput = {
    AND?: Lkup_LanguageWhereInput | Lkup_LanguageWhereInput[]
    OR?: Lkup_LanguageWhereInput[]
    NOT?: Lkup_LanguageWhereInput | Lkup_LanguageWhereInput[]
    LanguageID?: IntFilter<"Lkup_Language"> | number
    LanguageName?: StringFilter<"Lkup_Language"> | string
  }

  export type Lkup_LanguageOrderByWithRelationInput = {
    LanguageID?: SortOrder
    LanguageName?: SortOrder
  }

  export type Lkup_LanguageWhereUniqueInput = Prisma.AtLeast<{
    LanguageID?: number
    LanguageName?: string
    AND?: Lkup_LanguageWhereInput | Lkup_LanguageWhereInput[]
    OR?: Lkup_LanguageWhereInput[]
    NOT?: Lkup_LanguageWhereInput | Lkup_LanguageWhereInput[]
  }, "LanguageID" | "LanguageName">

  export type Lkup_LanguageOrderByWithAggregationInput = {
    LanguageID?: SortOrder
    LanguageName?: SortOrder
    _count?: Lkup_LanguageCountOrderByAggregateInput
    _avg?: Lkup_LanguageAvgOrderByAggregateInput
    _max?: Lkup_LanguageMaxOrderByAggregateInput
    _min?: Lkup_LanguageMinOrderByAggregateInput
    _sum?: Lkup_LanguageSumOrderByAggregateInput
  }

  export type Lkup_LanguageScalarWhereWithAggregatesInput = {
    AND?: Lkup_LanguageScalarWhereWithAggregatesInput | Lkup_LanguageScalarWhereWithAggregatesInput[]
    OR?: Lkup_LanguageScalarWhereWithAggregatesInput[]
    NOT?: Lkup_LanguageScalarWhereWithAggregatesInput | Lkup_LanguageScalarWhereWithAggregatesInput[]
    LanguageID?: IntWithAggregatesFilter<"Lkup_Language"> | number
    LanguageName?: StringWithAggregatesFilter<"Lkup_Language"> | string
  }

  export type Lkup_PaySlipWhereInput = {
    AND?: Lkup_PaySlipWhereInput | Lkup_PaySlipWhereInput[]
    OR?: Lkup_PaySlipWhereInput[]
    NOT?: Lkup_PaySlipWhereInput | Lkup_PaySlipWhereInput[]
    PaySlipCode?: IntFilter<"Lkup_PaySlip"> | number
    PaySlipName?: StringNullableFilter<"Lkup_PaySlip"> | string | null
    PaySlipNameSource?: StringNullableFilter<"Lkup_PaySlip"> | string | null
    IsTytle?: BoolFilter<"Lkup_PaySlip"> | boolean
  }

  export type Lkup_PaySlipOrderByWithRelationInput = {
    PaySlipCode?: SortOrder
    PaySlipName?: SortOrderInput | SortOrder
    PaySlipNameSource?: SortOrderInput | SortOrder
    IsTytle?: SortOrder
  }

  export type Lkup_PaySlipWhereUniqueInput = Prisma.AtLeast<{
    PaySlipCode?: number
    PaySlipName?: string
    AND?: Lkup_PaySlipWhereInput | Lkup_PaySlipWhereInput[]
    OR?: Lkup_PaySlipWhereInput[]
    NOT?: Lkup_PaySlipWhereInput | Lkup_PaySlipWhereInput[]
    PaySlipNameSource?: StringNullableFilter<"Lkup_PaySlip"> | string | null
    IsTytle?: BoolFilter<"Lkup_PaySlip"> | boolean
  }, "PaySlipCode" | "PaySlipName">

  export type Lkup_PaySlipOrderByWithAggregationInput = {
    PaySlipCode?: SortOrder
    PaySlipName?: SortOrderInput | SortOrder
    PaySlipNameSource?: SortOrderInput | SortOrder
    IsTytle?: SortOrder
    _count?: Lkup_PaySlipCountOrderByAggregateInput
    _avg?: Lkup_PaySlipAvgOrderByAggregateInput
    _max?: Lkup_PaySlipMaxOrderByAggregateInput
    _min?: Lkup_PaySlipMinOrderByAggregateInput
    _sum?: Lkup_PaySlipSumOrderByAggregateInput
  }

  export type Lkup_PaySlipScalarWhereWithAggregatesInput = {
    AND?: Lkup_PaySlipScalarWhereWithAggregatesInput | Lkup_PaySlipScalarWhereWithAggregatesInput[]
    OR?: Lkup_PaySlipScalarWhereWithAggregatesInput[]
    NOT?: Lkup_PaySlipScalarWhereWithAggregatesInput | Lkup_PaySlipScalarWhereWithAggregatesInput[]
    PaySlipCode?: IntWithAggregatesFilter<"Lkup_PaySlip"> | number
    PaySlipName?: StringNullableWithAggregatesFilter<"Lkup_PaySlip"> | string | null
    PaySlipNameSource?: StringNullableWithAggregatesFilter<"Lkup_PaySlip"> | string | null
    IsTytle?: BoolWithAggregatesFilter<"Lkup_PaySlip"> | boolean
  }

  export type Lkup_SectorWhereInput = {
    AND?: Lkup_SectorWhereInput | Lkup_SectorWhereInput[]
    OR?: Lkup_SectorWhereInput[]
    NOT?: Lkup_SectorWhereInput | Lkup_SectorWhereInput[]
    SectorID?: IntFilter<"Lkup_Sector"> | number
    SectorCode?: IntNullableFilter<"Lkup_Sector"> | number | null
    SectorName?: StringNullableFilter<"Lkup_Sector"> | string | null
  }

  export type Lkup_SectorOrderByWithRelationInput = {
    SectorID?: SortOrder
    SectorCode?: SortOrderInput | SortOrder
    SectorName?: SortOrderInput | SortOrder
  }

  export type Lkup_SectorWhereUniqueInput = Prisma.AtLeast<{
    SectorID?: number
    SectorCode?: number
    SectorName?: string
    AND?: Lkup_SectorWhereInput | Lkup_SectorWhereInput[]
    OR?: Lkup_SectorWhereInput[]
    NOT?: Lkup_SectorWhereInput | Lkup_SectorWhereInput[]
  }, "SectorID" | "SectorCode" | "SectorName">

  export type Lkup_SectorOrderByWithAggregationInput = {
    SectorID?: SortOrder
    SectorCode?: SortOrderInput | SortOrder
    SectorName?: SortOrderInput | SortOrder
    _count?: Lkup_SectorCountOrderByAggregateInput
    _avg?: Lkup_SectorAvgOrderByAggregateInput
    _max?: Lkup_SectorMaxOrderByAggregateInput
    _min?: Lkup_SectorMinOrderByAggregateInput
    _sum?: Lkup_SectorSumOrderByAggregateInput
  }

  export type Lkup_SectorScalarWhereWithAggregatesInput = {
    AND?: Lkup_SectorScalarWhereWithAggregatesInput | Lkup_SectorScalarWhereWithAggregatesInput[]
    OR?: Lkup_SectorScalarWhereWithAggregatesInput[]
    NOT?: Lkup_SectorScalarWhereWithAggregatesInput | Lkup_SectorScalarWhereWithAggregatesInput[]
    SectorID?: IntWithAggregatesFilter<"Lkup_Sector"> | number
    SectorCode?: IntNullableWithAggregatesFilter<"Lkup_Sector"> | number | null
    SectorName?: StringNullableWithAggregatesFilter<"Lkup_Sector"> | string | null
  }

  export type Lkup_SocialSecuritySectorWhereInput = {
    AND?: Lkup_SocialSecuritySectorWhereInput | Lkup_SocialSecuritySectorWhereInput[]
    OR?: Lkup_SocialSecuritySectorWhereInput[]
    NOT?: Lkup_SocialSecuritySectorWhereInput | Lkup_SocialSecuritySectorWhereInput[]
    SocialSecurityID?: IntFilter<"Lkup_SocialSecuritySector"> | number
    SocialSecurityCode?: IntFilter<"Lkup_SocialSecuritySector"> | number
    SocialSecurityName?: StringFilter<"Lkup_SocialSecuritySector"> | string
  }

  export type Lkup_SocialSecuritySectorOrderByWithRelationInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityCode?: SortOrder
    SocialSecurityName?: SortOrder
  }

  export type Lkup_SocialSecuritySectorWhereUniqueInput = Prisma.AtLeast<{
    SocialSecurityID?: number
    AND?: Lkup_SocialSecuritySectorWhereInput | Lkup_SocialSecuritySectorWhereInput[]
    OR?: Lkup_SocialSecuritySectorWhereInput[]
    NOT?: Lkup_SocialSecuritySectorWhereInput | Lkup_SocialSecuritySectorWhereInput[]
    SocialSecurityCode?: IntFilter<"Lkup_SocialSecuritySector"> | number
    SocialSecurityName?: StringFilter<"Lkup_SocialSecuritySector"> | string
  }, "SocialSecurityID">

  export type Lkup_SocialSecuritySectorOrderByWithAggregationInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityCode?: SortOrder
    SocialSecurityName?: SortOrder
    _count?: Lkup_SocialSecuritySectorCountOrderByAggregateInput
    _avg?: Lkup_SocialSecuritySectorAvgOrderByAggregateInput
    _max?: Lkup_SocialSecuritySectorMaxOrderByAggregateInput
    _min?: Lkup_SocialSecuritySectorMinOrderByAggregateInput
    _sum?: Lkup_SocialSecuritySectorSumOrderByAggregateInput
  }

  export type Lkup_SocialSecuritySectorScalarWhereWithAggregatesInput = {
    AND?: Lkup_SocialSecuritySectorScalarWhereWithAggregatesInput | Lkup_SocialSecuritySectorScalarWhereWithAggregatesInput[]
    OR?: Lkup_SocialSecuritySectorScalarWhereWithAggregatesInput[]
    NOT?: Lkup_SocialSecuritySectorScalarWhereWithAggregatesInput | Lkup_SocialSecuritySectorScalarWhereWithAggregatesInput[]
    SocialSecurityID?: IntWithAggregatesFilter<"Lkup_SocialSecuritySector"> | number
    SocialSecurityCode?: IntWithAggregatesFilter<"Lkup_SocialSecuritySector"> | number
    SocialSecurityName?: StringWithAggregatesFilter<"Lkup_SocialSecuritySector"> | string
  }

  export type Lkup_streetWhereInput = {
    AND?: Lkup_streetWhereInput | Lkup_streetWhereInput[]
    OR?: Lkup_streetWhereInput[]
    NOT?: Lkup_streetWhereInput | Lkup_streetWhereInput[]
    StrretID?: IntFilter<"Lkup_street"> | number
    StreetName?: StringNullableFilter<"Lkup_street"> | string | null
    StreetCode?: IntNullableFilter<"Lkup_street"> | number | null
    Citycode?: IntNullableFilter<"Lkup_street"> | number | null
    StreetNameEng?: StringNullableFilter<"Lkup_street"> | string | null
  }

  export type Lkup_streetOrderByWithRelationInput = {
    StrretID?: SortOrder
    StreetName?: SortOrderInput | SortOrder
    StreetCode?: SortOrderInput | SortOrder
    Citycode?: SortOrderInput | SortOrder
    StreetNameEng?: SortOrderInput | SortOrder
  }

  export type Lkup_streetWhereUniqueInput = Prisma.AtLeast<{
    StrretID?: number
    AND?: Lkup_streetWhereInput | Lkup_streetWhereInput[]
    OR?: Lkup_streetWhereInput[]
    NOT?: Lkup_streetWhereInput | Lkup_streetWhereInput[]
    StreetName?: StringNullableFilter<"Lkup_street"> | string | null
    StreetCode?: IntNullableFilter<"Lkup_street"> | number | null
    Citycode?: IntNullableFilter<"Lkup_street"> | number | null
    StreetNameEng?: StringNullableFilter<"Lkup_street"> | string | null
  }, "StrretID">

  export type Lkup_streetOrderByWithAggregationInput = {
    StrretID?: SortOrder
    StreetName?: SortOrderInput | SortOrder
    StreetCode?: SortOrderInput | SortOrder
    Citycode?: SortOrderInput | SortOrder
    StreetNameEng?: SortOrderInput | SortOrder
    _count?: Lkup_streetCountOrderByAggregateInput
    _avg?: Lkup_streetAvgOrderByAggregateInput
    _max?: Lkup_streetMaxOrderByAggregateInput
    _min?: Lkup_streetMinOrderByAggregateInput
    _sum?: Lkup_streetSumOrderByAggregateInput
  }

  export type Lkup_streetScalarWhereWithAggregatesInput = {
    AND?: Lkup_streetScalarWhereWithAggregatesInput | Lkup_streetScalarWhereWithAggregatesInput[]
    OR?: Lkup_streetScalarWhereWithAggregatesInput[]
    NOT?: Lkup_streetScalarWhereWithAggregatesInput | Lkup_streetScalarWhereWithAggregatesInput[]
    StrretID?: IntWithAggregatesFilter<"Lkup_street"> | number
    StreetName?: StringNullableWithAggregatesFilter<"Lkup_street"> | string | null
    StreetCode?: IntNullableWithAggregatesFilter<"Lkup_street"> | number | null
    Citycode?: IntNullableWithAggregatesFilter<"Lkup_street"> | number | null
    StreetNameEng?: StringNullableWithAggregatesFilter<"Lkup_street"> | string | null
  }

  export type PensionDetailWhereInput = {
    AND?: PensionDetailWhereInput | PensionDetailWhereInput[]
    OR?: PensionDetailWhereInput[]
    NOT?: PensionDetailWhereInput | PensionDetailWhereInput[]
    PensionDetailID?: IntFilter<"PensionDetail"> | number
    TypePension?: IntNullableFilter<"PensionDetail"> | number | null
    StartYearPension?: IntNullableFilter<"PensionDetail"> | number | null
    EmployerRate?: FloatNullableFilter<"PensionDetail"> | number | null
    EmployeeRate?: FloatNullableFilter<"PensionDetail"> | number | null
    EmployerCompensationRate?: FloatNullableFilter<"PensionDetail"> | number | null
    TotalPensionRate?: FloatNullableFilter<"PensionDetail"> | number | null
    AvarageSalaryPension?: FloatNullableFilter<"PensionDetail"> | number | null
    Deposit?: FloatNullableFilter<"PensionDetail"> | number | null
  }

  export type PensionDetailOrderByWithRelationInput = {
    PensionDetailID?: SortOrder
    TypePension?: SortOrderInput | SortOrder
    StartYearPension?: SortOrderInput | SortOrder
    EmployerRate?: SortOrderInput | SortOrder
    EmployeeRate?: SortOrderInput | SortOrder
    EmployerCompensationRate?: SortOrderInput | SortOrder
    TotalPensionRate?: SortOrderInput | SortOrder
    AvarageSalaryPension?: SortOrderInput | SortOrder
    Deposit?: SortOrderInput | SortOrder
  }

  export type PensionDetailWhereUniqueInput = Prisma.AtLeast<{
    PensionDetailID?: number
    AND?: PensionDetailWhereInput | PensionDetailWhereInput[]
    OR?: PensionDetailWhereInput[]
    NOT?: PensionDetailWhereInput | PensionDetailWhereInput[]
    TypePension?: IntNullableFilter<"PensionDetail"> | number | null
    StartYearPension?: IntNullableFilter<"PensionDetail"> | number | null
    EmployerRate?: FloatNullableFilter<"PensionDetail"> | number | null
    EmployeeRate?: FloatNullableFilter<"PensionDetail"> | number | null
    EmployerCompensationRate?: FloatNullableFilter<"PensionDetail"> | number | null
    TotalPensionRate?: FloatNullableFilter<"PensionDetail"> | number | null
    AvarageSalaryPension?: FloatNullableFilter<"PensionDetail"> | number | null
    Deposit?: FloatNullableFilter<"PensionDetail"> | number | null
  }, "PensionDetailID">

  export type PensionDetailOrderByWithAggregationInput = {
    PensionDetailID?: SortOrder
    TypePension?: SortOrderInput | SortOrder
    StartYearPension?: SortOrderInput | SortOrder
    EmployerRate?: SortOrderInput | SortOrder
    EmployeeRate?: SortOrderInput | SortOrder
    EmployerCompensationRate?: SortOrderInput | SortOrder
    TotalPensionRate?: SortOrderInput | SortOrder
    AvarageSalaryPension?: SortOrderInput | SortOrder
    Deposit?: SortOrderInput | SortOrder
    _count?: PensionDetailCountOrderByAggregateInput
    _avg?: PensionDetailAvgOrderByAggregateInput
    _max?: PensionDetailMaxOrderByAggregateInput
    _min?: PensionDetailMinOrderByAggregateInput
    _sum?: PensionDetailSumOrderByAggregateInput
  }

  export type PensionDetailScalarWhereWithAggregatesInput = {
    AND?: PensionDetailScalarWhereWithAggregatesInput | PensionDetailScalarWhereWithAggregatesInput[]
    OR?: PensionDetailScalarWhereWithAggregatesInput[]
    NOT?: PensionDetailScalarWhereWithAggregatesInput | PensionDetailScalarWhereWithAggregatesInput[]
    PensionDetailID?: IntWithAggregatesFilter<"PensionDetail"> | number
    TypePension?: IntNullableWithAggregatesFilter<"PensionDetail"> | number | null
    StartYearPension?: IntNullableWithAggregatesFilter<"PensionDetail"> | number | null
    EmployerRate?: FloatNullableWithAggregatesFilter<"PensionDetail"> | number | null
    EmployeeRate?: FloatNullableWithAggregatesFilter<"PensionDetail"> | number | null
    EmployerCompensationRate?: FloatNullableWithAggregatesFilter<"PensionDetail"> | number | null
    TotalPensionRate?: FloatNullableWithAggregatesFilter<"PensionDetail"> | number | null
    AvarageSalaryPension?: FloatNullableWithAggregatesFilter<"PensionDetail"> | number | null
    Deposit?: FloatNullableWithAggregatesFilter<"PensionDetail"> | number | null
  }

  export type ProductsWhereInput = {
    AND?: ProductsWhereInput | ProductsWhereInput[]
    OR?: ProductsWhereInput[]
    NOT?: ProductsWhereInput | ProductsWhereInput[]
    ProductsId?: StringFilter<"Products"> | string
    ProductName?: StringFilter<"Products"> | string
    ProductDescription?: StringNullableFilter<"Products"> | string | null
    CompaniesProducts?: CompaniesProductsListRelationFilter
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesListRelationFilter
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesListRelationFilter
  }

  export type ProductsOrderByWithRelationInput = {
    ProductsId?: SortOrder
    ProductName?: SortOrder
    ProductDescription?: SortOrderInput | SortOrder
    CompaniesProducts?: CompaniesProductsOrderByRelationAggregateInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesOrderByRelationAggregateInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesOrderByRelationAggregateInput
  }

  export type ProductsWhereUniqueInput = Prisma.AtLeast<{
    ProductsId?: string
    AND?: ProductsWhereInput | ProductsWhereInput[]
    OR?: ProductsWhereInput[]
    NOT?: ProductsWhereInput | ProductsWhereInput[]
    ProductName?: StringFilter<"Products"> | string
    ProductDescription?: StringNullableFilter<"Products"> | string | null
    CompaniesProducts?: CompaniesProductsListRelationFilter
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesListRelationFilter
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesListRelationFilter
  }, "ProductsId">

  export type ProductsOrderByWithAggregationInput = {
    ProductsId?: SortOrder
    ProductName?: SortOrder
    ProductDescription?: SortOrderInput | SortOrder
    _count?: ProductsCountOrderByAggregateInput
    _max?: ProductsMaxOrderByAggregateInput
    _min?: ProductsMinOrderByAggregateInput
  }

  export type ProductsScalarWhereWithAggregatesInput = {
    AND?: ProductsScalarWhereWithAggregatesInput | ProductsScalarWhereWithAggregatesInput[]
    OR?: ProductsScalarWhereWithAggregatesInput[]
    NOT?: ProductsScalarWhereWithAggregatesInput | ProductsScalarWhereWithAggregatesInput[]
    ProductsId?: StringWithAggregatesFilter<"Products"> | string
    ProductName?: StringWithAggregatesFilter<"Products"> | string
    ProductDescription?: StringNullableWithAggregatesFilter<"Products"> | string | null
  }

  export type RankWhereInput = {
    AND?: RankWhereInput | RankWhereInput[]
    OR?: RankWhereInput[]
    NOT?: RankWhereInput | RankWhereInput[]
    RankID?: IntFilter<"Rank"> | number
    SectorCode?: IntNullableFilter<"Rank"> | number | null
    RankYear?: IntNullableFilter<"Rank"> | number | null
    RankMonth?: IntNullableFilter<"Rank"> | number | null
    RankCode?: IntNullableFilter<"Rank"> | number | null
    RankName?: StringNullableFilter<"Rank"> | string | null
    Salary?: FloatNullableFilter<"Rank"> | number | null
    RankNumber?: IntNullableFilter<"Rank"> | number | null
  }

  export type RankOrderByWithRelationInput = {
    RankID?: SortOrder
    SectorCode?: SortOrderInput | SortOrder
    RankYear?: SortOrderInput | SortOrder
    RankMonth?: SortOrderInput | SortOrder
    RankCode?: SortOrderInput | SortOrder
    RankName?: SortOrderInput | SortOrder
    Salary?: SortOrderInput | SortOrder
    RankNumber?: SortOrderInput | SortOrder
  }

  export type RankWhereUniqueInput = Prisma.AtLeast<{
    RankID?: number
    AND?: RankWhereInput | RankWhereInput[]
    OR?: RankWhereInput[]
    NOT?: RankWhereInput | RankWhereInput[]
    SectorCode?: IntNullableFilter<"Rank"> | number | null
    RankYear?: IntNullableFilter<"Rank"> | number | null
    RankMonth?: IntNullableFilter<"Rank"> | number | null
    RankCode?: IntNullableFilter<"Rank"> | number | null
    RankName?: StringNullableFilter<"Rank"> | string | null
    Salary?: FloatNullableFilter<"Rank"> | number | null
    RankNumber?: IntNullableFilter<"Rank"> | number | null
  }, "RankID">

  export type RankOrderByWithAggregationInput = {
    RankID?: SortOrder
    SectorCode?: SortOrderInput | SortOrder
    RankYear?: SortOrderInput | SortOrder
    RankMonth?: SortOrderInput | SortOrder
    RankCode?: SortOrderInput | SortOrder
    RankName?: SortOrderInput | SortOrder
    Salary?: SortOrderInput | SortOrder
    RankNumber?: SortOrderInput | SortOrder
    _count?: RankCountOrderByAggregateInput
    _avg?: RankAvgOrderByAggregateInput
    _max?: RankMaxOrderByAggregateInput
    _min?: RankMinOrderByAggregateInput
    _sum?: RankSumOrderByAggregateInput
  }

  export type RankScalarWhereWithAggregatesInput = {
    AND?: RankScalarWhereWithAggregatesInput | RankScalarWhereWithAggregatesInput[]
    OR?: RankScalarWhereWithAggregatesInput[]
    NOT?: RankScalarWhereWithAggregatesInput | RankScalarWhereWithAggregatesInput[]
    RankID?: IntWithAggregatesFilter<"Rank"> | number
    SectorCode?: IntNullableWithAggregatesFilter<"Rank"> | number | null
    RankYear?: IntNullableWithAggregatesFilter<"Rank"> | number | null
    RankMonth?: IntNullableWithAggregatesFilter<"Rank"> | number | null
    RankCode?: IntNullableWithAggregatesFilter<"Rank"> | number | null
    RankName?: StringNullableWithAggregatesFilter<"Rank"> | string | null
    Salary?: FloatNullableWithAggregatesFilter<"Rank"> | number | null
    RankNumber?: IntNullableWithAggregatesFilter<"Rank"> | number | null
  }

  export type RecoveryDefinitionWhereInput = {
    AND?: RecoveryDefinitionWhereInput | RecoveryDefinitionWhereInput[]
    OR?: RecoveryDefinitionWhereInput[]
    NOT?: RecoveryDefinitionWhereInput | RecoveryDefinitionWhereInput[]
    RecoveryDefinitionID?: IntFilter<"RecoveryDefinition"> | number
    RecoveryDefinitionName?: StringNullableFilter<"RecoveryDefinition"> | string | null
    RecoveryYear?: StringNullableFilter<"RecoveryDefinition"> | string | null
    RecoveryDefinitionDetails?: RecoveryDefinitionDetailsListRelationFilter
    RecoveryDefinitionRateDetails?: RecoveryDefinitionRateDetailsListRelationFilter
  }

  export type RecoveryDefinitionOrderByWithRelationInput = {
    RecoveryDefinitionID?: SortOrder
    RecoveryDefinitionName?: SortOrderInput | SortOrder
    RecoveryYear?: SortOrderInput | SortOrder
    RecoveryDefinitionDetails?: RecoveryDefinitionDetailsOrderByRelationAggregateInput
    RecoveryDefinitionRateDetails?: RecoveryDefinitionRateDetailsOrderByRelationAggregateInput
  }

  export type RecoveryDefinitionWhereUniqueInput = Prisma.AtLeast<{
    RecoveryDefinitionID?: number
    AND?: RecoveryDefinitionWhereInput | RecoveryDefinitionWhereInput[]
    OR?: RecoveryDefinitionWhereInput[]
    NOT?: RecoveryDefinitionWhereInput | RecoveryDefinitionWhereInput[]
    RecoveryDefinitionName?: StringNullableFilter<"RecoveryDefinition"> | string | null
    RecoveryYear?: StringNullableFilter<"RecoveryDefinition"> | string | null
    RecoveryDefinitionDetails?: RecoveryDefinitionDetailsListRelationFilter
    RecoveryDefinitionRateDetails?: RecoveryDefinitionRateDetailsListRelationFilter
  }, "RecoveryDefinitionID">

  export type RecoveryDefinitionOrderByWithAggregationInput = {
    RecoveryDefinitionID?: SortOrder
    RecoveryDefinitionName?: SortOrderInput | SortOrder
    RecoveryYear?: SortOrderInput | SortOrder
    _count?: RecoveryDefinitionCountOrderByAggregateInput
    _avg?: RecoveryDefinitionAvgOrderByAggregateInput
    _max?: RecoveryDefinitionMaxOrderByAggregateInput
    _min?: RecoveryDefinitionMinOrderByAggregateInput
    _sum?: RecoveryDefinitionSumOrderByAggregateInput
  }

  export type RecoveryDefinitionScalarWhereWithAggregatesInput = {
    AND?: RecoveryDefinitionScalarWhereWithAggregatesInput | RecoveryDefinitionScalarWhereWithAggregatesInput[]
    OR?: RecoveryDefinitionScalarWhereWithAggregatesInput[]
    NOT?: RecoveryDefinitionScalarWhereWithAggregatesInput | RecoveryDefinitionScalarWhereWithAggregatesInput[]
    RecoveryDefinitionID?: IntWithAggregatesFilter<"RecoveryDefinition"> | number
    RecoveryDefinitionName?: StringNullableWithAggregatesFilter<"RecoveryDefinition"> | string | null
    RecoveryYear?: StringNullableWithAggregatesFilter<"RecoveryDefinition"> | string | null
  }

  export type RecoveryDefinitionDetailsWhereInput = {
    AND?: RecoveryDefinitionDetailsWhereInput | RecoveryDefinitionDetailsWhereInput[]
    OR?: RecoveryDefinitionDetailsWhereInput[]
    NOT?: RecoveryDefinitionDetailsWhereInput | RecoveryDefinitionDetailsWhereInput[]
    RewardRecoveryVectorID?: IntFilter<"RecoveryDefinitionDetails"> | number
    RecoveryDefinitionID?: IntNullableFilter<"RecoveryDefinitionDetails"> | number | null
    StartYearRewardRecovery?: FloatNullableFilter<"RecoveryDefinitionDetails"> | number | null
    EndYearRewardRecovery?: FloatNullableFilter<"RecoveryDefinitionDetails"> | number | null
    RecoveryDayQuantity?: IntNullableFilter<"RecoveryDefinitionDetails"> | number | null
    RecoveryYearDescription?: StringNullableFilter<"RecoveryDefinitionDetails"> | string | null
    RecoveryDefinition?: XOR<RecoveryDefinitionNullableScalarRelationFilter, RecoveryDefinitionWhereInput> | null
  }

  export type RecoveryDefinitionDetailsOrderByWithRelationInput = {
    RewardRecoveryVectorID?: SortOrder
    RecoveryDefinitionID?: SortOrderInput | SortOrder
    StartYearRewardRecovery?: SortOrderInput | SortOrder
    EndYearRewardRecovery?: SortOrderInput | SortOrder
    RecoveryDayQuantity?: SortOrderInput | SortOrder
    RecoveryYearDescription?: SortOrderInput | SortOrder
    RecoveryDefinition?: RecoveryDefinitionOrderByWithRelationInput
  }

  export type RecoveryDefinitionDetailsWhereUniqueInput = Prisma.AtLeast<{
    RewardRecoveryVectorID?: number
    AND?: RecoveryDefinitionDetailsWhereInput | RecoveryDefinitionDetailsWhereInput[]
    OR?: RecoveryDefinitionDetailsWhereInput[]
    NOT?: RecoveryDefinitionDetailsWhereInput | RecoveryDefinitionDetailsWhereInput[]
    RecoveryDefinitionID?: IntNullableFilter<"RecoveryDefinitionDetails"> | number | null
    StartYearRewardRecovery?: FloatNullableFilter<"RecoveryDefinitionDetails"> | number | null
    EndYearRewardRecovery?: FloatNullableFilter<"RecoveryDefinitionDetails"> | number | null
    RecoveryDayQuantity?: IntNullableFilter<"RecoveryDefinitionDetails"> | number | null
    RecoveryYearDescription?: StringNullableFilter<"RecoveryDefinitionDetails"> | string | null
    RecoveryDefinition?: XOR<RecoveryDefinitionNullableScalarRelationFilter, RecoveryDefinitionWhereInput> | null
  }, "RewardRecoveryVectorID">

  export type RecoveryDefinitionDetailsOrderByWithAggregationInput = {
    RewardRecoveryVectorID?: SortOrder
    RecoveryDefinitionID?: SortOrderInput | SortOrder
    StartYearRewardRecovery?: SortOrderInput | SortOrder
    EndYearRewardRecovery?: SortOrderInput | SortOrder
    RecoveryDayQuantity?: SortOrderInput | SortOrder
    RecoveryYearDescription?: SortOrderInput | SortOrder
    _count?: RecoveryDefinitionDetailsCountOrderByAggregateInput
    _avg?: RecoveryDefinitionDetailsAvgOrderByAggregateInput
    _max?: RecoveryDefinitionDetailsMaxOrderByAggregateInput
    _min?: RecoveryDefinitionDetailsMinOrderByAggregateInput
    _sum?: RecoveryDefinitionDetailsSumOrderByAggregateInput
  }

  export type RecoveryDefinitionDetailsScalarWhereWithAggregatesInput = {
    AND?: RecoveryDefinitionDetailsScalarWhereWithAggregatesInput | RecoveryDefinitionDetailsScalarWhereWithAggregatesInput[]
    OR?: RecoveryDefinitionDetailsScalarWhereWithAggregatesInput[]
    NOT?: RecoveryDefinitionDetailsScalarWhereWithAggregatesInput | RecoveryDefinitionDetailsScalarWhereWithAggregatesInput[]
    RewardRecoveryVectorID?: IntWithAggregatesFilter<"RecoveryDefinitionDetails"> | number
    RecoveryDefinitionID?: IntNullableWithAggregatesFilter<"RecoveryDefinitionDetails"> | number | null
    StartYearRewardRecovery?: FloatNullableWithAggregatesFilter<"RecoveryDefinitionDetails"> | number | null
    EndYearRewardRecovery?: FloatNullableWithAggregatesFilter<"RecoveryDefinitionDetails"> | number | null
    RecoveryDayQuantity?: IntNullableWithAggregatesFilter<"RecoveryDefinitionDetails"> | number | null
    RecoveryYearDescription?: StringNullableWithAggregatesFilter<"RecoveryDefinitionDetails"> | string | null
  }

  export type RecoveryDefinitionRateDetailsWhereInput = {
    AND?: RecoveryDefinitionRateDetailsWhereInput | RecoveryDefinitionRateDetailsWhereInput[]
    OR?: RecoveryDefinitionRateDetailsWhereInput[]
    NOT?: RecoveryDefinitionRateDetailsWhereInput | RecoveryDefinitionRateDetailsWhereInput[]
    RecoveryRewardID?: IntFilter<"RecoveryDefinitionRateDetails"> | number
    RecoveryDefinitionID?: IntNullableFilter<"RecoveryDefinitionRateDetails"> | number | null
    RewardYearMonth?: DateTimeNullableFilter<"RecoveryDefinitionRateDetails"> | Date | string | null
    RecoveryRewardRatePerDay?: FloatNullableFilter<"RecoveryDefinitionRateDetails"> | number | null
    RecoveryDefinition?: XOR<RecoveryDefinitionNullableScalarRelationFilter, RecoveryDefinitionWhereInput> | null
  }

  export type RecoveryDefinitionRateDetailsOrderByWithRelationInput = {
    RecoveryRewardID?: SortOrder
    RecoveryDefinitionID?: SortOrderInput | SortOrder
    RewardYearMonth?: SortOrderInput | SortOrder
    RecoveryRewardRatePerDay?: SortOrderInput | SortOrder
    RecoveryDefinition?: RecoveryDefinitionOrderByWithRelationInput
  }

  export type RecoveryDefinitionRateDetailsWhereUniqueInput = Prisma.AtLeast<{
    RecoveryRewardID?: number
    AND?: RecoveryDefinitionRateDetailsWhereInput | RecoveryDefinitionRateDetailsWhereInput[]
    OR?: RecoveryDefinitionRateDetailsWhereInput[]
    NOT?: RecoveryDefinitionRateDetailsWhereInput | RecoveryDefinitionRateDetailsWhereInput[]
    RecoveryDefinitionID?: IntNullableFilter<"RecoveryDefinitionRateDetails"> | number | null
    RewardYearMonth?: DateTimeNullableFilter<"RecoveryDefinitionRateDetails"> | Date | string | null
    RecoveryRewardRatePerDay?: FloatNullableFilter<"RecoveryDefinitionRateDetails"> | number | null
    RecoveryDefinition?: XOR<RecoveryDefinitionNullableScalarRelationFilter, RecoveryDefinitionWhereInput> | null
  }, "RecoveryRewardID">

  export type RecoveryDefinitionRateDetailsOrderByWithAggregationInput = {
    RecoveryRewardID?: SortOrder
    RecoveryDefinitionID?: SortOrderInput | SortOrder
    RewardYearMonth?: SortOrderInput | SortOrder
    RecoveryRewardRatePerDay?: SortOrderInput | SortOrder
    _count?: RecoveryDefinitionRateDetailsCountOrderByAggregateInput
    _avg?: RecoveryDefinitionRateDetailsAvgOrderByAggregateInput
    _max?: RecoveryDefinitionRateDetailsMaxOrderByAggregateInput
    _min?: RecoveryDefinitionRateDetailsMinOrderByAggregateInput
    _sum?: RecoveryDefinitionRateDetailsSumOrderByAggregateInput
  }

  export type RecoveryDefinitionRateDetailsScalarWhereWithAggregatesInput = {
    AND?: RecoveryDefinitionRateDetailsScalarWhereWithAggregatesInput | RecoveryDefinitionRateDetailsScalarWhereWithAggregatesInput[]
    OR?: RecoveryDefinitionRateDetailsScalarWhereWithAggregatesInput[]
    NOT?: RecoveryDefinitionRateDetailsScalarWhereWithAggregatesInput | RecoveryDefinitionRateDetailsScalarWhereWithAggregatesInput[]
    RecoveryRewardID?: IntWithAggregatesFilter<"RecoveryDefinitionRateDetails"> | number
    RecoveryDefinitionID?: IntNullableWithAggregatesFilter<"RecoveryDefinitionRateDetails"> | number | null
    RewardYearMonth?: DateTimeNullableWithAggregatesFilter<"RecoveryDefinitionRateDetails"> | Date | string | null
    RecoveryRewardRatePerDay?: FloatNullableWithAggregatesFilter<"RecoveryDefinitionRateDetails"> | number | null
  }

  export type ReportDefinitionsWhereInput = {
    AND?: ReportDefinitionsWhereInput | ReportDefinitionsWhereInput[]
    OR?: ReportDefinitionsWhereInput[]
    NOT?: ReportDefinitionsWhereInput | ReportDefinitionsWhereInput[]
    ReportID?: IntFilter<"ReportDefinitions"> | number
    ReportName?: StringNullableFilter<"ReportDefinitions"> | string | null
    OrderBy?: IntNullableFilter<"ReportDefinitions"> | number | null
    FieldName?: StringNullableFilter<"ReportDefinitions"> | string | null
    Caption?: StringNullableFilter<"ReportDefinitions"> | string | null
    Color?: IntNullableFilter<"ReportDefinitions"> | number | null
    Background?: IntNullableFilter<"ReportDefinitions"> | number | null
    ColumnWidth?: FloatNullableFilter<"ReportDefinitions"> | number | null
    FontStyle?: StringNullableFilter<"ReportDefinitions"> | string | null
    FontSize?: IntNullableFilter<"ReportDefinitions"> | number | null
    ReportTitle?: StringNullableFilter<"ReportDefinitions"> | string | null
    IsSum?: BoolFilter<"ReportDefinitions"> | boolean
    ColorIndex?: IntNullableFilter<"ReportDefinitions"> | number | null
  }

  export type ReportDefinitionsOrderByWithRelationInput = {
    ReportID?: SortOrder
    ReportName?: SortOrderInput | SortOrder
    OrderBy?: SortOrderInput | SortOrder
    FieldName?: SortOrderInput | SortOrder
    Caption?: SortOrderInput | SortOrder
    Color?: SortOrderInput | SortOrder
    Background?: SortOrderInput | SortOrder
    ColumnWidth?: SortOrderInput | SortOrder
    FontStyle?: SortOrderInput | SortOrder
    FontSize?: SortOrderInput | SortOrder
    ReportTitle?: SortOrderInput | SortOrder
    IsSum?: SortOrder
    ColorIndex?: SortOrderInput | SortOrder
  }

  export type ReportDefinitionsWhereUniqueInput = Prisma.AtLeast<{
    ReportID?: number
    ReportName_FieldName?: ReportDefinitionsReportNameFieldNameCompoundUniqueInput
    AND?: ReportDefinitionsWhereInput | ReportDefinitionsWhereInput[]
    OR?: ReportDefinitionsWhereInput[]
    NOT?: ReportDefinitionsWhereInput | ReportDefinitionsWhereInput[]
    ReportName?: StringNullableFilter<"ReportDefinitions"> | string | null
    OrderBy?: IntNullableFilter<"ReportDefinitions"> | number | null
    FieldName?: StringNullableFilter<"ReportDefinitions"> | string | null
    Caption?: StringNullableFilter<"ReportDefinitions"> | string | null
    Color?: IntNullableFilter<"ReportDefinitions"> | number | null
    Background?: IntNullableFilter<"ReportDefinitions"> | number | null
    ColumnWidth?: FloatNullableFilter<"ReportDefinitions"> | number | null
    FontStyle?: StringNullableFilter<"ReportDefinitions"> | string | null
    FontSize?: IntNullableFilter<"ReportDefinitions"> | number | null
    ReportTitle?: StringNullableFilter<"ReportDefinitions"> | string | null
    IsSum?: BoolFilter<"ReportDefinitions"> | boolean
    ColorIndex?: IntNullableFilter<"ReportDefinitions"> | number | null
  }, "ReportID" | "ReportName_FieldName">

  export type ReportDefinitionsOrderByWithAggregationInput = {
    ReportID?: SortOrder
    ReportName?: SortOrderInput | SortOrder
    OrderBy?: SortOrderInput | SortOrder
    FieldName?: SortOrderInput | SortOrder
    Caption?: SortOrderInput | SortOrder
    Color?: SortOrderInput | SortOrder
    Background?: SortOrderInput | SortOrder
    ColumnWidth?: SortOrderInput | SortOrder
    FontStyle?: SortOrderInput | SortOrder
    FontSize?: SortOrderInput | SortOrder
    ReportTitle?: SortOrderInput | SortOrder
    IsSum?: SortOrder
    ColorIndex?: SortOrderInput | SortOrder
    _count?: ReportDefinitionsCountOrderByAggregateInput
    _avg?: ReportDefinitionsAvgOrderByAggregateInput
    _max?: ReportDefinitionsMaxOrderByAggregateInput
    _min?: ReportDefinitionsMinOrderByAggregateInput
    _sum?: ReportDefinitionsSumOrderByAggregateInput
  }

  export type ReportDefinitionsScalarWhereWithAggregatesInput = {
    AND?: ReportDefinitionsScalarWhereWithAggregatesInput | ReportDefinitionsScalarWhereWithAggregatesInput[]
    OR?: ReportDefinitionsScalarWhereWithAggregatesInput[]
    NOT?: ReportDefinitionsScalarWhereWithAggregatesInput | ReportDefinitionsScalarWhereWithAggregatesInput[]
    ReportID?: IntWithAggregatesFilter<"ReportDefinitions"> | number
    ReportName?: StringNullableWithAggregatesFilter<"ReportDefinitions"> | string | null
    OrderBy?: IntNullableWithAggregatesFilter<"ReportDefinitions"> | number | null
    FieldName?: StringNullableWithAggregatesFilter<"ReportDefinitions"> | string | null
    Caption?: StringNullableWithAggregatesFilter<"ReportDefinitions"> | string | null
    Color?: IntNullableWithAggregatesFilter<"ReportDefinitions"> | number | null
    Background?: IntNullableWithAggregatesFilter<"ReportDefinitions"> | number | null
    ColumnWidth?: FloatNullableWithAggregatesFilter<"ReportDefinitions"> | number | null
    FontStyle?: StringNullableWithAggregatesFilter<"ReportDefinitions"> | string | null
    FontSize?: IntNullableWithAggregatesFilter<"ReportDefinitions"> | number | null
    ReportTitle?: StringNullableWithAggregatesFilter<"ReportDefinitions"> | string | null
    IsSum?: BoolWithAggregatesFilter<"ReportDefinitions"> | boolean
    ColorIndex?: IntNullableWithAggregatesFilter<"ReportDefinitions"> | number | null
  }

  export type RewardRecoveryRateWhereInput = {
    AND?: RewardRecoveryRateWhereInput | RewardRecoveryRateWhereInput[]
    OR?: RewardRecoveryRateWhereInput[]
    NOT?: RewardRecoveryRateWhereInput | RewardRecoveryRateWhereInput[]
    RecoveryRewardID?: IntFilter<"RewardRecoveryRate"> | number
    RewardYear?: IntNullableFilter<"RewardRecoveryRate"> | number | null
    RecoveryRewardRatePerDay?: FloatNullableFilter<"RewardRecoveryRate"> | number | null
  }

  export type RewardRecoveryRateOrderByWithRelationInput = {
    RecoveryRewardID?: SortOrder
    RewardYear?: SortOrderInput | SortOrder
    RecoveryRewardRatePerDay?: SortOrderInput | SortOrder
  }

  export type RewardRecoveryRateWhereUniqueInput = Prisma.AtLeast<{
    RecoveryRewardID?: number
    AND?: RewardRecoveryRateWhereInput | RewardRecoveryRateWhereInput[]
    OR?: RewardRecoveryRateWhereInput[]
    NOT?: RewardRecoveryRateWhereInput | RewardRecoveryRateWhereInput[]
    RewardYear?: IntNullableFilter<"RewardRecoveryRate"> | number | null
    RecoveryRewardRatePerDay?: FloatNullableFilter<"RewardRecoveryRate"> | number | null
  }, "RecoveryRewardID">

  export type RewardRecoveryRateOrderByWithAggregationInput = {
    RecoveryRewardID?: SortOrder
    RewardYear?: SortOrderInput | SortOrder
    RecoveryRewardRatePerDay?: SortOrderInput | SortOrder
    _count?: RewardRecoveryRateCountOrderByAggregateInput
    _avg?: RewardRecoveryRateAvgOrderByAggregateInput
    _max?: RewardRecoveryRateMaxOrderByAggregateInput
    _min?: RewardRecoveryRateMinOrderByAggregateInput
    _sum?: RewardRecoveryRateSumOrderByAggregateInput
  }

  export type RewardRecoveryRateScalarWhereWithAggregatesInput = {
    AND?: RewardRecoveryRateScalarWhereWithAggregatesInput | RewardRecoveryRateScalarWhereWithAggregatesInput[]
    OR?: RewardRecoveryRateScalarWhereWithAggregatesInput[]
    NOT?: RewardRecoveryRateScalarWhereWithAggregatesInput | RewardRecoveryRateScalarWhereWithAggregatesInput[]
    RecoveryRewardID?: IntWithAggregatesFilter<"RewardRecoveryRate"> | number
    RewardYear?: IntNullableWithAggregatesFilter<"RewardRecoveryRate"> | number | null
    RecoveryRewardRatePerDay?: FloatNullableWithAggregatesFilter<"RewardRecoveryRate"> | number | null
  }

  export type RewardRecoveryVectorWhereInput = {
    AND?: RewardRecoveryVectorWhereInput | RewardRecoveryVectorWhereInput[]
    OR?: RewardRecoveryVectorWhereInput[]
    NOT?: RewardRecoveryVectorWhereInput | RewardRecoveryVectorWhereInput[]
    RewardRecoveryVectorID?: IntFilter<"RewardRecoveryVector"> | number
    StartYearRewardRecovery?: FloatNullableFilter<"RewardRecoveryVector"> | number | null
    EndYearRewardRecovery?: FloatNullableFilter<"RewardRecoveryVector"> | number | null
    RecoveryDayQuantity?: IntNullableFilter<"RewardRecoveryVector"> | number | null
  }

  export type RewardRecoveryVectorOrderByWithRelationInput = {
    RewardRecoveryVectorID?: SortOrder
    StartYearRewardRecovery?: SortOrderInput | SortOrder
    EndYearRewardRecovery?: SortOrderInput | SortOrder
    RecoveryDayQuantity?: SortOrderInput | SortOrder
  }

  export type RewardRecoveryVectorWhereUniqueInput = Prisma.AtLeast<{
    RewardRecoveryVectorID?: number
    AND?: RewardRecoveryVectorWhereInput | RewardRecoveryVectorWhereInput[]
    OR?: RewardRecoveryVectorWhereInput[]
    NOT?: RewardRecoveryVectorWhereInput | RewardRecoveryVectorWhereInput[]
    StartYearRewardRecovery?: FloatNullableFilter<"RewardRecoveryVector"> | number | null
    EndYearRewardRecovery?: FloatNullableFilter<"RewardRecoveryVector"> | number | null
    RecoveryDayQuantity?: IntNullableFilter<"RewardRecoveryVector"> | number | null
  }, "RewardRecoveryVectorID">

  export type RewardRecoveryVectorOrderByWithAggregationInput = {
    RewardRecoveryVectorID?: SortOrder
    StartYearRewardRecovery?: SortOrderInput | SortOrder
    EndYearRewardRecovery?: SortOrderInput | SortOrder
    RecoveryDayQuantity?: SortOrderInput | SortOrder
    _count?: RewardRecoveryVectorCountOrderByAggregateInput
    _avg?: RewardRecoveryVectorAvgOrderByAggregateInput
    _max?: RewardRecoveryVectorMaxOrderByAggregateInput
    _min?: RewardRecoveryVectorMinOrderByAggregateInput
    _sum?: RewardRecoveryVectorSumOrderByAggregateInput
  }

  export type RewardRecoveryVectorScalarWhereWithAggregatesInput = {
    AND?: RewardRecoveryVectorScalarWhereWithAggregatesInput | RewardRecoveryVectorScalarWhereWithAggregatesInput[]
    OR?: RewardRecoveryVectorScalarWhereWithAggregatesInput[]
    NOT?: RewardRecoveryVectorScalarWhereWithAggregatesInput | RewardRecoveryVectorScalarWhereWithAggregatesInput[]
    RewardRecoveryVectorID?: IntWithAggregatesFilter<"RewardRecoveryVector"> | number
    StartYearRewardRecovery?: FloatNullableWithAggregatesFilter<"RewardRecoveryVector"> | number | null
    EndYearRewardRecovery?: FloatNullableWithAggregatesFilter<"RewardRecoveryVector"> | number | null
    RecoveryDayQuantity?: IntNullableWithAggregatesFilter<"RewardRecoveryVector"> | number | null
  }

  export type RewardSickVectorWhereInput = {
    AND?: RewardSickVectorWhereInput | RewardSickVectorWhereInput[]
    OR?: RewardSickVectorWhereInput[]
    NOT?: RewardSickVectorWhereInput | RewardSickVectorWhereInput[]
    RewardSickVectorID?: IntFilter<"RewardSickVector"> | number
    StartYearRewardSick?: IntNullableFilter<"RewardSickVector"> | number | null
    EndYearRewardSick?: IntNullableFilter<"RewardSickVector"> | number | null
    SickDayQuantity?: FloatNullableFilter<"RewardSickVector"> | number | null
  }

  export type RewardSickVectorOrderByWithRelationInput = {
    RewardSickVectorID?: SortOrder
    StartYearRewardSick?: SortOrderInput | SortOrder
    EndYearRewardSick?: SortOrderInput | SortOrder
    SickDayQuantity?: SortOrderInput | SortOrder
  }

  export type RewardSickVectorWhereUniqueInput = Prisma.AtLeast<{
    RewardSickVectorID?: number
    AND?: RewardSickVectorWhereInput | RewardSickVectorWhereInput[]
    OR?: RewardSickVectorWhereInput[]
    NOT?: RewardSickVectorWhereInput | RewardSickVectorWhereInput[]
    StartYearRewardSick?: IntNullableFilter<"RewardSickVector"> | number | null
    EndYearRewardSick?: IntNullableFilter<"RewardSickVector"> | number | null
    SickDayQuantity?: FloatNullableFilter<"RewardSickVector"> | number | null
  }, "RewardSickVectorID">

  export type RewardSickVectorOrderByWithAggregationInput = {
    RewardSickVectorID?: SortOrder
    StartYearRewardSick?: SortOrderInput | SortOrder
    EndYearRewardSick?: SortOrderInput | SortOrder
    SickDayQuantity?: SortOrderInput | SortOrder
    _count?: RewardSickVectorCountOrderByAggregateInput
    _avg?: RewardSickVectorAvgOrderByAggregateInput
    _max?: RewardSickVectorMaxOrderByAggregateInput
    _min?: RewardSickVectorMinOrderByAggregateInput
    _sum?: RewardSickVectorSumOrderByAggregateInput
  }

  export type RewardSickVectorScalarWhereWithAggregatesInput = {
    AND?: RewardSickVectorScalarWhereWithAggregatesInput | RewardSickVectorScalarWhereWithAggregatesInput[]
    OR?: RewardSickVectorScalarWhereWithAggregatesInput[]
    NOT?: RewardSickVectorScalarWhereWithAggregatesInput | RewardSickVectorScalarWhereWithAggregatesInput[]
    RewardSickVectorID?: IntWithAggregatesFilter<"RewardSickVector"> | number
    StartYearRewardSick?: IntNullableWithAggregatesFilter<"RewardSickVector"> | number | null
    EndYearRewardSick?: IntNullableWithAggregatesFilter<"RewardSickVector"> | number | null
    SickDayQuantity?: FloatNullableWithAggregatesFilter<"RewardSickVector"> | number | null
  }

  export type RewardVacationVectorWhereInput = {
    AND?: RewardVacationVectorWhereInput | RewardVacationVectorWhereInput[]
    OR?: RewardVacationVectorWhereInput[]
    NOT?: RewardVacationVectorWhereInput | RewardVacationVectorWhereInput[]
    RewardVocationVectorID?: IntFilter<"RewardVacationVector"> | number
    StartYearRewardVocation?: FloatNullableFilter<"RewardVacationVector"> | number | null
    EndYearRewardVocation?: FloatNullableFilter<"RewardVacationVector"> | number | null
    VocationDayQuantity6days?: IntNullableFilter<"RewardVacationVector"> | number | null
    VocationDayQuantity5days?: IntNullableFilter<"RewardVacationVector"> | number | null
  }

  export type RewardVacationVectorOrderByWithRelationInput = {
    RewardVocationVectorID?: SortOrder
    StartYearRewardVocation?: SortOrderInput | SortOrder
    EndYearRewardVocation?: SortOrderInput | SortOrder
    VocationDayQuantity6days?: SortOrderInput | SortOrder
    VocationDayQuantity5days?: SortOrderInput | SortOrder
  }

  export type RewardVacationVectorWhereUniqueInput = Prisma.AtLeast<{
    RewardVocationVectorID?: number
    AND?: RewardVacationVectorWhereInput | RewardVacationVectorWhereInput[]
    OR?: RewardVacationVectorWhereInput[]
    NOT?: RewardVacationVectorWhereInput | RewardVacationVectorWhereInput[]
    StartYearRewardVocation?: FloatNullableFilter<"RewardVacationVector"> | number | null
    EndYearRewardVocation?: FloatNullableFilter<"RewardVacationVector"> | number | null
    VocationDayQuantity6days?: IntNullableFilter<"RewardVacationVector"> | number | null
    VocationDayQuantity5days?: IntNullableFilter<"RewardVacationVector"> | number | null
  }, "RewardVocationVectorID">

  export type RewardVacationVectorOrderByWithAggregationInput = {
    RewardVocationVectorID?: SortOrder
    StartYearRewardVocation?: SortOrderInput | SortOrder
    EndYearRewardVocation?: SortOrderInput | SortOrder
    VocationDayQuantity6days?: SortOrderInput | SortOrder
    VocationDayQuantity5days?: SortOrderInput | SortOrder
    _count?: RewardVacationVectorCountOrderByAggregateInput
    _avg?: RewardVacationVectorAvgOrderByAggregateInput
    _max?: RewardVacationVectorMaxOrderByAggregateInput
    _min?: RewardVacationVectorMinOrderByAggregateInput
    _sum?: RewardVacationVectorSumOrderByAggregateInput
  }

  export type RewardVacationVectorScalarWhereWithAggregatesInput = {
    AND?: RewardVacationVectorScalarWhereWithAggregatesInput | RewardVacationVectorScalarWhereWithAggregatesInput[]
    OR?: RewardVacationVectorScalarWhereWithAggregatesInput[]
    NOT?: RewardVacationVectorScalarWhereWithAggregatesInput | RewardVacationVectorScalarWhereWithAggregatesInput[]
    RewardVocationVectorID?: IntWithAggregatesFilter<"RewardVacationVector"> | number
    StartYearRewardVocation?: FloatNullableWithAggregatesFilter<"RewardVacationVector"> | number | null
    EndYearRewardVocation?: FloatNullableWithAggregatesFilter<"RewardVacationVector"> | number | null
    VocationDayQuantity6days?: IntNullableWithAggregatesFilter<"RewardVacationVector"> | number | null
    VocationDayQuantity5days?: IntNullableWithAggregatesFilter<"RewardVacationVector"> | number | null
  }

  export type SickDefinitionWhereInput = {
    AND?: SickDefinitionWhereInput | SickDefinitionWhereInput[]
    OR?: SickDefinitionWhereInput[]
    NOT?: SickDefinitionWhereInput | SickDefinitionWhereInput[]
    SickDefinitionID?: IntFilter<"SickDefinition"> | number
    SickDescription?: StringNullableFilter<"SickDefinition"> | string | null
    SickDefinitionDetail?: SickDefinitionDetailListRelationFilter
  }

  export type SickDefinitionOrderByWithRelationInput = {
    SickDefinitionID?: SortOrder
    SickDescription?: SortOrderInput | SortOrder
    SickDefinitionDetail?: SickDefinitionDetailOrderByRelationAggregateInput
  }

  export type SickDefinitionWhereUniqueInput = Prisma.AtLeast<{
    SickDefinitionID?: number
    SickDescription?: string
    AND?: SickDefinitionWhereInput | SickDefinitionWhereInput[]
    OR?: SickDefinitionWhereInput[]
    NOT?: SickDefinitionWhereInput | SickDefinitionWhereInput[]
    SickDefinitionDetail?: SickDefinitionDetailListRelationFilter
  }, "SickDefinitionID" | "SickDescription">

  export type SickDefinitionOrderByWithAggregationInput = {
    SickDefinitionID?: SortOrder
    SickDescription?: SortOrderInput | SortOrder
    _count?: SickDefinitionCountOrderByAggregateInput
    _avg?: SickDefinitionAvgOrderByAggregateInput
    _max?: SickDefinitionMaxOrderByAggregateInput
    _min?: SickDefinitionMinOrderByAggregateInput
    _sum?: SickDefinitionSumOrderByAggregateInput
  }

  export type SickDefinitionScalarWhereWithAggregatesInput = {
    AND?: SickDefinitionScalarWhereWithAggregatesInput | SickDefinitionScalarWhereWithAggregatesInput[]
    OR?: SickDefinitionScalarWhereWithAggregatesInput[]
    NOT?: SickDefinitionScalarWhereWithAggregatesInput | SickDefinitionScalarWhereWithAggregatesInput[]
    SickDefinitionID?: IntWithAggregatesFilter<"SickDefinition"> | number
    SickDescription?: StringNullableWithAggregatesFilter<"SickDefinition"> | string | null
  }

  export type SickDefinitionDetailWhereInput = {
    AND?: SickDefinitionDetailWhereInput | SickDefinitionDetailWhereInput[]
    OR?: SickDefinitionDetailWhereInput[]
    NOT?: SickDefinitionDetailWhereInput | SickDefinitionDetailWhereInput[]
    RewardSickVectorID?: IntFilter<"SickDefinitionDetail"> | number
    SickDefinitionID?: IntFilter<"SickDefinitionDetail"> | number
    StartYearRewardSick?: IntNullableFilter<"SickDefinitionDetail"> | number | null
    EndYearRewardSick?: IntNullableFilter<"SickDefinitionDetail"> | number | null
    SickDayQuantity?: FloatNullableFilter<"SickDefinitionDetail"> | number | null
    SocialYearDescription?: StringNullableFilter<"SickDefinitionDetail"> | string | null
    SickDefinition?: XOR<SickDefinitionScalarRelationFilter, SickDefinitionWhereInput>
  }

  export type SickDefinitionDetailOrderByWithRelationInput = {
    RewardSickVectorID?: SortOrder
    SickDefinitionID?: SortOrder
    StartYearRewardSick?: SortOrderInput | SortOrder
    EndYearRewardSick?: SortOrderInput | SortOrder
    SickDayQuantity?: SortOrderInput | SortOrder
    SocialYearDescription?: SortOrderInput | SortOrder
    SickDefinition?: SickDefinitionOrderByWithRelationInput
  }

  export type SickDefinitionDetailWhereUniqueInput = Prisma.AtLeast<{
    RewardSickVectorID?: number
    AND?: SickDefinitionDetailWhereInput | SickDefinitionDetailWhereInput[]
    OR?: SickDefinitionDetailWhereInput[]
    NOT?: SickDefinitionDetailWhereInput | SickDefinitionDetailWhereInput[]
    SickDefinitionID?: IntFilter<"SickDefinitionDetail"> | number
    StartYearRewardSick?: IntNullableFilter<"SickDefinitionDetail"> | number | null
    EndYearRewardSick?: IntNullableFilter<"SickDefinitionDetail"> | number | null
    SickDayQuantity?: FloatNullableFilter<"SickDefinitionDetail"> | number | null
    SocialYearDescription?: StringNullableFilter<"SickDefinitionDetail"> | string | null
    SickDefinition?: XOR<SickDefinitionScalarRelationFilter, SickDefinitionWhereInput>
  }, "RewardSickVectorID">

  export type SickDefinitionDetailOrderByWithAggregationInput = {
    RewardSickVectorID?: SortOrder
    SickDefinitionID?: SortOrder
    StartYearRewardSick?: SortOrderInput | SortOrder
    EndYearRewardSick?: SortOrderInput | SortOrder
    SickDayQuantity?: SortOrderInput | SortOrder
    SocialYearDescription?: SortOrderInput | SortOrder
    _count?: SickDefinitionDetailCountOrderByAggregateInput
    _avg?: SickDefinitionDetailAvgOrderByAggregateInput
    _max?: SickDefinitionDetailMaxOrderByAggregateInput
    _min?: SickDefinitionDetailMinOrderByAggregateInput
    _sum?: SickDefinitionDetailSumOrderByAggregateInput
  }

  export type SickDefinitionDetailScalarWhereWithAggregatesInput = {
    AND?: SickDefinitionDetailScalarWhereWithAggregatesInput | SickDefinitionDetailScalarWhereWithAggregatesInput[]
    OR?: SickDefinitionDetailScalarWhereWithAggregatesInput[]
    NOT?: SickDefinitionDetailScalarWhereWithAggregatesInput | SickDefinitionDetailScalarWhereWithAggregatesInput[]
    RewardSickVectorID?: IntWithAggregatesFilter<"SickDefinitionDetail"> | number
    SickDefinitionID?: IntWithAggregatesFilter<"SickDefinitionDetail"> | number
    StartYearRewardSick?: IntNullableWithAggregatesFilter<"SickDefinitionDetail"> | number | null
    EndYearRewardSick?: IntNullableWithAggregatesFilter<"SickDefinitionDetail"> | number | null
    SickDayQuantity?: FloatNullableWithAggregatesFilter<"SickDefinitionDetail"> | number | null
    SocialYearDescription?: StringNullableWithAggregatesFilter<"SickDefinitionDetail"> | string | null
  }

  export type SocialSecurityWhereInput = {
    AND?: SocialSecurityWhereInput | SocialSecurityWhereInput[]
    OR?: SocialSecurityWhereInput[]
    NOT?: SocialSecurityWhereInput | SocialSecurityWhereInput[]
    SocialSecurityID?: IntFilter<"SocialSecurity"> | number
    SocialSecurityYear?: IntFilter<"SocialSecurity"> | number
    SocialSecurityMonth?: IntFilter<"SocialSecurity"> | number
    CurrentSocialSecurity?: BoolFilter<"SocialSecurity"> | boolean
    MinAccountTotalForDivuach?: IntNullableFilter<"SocialSecurity"> | number | null
    SocialSecurityDetile?: SocialSecurityDetileListRelationFilter
  }

  export type SocialSecurityOrderByWithRelationInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityYear?: SortOrder
    SocialSecurityMonth?: SortOrder
    CurrentSocialSecurity?: SortOrder
    MinAccountTotalForDivuach?: SortOrderInput | SortOrder
    SocialSecurityDetile?: SocialSecurityDetileOrderByRelationAggregateInput
  }

  export type SocialSecurityWhereUniqueInput = Prisma.AtLeast<{
    SocialSecurityID?: number
    AND?: SocialSecurityWhereInput | SocialSecurityWhereInput[]
    OR?: SocialSecurityWhereInput[]
    NOT?: SocialSecurityWhereInput | SocialSecurityWhereInput[]
    SocialSecurityYear?: IntFilter<"SocialSecurity"> | number
    SocialSecurityMonth?: IntFilter<"SocialSecurity"> | number
    CurrentSocialSecurity?: BoolFilter<"SocialSecurity"> | boolean
    MinAccountTotalForDivuach?: IntNullableFilter<"SocialSecurity"> | number | null
    SocialSecurityDetile?: SocialSecurityDetileListRelationFilter
  }, "SocialSecurityID">

  export type SocialSecurityOrderByWithAggregationInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityYear?: SortOrder
    SocialSecurityMonth?: SortOrder
    CurrentSocialSecurity?: SortOrder
    MinAccountTotalForDivuach?: SortOrderInput | SortOrder
    _count?: SocialSecurityCountOrderByAggregateInput
    _avg?: SocialSecurityAvgOrderByAggregateInput
    _max?: SocialSecurityMaxOrderByAggregateInput
    _min?: SocialSecurityMinOrderByAggregateInput
    _sum?: SocialSecuritySumOrderByAggregateInput
  }

  export type SocialSecurityScalarWhereWithAggregatesInput = {
    AND?: SocialSecurityScalarWhereWithAggregatesInput | SocialSecurityScalarWhereWithAggregatesInput[]
    OR?: SocialSecurityScalarWhereWithAggregatesInput[]
    NOT?: SocialSecurityScalarWhereWithAggregatesInput | SocialSecurityScalarWhereWithAggregatesInput[]
    SocialSecurityID?: IntWithAggregatesFilter<"SocialSecurity"> | number
    SocialSecurityYear?: IntWithAggregatesFilter<"SocialSecurity"> | number
    SocialSecurityMonth?: IntWithAggregatesFilter<"SocialSecurity"> | number
    CurrentSocialSecurity?: BoolWithAggregatesFilter<"SocialSecurity"> | boolean
    MinAccountTotalForDivuach?: IntNullableWithAggregatesFilter<"SocialSecurity"> | number | null
  }

  export type SocialSecurityDetileWhereInput = {
    AND?: SocialSecurityDetileWhereInput | SocialSecurityDetileWhereInput[]
    OR?: SocialSecurityDetileWhereInput[]
    NOT?: SocialSecurityDetileWhereInput | SocialSecurityDetileWhereInput[]
    SocialSecurityDetailID?: IntFilter<"SocialSecurityDetile"> | number
    SocialSecurityID?: IntFilter<"SocialSecurityDetile"> | number
    SocialYear?: IntFilter<"SocialSecurityDetile"> | number
    SocialMonth?: IntFilter<"SocialSecurityDetile"> | number
    Sector?: IntFilter<"SocialSecurityDetile"> | number
    SocialSecurityCode?: IntFilter<"SocialSecurityDetile"> | number
    AverageSalary?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinNationalInsByMony?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByMony?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinDeductionNationalInsByMony?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinNationalInsByEmployee?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByEmployee?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinNationalInsByEmployer?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByEmployer?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByMonyEmployee?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    AverageEmbodiment?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DeductionMax?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DeductionPercent?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditPoint?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    FactorToReduction?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinHoursToPay?: IntNullableFilter<"SocialSecurityDetile"> | number | null
    MinimumPayFor5Day?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinimumPayFor6Day?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxPrecentReduction?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    hourPerDayfor5?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    hourPerDayfor6?: IntNullableFilter<"SocialSecurityDetile"> | number | null
    hourInfridayDay?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    TaxPrecent?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    EmployerTax?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DiscountInTaxInEilat?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    TaxUnitNumber?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    FundPercentConstruction?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour100?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour125?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour150?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour175?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour200?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardMan?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardWoman?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardChild?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardBaby?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardInAddition?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardLackMobilityChild?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardImmigrant18?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    ControlingShareholder?: BoolFilter<"SocialSecurityDetile"> | boolean
    HealthInsuranceEmployeeLow?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    HealthInsuranceEmployeeAbove?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    HealthInsuranceEmployerLow?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    HealthInsuranceEmployerAbove?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    ValueOfVehicleUseHibberdDiscount?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Deposit?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    ValueOfMobileUse?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    PensionCeiling?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    PensionCredit?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DepositEmployerPrecent?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DepositEmployeePrecent?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    TotalHourPerWeek?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardAdultChild?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardChild1_5?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DepositEmployeePrecentExecption?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    SocialSecurity?: XOR<SocialSecurityScalarRelationFilter, SocialSecurityWhereInput>
  }

  export type SocialSecurityDetileOrderByWithRelationInput = {
    SocialSecurityDetailID?: SortOrder
    SocialSecurityID?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    Sector?: SortOrder
    SocialSecurityCode?: SortOrder
    AverageSalary?: SortOrderInput | SortOrder
    MinNationalInsByMony?: SortOrderInput | SortOrder
    MaxNationalInsByMony?: SortOrderInput | SortOrder
    MinDeductionNationalInsByMony?: SortOrderInput | SortOrder
    MinNationalInsByEmployee?: SortOrderInput | SortOrder
    MaxNationalInsByEmployee?: SortOrderInput | SortOrder
    MinNationalInsByEmployer?: SortOrderInput | SortOrder
    MaxNationalInsByEmployer?: SortOrderInput | SortOrder
    MaxNationalInsByMonyEmployee?: SortOrderInput | SortOrder
    AverageEmbodiment?: SortOrderInput | SortOrder
    DeductionMax?: SortOrderInput | SortOrder
    DeductionPercent?: SortOrderInput | SortOrder
    CreditPoint?: SortOrderInput | SortOrder
    FactorToReduction?: SortOrderInput | SortOrder
    MinHoursToPay?: SortOrderInput | SortOrder
    MinimumPayFor5Day?: SortOrderInput | SortOrder
    MinimumPayFor6Day?: SortOrderInput | SortOrder
    MaxPrecentReduction?: SortOrderInput | SortOrder
    hourPerDayfor5?: SortOrderInput | SortOrder
    hourPerDayfor6?: SortOrderInput | SortOrder
    hourInfridayDay?: SortOrderInput | SortOrder
    TaxPrecent?: SortOrderInput | SortOrder
    EmployerTax?: SortOrderInput | SortOrder
    DiscountInTaxInEilat?: SortOrderInput | SortOrder
    TaxUnitNumber?: SortOrderInput | SortOrder
    FundPercentConstruction?: SortOrderInput | SortOrder
    Hour100?: SortOrderInput | SortOrder
    Hour125?: SortOrderInput | SortOrder
    Hour150?: SortOrderInput | SortOrder
    Hour175?: SortOrderInput | SortOrder
    Hour200?: SortOrderInput | SortOrder
    CreditCardMan?: SortOrderInput | SortOrder
    CreditCardWoman?: SortOrderInput | SortOrder
    CreditCardChild?: SortOrderInput | SortOrder
    CreditCardBaby?: SortOrderInput | SortOrder
    CreditCardInAddition?: SortOrderInput | SortOrder
    CreditCardLackMobilityChild?: SortOrderInput | SortOrder
    CreditCardImmigrant18?: SortOrderInput | SortOrder
    ControlingShareholder?: SortOrder
    HealthInsuranceEmployeeLow?: SortOrderInput | SortOrder
    HealthInsuranceEmployeeAbove?: SortOrderInput | SortOrder
    HealthInsuranceEmployerLow?: SortOrderInput | SortOrder
    HealthInsuranceEmployerAbove?: SortOrderInput | SortOrder
    ValueOfVehicleUseHibberdDiscount?: SortOrderInput | SortOrder
    Deposit?: SortOrderInput | SortOrder
    ValueOfMobileUse?: SortOrderInput | SortOrder
    PensionCeiling?: SortOrderInput | SortOrder
    PensionCredit?: SortOrderInput | SortOrder
    DepositEmployerPrecent?: SortOrderInput | SortOrder
    DepositEmployeePrecent?: SortOrderInput | SortOrder
    TotalHourPerWeek?: SortOrderInput | SortOrder
    CreditCardAdultChild?: SortOrderInput | SortOrder
    CreditCardChild1_5?: SortOrderInput | SortOrder
    DepositEmployeePrecentExecption?: SortOrderInput | SortOrder
    SocialSecurity?: SocialSecurityOrderByWithRelationInput
  }

  export type SocialSecurityDetileWhereUniqueInput = Prisma.AtLeast<{
    SocialSecurityDetailID?: number
    AND?: SocialSecurityDetileWhereInput | SocialSecurityDetileWhereInput[]
    OR?: SocialSecurityDetileWhereInput[]
    NOT?: SocialSecurityDetileWhereInput | SocialSecurityDetileWhereInput[]
    SocialSecurityID?: IntFilter<"SocialSecurityDetile"> | number
    SocialYear?: IntFilter<"SocialSecurityDetile"> | number
    SocialMonth?: IntFilter<"SocialSecurityDetile"> | number
    Sector?: IntFilter<"SocialSecurityDetile"> | number
    SocialSecurityCode?: IntFilter<"SocialSecurityDetile"> | number
    AverageSalary?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinNationalInsByMony?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByMony?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinDeductionNationalInsByMony?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinNationalInsByEmployee?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByEmployee?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinNationalInsByEmployer?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByEmployer?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByMonyEmployee?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    AverageEmbodiment?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DeductionMax?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DeductionPercent?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditPoint?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    FactorToReduction?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinHoursToPay?: IntNullableFilter<"SocialSecurityDetile"> | number | null
    MinimumPayFor5Day?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinimumPayFor6Day?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxPrecentReduction?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    hourPerDayfor5?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    hourPerDayfor6?: IntNullableFilter<"SocialSecurityDetile"> | number | null
    hourInfridayDay?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    TaxPrecent?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    EmployerTax?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DiscountInTaxInEilat?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    TaxUnitNumber?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    FundPercentConstruction?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour100?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour125?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour150?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour175?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour200?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardMan?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardWoman?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardChild?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardBaby?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardInAddition?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardLackMobilityChild?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardImmigrant18?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    ControlingShareholder?: BoolFilter<"SocialSecurityDetile"> | boolean
    HealthInsuranceEmployeeLow?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    HealthInsuranceEmployeeAbove?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    HealthInsuranceEmployerLow?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    HealthInsuranceEmployerAbove?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    ValueOfVehicleUseHibberdDiscount?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Deposit?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    ValueOfMobileUse?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    PensionCeiling?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    PensionCredit?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DepositEmployerPrecent?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DepositEmployeePrecent?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    TotalHourPerWeek?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardAdultChild?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardChild1_5?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DepositEmployeePrecentExecption?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    SocialSecurity?: XOR<SocialSecurityScalarRelationFilter, SocialSecurityWhereInput>
  }, "SocialSecurityDetailID">

  export type SocialSecurityDetileOrderByWithAggregationInput = {
    SocialSecurityDetailID?: SortOrder
    SocialSecurityID?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    Sector?: SortOrder
    SocialSecurityCode?: SortOrder
    AverageSalary?: SortOrderInput | SortOrder
    MinNationalInsByMony?: SortOrderInput | SortOrder
    MaxNationalInsByMony?: SortOrderInput | SortOrder
    MinDeductionNationalInsByMony?: SortOrderInput | SortOrder
    MinNationalInsByEmployee?: SortOrderInput | SortOrder
    MaxNationalInsByEmployee?: SortOrderInput | SortOrder
    MinNationalInsByEmployer?: SortOrderInput | SortOrder
    MaxNationalInsByEmployer?: SortOrderInput | SortOrder
    MaxNationalInsByMonyEmployee?: SortOrderInput | SortOrder
    AverageEmbodiment?: SortOrderInput | SortOrder
    DeductionMax?: SortOrderInput | SortOrder
    DeductionPercent?: SortOrderInput | SortOrder
    CreditPoint?: SortOrderInput | SortOrder
    FactorToReduction?: SortOrderInput | SortOrder
    MinHoursToPay?: SortOrderInput | SortOrder
    MinimumPayFor5Day?: SortOrderInput | SortOrder
    MinimumPayFor6Day?: SortOrderInput | SortOrder
    MaxPrecentReduction?: SortOrderInput | SortOrder
    hourPerDayfor5?: SortOrderInput | SortOrder
    hourPerDayfor6?: SortOrderInput | SortOrder
    hourInfridayDay?: SortOrderInput | SortOrder
    TaxPrecent?: SortOrderInput | SortOrder
    EmployerTax?: SortOrderInput | SortOrder
    DiscountInTaxInEilat?: SortOrderInput | SortOrder
    TaxUnitNumber?: SortOrderInput | SortOrder
    FundPercentConstruction?: SortOrderInput | SortOrder
    Hour100?: SortOrderInput | SortOrder
    Hour125?: SortOrderInput | SortOrder
    Hour150?: SortOrderInput | SortOrder
    Hour175?: SortOrderInput | SortOrder
    Hour200?: SortOrderInput | SortOrder
    CreditCardMan?: SortOrderInput | SortOrder
    CreditCardWoman?: SortOrderInput | SortOrder
    CreditCardChild?: SortOrderInput | SortOrder
    CreditCardBaby?: SortOrderInput | SortOrder
    CreditCardInAddition?: SortOrderInput | SortOrder
    CreditCardLackMobilityChild?: SortOrderInput | SortOrder
    CreditCardImmigrant18?: SortOrderInput | SortOrder
    ControlingShareholder?: SortOrder
    HealthInsuranceEmployeeLow?: SortOrderInput | SortOrder
    HealthInsuranceEmployeeAbove?: SortOrderInput | SortOrder
    HealthInsuranceEmployerLow?: SortOrderInput | SortOrder
    HealthInsuranceEmployerAbove?: SortOrderInput | SortOrder
    ValueOfVehicleUseHibberdDiscount?: SortOrderInput | SortOrder
    Deposit?: SortOrderInput | SortOrder
    ValueOfMobileUse?: SortOrderInput | SortOrder
    PensionCeiling?: SortOrderInput | SortOrder
    PensionCredit?: SortOrderInput | SortOrder
    DepositEmployerPrecent?: SortOrderInput | SortOrder
    DepositEmployeePrecent?: SortOrderInput | SortOrder
    TotalHourPerWeek?: SortOrderInput | SortOrder
    CreditCardAdultChild?: SortOrderInput | SortOrder
    CreditCardChild1_5?: SortOrderInput | SortOrder
    DepositEmployeePrecentExecption?: SortOrderInput | SortOrder
    _count?: SocialSecurityDetileCountOrderByAggregateInput
    _avg?: SocialSecurityDetileAvgOrderByAggregateInput
    _max?: SocialSecurityDetileMaxOrderByAggregateInput
    _min?: SocialSecurityDetileMinOrderByAggregateInput
    _sum?: SocialSecurityDetileSumOrderByAggregateInput
  }

  export type SocialSecurityDetileScalarWhereWithAggregatesInput = {
    AND?: SocialSecurityDetileScalarWhereWithAggregatesInput | SocialSecurityDetileScalarWhereWithAggregatesInput[]
    OR?: SocialSecurityDetileScalarWhereWithAggregatesInput[]
    NOT?: SocialSecurityDetileScalarWhereWithAggregatesInput | SocialSecurityDetileScalarWhereWithAggregatesInput[]
    SocialSecurityDetailID?: IntWithAggregatesFilter<"SocialSecurityDetile"> | number
    SocialSecurityID?: IntWithAggregatesFilter<"SocialSecurityDetile"> | number
    SocialYear?: IntWithAggregatesFilter<"SocialSecurityDetile"> | number
    SocialMonth?: IntWithAggregatesFilter<"SocialSecurityDetile"> | number
    Sector?: IntWithAggregatesFilter<"SocialSecurityDetile"> | number
    SocialSecurityCode?: IntWithAggregatesFilter<"SocialSecurityDetile"> | number
    AverageSalary?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    MinNationalInsByMony?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByMony?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    MinDeductionNationalInsByMony?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    MinNationalInsByEmployee?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByEmployee?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    MinNationalInsByEmployer?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByEmployer?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByMonyEmployee?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    AverageEmbodiment?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    DeductionMax?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    DeductionPercent?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    CreditPoint?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    FactorToReduction?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    MinHoursToPay?: IntNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    MinimumPayFor5Day?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    MinimumPayFor6Day?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    MaxPrecentReduction?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    hourPerDayfor5?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    hourPerDayfor6?: IntNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    hourInfridayDay?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    TaxPrecent?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    EmployerTax?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    DiscountInTaxInEilat?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    TaxUnitNumber?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    FundPercentConstruction?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    Hour100?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    Hour125?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    Hour150?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    Hour175?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    Hour200?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    CreditCardMan?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    CreditCardWoman?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    CreditCardChild?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    CreditCardBaby?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    CreditCardInAddition?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    CreditCardLackMobilityChild?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    CreditCardImmigrant18?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    ControlingShareholder?: BoolWithAggregatesFilter<"SocialSecurityDetile"> | boolean
    HealthInsuranceEmployeeLow?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    HealthInsuranceEmployeeAbove?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    HealthInsuranceEmployerLow?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    HealthInsuranceEmployerAbove?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    ValueOfVehicleUseHibberdDiscount?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    Deposit?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    ValueOfMobileUse?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    PensionCeiling?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    PensionCredit?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    DepositEmployerPrecent?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    DepositEmployeePrecent?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    TotalHourPerWeek?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    CreditCardAdultChild?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    CreditCardChild1_5?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
    DepositEmployeePrecentExecption?: FloatNullableWithAggregatesFilter<"SocialSecurityDetile"> | number | null
  }

  export type sysdiagramsWhereInput = {
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    diagram_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Uint8Array | null
  }

  export type sysdiagramsOrderByWithRelationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
  }

  export type sysdiagramsWhereUniqueInput = Prisma.AtLeast<{
    diagram_id?: number
    principal_id_name?: sysdiagramsPrincipal_idNameCompoundUniqueInput
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Uint8Array | null
  }, "diagram_id" | "principal_id_name">

  export type sysdiagramsOrderByWithAggregationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
    _count?: sysdiagramsCountOrderByAggregateInput
    _avg?: sysdiagramsAvgOrderByAggregateInput
    _max?: sysdiagramsMaxOrderByAggregateInput
    _min?: sysdiagramsMinOrderByAggregateInput
    _sum?: sysdiagramsSumOrderByAggregateInput
  }

  export type sysdiagramsScalarWhereWithAggregatesInput = {
    AND?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    OR?: sysdiagramsScalarWhereWithAggregatesInput[]
    NOT?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"sysdiagrams"> | string
    principal_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    diagram_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    version?: IntNullableWithAggregatesFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableWithAggregatesFilter<"sysdiagrams"> | Uint8Array | null
  }

  export type SystemDefinitionWhereInput = {
    AND?: SystemDefinitionWhereInput | SystemDefinitionWhereInput[]
    OR?: SystemDefinitionWhereInput[]
    NOT?: SystemDefinitionWhereInput | SystemDefinitionWhereInput[]
    SystemDefinitionId?: StringFilter<"SystemDefinition"> | string
    CreatedAt?: DateTimeNullableFilter<"SystemDefinition"> | Date | string | null
    FieldDescription?: StringNullableFilter<"SystemDefinition"> | string | null
    FieldValue?: StringNullableFilter<"SystemDefinition"> | string | null
  }

  export type SystemDefinitionOrderByWithRelationInput = {
    SystemDefinitionId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    FieldDescription?: SortOrderInput | SortOrder
    FieldValue?: SortOrderInput | SortOrder
  }

  export type SystemDefinitionWhereUniqueInput = Prisma.AtLeast<{
    SystemDefinitionId?: string
    AND?: SystemDefinitionWhereInput | SystemDefinitionWhereInput[]
    OR?: SystemDefinitionWhereInput[]
    NOT?: SystemDefinitionWhereInput | SystemDefinitionWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"SystemDefinition"> | Date | string | null
    FieldDescription?: StringNullableFilter<"SystemDefinition"> | string | null
    FieldValue?: StringNullableFilter<"SystemDefinition"> | string | null
  }, "SystemDefinitionId">

  export type SystemDefinitionOrderByWithAggregationInput = {
    SystemDefinitionId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    FieldDescription?: SortOrderInput | SortOrder
    FieldValue?: SortOrderInput | SortOrder
    _count?: SystemDefinitionCountOrderByAggregateInput
    _max?: SystemDefinitionMaxOrderByAggregateInput
    _min?: SystemDefinitionMinOrderByAggregateInput
  }

  export type SystemDefinitionScalarWhereWithAggregatesInput = {
    AND?: SystemDefinitionScalarWhereWithAggregatesInput | SystemDefinitionScalarWhereWithAggregatesInput[]
    OR?: SystemDefinitionScalarWhereWithAggregatesInput[]
    NOT?: SystemDefinitionScalarWhereWithAggregatesInput | SystemDefinitionScalarWhereWithAggregatesInput[]
    SystemDefinitionId?: StringWithAggregatesFilter<"SystemDefinition"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"SystemDefinition"> | Date | string | null
    FieldDescription?: StringNullableWithAggregatesFilter<"SystemDefinition"> | string | null
    FieldValue?: StringNullableWithAggregatesFilter<"SystemDefinition"> | string | null
  }

  export type SystemMaintenancWhereInput = {
    AND?: SystemMaintenancWhereInput | SystemMaintenancWhereInput[]
    OR?: SystemMaintenancWhereInput[]
    NOT?: SystemMaintenancWhereInput | SystemMaintenancWhereInput[]
    SystemMaintenancID?: IntFilter<"SystemMaintenanc"> | number
    UserMsg?: StringFilter<"SystemMaintenanc"> | string
    LogOutFrequency?: IntFilter<"SystemMaintenanc"> | number
    SystemMaintenanc?: BoolFilter<"SystemMaintenanc"> | boolean
  }

  export type SystemMaintenancOrderByWithRelationInput = {
    SystemMaintenancID?: SortOrder
    UserMsg?: SortOrder
    LogOutFrequency?: SortOrder
    SystemMaintenanc?: SortOrder
  }

  export type SystemMaintenancWhereUniqueInput = Prisma.AtLeast<{
    SystemMaintenancID?: number
    AND?: SystemMaintenancWhereInput | SystemMaintenancWhereInput[]
    OR?: SystemMaintenancWhereInput[]
    NOT?: SystemMaintenancWhereInput | SystemMaintenancWhereInput[]
    UserMsg?: StringFilter<"SystemMaintenanc"> | string
    LogOutFrequency?: IntFilter<"SystemMaintenanc"> | number
    SystemMaintenanc?: BoolFilter<"SystemMaintenanc"> | boolean
  }, "SystemMaintenancID">

  export type SystemMaintenancOrderByWithAggregationInput = {
    SystemMaintenancID?: SortOrder
    UserMsg?: SortOrder
    LogOutFrequency?: SortOrder
    SystemMaintenanc?: SortOrder
    _count?: SystemMaintenancCountOrderByAggregateInput
    _avg?: SystemMaintenancAvgOrderByAggregateInput
    _max?: SystemMaintenancMaxOrderByAggregateInput
    _min?: SystemMaintenancMinOrderByAggregateInput
    _sum?: SystemMaintenancSumOrderByAggregateInput
  }

  export type SystemMaintenancScalarWhereWithAggregatesInput = {
    AND?: SystemMaintenancScalarWhereWithAggregatesInput | SystemMaintenancScalarWhereWithAggregatesInput[]
    OR?: SystemMaintenancScalarWhereWithAggregatesInput[]
    NOT?: SystemMaintenancScalarWhereWithAggregatesInput | SystemMaintenancScalarWhereWithAggregatesInput[]
    SystemMaintenancID?: IntWithAggregatesFilter<"SystemMaintenanc"> | number
    UserMsg?: StringWithAggregatesFilter<"SystemMaintenanc"> | string
    LogOutFrequency?: IntWithAggregatesFilter<"SystemMaintenanc"> | number
    SystemMaintenanc?: BoolWithAggregatesFilter<"SystemMaintenanc"> | boolean
  }

  export type TaxStepDetileWhereInput = {
    AND?: TaxStepDetileWhereInput | TaxStepDetileWhereInput[]
    OR?: TaxStepDetileWhereInput[]
    NOT?: TaxStepDetileWhereInput | TaxStepDetileWhereInput[]
    TaxStepDetileID?: IntFilter<"TaxStepDetile"> | number
    TaxStapID?: IntFilter<"TaxStepDetile"> | number
    TaxYear?: IntFilter<"TaxStepDetile"> | number
    TaxMonth?: IntFilter<"TaxStepDetile"> | number
    StepNumber?: IntNullableFilter<"TaxStepDetile"> | number | null
    TaxStap?: IntNullableFilter<"TaxStepDetile"> | number | null
    TaxStapPercent?: FloatNullableFilter<"TaxStepDetile"> | number | null
    TaxSteps?: XOR<TaxStepsScalarRelationFilter, TaxStepsWhereInput>
  }

  export type TaxStepDetileOrderByWithRelationInput = {
    TaxStepDetileID?: SortOrder
    TaxStapID?: SortOrder
    TaxYear?: SortOrder
    TaxMonth?: SortOrder
    StepNumber?: SortOrderInput | SortOrder
    TaxStap?: SortOrderInput | SortOrder
    TaxStapPercent?: SortOrderInput | SortOrder
    TaxSteps?: TaxStepsOrderByWithRelationInput
  }

  export type TaxStepDetileWhereUniqueInput = Prisma.AtLeast<{
    TaxStepDetileID?: number
    AND?: TaxStepDetileWhereInput | TaxStepDetileWhereInput[]
    OR?: TaxStepDetileWhereInput[]
    NOT?: TaxStepDetileWhereInput | TaxStepDetileWhereInput[]
    TaxStapID?: IntFilter<"TaxStepDetile"> | number
    TaxYear?: IntFilter<"TaxStepDetile"> | number
    TaxMonth?: IntFilter<"TaxStepDetile"> | number
    StepNumber?: IntNullableFilter<"TaxStepDetile"> | number | null
    TaxStap?: IntNullableFilter<"TaxStepDetile"> | number | null
    TaxStapPercent?: FloatNullableFilter<"TaxStepDetile"> | number | null
    TaxSteps?: XOR<TaxStepsScalarRelationFilter, TaxStepsWhereInput>
  }, "TaxStepDetileID">

  export type TaxStepDetileOrderByWithAggregationInput = {
    TaxStepDetileID?: SortOrder
    TaxStapID?: SortOrder
    TaxYear?: SortOrder
    TaxMonth?: SortOrder
    StepNumber?: SortOrderInput | SortOrder
    TaxStap?: SortOrderInput | SortOrder
    TaxStapPercent?: SortOrderInput | SortOrder
    _count?: TaxStepDetileCountOrderByAggregateInput
    _avg?: TaxStepDetileAvgOrderByAggregateInput
    _max?: TaxStepDetileMaxOrderByAggregateInput
    _min?: TaxStepDetileMinOrderByAggregateInput
    _sum?: TaxStepDetileSumOrderByAggregateInput
  }

  export type TaxStepDetileScalarWhereWithAggregatesInput = {
    AND?: TaxStepDetileScalarWhereWithAggregatesInput | TaxStepDetileScalarWhereWithAggregatesInput[]
    OR?: TaxStepDetileScalarWhereWithAggregatesInput[]
    NOT?: TaxStepDetileScalarWhereWithAggregatesInput | TaxStepDetileScalarWhereWithAggregatesInput[]
    TaxStepDetileID?: IntWithAggregatesFilter<"TaxStepDetile"> | number
    TaxStapID?: IntWithAggregatesFilter<"TaxStepDetile"> | number
    TaxYear?: IntWithAggregatesFilter<"TaxStepDetile"> | number
    TaxMonth?: IntWithAggregatesFilter<"TaxStepDetile"> | number
    StepNumber?: IntNullableWithAggregatesFilter<"TaxStepDetile"> | number | null
    TaxStap?: IntNullableWithAggregatesFilter<"TaxStepDetile"> | number | null
    TaxStapPercent?: FloatNullableWithAggregatesFilter<"TaxStepDetile"> | number | null
  }

  export type TaxStepsWhereInput = {
    AND?: TaxStepsWhereInput | TaxStepsWhereInput[]
    OR?: TaxStepsWhereInput[]
    NOT?: TaxStepsWhereInput | TaxStepsWhereInput[]
    TaxStapID?: IntFilter<"TaxSteps"> | number
    TaxMonth?: IntFilter<"TaxSteps"> | number
    TaxYear?: IntFilter<"TaxSteps"> | number
    CurrentTaxStep?: BoolFilter<"TaxSteps"> | boolean
    TaxStepDetile?: TaxStepDetileListRelationFilter
  }

  export type TaxStepsOrderByWithRelationInput = {
    TaxStapID?: SortOrder
    TaxMonth?: SortOrder
    TaxYear?: SortOrder
    CurrentTaxStep?: SortOrder
    TaxStepDetile?: TaxStepDetileOrderByRelationAggregateInput
  }

  export type TaxStepsWhereUniqueInput = Prisma.AtLeast<{
    TaxStapID?: number
    AND?: TaxStepsWhereInput | TaxStepsWhereInput[]
    OR?: TaxStepsWhereInput[]
    NOT?: TaxStepsWhereInput | TaxStepsWhereInput[]
    TaxMonth?: IntFilter<"TaxSteps"> | number
    TaxYear?: IntFilter<"TaxSteps"> | number
    CurrentTaxStep?: BoolFilter<"TaxSteps"> | boolean
    TaxStepDetile?: TaxStepDetileListRelationFilter
  }, "TaxStapID">

  export type TaxStepsOrderByWithAggregationInput = {
    TaxStapID?: SortOrder
    TaxMonth?: SortOrder
    TaxYear?: SortOrder
    CurrentTaxStep?: SortOrder
    _count?: TaxStepsCountOrderByAggregateInput
    _avg?: TaxStepsAvgOrderByAggregateInput
    _max?: TaxStepsMaxOrderByAggregateInput
    _min?: TaxStepsMinOrderByAggregateInput
    _sum?: TaxStepsSumOrderByAggregateInput
  }

  export type TaxStepsScalarWhereWithAggregatesInput = {
    AND?: TaxStepsScalarWhereWithAggregatesInput | TaxStepsScalarWhereWithAggregatesInput[]
    OR?: TaxStepsScalarWhereWithAggregatesInput[]
    NOT?: TaxStepsScalarWhereWithAggregatesInput | TaxStepsScalarWhereWithAggregatesInput[]
    TaxStapID?: IntWithAggregatesFilter<"TaxSteps"> | number
    TaxMonth?: IntWithAggregatesFilter<"TaxSteps"> | number
    TaxYear?: IntWithAggregatesFilter<"TaxSteps"> | number
    CurrentTaxStep?: BoolWithAggregatesFilter<"TaxSteps"> | boolean
  }

  export type UnionFeeWhereInput = {
    AND?: UnionFeeWhereInput | UnionFeeWhereInput[]
    OR?: UnionFeeWhereInput[]
    NOT?: UnionFeeWhereInput | UnionFeeWhereInput[]
    ID?: IntFilter<"UnionFee"> | number
    UnionCode?: IntFilter<"UnionFee"> | number
    UnionName?: StringFilter<"UnionFee"> | string
    UnionFeeDetile?: UnionFeeDetileListRelationFilter
  }

  export type UnionFeeOrderByWithRelationInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
    UnionName?: SortOrder
    UnionFeeDetile?: UnionFeeDetileOrderByRelationAggregateInput
  }

  export type UnionFeeWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    UnionCode?: number
    UnionName?: string
    AND?: UnionFeeWhereInput | UnionFeeWhereInput[]
    OR?: UnionFeeWhereInput[]
    NOT?: UnionFeeWhereInput | UnionFeeWhereInput[]
    UnionFeeDetile?: UnionFeeDetileListRelationFilter
  }, "ID" | "UnionCode" | "UnionName">

  export type UnionFeeOrderByWithAggregationInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
    UnionName?: SortOrder
    _count?: UnionFeeCountOrderByAggregateInput
    _avg?: UnionFeeAvgOrderByAggregateInput
    _max?: UnionFeeMaxOrderByAggregateInput
    _min?: UnionFeeMinOrderByAggregateInput
    _sum?: UnionFeeSumOrderByAggregateInput
  }

  export type UnionFeeScalarWhereWithAggregatesInput = {
    AND?: UnionFeeScalarWhereWithAggregatesInput | UnionFeeScalarWhereWithAggregatesInput[]
    OR?: UnionFeeScalarWhereWithAggregatesInput[]
    NOT?: UnionFeeScalarWhereWithAggregatesInput | UnionFeeScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"UnionFee"> | number
    UnionCode?: IntWithAggregatesFilter<"UnionFee"> | number
    UnionName?: StringWithAggregatesFilter<"UnionFee"> | string
  }

  export type UnionFeeDetileWhereInput = {
    AND?: UnionFeeDetileWhereInput | UnionFeeDetileWhereInput[]
    OR?: UnionFeeDetileWhereInput[]
    NOT?: UnionFeeDetileWhereInput | UnionFeeDetileWhereInput[]
    ID?: IntFilter<"UnionFeeDetile"> | number
    UnionCode?: IntFilter<"UnionFeeDetile"> | number
    SocialYear?: IntFilter<"UnionFeeDetile"> | number
    SocialMonth?: IntFilter<"UnionFeeDetile"> | number
    FeePercentage_No?: FloatNullableFilter<"UnionFeeDetile"> | number | null
    FeePercentage_Yes?: FloatNullableFilter<"UnionFeeDetile"> | number | null
    MaxFee?: FloatNullableFilter<"UnionFeeDetile"> | number | null
    MaxAdminFee?: FloatNullableFilter<"UnionFeeDetile"> | number | null
    UnionFee?: XOR<UnionFeeScalarRelationFilter, UnionFeeWhereInput>
  }

  export type UnionFeeDetileOrderByWithRelationInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    FeePercentage_No?: SortOrderInput | SortOrder
    FeePercentage_Yes?: SortOrderInput | SortOrder
    MaxFee?: SortOrderInput | SortOrder
    MaxAdminFee?: SortOrderInput | SortOrder
    UnionFee?: UnionFeeOrderByWithRelationInput
  }

  export type UnionFeeDetileWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: UnionFeeDetileWhereInput | UnionFeeDetileWhereInput[]
    OR?: UnionFeeDetileWhereInput[]
    NOT?: UnionFeeDetileWhereInput | UnionFeeDetileWhereInput[]
    UnionCode?: IntFilter<"UnionFeeDetile"> | number
    SocialYear?: IntFilter<"UnionFeeDetile"> | number
    SocialMonth?: IntFilter<"UnionFeeDetile"> | number
    FeePercentage_No?: FloatNullableFilter<"UnionFeeDetile"> | number | null
    FeePercentage_Yes?: FloatNullableFilter<"UnionFeeDetile"> | number | null
    MaxFee?: FloatNullableFilter<"UnionFeeDetile"> | number | null
    MaxAdminFee?: FloatNullableFilter<"UnionFeeDetile"> | number | null
    UnionFee?: XOR<UnionFeeScalarRelationFilter, UnionFeeWhereInput>
  }, "ID">

  export type UnionFeeDetileOrderByWithAggregationInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    FeePercentage_No?: SortOrderInput | SortOrder
    FeePercentage_Yes?: SortOrderInput | SortOrder
    MaxFee?: SortOrderInput | SortOrder
    MaxAdminFee?: SortOrderInput | SortOrder
    _count?: UnionFeeDetileCountOrderByAggregateInput
    _avg?: UnionFeeDetileAvgOrderByAggregateInput
    _max?: UnionFeeDetileMaxOrderByAggregateInput
    _min?: UnionFeeDetileMinOrderByAggregateInput
    _sum?: UnionFeeDetileSumOrderByAggregateInput
  }

  export type UnionFeeDetileScalarWhereWithAggregatesInput = {
    AND?: UnionFeeDetileScalarWhereWithAggregatesInput | UnionFeeDetileScalarWhereWithAggregatesInput[]
    OR?: UnionFeeDetileScalarWhereWithAggregatesInput[]
    NOT?: UnionFeeDetileScalarWhereWithAggregatesInput | UnionFeeDetileScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"UnionFeeDetile"> | number
    UnionCode?: IntWithAggregatesFilter<"UnionFeeDetile"> | number
    SocialYear?: IntWithAggregatesFilter<"UnionFeeDetile"> | number
    SocialMonth?: IntWithAggregatesFilter<"UnionFeeDetile"> | number
    FeePercentage_No?: FloatNullableWithAggregatesFilter<"UnionFeeDetile"> | number | null
    FeePercentage_Yes?: FloatNullableWithAggregatesFilter<"UnionFeeDetile"> | number | null
    MaxFee?: FloatNullableWithAggregatesFilter<"UnionFeeDetile"> | number | null
    MaxAdminFee?: FloatNullableWithAggregatesFilter<"UnionFeeDetile"> | number | null
  }

  export type VacationDefinitionDetailsWhereInput = {
    AND?: VacationDefinitionDetailsWhereInput | VacationDefinitionDetailsWhereInput[]
    OR?: VacationDefinitionDetailsWhereInput[]
    NOT?: VacationDefinitionDetailsWhereInput | VacationDefinitionDetailsWhereInput[]
    VacationlDefinitionDetaillID?: IntFilter<"VacationDefinitionDetails"> | number
    VacationlDefinitionID?: IntNullableFilter<"VacationDefinitionDetails"> | number | null
    StartMonthReward?: FloatNullableFilter<"VacationDefinitionDetails"> | number | null
    EndMonthrReward?: FloatNullableFilter<"VacationDefinitionDetails"> | number | null
    DayQuantity6days?: IntNullableFilter<"VacationDefinitionDetails"> | number | null
    DayQuantity5days?: IntNullableFilter<"VacationDefinitionDetails"> | number | null
    SocialYearDescription?: StringNullableFilter<"VacationDefinitionDetails"> | string | null
    DayQuantity?: IntNullableFilter<"VacationDefinitionDetails"> | number | null
    VacationlDefinition?: XOR<VacationlDefinitionNullableScalarRelationFilter, VacationlDefinitionWhereInput> | null
  }

  export type VacationDefinitionDetailsOrderByWithRelationInput = {
    VacationlDefinitionDetaillID?: SortOrder
    VacationlDefinitionID?: SortOrderInput | SortOrder
    StartMonthReward?: SortOrderInput | SortOrder
    EndMonthrReward?: SortOrderInput | SortOrder
    DayQuantity6days?: SortOrderInput | SortOrder
    DayQuantity5days?: SortOrderInput | SortOrder
    SocialYearDescription?: SortOrderInput | SortOrder
    DayQuantity?: SortOrderInput | SortOrder
    VacationlDefinition?: VacationlDefinitionOrderByWithRelationInput
  }

  export type VacationDefinitionDetailsWhereUniqueInput = Prisma.AtLeast<{
    VacationlDefinitionDetaillID?: number
    AND?: VacationDefinitionDetailsWhereInput | VacationDefinitionDetailsWhereInput[]
    OR?: VacationDefinitionDetailsWhereInput[]
    NOT?: VacationDefinitionDetailsWhereInput | VacationDefinitionDetailsWhereInput[]
    VacationlDefinitionID?: IntNullableFilter<"VacationDefinitionDetails"> | number | null
    StartMonthReward?: FloatNullableFilter<"VacationDefinitionDetails"> | number | null
    EndMonthrReward?: FloatNullableFilter<"VacationDefinitionDetails"> | number | null
    DayQuantity6days?: IntNullableFilter<"VacationDefinitionDetails"> | number | null
    DayQuantity5days?: IntNullableFilter<"VacationDefinitionDetails"> | number | null
    SocialYearDescription?: StringNullableFilter<"VacationDefinitionDetails"> | string | null
    DayQuantity?: IntNullableFilter<"VacationDefinitionDetails"> | number | null
    VacationlDefinition?: XOR<VacationlDefinitionNullableScalarRelationFilter, VacationlDefinitionWhereInput> | null
  }, "VacationlDefinitionDetaillID">

  export type VacationDefinitionDetailsOrderByWithAggregationInput = {
    VacationlDefinitionDetaillID?: SortOrder
    VacationlDefinitionID?: SortOrderInput | SortOrder
    StartMonthReward?: SortOrderInput | SortOrder
    EndMonthrReward?: SortOrderInput | SortOrder
    DayQuantity6days?: SortOrderInput | SortOrder
    DayQuantity5days?: SortOrderInput | SortOrder
    SocialYearDescription?: SortOrderInput | SortOrder
    DayQuantity?: SortOrderInput | SortOrder
    _count?: VacationDefinitionDetailsCountOrderByAggregateInput
    _avg?: VacationDefinitionDetailsAvgOrderByAggregateInput
    _max?: VacationDefinitionDetailsMaxOrderByAggregateInput
    _min?: VacationDefinitionDetailsMinOrderByAggregateInput
    _sum?: VacationDefinitionDetailsSumOrderByAggregateInput
  }

  export type VacationDefinitionDetailsScalarWhereWithAggregatesInput = {
    AND?: VacationDefinitionDetailsScalarWhereWithAggregatesInput | VacationDefinitionDetailsScalarWhereWithAggregatesInput[]
    OR?: VacationDefinitionDetailsScalarWhereWithAggregatesInput[]
    NOT?: VacationDefinitionDetailsScalarWhereWithAggregatesInput | VacationDefinitionDetailsScalarWhereWithAggregatesInput[]
    VacationlDefinitionDetaillID?: IntWithAggregatesFilter<"VacationDefinitionDetails"> | number
    VacationlDefinitionID?: IntNullableWithAggregatesFilter<"VacationDefinitionDetails"> | number | null
    StartMonthReward?: FloatNullableWithAggregatesFilter<"VacationDefinitionDetails"> | number | null
    EndMonthrReward?: FloatNullableWithAggregatesFilter<"VacationDefinitionDetails"> | number | null
    DayQuantity6days?: IntNullableWithAggregatesFilter<"VacationDefinitionDetails"> | number | null
    DayQuantity5days?: IntNullableWithAggregatesFilter<"VacationDefinitionDetails"> | number | null
    SocialYearDescription?: StringNullableWithAggregatesFilter<"VacationDefinitionDetails"> | string | null
    DayQuantity?: IntNullableWithAggregatesFilter<"VacationDefinitionDetails"> | number | null
  }

  export type VacationlDefinitionWhereInput = {
    AND?: VacationlDefinitionWhereInput | VacationlDefinitionWhereInput[]
    OR?: VacationlDefinitionWhereInput[]
    NOT?: VacationlDefinitionWhereInput | VacationlDefinitionWhereInput[]
    VacationlDefinitionID?: IntFilter<"VacationlDefinition"> | number
    VacationlDefinitionName?: StringFilter<"VacationlDefinition"> | string
    VacationDefinitionDetails?: VacationDefinitionDetailsListRelationFilter
  }

  export type VacationlDefinitionOrderByWithRelationInput = {
    VacationlDefinitionID?: SortOrder
    VacationlDefinitionName?: SortOrder
    VacationDefinitionDetails?: VacationDefinitionDetailsOrderByRelationAggregateInput
  }

  export type VacationlDefinitionWhereUniqueInput = Prisma.AtLeast<{
    VacationlDefinitionID?: number
    VacationlDefinitionName?: string
    AND?: VacationlDefinitionWhereInput | VacationlDefinitionWhereInput[]
    OR?: VacationlDefinitionWhereInput[]
    NOT?: VacationlDefinitionWhereInput | VacationlDefinitionWhereInput[]
    VacationDefinitionDetails?: VacationDefinitionDetailsListRelationFilter
  }, "VacationlDefinitionID" | "VacationlDefinitionName">

  export type VacationlDefinitionOrderByWithAggregationInput = {
    VacationlDefinitionID?: SortOrder
    VacationlDefinitionName?: SortOrder
    _count?: VacationlDefinitionCountOrderByAggregateInput
    _avg?: VacationlDefinitionAvgOrderByAggregateInput
    _max?: VacationlDefinitionMaxOrderByAggregateInput
    _min?: VacationlDefinitionMinOrderByAggregateInput
    _sum?: VacationlDefinitionSumOrderByAggregateInput
  }

  export type VacationlDefinitionScalarWhereWithAggregatesInput = {
    AND?: VacationlDefinitionScalarWhereWithAggregatesInput | VacationlDefinitionScalarWhereWithAggregatesInput[]
    OR?: VacationlDefinitionScalarWhereWithAggregatesInput[]
    NOT?: VacationlDefinitionScalarWhereWithAggregatesInput | VacationlDefinitionScalarWhereWithAggregatesInput[]
    VacationlDefinitionID?: IntWithAggregatesFilter<"VacationlDefinition"> | number
    VacationlDefinitionName?: StringWithAggregatesFilter<"VacationlDefinition"> | string
  }

  export type ValueOfVehicleUseWhereInput = {
    AND?: ValueOfVehicleUseWhereInput | ValueOfVehicleUseWhereInput[]
    OR?: ValueOfVehicleUseWhereInput[]
    NOT?: ValueOfVehicleUseWhereInput | ValueOfVehicleUseWhereInput[]
    ValueOfVehicleUselID?: IntFilter<"ValueOfVehicleUse"> | number
    Year?: IntNullableFilter<"ValueOfVehicleUse"> | number | null
    Month?: IntNullableFilter<"ValueOfVehicleUse"> | number | null
    GroupOfVehicle?: IntFilter<"ValueOfVehicleUse"> | number
    Value?: FloatNullableFilter<"ValueOfVehicleUse"> | number | null
  }

  export type ValueOfVehicleUseOrderByWithRelationInput = {
    ValueOfVehicleUselID?: SortOrder
    Year?: SortOrderInput | SortOrder
    Month?: SortOrderInput | SortOrder
    GroupOfVehicle?: SortOrder
    Value?: SortOrderInput | SortOrder
  }

  export type ValueOfVehicleUseWhereUniqueInput = Prisma.AtLeast<{
    ValueOfVehicleUselID?: number
    AND?: ValueOfVehicleUseWhereInput | ValueOfVehicleUseWhereInput[]
    OR?: ValueOfVehicleUseWhereInput[]
    NOT?: ValueOfVehicleUseWhereInput | ValueOfVehicleUseWhereInput[]
    Year?: IntNullableFilter<"ValueOfVehicleUse"> | number | null
    Month?: IntNullableFilter<"ValueOfVehicleUse"> | number | null
    GroupOfVehicle?: IntFilter<"ValueOfVehicleUse"> | number
    Value?: FloatNullableFilter<"ValueOfVehicleUse"> | number | null
  }, "ValueOfVehicleUselID">

  export type ValueOfVehicleUseOrderByWithAggregationInput = {
    ValueOfVehicleUselID?: SortOrder
    Year?: SortOrderInput | SortOrder
    Month?: SortOrderInput | SortOrder
    GroupOfVehicle?: SortOrder
    Value?: SortOrderInput | SortOrder
    _count?: ValueOfVehicleUseCountOrderByAggregateInput
    _avg?: ValueOfVehicleUseAvgOrderByAggregateInput
    _max?: ValueOfVehicleUseMaxOrderByAggregateInput
    _min?: ValueOfVehicleUseMinOrderByAggregateInput
    _sum?: ValueOfVehicleUseSumOrderByAggregateInput
  }

  export type ValueOfVehicleUseScalarWhereWithAggregatesInput = {
    AND?: ValueOfVehicleUseScalarWhereWithAggregatesInput | ValueOfVehicleUseScalarWhereWithAggregatesInput[]
    OR?: ValueOfVehicleUseScalarWhereWithAggregatesInput[]
    NOT?: ValueOfVehicleUseScalarWhereWithAggregatesInput | ValueOfVehicleUseScalarWhereWithAggregatesInput[]
    ValueOfVehicleUselID?: IntWithAggregatesFilter<"ValueOfVehicleUse"> | number
    Year?: IntNullableWithAggregatesFilter<"ValueOfVehicleUse"> | number | null
    Month?: IntNullableWithAggregatesFilter<"ValueOfVehicleUse"> | number | null
    GroupOfVehicle?: IntWithAggregatesFilter<"ValueOfVehicleUse"> | number
    Value?: FloatNullableWithAggregatesFilter<"ValueOfVehicleUse"> | number | null
  }

  export type ValueOfVehicleUseByDetileWhereInput = {
    AND?: ValueOfVehicleUseByDetileWhereInput | ValueOfVehicleUseByDetileWhereInput[]
    OR?: ValueOfVehicleUseByDetileWhereInput[]
    NOT?: ValueOfVehicleUseByDetileWhereInput | ValueOfVehicleUseByDetileWhereInput[]
    ID?: IntFilter<"ValueOfVehicleUseByDetile"> | number
    Year?: FloatFilter<"ValueOfVehicleUseByDetile"> | number
    RegistryYear?: IntFilter<"ValueOfVehicleUseByDetile"> | number
    VehicleCode?: IntFilter<"ValueOfVehicleUseByDetile"> | number
    ProductCode?: IntFilter<"ValueOfVehicleUseByDetile"> | number
    ProductName?: StringFilter<"ValueOfVehicleUseByDetile"> | string
    ModelCode?: IntFilter<"ValueOfVehicleUseByDetile"> | number
    ModelName?: StringFilter<"ValueOfVehicleUseByDetile"> | string
    FuelType?: IntNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    CommercialName?: StringNullableFilter<"ValueOfVehicleUseByDetile"> | string | null
    Automatic?: IntNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    Hybrid?: IntNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    GreenGrade?: IntNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    PolutionGrade?: IntNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    EngineVolume?: IntNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    Weight?: FloatNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    BeginDate?: DateTimeNullableFilter<"ValueOfVehicleUseByDetile"> | Date | string | null
    ListPrice?: FloatNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    AjustedPrice?: FloatNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    Value?: FloatNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
  }

  export type ValueOfVehicleUseByDetileOrderByWithRelationInput = {
    ID?: SortOrder
    Year?: SortOrder
    RegistryYear?: SortOrder
    VehicleCode?: SortOrder
    ProductCode?: SortOrder
    ProductName?: SortOrder
    ModelCode?: SortOrder
    ModelName?: SortOrder
    FuelType?: SortOrderInput | SortOrder
    CommercialName?: SortOrderInput | SortOrder
    Automatic?: SortOrderInput | SortOrder
    Hybrid?: SortOrderInput | SortOrder
    GreenGrade?: SortOrderInput | SortOrder
    PolutionGrade?: SortOrderInput | SortOrder
    EngineVolume?: SortOrderInput | SortOrder
    Weight?: SortOrderInput | SortOrder
    BeginDate?: SortOrderInput | SortOrder
    ListPrice?: SortOrderInput | SortOrder
    AjustedPrice?: SortOrderInput | SortOrder
    Value?: SortOrderInput | SortOrder
  }

  export type ValueOfVehicleUseByDetileWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: ValueOfVehicleUseByDetileWhereInput | ValueOfVehicleUseByDetileWhereInput[]
    OR?: ValueOfVehicleUseByDetileWhereInput[]
    NOT?: ValueOfVehicleUseByDetileWhereInput | ValueOfVehicleUseByDetileWhereInput[]
    Year?: FloatFilter<"ValueOfVehicleUseByDetile"> | number
    RegistryYear?: IntFilter<"ValueOfVehicleUseByDetile"> | number
    VehicleCode?: IntFilter<"ValueOfVehicleUseByDetile"> | number
    ProductCode?: IntFilter<"ValueOfVehicleUseByDetile"> | number
    ProductName?: StringFilter<"ValueOfVehicleUseByDetile"> | string
    ModelCode?: IntFilter<"ValueOfVehicleUseByDetile"> | number
    ModelName?: StringFilter<"ValueOfVehicleUseByDetile"> | string
    FuelType?: IntNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    CommercialName?: StringNullableFilter<"ValueOfVehicleUseByDetile"> | string | null
    Automatic?: IntNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    Hybrid?: IntNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    GreenGrade?: IntNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    PolutionGrade?: IntNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    EngineVolume?: IntNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    Weight?: FloatNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    BeginDate?: DateTimeNullableFilter<"ValueOfVehicleUseByDetile"> | Date | string | null
    ListPrice?: FloatNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    AjustedPrice?: FloatNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
    Value?: FloatNullableFilter<"ValueOfVehicleUseByDetile"> | number | null
  }, "ID">

  export type ValueOfVehicleUseByDetileOrderByWithAggregationInput = {
    ID?: SortOrder
    Year?: SortOrder
    RegistryYear?: SortOrder
    VehicleCode?: SortOrder
    ProductCode?: SortOrder
    ProductName?: SortOrder
    ModelCode?: SortOrder
    ModelName?: SortOrder
    FuelType?: SortOrderInput | SortOrder
    CommercialName?: SortOrderInput | SortOrder
    Automatic?: SortOrderInput | SortOrder
    Hybrid?: SortOrderInput | SortOrder
    GreenGrade?: SortOrderInput | SortOrder
    PolutionGrade?: SortOrderInput | SortOrder
    EngineVolume?: SortOrderInput | SortOrder
    Weight?: SortOrderInput | SortOrder
    BeginDate?: SortOrderInput | SortOrder
    ListPrice?: SortOrderInput | SortOrder
    AjustedPrice?: SortOrderInput | SortOrder
    Value?: SortOrderInput | SortOrder
    _count?: ValueOfVehicleUseByDetileCountOrderByAggregateInput
    _avg?: ValueOfVehicleUseByDetileAvgOrderByAggregateInput
    _max?: ValueOfVehicleUseByDetileMaxOrderByAggregateInput
    _min?: ValueOfVehicleUseByDetileMinOrderByAggregateInput
    _sum?: ValueOfVehicleUseByDetileSumOrderByAggregateInput
  }

  export type ValueOfVehicleUseByDetileScalarWhereWithAggregatesInput = {
    AND?: ValueOfVehicleUseByDetileScalarWhereWithAggregatesInput | ValueOfVehicleUseByDetileScalarWhereWithAggregatesInput[]
    OR?: ValueOfVehicleUseByDetileScalarWhereWithAggregatesInput[]
    NOT?: ValueOfVehicleUseByDetileScalarWhereWithAggregatesInput | ValueOfVehicleUseByDetileScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number
    Year?: FloatWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number
    RegistryYear?: IntWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number
    VehicleCode?: IntWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number
    ProductCode?: IntWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number
    ProductName?: StringWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | string
    ModelCode?: IntWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number
    ModelName?: StringWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | string
    FuelType?: IntNullableWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number | null
    CommercialName?: StringNullableWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | string | null
    Automatic?: IntNullableWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number | null
    Hybrid?: IntNullableWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number | null
    GreenGrade?: IntNullableWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number | null
    PolutionGrade?: IntNullableWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number | null
    EngineVolume?: IntNullableWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number | null
    Weight?: FloatNullableWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number | null
    BeginDate?: DateTimeNullableWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | Date | string | null
    ListPrice?: FloatNullableWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number | null
    AjustedPrice?: FloatNullableWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number | null
    Value?: FloatNullableWithAggregatesFilter<"ValueOfVehicleUseByDetile"> | number | null
  }

  export type AdvanceNoticeCreateInput = {
    StartPeriod?: number | null
    EndPeriod?: number | null
    DaysOfNotice?: number | null
  }

  export type AdvanceNoticeUncheckedCreateInput = {
    AdvanceNoticeID?: number
    StartPeriod?: number | null
    EndPeriod?: number | null
    DaysOfNotice?: number | null
  }

  export type AdvanceNoticeUpdateInput = {
    StartPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    EndPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    DaysOfNotice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdvanceNoticeUncheckedUpdateInput = {
    AdvanceNoticeID?: IntFieldUpdateOperationsInput | number
    StartPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    EndPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    DaysOfNotice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdvanceNoticeCreateManyInput = {
    StartPeriod?: number | null
    EndPeriod?: number | null
    DaysOfNotice?: number | null
  }

  export type AdvanceNoticeUpdateManyMutationInput = {
    StartPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    EndPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    DaysOfNotice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdvanceNoticeUncheckedUpdateManyInput = {
    AdvanceNoticeID?: IntFieldUpdateOperationsInput | number
    StartPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    EndPeriod?: NullableFloatFieldUpdateOperationsInput | number | null
    DaysOfNotice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AutoWordReportCreateInput = {
    ReportName?: string | null
    ReportTemplateName?: string | null
    IsEmployee: boolean
    IsCustomer: boolean
    StrSQL?: string | null
    IsChossCustomerOrEmployee: boolean
    SaveInArchive?: number | null
    IsView: boolean
    AutoWordReportSub?: AutoWordReportSubCreateNestedManyWithoutAutoWordReportInput
  }

  export type AutoWordReportUncheckedCreateInput = {
    ReportID?: number
    ReportName?: string | null
    ReportTemplateName?: string | null
    IsEmployee: boolean
    IsCustomer: boolean
    StrSQL?: string | null
    IsChossCustomerOrEmployee: boolean
    SaveInArchive?: number | null
    IsView: boolean
    AutoWordReportSub?: AutoWordReportSubUncheckedCreateNestedManyWithoutAutoWordReportInput
  }

  export type AutoWordReportUpdateInput = {
    ReportName?: NullableStringFieldUpdateOperationsInput | string | null
    ReportTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    IsEmployee?: BoolFieldUpdateOperationsInput | boolean
    IsCustomer?: BoolFieldUpdateOperationsInput | boolean
    StrSQL?: NullableStringFieldUpdateOperationsInput | string | null
    IsChossCustomerOrEmployee?: BoolFieldUpdateOperationsInput | boolean
    SaveInArchive?: NullableIntFieldUpdateOperationsInput | number | null
    IsView?: BoolFieldUpdateOperationsInput | boolean
    AutoWordReportSub?: AutoWordReportSubUpdateManyWithoutAutoWordReportNestedInput
  }

  export type AutoWordReportUncheckedUpdateInput = {
    ReportID?: IntFieldUpdateOperationsInput | number
    ReportName?: NullableStringFieldUpdateOperationsInput | string | null
    ReportTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    IsEmployee?: BoolFieldUpdateOperationsInput | boolean
    IsCustomer?: BoolFieldUpdateOperationsInput | boolean
    StrSQL?: NullableStringFieldUpdateOperationsInput | string | null
    IsChossCustomerOrEmployee?: BoolFieldUpdateOperationsInput | boolean
    SaveInArchive?: NullableIntFieldUpdateOperationsInput | number | null
    IsView?: BoolFieldUpdateOperationsInput | boolean
    AutoWordReportSub?: AutoWordReportSubUncheckedUpdateManyWithoutAutoWordReportNestedInput
  }

  export type AutoWordReportCreateManyInput = {
    ReportName?: string | null
    ReportTemplateName?: string | null
    IsEmployee: boolean
    IsCustomer: boolean
    StrSQL?: string | null
    IsChossCustomerOrEmployee: boolean
    SaveInArchive?: number | null
    IsView: boolean
  }

  export type AutoWordReportUpdateManyMutationInput = {
    ReportName?: NullableStringFieldUpdateOperationsInput | string | null
    ReportTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    IsEmployee?: BoolFieldUpdateOperationsInput | boolean
    IsCustomer?: BoolFieldUpdateOperationsInput | boolean
    StrSQL?: NullableStringFieldUpdateOperationsInput | string | null
    IsChossCustomerOrEmployee?: BoolFieldUpdateOperationsInput | boolean
    SaveInArchive?: NullableIntFieldUpdateOperationsInput | number | null
    IsView?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutoWordReportUncheckedUpdateManyInput = {
    ReportID?: IntFieldUpdateOperationsInput | number
    ReportName?: NullableStringFieldUpdateOperationsInput | string | null
    ReportTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    IsEmployee?: BoolFieldUpdateOperationsInput | boolean
    IsCustomer?: BoolFieldUpdateOperationsInput | boolean
    StrSQL?: NullableStringFieldUpdateOperationsInput | string | null
    IsChossCustomerOrEmployee?: BoolFieldUpdateOperationsInput | boolean
    SaveInArchive?: NullableIntFieldUpdateOperationsInput | number | null
    IsView?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutoWordReportSubCreateInput = {
    FieldNameTB?: string | null
    FieldNameReport?: string | null
    AutoWordReport?: AutoWordReportCreateNestedOneWithoutAutoWordReportSubInput
  }

  export type AutoWordReportSubUncheckedCreateInput = {
    ReportSubID?: number
    ReportID?: number | null
    FieldNameTB?: string | null
    FieldNameReport?: string | null
  }

  export type AutoWordReportSubUpdateInput = {
    FieldNameTB?: NullableStringFieldUpdateOperationsInput | string | null
    FieldNameReport?: NullableStringFieldUpdateOperationsInput | string | null
    AutoWordReport?: AutoWordReportUpdateOneWithoutAutoWordReportSubNestedInput
  }

  export type AutoWordReportSubUncheckedUpdateInput = {
    ReportSubID?: IntFieldUpdateOperationsInput | number
    ReportID?: NullableIntFieldUpdateOperationsInput | number | null
    FieldNameTB?: NullableStringFieldUpdateOperationsInput | string | null
    FieldNameReport?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AutoWordReportSubCreateManyInput = {
    ReportID?: number | null
    FieldNameTB?: string | null
    FieldNameReport?: string | null
  }

  export type AutoWordReportSubUpdateManyMutationInput = {
    FieldNameTB?: NullableStringFieldUpdateOperationsInput | string | null
    FieldNameReport?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AutoWordReportSubUncheckedUpdateManyInput = {
    ReportSubID?: IntFieldUpdateOperationsInput | number
    ReportID?: NullableIntFieldUpdateOperationsInput | number | null
    FieldNameTB?: NullableStringFieldUpdateOperationsInput | string | null
    FieldNameReport?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeHistoryCreateInput = {
    Application_Name?: string | null
    ChangeDate?: Date | string | null
    Version_Number?: string | null
    ChangeDescription?: string | null
    ConvertDatabase: boolean
  }

  export type ChangeHistoryUncheckedCreateInput = {
    ChangeHistoryID?: number
    Application_Name?: string | null
    ChangeDate?: Date | string | null
    Version_Number?: string | null
    ChangeDescription?: string | null
    ConvertDatabase: boolean
  }

  export type ChangeHistoryUpdateInput = {
    Application_Name?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version_Number?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ConvertDatabase?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChangeHistoryUncheckedUpdateInput = {
    ChangeHistoryID?: IntFieldUpdateOperationsInput | number
    Application_Name?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version_Number?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ConvertDatabase?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChangeHistoryCreateManyInput = {
    Application_Name?: string | null
    ChangeDate?: Date | string | null
    Version_Number?: string | null
    ChangeDescription?: string | null
    ConvertDatabase: boolean
  }

  export type ChangeHistoryUpdateManyMutationInput = {
    Application_Name?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version_Number?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ConvertDatabase?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChangeHistoryUncheckedUpdateManyInput = {
    ChangeHistoryID?: IntFieldUpdateOperationsInput | number
    Application_Name?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version_Number?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ConvertDatabase?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CitysIncomeTaxDiscountCreateInput = {
    ID: number
    Year: number
    GroupCode: number
    CityName: string
    DiscountPercent?: number | null
    MaximumIncome?: number | null
    MaximumIncomePerMonth?: number | null
  }

  export type CitysIncomeTaxDiscountUncheckedCreateInput = {
    ID: number
    Year: number
    GroupCode: number
    CityName: string
    DiscountPercent?: number | null
    MaximumIncome?: number | null
    MaximumIncomePerMonth?: number | null
  }

  export type CitysIncomeTaxDiscountUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Year?: FloatFieldUpdateOperationsInput | number
    GroupCode?: IntFieldUpdateOperationsInput | number
    CityName?: StringFieldUpdateOperationsInput | string
    DiscountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    MaximumIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    MaximumIncomePerMonth?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CitysIncomeTaxDiscountUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Year?: FloatFieldUpdateOperationsInput | number
    GroupCode?: IntFieldUpdateOperationsInput | number
    CityName?: StringFieldUpdateOperationsInput | string
    DiscountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    MaximumIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    MaximumIncomePerMonth?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CitysIncomeTaxDiscountCreateManyInput = {
    ID: number
    Year: number
    GroupCode: number
    CityName: string
    DiscountPercent?: number | null
    MaximumIncome?: number | null
    MaximumIncomePerMonth?: number | null
  }

  export type CitysIncomeTaxDiscountUpdateManyMutationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Year?: FloatFieldUpdateOperationsInput | number
    GroupCode?: IntFieldUpdateOperationsInput | number
    CityName?: StringFieldUpdateOperationsInput | string
    DiscountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    MaximumIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    MaximumIncomePerMonth?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CitysIncomeTaxDiscountUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Year?: FloatFieldUpdateOperationsInput | number
    GroupCode?: IntFieldUpdateOperationsInput | number
    CityName?: StringFieldUpdateOperationsInput | string
    DiscountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    MaximumIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    MaximumIncomePerMonth?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CompaniesCreateInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    CompaniesType?: CompaniesTypeCreateNestedOneWithoutCompaniesInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompanies_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    LandPages?: LandPagesCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesUncheckedCreateInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    UserId?: string | null
    CompanyTypeID?: string
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    LandPages?: LandPagesUncheckedCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesUpdateInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesType?: CompaniesTypeUpdateOneRequiredWithoutCompaniesNestedInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersUpdateOneWithoutCompanies_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    LandPages?: LandPagesUpdateOneWithoutCompaniesNestedInput
  }

  export type CompaniesUncheckedUpdateInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    LandPages?: LandPagesUncheckedUpdateOneWithoutCompaniesNestedInput
  }

  export type CompaniesCreateManyInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    UserId?: string | null
    CompanyTypeID?: string
  }

  export type CompaniesUpdateManyMutationInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUncheckedUpdateManyInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyTypeID?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesProductsCreateInput = {
    CompaniesProductsId?: string
    CreatedAt?: Date | string | null
    LastVersionDate_Salary?: Date | string | null
    LastVersionDate_ManPower?: Date | string | null
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompaniesProductsInput
    Companies: CompaniesCreateNestedOneWithoutCompaniesProductsInput
    Products: ProductsCreateNestedOneWithoutCompaniesProductsInput
  }

  export type CompaniesProductsUncheckedCreateInput = {
    CompaniesProductsId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    UserId?: string | null
    LastVersionDate_Salary?: Date | string | null
    LastVersionDate_ManPower?: Date | string | null
  }

  export type CompaniesProductsUpdateInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutCompaniesProductsNestedInput
    Companies?: CompaniesUpdateOneRequiredWithoutCompaniesProductsNestedInput
    Products?: ProductsUpdateOneRequiredWithoutCompaniesProductsNestedInput
  }

  export type CompaniesProductsUncheckedUpdateInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompaniesProductsCreateManyInput = {
    CompaniesProductsId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    UserId?: string | null
    LastVersionDate_Salary?: Date | string | null
    LastVersionDate_ManPower?: Date | string | null
  }

  export type CompaniesProductsUpdateManyMutationInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompaniesProductsUncheckedUpdateManyInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompaniesProductsExpireDatesCreateInput = {
    CompaniesProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompaniesProductsExpireDatesInput
    Companies: CompaniesCreateNestedOneWithoutCompaniesProductsExpireDatesInput
    Products: ProductsCreateNestedOneWithoutCompaniesProductsExpireDatesInput
  }

  export type CompaniesProductsExpireDatesUncheckedCreateInput = {
    CompaniesProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    UserId?: string | null
  }

  export type CompaniesProductsExpireDatesUpdateInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutCompaniesProductsExpireDatesNestedInput
    Companies?: CompaniesUpdateOneRequiredWithoutCompaniesProductsExpireDatesNestedInput
    Products?: ProductsUpdateOneRequiredWithoutCompaniesProductsExpireDatesNestedInput
  }

  export type CompaniesProductsExpireDatesUncheckedUpdateInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesProductsExpireDatesCreateManyInput = {
    CompaniesProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    UserId?: string | null
  }

  export type CompaniesProductsExpireDatesUpdateManyMutationInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesProductsExpireDatesUncheckedUpdateManyInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesTypeCreateInput = {
    CompaniesTypeID?: string
    CompaniesType: string
    Companies?: CompaniesCreateNestedManyWithoutCompaniesTypeInput
  }

  export type CompaniesTypeUncheckedCreateInput = {
    CompaniesTypeID?: string
    CompaniesType: string
    Companies?: CompaniesUncheckedCreateNestedManyWithoutCompaniesTypeInput
  }

  export type CompaniesTypeUpdateInput = {
    CompaniesTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesType?: StringFieldUpdateOperationsInput | string
    Companies?: CompaniesUpdateManyWithoutCompaniesTypeNestedInput
  }

  export type CompaniesTypeUncheckedUpdateInput = {
    CompaniesTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesType?: StringFieldUpdateOperationsInput | string
    Companies?: CompaniesUncheckedUpdateManyWithoutCompaniesTypeNestedInput
  }

  export type CompaniesTypeCreateManyInput = {
    CompaniesTypeID?: string
    CompaniesType: string
  }

  export type CompaniesTypeUpdateManyMutationInput = {
    CompaniesTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesType?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesTypeUncheckedUpdateManyInput = {
    CompaniesTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesType?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesUsersCreateInput = {
    CompaniesUsersID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutOther_CompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersCreateNestedManyWithoutCompaniesUsersInput
    Companies_CompaniesUsers_CompanyIDToCompanies: CompaniesCreateNestedOneWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersUncheckedCreateInput = {
    CompaniesUsersID: string
    CompanyID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    UserId?: string | null
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersUpdateInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutOther_CompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUpdateManyWithoutCompaniesUsersNestedInput
    Companies_CompaniesUsers_CompanyIDToCompanies?: CompaniesUpdateOneRequiredWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersUncheckedUpdateInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersCreateManyInput = {
    CompaniesUsersID: string
    CompanyID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    UserId?: string | null
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
  }

  export type CompaniesUsersUpdateManyMutationInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersUncheckedUpdateManyInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersProductsExpireDatesCreateInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers: CompaniesUsersCreateNestedOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    Companies: CompaniesCreateNestedOneWithoutCompaniesUsersProductsExpireDatesInput
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
    Products: ProductsCreateNestedOneWithoutCompaniesUsersProductsExpireDatesInput
  }

  export type CompaniesUsersProductsExpireDatesUncheckedCreateInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    CompaniesUsersID: string
    StartDate: Date | string
    EndDate: Date | string
    UserId?: string | null
    Comments?: string | null
  }

  export type CompaniesUsersProductsExpireDatesUpdateInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersUpdateOneRequiredWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    Companies?: CompaniesUpdateOneRequiredWithoutCompaniesUsersProductsExpireDatesNestedInput
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersUpdateOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
    Products?: ProductsUpdateOneRequiredWithoutCompaniesUsersProductsExpireDatesNestedInput
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersProductsExpireDatesCreateManyInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    CompaniesUsersID: string
    StartDate: Date | string
    EndDate: Date | string
    UserId?: string | null
    Comments?: string | null
  }

  export type CompaniesUsersProductsExpireDatesUpdateManyMutationInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateManyInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CopyrightCreateInput = {
    CopyrightID: number
    Copyright: string
    DbGeneralVer: number
  }

  export type CopyrightUncheckedCreateInput = {
    CopyrightID: number
    Copyright: string
    DbGeneralVer: number
  }

  export type CopyrightUpdateInput = {
    CopyrightID?: IntFieldUpdateOperationsInput | number
    Copyright?: StringFieldUpdateOperationsInput | string
    DbGeneralVer?: FloatFieldUpdateOperationsInput | number
  }

  export type CopyrightUncheckedUpdateInput = {
    CopyrightID?: IntFieldUpdateOperationsInput | number
    Copyright?: StringFieldUpdateOperationsInput | string
    DbGeneralVer?: FloatFieldUpdateOperationsInput | number
  }

  export type CopyrightCreateManyInput = {
    CopyrightID: number
    Copyright: string
    DbGeneralVer: number
  }

  export type CopyrightUpdateManyMutationInput = {
    CopyrightID?: IntFieldUpdateOperationsInput | number
    Copyright?: StringFieldUpdateOperationsInput | string
    DbGeneralVer?: FloatFieldUpdateOperationsInput | number
  }

  export type CopyrightUncheckedUpdateManyInput = {
    CopyrightID?: IntFieldUpdateOperationsInput | number
    Copyright?: StringFieldUpdateOperationsInput | string
    DbGeneralVer?: FloatFieldUpdateOperationsInput | number
  }

  export type CountriesCreateInput = {
    CountryCode: number
    CountryName: string
    CountryNameEnglish: string
    MultipleSelect?: boolean | null
    CommentPayslip?: string | null
    CommentHour?: string | null
    DefaultLanguageCol?: string | null
  }

  export type CountriesUncheckedCreateInput = {
    CountryID?: number
    CountryCode: number
    CountryName: string
    CountryNameEnglish: string
    MultipleSelect?: boolean | null
    CommentPayslip?: string | null
    CommentHour?: string | null
    DefaultLanguageCol?: string | null
  }

  export type CountriesUpdateInput = {
    CountryCode?: IntFieldUpdateOperationsInput | number
    CountryName?: StringFieldUpdateOperationsInput | string
    CountryNameEnglish?: StringFieldUpdateOperationsInput | string
    MultipleSelect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CommentPayslip?: NullableStringFieldUpdateOperationsInput | string | null
    CommentHour?: NullableStringFieldUpdateOperationsInput | string | null
    DefaultLanguageCol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountriesUncheckedUpdateInput = {
    CountryID?: IntFieldUpdateOperationsInput | number
    CountryCode?: IntFieldUpdateOperationsInput | number
    CountryName?: StringFieldUpdateOperationsInput | string
    CountryNameEnglish?: StringFieldUpdateOperationsInput | string
    MultipleSelect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CommentPayslip?: NullableStringFieldUpdateOperationsInput | string | null
    CommentHour?: NullableStringFieldUpdateOperationsInput | string | null
    DefaultLanguageCol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountriesCreateManyInput = {
    CountryCode: number
    CountryName: string
    CountryNameEnglish: string
    MultipleSelect?: boolean | null
    CommentPayslip?: string | null
    CommentHour?: string | null
    DefaultLanguageCol?: string | null
  }

  export type CountriesUpdateManyMutationInput = {
    CountryCode?: IntFieldUpdateOperationsInput | number
    CountryName?: StringFieldUpdateOperationsInput | string
    CountryNameEnglish?: StringFieldUpdateOperationsInput | string
    MultipleSelect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CommentPayslip?: NullableStringFieldUpdateOperationsInput | string | null
    CommentHour?: NullableStringFieldUpdateOperationsInput | string | null
    DefaultLanguageCol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountriesUncheckedUpdateManyInput = {
    CountryID?: IntFieldUpdateOperationsInput | number
    CountryCode?: IntFieldUpdateOperationsInput | number
    CountryName?: StringFieldUpdateOperationsInput | string
    CountryNameEnglish?: StringFieldUpdateOperationsInput | string
    MultipleSelect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CommentPayslip?: NullableStringFieldUpdateOperationsInput | string | null
    CommentHour?: NullableStringFieldUpdateOperationsInput | string | null
    DefaultLanguageCol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditShiftCreateInput = {
    CreditShiftDate?: Date | string | null
    MaxCreditShiftPrecent?: number | null
    MaxCreditShiftLimit?: number | null
    CreditPrecent?: number | null
  }

  export type CreditShiftUncheckedCreateInput = {
    CreditShiftID?: number
    CreditShiftDate?: Date | string | null
    MaxCreditShiftPrecent?: number | null
    MaxCreditShiftLimit?: number | null
    CreditPrecent?: number | null
  }

  export type CreditShiftUpdateInput = {
    CreditShiftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MaxCreditShiftPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxCreditShiftLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditShiftUncheckedUpdateInput = {
    CreditShiftID?: IntFieldUpdateOperationsInput | number
    CreditShiftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MaxCreditShiftPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxCreditShiftLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditShiftCreateManyInput = {
    CreditShiftDate?: Date | string | null
    MaxCreditShiftPrecent?: number | null
    MaxCreditShiftLimit?: number | null
    CreditPrecent?: number | null
  }

  export type CreditShiftUpdateManyMutationInput = {
    CreditShiftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MaxCreditShiftPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxCreditShiftLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditShiftUncheckedUpdateManyInput = {
    CreditShiftID?: IntFieldUpdateOperationsInput | number
    CreditShiftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MaxCreditShiftPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxCreditShiftLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DaysInMonthCreateInput = {
    DateManaged: Date | string
    YearManaged?: number | null
    MonthManaged?: number | null
    DayInMonth?: number | null
    DayInWeek?: number | null
    WeekInYear?: number | null
    WeekInMonth?: number | null
    DayTypeID?: number | null
    StartEndTimeSabat?: Date | string | null
    HolidayName?: string | null
  }

  export type DaysInMonthUncheckedCreateInput = {
    DateManagedID?: number
    DateManaged: Date | string
    YearManaged?: number | null
    MonthManaged?: number | null
    DayInMonth?: number | null
    DayInWeek?: number | null
    WeekInYear?: number | null
    WeekInMonth?: number | null
    DayTypeID?: number | null
    StartEndTimeSabat?: Date | string | null
    HolidayName?: string | null
  }

  export type DaysInMonthUpdateInput = {
    DateManaged?: DateTimeFieldUpdateOperationsInput | Date | string
    YearManaged?: NullableIntFieldUpdateOperationsInput | number | null
    MonthManaged?: NullableIntFieldUpdateOperationsInput | number | null
    DayInMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    DayInWeek?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInYear?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInMonth?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DaysInMonthUncheckedUpdateInput = {
    DateManagedID?: IntFieldUpdateOperationsInput | number
    DateManaged?: DateTimeFieldUpdateOperationsInput | Date | string
    YearManaged?: NullableIntFieldUpdateOperationsInput | number | null
    MonthManaged?: NullableIntFieldUpdateOperationsInput | number | null
    DayInMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    DayInWeek?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInYear?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInMonth?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DaysInMonthCreateManyInput = {
    DateManaged: Date | string
    YearManaged?: number | null
    MonthManaged?: number | null
    DayInMonth?: number | null
    DayInWeek?: number | null
    WeekInYear?: number | null
    WeekInMonth?: number | null
    DayTypeID?: number | null
    StartEndTimeSabat?: Date | string | null
    HolidayName?: string | null
  }

  export type DaysInMonthUpdateManyMutationInput = {
    DateManaged?: DateTimeFieldUpdateOperationsInput | Date | string
    YearManaged?: NullableIntFieldUpdateOperationsInput | number | null
    MonthManaged?: NullableIntFieldUpdateOperationsInput | number | null
    DayInMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    DayInWeek?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInYear?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInMonth?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DaysInMonthUncheckedUpdateManyInput = {
    DateManagedID?: IntFieldUpdateOperationsInput | number
    DateManaged?: DateTimeFieldUpdateOperationsInput | Date | string
    YearManaged?: NullableIntFieldUpdateOperationsInput | number | null
    MonthManaged?: NullableIntFieldUpdateOperationsInput | number | null
    DayInMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    DayInWeek?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInYear?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInMonth?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DaysInMonth_NewYearCreateInput = {
    DateManaged: Date | string
    YearManaged?: number | null
    MonthManaged?: number | null
    DayInMonth?: number | null
    DayInWeek?: number | null
    WeekInYear?: number | null
    WeekInMonth?: number | null
    DayTypeID?: number | null
    StartEndTimeSabat?: Date | string | null
    HolidayName?: string | null
  }

  export type DaysInMonth_NewYearUncheckedCreateInput = {
    DateManagedID?: number
    DateManaged: Date | string
    YearManaged?: number | null
    MonthManaged?: number | null
    DayInMonth?: number | null
    DayInWeek?: number | null
    WeekInYear?: number | null
    WeekInMonth?: number | null
    DayTypeID?: number | null
    StartEndTimeSabat?: Date | string | null
    HolidayName?: string | null
  }

  export type DaysInMonth_NewYearUpdateInput = {
    DateManaged?: DateTimeFieldUpdateOperationsInput | Date | string
    YearManaged?: NullableIntFieldUpdateOperationsInput | number | null
    MonthManaged?: NullableIntFieldUpdateOperationsInput | number | null
    DayInMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    DayInWeek?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInYear?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInMonth?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DaysInMonth_NewYearUncheckedUpdateInput = {
    DateManagedID?: IntFieldUpdateOperationsInput | number
    DateManaged?: DateTimeFieldUpdateOperationsInput | Date | string
    YearManaged?: NullableIntFieldUpdateOperationsInput | number | null
    MonthManaged?: NullableIntFieldUpdateOperationsInput | number | null
    DayInMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    DayInWeek?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInYear?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInMonth?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DaysInMonth_NewYearCreateManyInput = {
    DateManaged: Date | string
    YearManaged?: number | null
    MonthManaged?: number | null
    DayInMonth?: number | null
    DayInWeek?: number | null
    WeekInYear?: number | null
    WeekInMonth?: number | null
    DayTypeID?: number | null
    StartEndTimeSabat?: Date | string | null
    HolidayName?: string | null
  }

  export type DaysInMonth_NewYearUpdateManyMutationInput = {
    DateManaged?: DateTimeFieldUpdateOperationsInput | Date | string
    YearManaged?: NullableIntFieldUpdateOperationsInput | number | null
    MonthManaged?: NullableIntFieldUpdateOperationsInput | number | null
    DayInMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    DayInWeek?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInYear?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInMonth?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DaysInMonth_NewYearUncheckedUpdateManyInput = {
    DateManagedID?: IntFieldUpdateOperationsInput | number
    DateManaged?: DateTimeFieldUpdateOperationsInput | Date | string
    YearManaged?: NullableIntFieldUpdateOperationsInput | number | null
    MonthManaged?: NullableIntFieldUpdateOperationsInput | number | null
    DayInMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    DayInWeek?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInYear?: NullableIntFieldUpdateOperationsInput | number | null
    WeekInMonth?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DayTypeCreateInput = {
    DayTypeID: number
    DayTypeName: string
    SetOrder: number
  }

  export type DayTypeUncheckedCreateInput = {
    DayTypeID: number
    DayTypeName: string
    SetOrder: number
  }

  export type DayTypeUpdateInput = {
    DayTypeID?: IntFieldUpdateOperationsInput | number
    DayTypeName?: StringFieldUpdateOperationsInput | string
    SetOrder?: IntFieldUpdateOperationsInput | number
  }

  export type DayTypeUncheckedUpdateInput = {
    DayTypeID?: IntFieldUpdateOperationsInput | number
    DayTypeName?: StringFieldUpdateOperationsInput | string
    SetOrder?: IntFieldUpdateOperationsInput | number
  }

  export type DayTypeCreateManyInput = {
    DayTypeID: number
    DayTypeName: string
    SetOrder: number
  }

  export type DayTypeUpdateManyMutationInput = {
    DayTypeID?: IntFieldUpdateOperationsInput | number
    DayTypeName?: StringFieldUpdateOperationsInput | string
    SetOrder?: IntFieldUpdateOperationsInput | number
  }

  export type DayTypeUncheckedUpdateManyInput = {
    DayTypeID?: IntFieldUpdateOperationsInput | number
    DayTypeName?: StringFieldUpdateOperationsInput | string
    SetOrder?: IntFieldUpdateOperationsInput | number
  }

  export type DisplayTypeCreateInput = {
    DisplayType: string
    URL: string
    IsShowInDanzarCRM?: number
  }

  export type DisplayTypeUncheckedCreateInput = {
    DisplayTypeID?: number
    DisplayType: string
    URL: string
    IsShowInDanzarCRM?: number
  }

  export type DisplayTypeUpdateInput = {
    DisplayType?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    IsShowInDanzarCRM?: IntFieldUpdateOperationsInput | number
  }

  export type DisplayTypeUncheckedUpdateInput = {
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    DisplayType?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    IsShowInDanzarCRM?: IntFieldUpdateOperationsInput | number
  }

  export type DisplayTypeCreateManyInput = {
    DisplayType: string
    URL: string
    IsShowInDanzarCRM?: number
  }

  export type DisplayTypeUpdateManyMutationInput = {
    DisplayType?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    IsShowInDanzarCRM?: IntFieldUpdateOperationsInput | number
  }

  export type DisplayTypeUncheckedUpdateManyInput = {
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    DisplayType?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    IsShowInDanzarCRM?: IntFieldUpdateOperationsInput | number
  }

  export type HashIndexGeneralCreateInput = {
    HashName?: string | null
  }

  export type HashIndexGeneralUncheckedCreateInput = {
    HashCode?: number
    HashName?: string | null
  }

  export type HashIndexGeneralUpdateInput = {
    HashName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HashIndexGeneralUncheckedUpdateInput = {
    HashCode?: IntFieldUpdateOperationsInput | number
    HashName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HashIndexGeneralCreateManyInput = {
    HashName?: string | null
  }

  export type HashIndexGeneralUpdateManyMutationInput = {
    HashName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HashIndexGeneralUncheckedUpdateManyInput = {
    HashCode?: IntFieldUpdateOperationsInput | number
    HashName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HashSecurityCreateInput = {
    HashID?: string
    HashCode: bigint | number
    IsUse?: number
  }

  export type HashSecurityUncheckedCreateInput = {
    HashID?: string
    HashCode: bigint | number
    IsUse?: number
  }

  export type HashSecurityUpdateInput = {
    HashID?: StringFieldUpdateOperationsInput | string
    HashCode?: BigIntFieldUpdateOperationsInput | bigint | number
    IsUse?: IntFieldUpdateOperationsInput | number
  }

  export type HashSecurityUncheckedUpdateInput = {
    HashID?: StringFieldUpdateOperationsInput | string
    HashCode?: BigIntFieldUpdateOperationsInput | bigint | number
    IsUse?: IntFieldUpdateOperationsInput | number
  }

  export type HashSecurityCreateManyInput = {
    HashID?: string
    HashCode: bigint | number
    IsUse?: number
  }

  export type HashSecurityUpdateManyMutationInput = {
    HashID?: StringFieldUpdateOperationsInput | string
    HashCode?: BigIntFieldUpdateOperationsInput | bigint | number
    IsUse?: IntFieldUpdateOperationsInput | number
  }

  export type HashSecurityUncheckedUpdateManyInput = {
    HashID?: StringFieldUpdateOperationsInput | string
    HashCode?: BigIntFieldUpdateOperationsInput | bigint | number
    IsUse?: IntFieldUpdateOperationsInput | number
  }

  export type JobsCreateInput = {
    JobTitle: string
  }

  export type JobsUncheckedCreateInput = {
    JobsID?: number
    JobTitle: string
  }

  export type JobsUpdateInput = {
    JobTitle?: StringFieldUpdateOperationsInput | string
  }

  export type JobsUncheckedUpdateInput = {
    JobsID?: IntFieldUpdateOperationsInput | number
    JobTitle?: StringFieldUpdateOperationsInput | string
  }

  export type JobsCreateManyInput = {
    JobTitle: string
  }

  export type JobsUpdateManyMutationInput = {
    JobTitle?: StringFieldUpdateOperationsInput | string
  }

  export type JobsUncheckedUpdateManyInput = {
    JobsID?: IntFieldUpdateOperationsInput | number
    JobTitle?: StringFieldUpdateOperationsInput | string
  }

  export type KupaGemelCreateInput = {
    KupaName?: string | null
    AllowanceEmployeePercent?: number | null
    AllowanceEmployerPercent?: number | null
    AllowanceCompensationPercen?: number | null
    IsAndromedaRecord: boolean
    EducationFundPercentEmp?: number | null
    EducationFundPercentEmpoyer?: number | null
  }

  export type KupaGemelUncheckedCreateInput = {
    KupaID?: number
    KupaName?: string | null
    AllowanceEmployeePercent?: number | null
    AllowanceEmployerPercent?: number | null
    AllowanceCompensationPercen?: number | null
    IsAndromedaRecord: boolean
    EducationFundPercentEmp?: number | null
    EducationFundPercentEmpoyer?: number | null
  }

  export type KupaGemelUpdateInput = {
    KupaName?: NullableStringFieldUpdateOperationsInput | string | null
    AllowanceEmployeePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    AllowanceEmployerPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    AllowanceCompensationPercen?: NullableFloatFieldUpdateOperationsInput | number | null
    IsAndromedaRecord?: BoolFieldUpdateOperationsInput | boolean
    EducationFundPercentEmp?: NullableFloatFieldUpdateOperationsInput | number | null
    EducationFundPercentEmpoyer?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type KupaGemelUncheckedUpdateInput = {
    KupaID?: IntFieldUpdateOperationsInput | number
    KupaName?: NullableStringFieldUpdateOperationsInput | string | null
    AllowanceEmployeePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    AllowanceEmployerPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    AllowanceCompensationPercen?: NullableFloatFieldUpdateOperationsInput | number | null
    IsAndromedaRecord?: BoolFieldUpdateOperationsInput | boolean
    EducationFundPercentEmp?: NullableFloatFieldUpdateOperationsInput | number | null
    EducationFundPercentEmpoyer?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type KupaGemelCreateManyInput = {
    KupaName?: string | null
    AllowanceEmployeePercent?: number | null
    AllowanceEmployerPercent?: number | null
    AllowanceCompensationPercen?: number | null
    IsAndromedaRecord: boolean
    EducationFundPercentEmp?: number | null
    EducationFundPercentEmpoyer?: number | null
  }

  export type KupaGemelUpdateManyMutationInput = {
    KupaName?: NullableStringFieldUpdateOperationsInput | string | null
    AllowanceEmployeePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    AllowanceEmployerPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    AllowanceCompensationPercen?: NullableFloatFieldUpdateOperationsInput | number | null
    IsAndromedaRecord?: BoolFieldUpdateOperationsInput | boolean
    EducationFundPercentEmp?: NullableFloatFieldUpdateOperationsInput | number | null
    EducationFundPercentEmpoyer?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type KupaGemelUncheckedUpdateManyInput = {
    KupaID?: IntFieldUpdateOperationsInput | number
    KupaName?: NullableStringFieldUpdateOperationsInput | string | null
    AllowanceEmployeePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    AllowanceEmployerPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    AllowanceCompensationPercen?: NullableFloatFieldUpdateOperationsInput | number | null
    IsAndromedaRecord?: BoolFieldUpdateOperationsInput | boolean
    EducationFundPercentEmp?: NullableFloatFieldUpdateOperationsInput | number | null
    EducationFundPercentEmpoyer?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LandPagesCreateInput = {
    LandPageRowId?: string
    CreatedAt?: Date | string | null
    JsonData?: string | null
    ViewDate?: Date | string | null
    CompletedDate?: Date | string | null
    Companies: CompaniesCreateNestedOneWithoutLandPagesInput
  }

  export type LandPagesUncheckedCreateInput = {
    LandPageRowId?: string
    CompanyID: string
    CreatedAt?: Date | string | null
    JsonData?: string | null
    ViewDate?: Date | string | null
    CompletedDate?: Date | string | null
  }

  export type LandPagesUpdateInput = {
    LandPageRowId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JsonData?: NullableStringFieldUpdateOperationsInput | string | null
    ViewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Companies?: CompaniesUpdateOneRequiredWithoutLandPagesNestedInput
  }

  export type LandPagesUncheckedUpdateInput = {
    LandPageRowId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JsonData?: NullableStringFieldUpdateOperationsInput | string | null
    ViewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LandPagesCreateManyInput = {
    LandPageRowId?: string
    CompanyID: string
    CreatedAt?: Date | string | null
    JsonData?: string | null
    ViewDate?: Date | string | null
    CompletedDate?: Date | string | null
  }

  export type LandPagesUpdateManyMutationInput = {
    LandPageRowId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JsonData?: NullableStringFieldUpdateOperationsInput | string | null
    ViewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LandPagesUncheckedUpdateManyInput = {
    LandPageRowId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JsonData?: NullableStringFieldUpdateOperationsInput | string | null
    ViewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LanguageDefinitionCreateInput = {
    ObjectName: string
    ControlTypeID: number
    ControlName: string
    CaptionEnglish?: string | null
    CaptionHebrow?: string | null
    CaptionRomanian?: string | null
    CaptionRussian?: string | null
    CaptionChinese?: string | null
    CaptionTurkish?: string | null
  }

  export type LanguageDefinitionUncheckedCreateInput = {
    LanguageDefinitionID?: number
    ObjectName: string
    ControlTypeID: number
    ControlName: string
    CaptionEnglish?: string | null
    CaptionHebrow?: string | null
    CaptionRomanian?: string | null
    CaptionRussian?: string | null
    CaptionChinese?: string | null
    CaptionTurkish?: string | null
  }

  export type LanguageDefinitionUpdateInput = {
    ObjectName?: StringFieldUpdateOperationsInput | string
    ControlTypeID?: IntFieldUpdateOperationsInput | number
    ControlName?: StringFieldUpdateOperationsInput | string
    CaptionEnglish?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionHebrow?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionRomanian?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionRussian?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionChinese?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionTurkish?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LanguageDefinitionUncheckedUpdateInput = {
    LanguageDefinitionID?: IntFieldUpdateOperationsInput | number
    ObjectName?: StringFieldUpdateOperationsInput | string
    ControlTypeID?: IntFieldUpdateOperationsInput | number
    ControlName?: StringFieldUpdateOperationsInput | string
    CaptionEnglish?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionHebrow?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionRomanian?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionRussian?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionChinese?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionTurkish?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LanguageDefinitionCreateManyInput = {
    ObjectName: string
    ControlTypeID: number
    ControlName: string
    CaptionEnglish?: string | null
    CaptionHebrow?: string | null
    CaptionRomanian?: string | null
    CaptionRussian?: string | null
    CaptionChinese?: string | null
    CaptionTurkish?: string | null
  }

  export type LanguageDefinitionUpdateManyMutationInput = {
    ObjectName?: StringFieldUpdateOperationsInput | string
    ControlTypeID?: IntFieldUpdateOperationsInput | number
    ControlName?: StringFieldUpdateOperationsInput | string
    CaptionEnglish?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionHebrow?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionRomanian?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionRussian?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionChinese?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionTurkish?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LanguageDefinitionUncheckedUpdateManyInput = {
    LanguageDefinitionID?: IntFieldUpdateOperationsInput | number
    ObjectName?: StringFieldUpdateOperationsInput | string
    ControlTypeID?: IntFieldUpdateOperationsInput | number
    ControlName?: StringFieldUpdateOperationsInput | string
    CaptionEnglish?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionHebrow?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionRomanian?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionRussian?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionChinese?: NullableStringFieldUpdateOperationsInput | string | null
    CaptionTurkish?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_AreaCreateInput = {
    AreaCode: number
    AreaName: string
    Amount: number
  }

  export type Lkup_AreaUncheckedCreateInput = {
    AreaID?: number
    AreaCode: number
    AreaName: string
    Amount: number
  }

  export type Lkup_AreaUpdateInput = {
    AreaCode?: IntFieldUpdateOperationsInput | number
    AreaName?: StringFieldUpdateOperationsInput | string
    Amount?: FloatFieldUpdateOperationsInput | number
  }

  export type Lkup_AreaUncheckedUpdateInput = {
    AreaID?: IntFieldUpdateOperationsInput | number
    AreaCode?: IntFieldUpdateOperationsInput | number
    AreaName?: StringFieldUpdateOperationsInput | string
    Amount?: FloatFieldUpdateOperationsInput | number
  }

  export type Lkup_AreaCreateManyInput = {
    AreaCode: number
    AreaName: string
    Amount: number
  }

  export type Lkup_AreaUpdateManyMutationInput = {
    AreaCode?: IntFieldUpdateOperationsInput | number
    AreaName?: StringFieldUpdateOperationsInput | string
    Amount?: FloatFieldUpdateOperationsInput | number
  }

  export type Lkup_AreaUncheckedUpdateManyInput = {
    AreaID?: IntFieldUpdateOperationsInput | number
    AreaCode?: IntFieldUpdateOperationsInput | number
    AreaName?: StringFieldUpdateOperationsInput | string
    Amount?: FloatFieldUpdateOperationsInput | number
  }

  export type Lkup_BanksCreateInput = {
    BankName: string
    BankNumber: number
    CountryID?: number | null
  }

  export type Lkup_BanksUncheckedCreateInput = {
    BankID?: number
    BankName: string
    BankNumber: number
    CountryID?: number | null
  }

  export type Lkup_BanksUpdateInput = {
    BankName?: StringFieldUpdateOperationsInput | string
    BankNumber?: IntFieldUpdateOperationsInput | number
    CountryID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Lkup_BanksUncheckedUpdateInput = {
    BankID?: IntFieldUpdateOperationsInput | number
    BankName?: StringFieldUpdateOperationsInput | string
    BankNumber?: IntFieldUpdateOperationsInput | number
    CountryID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Lkup_BanksCreateManyInput = {
    BankName: string
    BankNumber: number
    CountryID?: number | null
  }

  export type Lkup_BanksUpdateManyMutationInput = {
    BankName?: StringFieldUpdateOperationsInput | string
    BankNumber?: IntFieldUpdateOperationsInput | number
    CountryID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Lkup_BanksUncheckedUpdateManyInput = {
    BankID?: IntFieldUpdateOperationsInput | number
    BankName?: StringFieldUpdateOperationsInput | string
    BankNumber?: IntFieldUpdateOperationsInput | number
    CountryID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Lkup_BanksVerBranchCreateInput = {
    BankID?: number | null
    BranchName?: string | null
    BranchCode?: string | null
    Address?: string | null
    SortCode?: string | null
    Phone_1?: string | null
    Phone_2?: string | null
    FaxNumber?: string | null
    EMail?: string | null
    Comment?: string | null
  }

  export type Lkup_BanksVerBranchUncheckedCreateInput = {
    BranchID?: number
    BankID?: number | null
    BranchName?: string | null
    BranchCode?: string | null
    Address?: string | null
    SortCode?: string | null
    Phone_1?: string | null
    Phone_2?: string | null
    FaxNumber?: string | null
    EMail?: string | null
    Comment?: string | null
  }

  export type Lkup_BanksVerBranchUpdateInput = {
    BankID?: NullableIntFieldUpdateOperationsInput | number | null
    BranchName?: NullableStringFieldUpdateOperationsInput | string | null
    BranchCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    SortCode?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    FaxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EMail?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_BanksVerBranchUncheckedUpdateInput = {
    BranchID?: IntFieldUpdateOperationsInput | number
    BankID?: NullableIntFieldUpdateOperationsInput | number | null
    BranchName?: NullableStringFieldUpdateOperationsInput | string | null
    BranchCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    SortCode?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    FaxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EMail?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_BanksVerBranchCreateManyInput = {
    BankID?: number | null
    BranchName?: string | null
    BranchCode?: string | null
    Address?: string | null
    SortCode?: string | null
    Phone_1?: string | null
    Phone_2?: string | null
    FaxNumber?: string | null
    EMail?: string | null
    Comment?: string | null
  }

  export type Lkup_BanksVerBranchUpdateManyMutationInput = {
    BankID?: NullableIntFieldUpdateOperationsInput | number | null
    BranchName?: NullableStringFieldUpdateOperationsInput | string | null
    BranchCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    SortCode?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    FaxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EMail?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_BanksVerBranchUncheckedUpdateManyInput = {
    BranchID?: IntFieldUpdateOperationsInput | number
    BankID?: NullableIntFieldUpdateOperationsInput | number | null
    BranchName?: NullableStringFieldUpdateOperationsInput | string | null
    BranchCode?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    SortCode?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    FaxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EMail?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_CityCreateInput = {
    CityCode: number
    CityName: string
    CityNameEng: string
  }

  export type Lkup_CityUncheckedCreateInput = {
    CityID?: number
    CityCode: number
    CityName: string
    CityNameEng: string
  }

  export type Lkup_CityUpdateInput = {
    CityCode?: IntFieldUpdateOperationsInput | number
    CityName?: StringFieldUpdateOperationsInput | string
    CityNameEng?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_CityUncheckedUpdateInput = {
    CityID?: IntFieldUpdateOperationsInput | number
    CityCode?: IntFieldUpdateOperationsInput | number
    CityName?: StringFieldUpdateOperationsInput | string
    CityNameEng?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_CityCreateManyInput = {
    CityCode: number
    CityName: string
    CityNameEng: string
  }

  export type Lkup_CityUpdateManyMutationInput = {
    CityCode?: IntFieldUpdateOperationsInput | number
    CityName?: StringFieldUpdateOperationsInput | string
    CityNameEng?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_CityUncheckedUpdateManyInput = {
    CityID?: IntFieldUpdateOperationsInput | number
    CityCode?: IntFieldUpdateOperationsInput | number
    CityName?: StringFieldUpdateOperationsInput | string
    CityNameEng?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_CorporationCreateInput = {
    CorporationName: string
    IsActive?: number
    CorporationNumber: number
    Address?: string | null
    Email?: string | null
    Phone?: string | null
    Cfo_email?: string | null
    Contact_name?: string | null
    Contact_phone?: string | null
    Ops_email?: string | null
    SoftTalkTaxToken?: string | null
    CorporationAutoLink?: string | null
  }

  export type Lkup_CorporationUncheckedCreateInput = {
    CorporationID?: number
    CorporationName: string
    IsActive?: number
    CorporationNumber: number
    Address?: string | null
    Email?: string | null
    Phone?: string | null
    Cfo_email?: string | null
    Contact_name?: string | null
    Contact_phone?: string | null
    Ops_email?: string | null
    SoftTalkTaxToken?: string | null
    CorporationAutoLink?: string | null
  }

  export type Lkup_CorporationUpdateInput = {
    CorporationName?: StringFieldUpdateOperationsInput | string
    IsActive?: IntFieldUpdateOperationsInput | number
    CorporationNumber?: IntFieldUpdateOperationsInput | number
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Cfo_email?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    Ops_email?: NullableStringFieldUpdateOperationsInput | string | null
    SoftTalkTaxToken?: NullableStringFieldUpdateOperationsInput | string | null
    CorporationAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_CorporationUncheckedUpdateInput = {
    CorporationID?: IntFieldUpdateOperationsInput | number
    CorporationName?: StringFieldUpdateOperationsInput | string
    IsActive?: IntFieldUpdateOperationsInput | number
    CorporationNumber?: IntFieldUpdateOperationsInput | number
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Cfo_email?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    Ops_email?: NullableStringFieldUpdateOperationsInput | string | null
    SoftTalkTaxToken?: NullableStringFieldUpdateOperationsInput | string | null
    CorporationAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_CorporationCreateManyInput = {
    CorporationName: string
    IsActive?: number
    CorporationNumber: number
    Address?: string | null
    Email?: string | null
    Phone?: string | null
    Cfo_email?: string | null
    Contact_name?: string | null
    Contact_phone?: string | null
    Ops_email?: string | null
    SoftTalkTaxToken?: string | null
    CorporationAutoLink?: string | null
  }

  export type Lkup_CorporationUpdateManyMutationInput = {
    CorporationName?: StringFieldUpdateOperationsInput | string
    IsActive?: IntFieldUpdateOperationsInput | number
    CorporationNumber?: IntFieldUpdateOperationsInput | number
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Cfo_email?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    Ops_email?: NullableStringFieldUpdateOperationsInput | string | null
    SoftTalkTaxToken?: NullableStringFieldUpdateOperationsInput | string | null
    CorporationAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_CorporationUncheckedUpdateManyInput = {
    CorporationID?: IntFieldUpdateOperationsInput | number
    CorporationName?: StringFieldUpdateOperationsInput | string
    IsActive?: IntFieldUpdateOperationsInput | number
    CorporationNumber?: IntFieldUpdateOperationsInput | number
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Cfo_email?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    Ops_email?: NullableStringFieldUpdateOperationsInput | string | null
    SoftTalkTaxToken?: NullableStringFieldUpdateOperationsInput | string | null
    CorporationAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_CountryCreateInput = {
    CountryCode: string
    CountryName: string
    CountryNameEnglish?: string | null
    MultipleSelect?: number
  }

  export type Lkup_CountryUncheckedCreateInput = {
    CountryID?: number
    CountryCode: string
    CountryName: string
    CountryNameEnglish?: string | null
    MultipleSelect?: number
  }

  export type Lkup_CountryUpdateInput = {
    CountryCode?: StringFieldUpdateOperationsInput | string
    CountryName?: StringFieldUpdateOperationsInput | string
    CountryNameEnglish?: NullableStringFieldUpdateOperationsInput | string | null
    MultipleSelect?: IntFieldUpdateOperationsInput | number
  }

  export type Lkup_CountryUncheckedUpdateInput = {
    CountryID?: IntFieldUpdateOperationsInput | number
    CountryCode?: StringFieldUpdateOperationsInput | string
    CountryName?: StringFieldUpdateOperationsInput | string
    CountryNameEnglish?: NullableStringFieldUpdateOperationsInput | string | null
    MultipleSelect?: IntFieldUpdateOperationsInput | number
  }

  export type Lkup_CountryCreateManyInput = {
    CountryCode: string
    CountryName: string
    CountryNameEnglish?: string | null
    MultipleSelect?: number
  }

  export type Lkup_CountryUpdateManyMutationInput = {
    CountryCode?: StringFieldUpdateOperationsInput | string
    CountryName?: StringFieldUpdateOperationsInput | string
    CountryNameEnglish?: NullableStringFieldUpdateOperationsInput | string | null
    MultipleSelect?: IntFieldUpdateOperationsInput | number
  }

  export type Lkup_CountryUncheckedUpdateManyInput = {
    CountryID?: IntFieldUpdateOperationsInput | number
    CountryCode?: StringFieldUpdateOperationsInput | string
    CountryName?: StringFieldUpdateOperationsInput | string
    CountryNameEnglish?: NullableStringFieldUpdateOperationsInput | string | null
    MultipleSelect?: IntFieldUpdateOperationsInput | number
  }

  export type Lkup_CreaditCardCreateInput = {
    CardName: string
    CardCode: number
  }

  export type Lkup_CreaditCardUncheckedCreateInput = {
    CardID?: number
    CardName: string
    CardCode: number
  }

  export type Lkup_CreaditCardUpdateInput = {
    CardName?: StringFieldUpdateOperationsInput | string
    CardCode?: IntFieldUpdateOperationsInput | number
  }

  export type Lkup_CreaditCardUncheckedUpdateInput = {
    CardID?: IntFieldUpdateOperationsInput | number
    CardName?: StringFieldUpdateOperationsInput | string
    CardCode?: IntFieldUpdateOperationsInput | number
  }

  export type Lkup_CreaditCardCreateManyInput = {
    CardName: string
    CardCode: number
  }

  export type Lkup_CreaditCardUpdateManyMutationInput = {
    CardName?: StringFieldUpdateOperationsInput | string
    CardCode?: IntFieldUpdateOperationsInput | number
  }

  export type Lkup_CreaditCardUncheckedUpdateManyInput = {
    CardID?: IntFieldUpdateOperationsInput | number
    CardName?: StringFieldUpdateOperationsInput | string
    CardCode?: IntFieldUpdateOperationsInput | number
  }

  export type Lkup_EmployeesTypeCreateInput = {
    TypeName: string
  }

  export type Lkup_EmployeesTypeUncheckedCreateInput = {
    TypeID?: number
    TypeName: string
  }

  export type Lkup_EmployeesTypeUpdateInput = {
    TypeName?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_EmployeesTypeUncheckedUpdateInput = {
    TypeID?: IntFieldUpdateOperationsInput | number
    TypeName?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_EmployeesTypeCreateManyInput = {
    TypeName: string
  }

  export type Lkup_EmployeesTypeUpdateManyMutationInput = {
    TypeName?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_EmployeesTypeUncheckedUpdateManyInput = {
    TypeID?: IntFieldUpdateOperationsInput | number
    TypeName?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_LanguageCreateInput = {
    LanguageName: string
  }

  export type Lkup_LanguageUncheckedCreateInput = {
    LanguageID?: number
    LanguageName: string
  }

  export type Lkup_LanguageUpdateInput = {
    LanguageName?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_LanguageUncheckedUpdateInput = {
    LanguageID?: IntFieldUpdateOperationsInput | number
    LanguageName?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_LanguageCreateManyInput = {
    LanguageName: string
  }

  export type Lkup_LanguageUpdateManyMutationInput = {
    LanguageName?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_LanguageUncheckedUpdateManyInput = {
    LanguageID?: IntFieldUpdateOperationsInput | number
    LanguageName?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_PaySlipCreateInput = {
    PaySlipName?: string | null
    PaySlipNameSource?: string | null
    IsTytle: boolean
  }

  export type Lkup_PaySlipUncheckedCreateInput = {
    PaySlipCode?: number
    PaySlipName?: string | null
    PaySlipNameSource?: string | null
    IsTytle: boolean
  }

  export type Lkup_PaySlipUpdateInput = {
    PaySlipName?: NullableStringFieldUpdateOperationsInput | string | null
    PaySlipNameSource?: NullableStringFieldUpdateOperationsInput | string | null
    IsTytle?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Lkup_PaySlipUncheckedUpdateInput = {
    PaySlipCode?: IntFieldUpdateOperationsInput | number
    PaySlipName?: NullableStringFieldUpdateOperationsInput | string | null
    PaySlipNameSource?: NullableStringFieldUpdateOperationsInput | string | null
    IsTytle?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Lkup_PaySlipCreateManyInput = {
    PaySlipName?: string | null
    PaySlipNameSource?: string | null
    IsTytle: boolean
  }

  export type Lkup_PaySlipUpdateManyMutationInput = {
    PaySlipName?: NullableStringFieldUpdateOperationsInput | string | null
    PaySlipNameSource?: NullableStringFieldUpdateOperationsInput | string | null
    IsTytle?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Lkup_PaySlipUncheckedUpdateManyInput = {
    PaySlipCode?: IntFieldUpdateOperationsInput | number
    PaySlipName?: NullableStringFieldUpdateOperationsInput | string | null
    PaySlipNameSource?: NullableStringFieldUpdateOperationsInput | string | null
    IsTytle?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Lkup_SectorCreateInput = {
    SectorCode?: number | null
    SectorName?: string | null
  }

  export type Lkup_SectorUncheckedCreateInput = {
    SectorID?: number
    SectorCode?: number | null
    SectorName?: string | null
  }

  export type Lkup_SectorUpdateInput = {
    SectorCode?: NullableIntFieldUpdateOperationsInput | number | null
    SectorName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_SectorUncheckedUpdateInput = {
    SectorID?: IntFieldUpdateOperationsInput | number
    SectorCode?: NullableIntFieldUpdateOperationsInput | number | null
    SectorName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_SectorCreateManyInput = {
    SectorCode?: number | null
    SectorName?: string | null
  }

  export type Lkup_SectorUpdateManyMutationInput = {
    SectorCode?: NullableIntFieldUpdateOperationsInput | number | null
    SectorName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_SectorUncheckedUpdateManyInput = {
    SectorID?: IntFieldUpdateOperationsInput | number
    SectorCode?: NullableIntFieldUpdateOperationsInput | number | null
    SectorName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_SocialSecuritySectorCreateInput = {
    SocialSecurityCode: number
    SocialSecurityName: string
  }

  export type Lkup_SocialSecuritySectorUncheckedCreateInput = {
    SocialSecurityID?: number
    SocialSecurityCode: number
    SocialSecurityName: string
  }

  export type Lkup_SocialSecuritySectorUpdateInput = {
    SocialSecurityCode?: IntFieldUpdateOperationsInput | number
    SocialSecurityName?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_SocialSecuritySectorUncheckedUpdateInput = {
    SocialSecurityID?: IntFieldUpdateOperationsInput | number
    SocialSecurityCode?: IntFieldUpdateOperationsInput | number
    SocialSecurityName?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_SocialSecuritySectorCreateManyInput = {
    SocialSecurityCode: number
    SocialSecurityName: string
  }

  export type Lkup_SocialSecuritySectorUpdateManyMutationInput = {
    SocialSecurityCode?: IntFieldUpdateOperationsInput | number
    SocialSecurityName?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_SocialSecuritySectorUncheckedUpdateManyInput = {
    SocialSecurityID?: IntFieldUpdateOperationsInput | number
    SocialSecurityCode?: IntFieldUpdateOperationsInput | number
    SocialSecurityName?: StringFieldUpdateOperationsInput | string
  }

  export type Lkup_streetCreateInput = {
    StreetName?: string | null
    StreetCode?: number | null
    Citycode?: number | null
    StreetNameEng?: string | null
  }

  export type Lkup_streetUncheckedCreateInput = {
    StrretID?: number
    StreetName?: string | null
    StreetCode?: number | null
    Citycode?: number | null
    StreetNameEng?: string | null
  }

  export type Lkup_streetUpdateInput = {
    StreetName?: NullableStringFieldUpdateOperationsInput | string | null
    StreetCode?: NullableIntFieldUpdateOperationsInput | number | null
    Citycode?: NullableIntFieldUpdateOperationsInput | number | null
    StreetNameEng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_streetUncheckedUpdateInput = {
    StrretID?: IntFieldUpdateOperationsInput | number
    StreetName?: NullableStringFieldUpdateOperationsInput | string | null
    StreetCode?: NullableIntFieldUpdateOperationsInput | number | null
    Citycode?: NullableIntFieldUpdateOperationsInput | number | null
    StreetNameEng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_streetCreateManyInput = {
    StreetName?: string | null
    StreetCode?: number | null
    Citycode?: number | null
    StreetNameEng?: string | null
  }

  export type Lkup_streetUpdateManyMutationInput = {
    StreetName?: NullableStringFieldUpdateOperationsInput | string | null
    StreetCode?: NullableIntFieldUpdateOperationsInput | number | null
    Citycode?: NullableIntFieldUpdateOperationsInput | number | null
    StreetNameEng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_streetUncheckedUpdateManyInput = {
    StrretID?: IntFieldUpdateOperationsInput | number
    StreetName?: NullableStringFieldUpdateOperationsInput | string | null
    StreetCode?: NullableIntFieldUpdateOperationsInput | number | null
    Citycode?: NullableIntFieldUpdateOperationsInput | number | null
    StreetNameEng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PensionDetailCreateInput = {
    TypePension?: number | null
    StartYearPension?: number | null
    EmployerRate?: number | null
    EmployeeRate?: number | null
    EmployerCompensationRate?: number | null
    TotalPensionRate?: number | null
    AvarageSalaryPension?: number | null
    Deposit?: number | null
  }

  export type PensionDetailUncheckedCreateInput = {
    PensionDetailID?: number
    TypePension?: number | null
    StartYearPension?: number | null
    EmployerRate?: number | null
    EmployeeRate?: number | null
    EmployerCompensationRate?: number | null
    TotalPensionRate?: number | null
    AvarageSalaryPension?: number | null
    Deposit?: number | null
  }

  export type PensionDetailUpdateInput = {
    TypePension?: NullableIntFieldUpdateOperationsInput | number | null
    StartYearPension?: NullableIntFieldUpdateOperationsInput | number | null
    EmployerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployerCompensationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalPensionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    AvarageSalaryPension?: NullableFloatFieldUpdateOperationsInput | number | null
    Deposit?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PensionDetailUncheckedUpdateInput = {
    PensionDetailID?: IntFieldUpdateOperationsInput | number
    TypePension?: NullableIntFieldUpdateOperationsInput | number | null
    StartYearPension?: NullableIntFieldUpdateOperationsInput | number | null
    EmployerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployerCompensationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalPensionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    AvarageSalaryPension?: NullableFloatFieldUpdateOperationsInput | number | null
    Deposit?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PensionDetailCreateManyInput = {
    TypePension?: number | null
    StartYearPension?: number | null
    EmployerRate?: number | null
    EmployeeRate?: number | null
    EmployerCompensationRate?: number | null
    TotalPensionRate?: number | null
    AvarageSalaryPension?: number | null
    Deposit?: number | null
  }

  export type PensionDetailUpdateManyMutationInput = {
    TypePension?: NullableIntFieldUpdateOperationsInput | number | null
    StartYearPension?: NullableIntFieldUpdateOperationsInput | number | null
    EmployerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployerCompensationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalPensionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    AvarageSalaryPension?: NullableFloatFieldUpdateOperationsInput | number | null
    Deposit?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PensionDetailUncheckedUpdateManyInput = {
    PensionDetailID?: IntFieldUpdateOperationsInput | number
    TypePension?: NullableIntFieldUpdateOperationsInput | number | null
    StartYearPension?: NullableIntFieldUpdateOperationsInput | number | null
    EmployerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployerCompensationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalPensionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    AvarageSalaryPension?: NullableFloatFieldUpdateOperationsInput | number | null
    Deposit?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProductsCreateInput = {
    ProductsId?: string
    ProductName: string
    ProductDescription?: string | null
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutProductsInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutProductsInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateInput = {
    ProductsId?: string
    ProductName: string
    ProductDescription?: string | null
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutProductsInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutProductsInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsUpdateInput = {
    ProductsId?: StringFieldUpdateOperationsInput | string
    ProductName?: StringFieldUpdateOperationsInput | string
    ProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutProductsNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutProductsNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateInput = {
    ProductsId?: StringFieldUpdateOperationsInput | string
    ProductName?: StringFieldUpdateOperationsInput | string
    ProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutProductsNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutProductsNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsCreateManyInput = {
    ProductsId?: string
    ProductName: string
    ProductDescription?: string | null
  }

  export type ProductsUpdateManyMutationInput = {
    ProductsId?: StringFieldUpdateOperationsInput | string
    ProductName?: StringFieldUpdateOperationsInput | string
    ProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductsUncheckedUpdateManyInput = {
    ProductsId?: StringFieldUpdateOperationsInput | string
    ProductName?: StringFieldUpdateOperationsInput | string
    ProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RankCreateInput = {
    SectorCode?: number | null
    RankYear?: number | null
    RankMonth?: number | null
    RankCode?: number | null
    RankName?: string | null
    Salary?: number | null
    RankNumber?: number | null
  }

  export type RankUncheckedCreateInput = {
    RankID?: number
    SectorCode?: number | null
    RankYear?: number | null
    RankMonth?: number | null
    RankCode?: number | null
    RankName?: string | null
    Salary?: number | null
    RankNumber?: number | null
  }

  export type RankUpdateInput = {
    SectorCode?: NullableIntFieldUpdateOperationsInput | number | null
    RankYear?: NullableIntFieldUpdateOperationsInput | number | null
    RankMonth?: NullableIntFieldUpdateOperationsInput | number | null
    RankCode?: NullableIntFieldUpdateOperationsInput | number | null
    RankName?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableFloatFieldUpdateOperationsInput | number | null
    RankNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankUncheckedUpdateInput = {
    RankID?: IntFieldUpdateOperationsInput | number
    SectorCode?: NullableIntFieldUpdateOperationsInput | number | null
    RankYear?: NullableIntFieldUpdateOperationsInput | number | null
    RankMonth?: NullableIntFieldUpdateOperationsInput | number | null
    RankCode?: NullableIntFieldUpdateOperationsInput | number | null
    RankName?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableFloatFieldUpdateOperationsInput | number | null
    RankNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankCreateManyInput = {
    SectorCode?: number | null
    RankYear?: number | null
    RankMonth?: number | null
    RankCode?: number | null
    RankName?: string | null
    Salary?: number | null
    RankNumber?: number | null
  }

  export type RankUpdateManyMutationInput = {
    SectorCode?: NullableIntFieldUpdateOperationsInput | number | null
    RankYear?: NullableIntFieldUpdateOperationsInput | number | null
    RankMonth?: NullableIntFieldUpdateOperationsInput | number | null
    RankCode?: NullableIntFieldUpdateOperationsInput | number | null
    RankName?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableFloatFieldUpdateOperationsInput | number | null
    RankNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankUncheckedUpdateManyInput = {
    RankID?: IntFieldUpdateOperationsInput | number
    SectorCode?: NullableIntFieldUpdateOperationsInput | number | null
    RankYear?: NullableIntFieldUpdateOperationsInput | number | null
    RankMonth?: NullableIntFieldUpdateOperationsInput | number | null
    RankCode?: NullableIntFieldUpdateOperationsInput | number | null
    RankName?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableFloatFieldUpdateOperationsInput | number | null
    RankNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecoveryDefinitionCreateInput = {
    RecoveryDefinitionName?: string | null
    RecoveryYear?: string | null
    RecoveryDefinitionDetails?: RecoveryDefinitionDetailsCreateNestedManyWithoutRecoveryDefinitionInput
    RecoveryDefinitionRateDetails?: RecoveryDefinitionRateDetailsCreateNestedManyWithoutRecoveryDefinitionInput
  }

  export type RecoveryDefinitionUncheckedCreateInput = {
    RecoveryDefinitionID?: number
    RecoveryDefinitionName?: string | null
    RecoveryYear?: string | null
    RecoveryDefinitionDetails?: RecoveryDefinitionDetailsUncheckedCreateNestedManyWithoutRecoveryDefinitionInput
    RecoveryDefinitionRateDetails?: RecoveryDefinitionRateDetailsUncheckedCreateNestedManyWithoutRecoveryDefinitionInput
  }

  export type RecoveryDefinitionUpdateInput = {
    RecoveryDefinitionName?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryYear?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryDefinitionDetails?: RecoveryDefinitionDetailsUpdateManyWithoutRecoveryDefinitionNestedInput
    RecoveryDefinitionRateDetails?: RecoveryDefinitionRateDetailsUpdateManyWithoutRecoveryDefinitionNestedInput
  }

  export type RecoveryDefinitionUncheckedUpdateInput = {
    RecoveryDefinitionID?: IntFieldUpdateOperationsInput | number
    RecoveryDefinitionName?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryYear?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryDefinitionDetails?: RecoveryDefinitionDetailsUncheckedUpdateManyWithoutRecoveryDefinitionNestedInput
    RecoveryDefinitionRateDetails?: RecoveryDefinitionRateDetailsUncheckedUpdateManyWithoutRecoveryDefinitionNestedInput
  }

  export type RecoveryDefinitionCreateManyInput = {
    RecoveryDefinitionName?: string | null
    RecoveryYear?: string | null
  }

  export type RecoveryDefinitionUpdateManyMutationInput = {
    RecoveryDefinitionName?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryYear?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecoveryDefinitionUncheckedUpdateManyInput = {
    RecoveryDefinitionID?: IntFieldUpdateOperationsInput | number
    RecoveryDefinitionName?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryYear?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecoveryDefinitionDetailsCreateInput = {
    StartYearRewardRecovery?: number | null
    EndYearRewardRecovery?: number | null
    RecoveryDayQuantity?: number | null
    RecoveryYearDescription?: string | null
    RecoveryDefinition?: RecoveryDefinitionCreateNestedOneWithoutRecoveryDefinitionDetailsInput
  }

  export type RecoveryDefinitionDetailsUncheckedCreateInput = {
    RewardRecoveryVectorID?: number
    RecoveryDefinitionID?: number | null
    StartYearRewardRecovery?: number | null
    EndYearRewardRecovery?: number | null
    RecoveryDayQuantity?: number | null
    RecoveryYearDescription?: string | null
  }

  export type RecoveryDefinitionDetailsUpdateInput = {
    StartYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    RecoveryDayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    RecoveryYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryDefinition?: RecoveryDefinitionUpdateOneWithoutRecoveryDefinitionDetailsNestedInput
  }

  export type RecoveryDefinitionDetailsUncheckedUpdateInput = {
    RewardRecoveryVectorID?: IntFieldUpdateOperationsInput | number
    RecoveryDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    StartYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    RecoveryDayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    RecoveryYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecoveryDefinitionDetailsCreateManyInput = {
    RecoveryDefinitionID?: number | null
    StartYearRewardRecovery?: number | null
    EndYearRewardRecovery?: number | null
    RecoveryDayQuantity?: number | null
    RecoveryYearDescription?: string | null
  }

  export type RecoveryDefinitionDetailsUpdateManyMutationInput = {
    StartYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    RecoveryDayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    RecoveryYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecoveryDefinitionDetailsUncheckedUpdateManyInput = {
    RewardRecoveryVectorID?: IntFieldUpdateOperationsInput | number
    RecoveryDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    StartYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    RecoveryDayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    RecoveryYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecoveryDefinitionRateDetailsCreateInput = {
    RecoveryRewardID: number
    RewardYearMonth?: Date | string | null
    RecoveryRewardRatePerDay?: number | null
    RecoveryDefinition?: RecoveryDefinitionCreateNestedOneWithoutRecoveryDefinitionRateDetailsInput
  }

  export type RecoveryDefinitionRateDetailsUncheckedCreateInput = {
    RecoveryRewardID: number
    RecoveryDefinitionID?: number | null
    RewardYearMonth?: Date | string | null
    RecoveryRewardRatePerDay?: number | null
  }

  export type RecoveryDefinitionRateDetailsUpdateInput = {
    RecoveryRewardID?: IntFieldUpdateOperationsInput | number
    RewardYearMonth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RecoveryRewardRatePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    RecoveryDefinition?: RecoveryDefinitionUpdateOneWithoutRecoveryDefinitionRateDetailsNestedInput
  }

  export type RecoveryDefinitionRateDetailsUncheckedUpdateInput = {
    RecoveryRewardID?: IntFieldUpdateOperationsInput | number
    RecoveryDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    RewardYearMonth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RecoveryRewardRatePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RecoveryDefinitionRateDetailsCreateManyInput = {
    RecoveryRewardID: number
    RecoveryDefinitionID?: number | null
    RewardYearMonth?: Date | string | null
    RecoveryRewardRatePerDay?: number | null
  }

  export type RecoveryDefinitionRateDetailsUpdateManyMutationInput = {
    RecoveryRewardID?: IntFieldUpdateOperationsInput | number
    RewardYearMonth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RecoveryRewardRatePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RecoveryDefinitionRateDetailsUncheckedUpdateManyInput = {
    RecoveryRewardID?: IntFieldUpdateOperationsInput | number
    RecoveryDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    RewardYearMonth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RecoveryRewardRatePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ReportDefinitionsCreateInput = {
    ReportName?: string | null
    OrderBy?: number | null
    FieldName?: string | null
    Caption?: string | null
    Color?: number | null
    Background?: number | null
    ColumnWidth?: number | null
    FontStyle?: string | null
    FontSize?: number | null
    ReportTitle?: string | null
    IsSum: boolean
    ColorIndex?: number | null
  }

  export type ReportDefinitionsUncheckedCreateInput = {
    ReportID?: number
    ReportName?: string | null
    OrderBy?: number | null
    FieldName?: string | null
    Caption?: string | null
    Color?: number | null
    Background?: number | null
    ColumnWidth?: number | null
    FontStyle?: string | null
    FontSize?: number | null
    ReportTitle?: string | null
    IsSum: boolean
    ColorIndex?: number | null
  }

  export type ReportDefinitionsUpdateInput = {
    ReportName?: NullableStringFieldUpdateOperationsInput | string | null
    OrderBy?: NullableIntFieldUpdateOperationsInput | number | null
    FieldName?: NullableStringFieldUpdateOperationsInput | string | null
    Caption?: NullableStringFieldUpdateOperationsInput | string | null
    Color?: NullableIntFieldUpdateOperationsInput | number | null
    Background?: NullableIntFieldUpdateOperationsInput | number | null
    ColumnWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    FontStyle?: NullableStringFieldUpdateOperationsInput | string | null
    FontSize?: NullableIntFieldUpdateOperationsInput | number | null
    ReportTitle?: NullableStringFieldUpdateOperationsInput | string | null
    IsSum?: BoolFieldUpdateOperationsInput | boolean
    ColorIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportDefinitionsUncheckedUpdateInput = {
    ReportID?: IntFieldUpdateOperationsInput | number
    ReportName?: NullableStringFieldUpdateOperationsInput | string | null
    OrderBy?: NullableIntFieldUpdateOperationsInput | number | null
    FieldName?: NullableStringFieldUpdateOperationsInput | string | null
    Caption?: NullableStringFieldUpdateOperationsInput | string | null
    Color?: NullableIntFieldUpdateOperationsInput | number | null
    Background?: NullableIntFieldUpdateOperationsInput | number | null
    ColumnWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    FontStyle?: NullableStringFieldUpdateOperationsInput | string | null
    FontSize?: NullableIntFieldUpdateOperationsInput | number | null
    ReportTitle?: NullableStringFieldUpdateOperationsInput | string | null
    IsSum?: BoolFieldUpdateOperationsInput | boolean
    ColorIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportDefinitionsCreateManyInput = {
    ReportName?: string | null
    OrderBy?: number | null
    FieldName?: string | null
    Caption?: string | null
    Color?: number | null
    Background?: number | null
    ColumnWidth?: number | null
    FontStyle?: string | null
    FontSize?: number | null
    ReportTitle?: string | null
    IsSum: boolean
    ColorIndex?: number | null
  }

  export type ReportDefinitionsUpdateManyMutationInput = {
    ReportName?: NullableStringFieldUpdateOperationsInput | string | null
    OrderBy?: NullableIntFieldUpdateOperationsInput | number | null
    FieldName?: NullableStringFieldUpdateOperationsInput | string | null
    Caption?: NullableStringFieldUpdateOperationsInput | string | null
    Color?: NullableIntFieldUpdateOperationsInput | number | null
    Background?: NullableIntFieldUpdateOperationsInput | number | null
    ColumnWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    FontStyle?: NullableStringFieldUpdateOperationsInput | string | null
    FontSize?: NullableIntFieldUpdateOperationsInput | number | null
    ReportTitle?: NullableStringFieldUpdateOperationsInput | string | null
    IsSum?: BoolFieldUpdateOperationsInput | boolean
    ColorIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportDefinitionsUncheckedUpdateManyInput = {
    ReportID?: IntFieldUpdateOperationsInput | number
    ReportName?: NullableStringFieldUpdateOperationsInput | string | null
    OrderBy?: NullableIntFieldUpdateOperationsInput | number | null
    FieldName?: NullableStringFieldUpdateOperationsInput | string | null
    Caption?: NullableStringFieldUpdateOperationsInput | string | null
    Color?: NullableIntFieldUpdateOperationsInput | number | null
    Background?: NullableIntFieldUpdateOperationsInput | number | null
    ColumnWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    FontStyle?: NullableStringFieldUpdateOperationsInput | string | null
    FontSize?: NullableIntFieldUpdateOperationsInput | number | null
    ReportTitle?: NullableStringFieldUpdateOperationsInput | string | null
    IsSum?: BoolFieldUpdateOperationsInput | boolean
    ColorIndex?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RewardRecoveryRateCreateInput = {
    RewardYear?: number | null
    RecoveryRewardRatePerDay?: number | null
  }

  export type RewardRecoveryRateUncheckedCreateInput = {
    RecoveryRewardID?: number
    RewardYear?: number | null
    RecoveryRewardRatePerDay?: number | null
  }

  export type RewardRecoveryRateUpdateInput = {
    RewardYear?: NullableIntFieldUpdateOperationsInput | number | null
    RecoveryRewardRatePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RewardRecoveryRateUncheckedUpdateInput = {
    RecoveryRewardID?: IntFieldUpdateOperationsInput | number
    RewardYear?: NullableIntFieldUpdateOperationsInput | number | null
    RecoveryRewardRatePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RewardRecoveryRateCreateManyInput = {
    RewardYear?: number | null
    RecoveryRewardRatePerDay?: number | null
  }

  export type RewardRecoveryRateUpdateManyMutationInput = {
    RewardYear?: NullableIntFieldUpdateOperationsInput | number | null
    RecoveryRewardRatePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RewardRecoveryRateUncheckedUpdateManyInput = {
    RecoveryRewardID?: IntFieldUpdateOperationsInput | number
    RewardYear?: NullableIntFieldUpdateOperationsInput | number | null
    RecoveryRewardRatePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RewardRecoveryVectorCreateInput = {
    StartYearRewardRecovery?: number | null
    EndYearRewardRecovery?: number | null
    RecoveryDayQuantity?: number | null
  }

  export type RewardRecoveryVectorUncheckedCreateInput = {
    RewardRecoveryVectorID?: number
    StartYearRewardRecovery?: number | null
    EndYearRewardRecovery?: number | null
    RecoveryDayQuantity?: number | null
  }

  export type RewardRecoveryVectorUpdateInput = {
    StartYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    RecoveryDayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RewardRecoveryVectorUncheckedUpdateInput = {
    RewardRecoveryVectorID?: IntFieldUpdateOperationsInput | number
    StartYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    RecoveryDayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RewardRecoveryVectorCreateManyInput = {
    StartYearRewardRecovery?: number | null
    EndYearRewardRecovery?: number | null
    RecoveryDayQuantity?: number | null
  }

  export type RewardRecoveryVectorUpdateManyMutationInput = {
    StartYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    RecoveryDayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RewardRecoveryVectorUncheckedUpdateManyInput = {
    RewardRecoveryVectorID?: IntFieldUpdateOperationsInput | number
    StartYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    RecoveryDayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RewardSickVectorCreateInput = {
    RewardSickVectorID: number
    StartYearRewardSick?: number | null
    EndYearRewardSick?: number | null
    SickDayQuantity?: number | null
  }

  export type RewardSickVectorUncheckedCreateInput = {
    RewardSickVectorID: number
    StartYearRewardSick?: number | null
    EndYearRewardSick?: number | null
    SickDayQuantity?: number | null
  }

  export type RewardSickVectorUpdateInput = {
    RewardSickVectorID?: IntFieldUpdateOperationsInput | number
    StartYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    EndYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    SickDayQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RewardSickVectorUncheckedUpdateInput = {
    RewardSickVectorID?: IntFieldUpdateOperationsInput | number
    StartYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    EndYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    SickDayQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RewardSickVectorCreateManyInput = {
    RewardSickVectorID: number
    StartYearRewardSick?: number | null
    EndYearRewardSick?: number | null
    SickDayQuantity?: number | null
  }

  export type RewardSickVectorUpdateManyMutationInput = {
    RewardSickVectorID?: IntFieldUpdateOperationsInput | number
    StartYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    EndYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    SickDayQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RewardSickVectorUncheckedUpdateManyInput = {
    RewardSickVectorID?: IntFieldUpdateOperationsInput | number
    StartYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    EndYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    SickDayQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RewardVacationVectorCreateInput = {
    StartYearRewardVocation?: number | null
    EndYearRewardVocation?: number | null
    VocationDayQuantity6days?: number | null
    VocationDayQuantity5days?: number | null
  }

  export type RewardVacationVectorUncheckedCreateInput = {
    RewardVocationVectorID?: number
    StartYearRewardVocation?: number | null
    EndYearRewardVocation?: number | null
    VocationDayQuantity6days?: number | null
    VocationDayQuantity5days?: number | null
  }

  export type RewardVacationVectorUpdateInput = {
    StartYearRewardVocation?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardVocation?: NullableFloatFieldUpdateOperationsInput | number | null
    VocationDayQuantity6days?: NullableIntFieldUpdateOperationsInput | number | null
    VocationDayQuantity5days?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RewardVacationVectorUncheckedUpdateInput = {
    RewardVocationVectorID?: IntFieldUpdateOperationsInput | number
    StartYearRewardVocation?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardVocation?: NullableFloatFieldUpdateOperationsInput | number | null
    VocationDayQuantity6days?: NullableIntFieldUpdateOperationsInput | number | null
    VocationDayQuantity5days?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RewardVacationVectorCreateManyInput = {
    StartYearRewardVocation?: number | null
    EndYearRewardVocation?: number | null
    VocationDayQuantity6days?: number | null
    VocationDayQuantity5days?: number | null
  }

  export type RewardVacationVectorUpdateManyMutationInput = {
    StartYearRewardVocation?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardVocation?: NullableFloatFieldUpdateOperationsInput | number | null
    VocationDayQuantity6days?: NullableIntFieldUpdateOperationsInput | number | null
    VocationDayQuantity5days?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RewardVacationVectorUncheckedUpdateManyInput = {
    RewardVocationVectorID?: IntFieldUpdateOperationsInput | number
    StartYearRewardVocation?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardVocation?: NullableFloatFieldUpdateOperationsInput | number | null
    VocationDayQuantity6days?: NullableIntFieldUpdateOperationsInput | number | null
    VocationDayQuantity5days?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SickDefinitionCreateInput = {
    SickDefinitionID: number
    SickDescription?: string | null
    SickDefinitionDetail?: SickDefinitionDetailCreateNestedManyWithoutSickDefinitionInput
  }

  export type SickDefinitionUncheckedCreateInput = {
    SickDefinitionID: number
    SickDescription?: string | null
    SickDefinitionDetail?: SickDefinitionDetailUncheckedCreateNestedManyWithoutSickDefinitionInput
  }

  export type SickDefinitionUpdateInput = {
    SickDefinitionID?: IntFieldUpdateOperationsInput | number
    SickDescription?: NullableStringFieldUpdateOperationsInput | string | null
    SickDefinitionDetail?: SickDefinitionDetailUpdateManyWithoutSickDefinitionNestedInput
  }

  export type SickDefinitionUncheckedUpdateInput = {
    SickDefinitionID?: IntFieldUpdateOperationsInput | number
    SickDescription?: NullableStringFieldUpdateOperationsInput | string | null
    SickDefinitionDetail?: SickDefinitionDetailUncheckedUpdateManyWithoutSickDefinitionNestedInput
  }

  export type SickDefinitionCreateManyInput = {
    SickDefinitionID: number
    SickDescription?: string | null
  }

  export type SickDefinitionUpdateManyMutationInput = {
    SickDefinitionID?: IntFieldUpdateOperationsInput | number
    SickDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SickDefinitionUncheckedUpdateManyInput = {
    SickDefinitionID?: IntFieldUpdateOperationsInput | number
    SickDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SickDefinitionDetailCreateInput = {
    StartYearRewardSick?: number | null
    EndYearRewardSick?: number | null
    SickDayQuantity?: number | null
    SocialYearDescription?: string | null
    SickDefinition: SickDefinitionCreateNestedOneWithoutSickDefinitionDetailInput
  }

  export type SickDefinitionDetailUncheckedCreateInput = {
    RewardSickVectorID?: number
    SickDefinitionID: number
    StartYearRewardSick?: number | null
    EndYearRewardSick?: number | null
    SickDayQuantity?: number | null
    SocialYearDescription?: string | null
  }

  export type SickDefinitionDetailUpdateInput = {
    StartYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    EndYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    SickDayQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
    SickDefinition?: SickDefinitionUpdateOneRequiredWithoutSickDefinitionDetailNestedInput
  }

  export type SickDefinitionDetailUncheckedUpdateInput = {
    RewardSickVectorID?: IntFieldUpdateOperationsInput | number
    SickDefinitionID?: IntFieldUpdateOperationsInput | number
    StartYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    EndYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    SickDayQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SickDefinitionDetailCreateManyInput = {
    SickDefinitionID: number
    StartYearRewardSick?: number | null
    EndYearRewardSick?: number | null
    SickDayQuantity?: number | null
    SocialYearDescription?: string | null
  }

  export type SickDefinitionDetailUpdateManyMutationInput = {
    StartYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    EndYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    SickDayQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SickDefinitionDetailUncheckedUpdateManyInput = {
    RewardSickVectorID?: IntFieldUpdateOperationsInput | number
    SickDefinitionID?: IntFieldUpdateOperationsInput | number
    StartYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    EndYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    SickDayQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialSecurityCreateInput = {
    SocialSecurityID: number
    SocialSecurityYear: number
    SocialSecurityMonth: number
    CurrentSocialSecurity: boolean
    MinAccountTotalForDivuach?: number | null
    SocialSecurityDetile?: SocialSecurityDetileCreateNestedManyWithoutSocialSecurityInput
  }

  export type SocialSecurityUncheckedCreateInput = {
    SocialSecurityID: number
    SocialSecurityYear: number
    SocialSecurityMonth: number
    CurrentSocialSecurity: boolean
    MinAccountTotalForDivuach?: number | null
    SocialSecurityDetile?: SocialSecurityDetileUncheckedCreateNestedManyWithoutSocialSecurityInput
  }

  export type SocialSecurityUpdateInput = {
    SocialSecurityID?: IntFieldUpdateOperationsInput | number
    SocialSecurityYear?: IntFieldUpdateOperationsInput | number
    SocialSecurityMonth?: IntFieldUpdateOperationsInput | number
    CurrentSocialSecurity?: BoolFieldUpdateOperationsInput | boolean
    MinAccountTotalForDivuach?: NullableIntFieldUpdateOperationsInput | number | null
    SocialSecurityDetile?: SocialSecurityDetileUpdateManyWithoutSocialSecurityNestedInput
  }

  export type SocialSecurityUncheckedUpdateInput = {
    SocialSecurityID?: IntFieldUpdateOperationsInput | number
    SocialSecurityYear?: IntFieldUpdateOperationsInput | number
    SocialSecurityMonth?: IntFieldUpdateOperationsInput | number
    CurrentSocialSecurity?: BoolFieldUpdateOperationsInput | boolean
    MinAccountTotalForDivuach?: NullableIntFieldUpdateOperationsInput | number | null
    SocialSecurityDetile?: SocialSecurityDetileUncheckedUpdateManyWithoutSocialSecurityNestedInput
  }

  export type SocialSecurityCreateManyInput = {
    SocialSecurityID: number
    SocialSecurityYear: number
    SocialSecurityMonth: number
    CurrentSocialSecurity: boolean
    MinAccountTotalForDivuach?: number | null
  }

  export type SocialSecurityUpdateManyMutationInput = {
    SocialSecurityID?: IntFieldUpdateOperationsInput | number
    SocialSecurityYear?: IntFieldUpdateOperationsInput | number
    SocialSecurityMonth?: IntFieldUpdateOperationsInput | number
    CurrentSocialSecurity?: BoolFieldUpdateOperationsInput | boolean
    MinAccountTotalForDivuach?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SocialSecurityUncheckedUpdateManyInput = {
    SocialSecurityID?: IntFieldUpdateOperationsInput | number
    SocialSecurityYear?: IntFieldUpdateOperationsInput | number
    SocialSecurityMonth?: IntFieldUpdateOperationsInput | number
    CurrentSocialSecurity?: BoolFieldUpdateOperationsInput | boolean
    MinAccountTotalForDivuach?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SocialSecurityDetileCreateInput = {
    SocialYear: number
    SocialMonth: number
    Sector: number
    SocialSecurityCode: number
    AverageSalary?: number | null
    MinNationalInsByMony?: number | null
    MaxNationalInsByMony?: number | null
    MinDeductionNationalInsByMony?: number | null
    MinNationalInsByEmployee?: number | null
    MaxNationalInsByEmployee?: number | null
    MinNationalInsByEmployer?: number | null
    MaxNationalInsByEmployer?: number | null
    MaxNationalInsByMonyEmployee?: number | null
    AverageEmbodiment?: number | null
    DeductionMax?: number | null
    DeductionPercent?: number | null
    CreditPoint?: number | null
    FactorToReduction?: number | null
    MinHoursToPay?: number | null
    MinimumPayFor5Day?: number | null
    MinimumPayFor6Day?: number | null
    MaxPrecentReduction?: number | null
    hourPerDayfor5?: number | null
    hourPerDayfor6?: number | null
    hourInfridayDay?: number | null
    TaxPrecent?: number | null
    EmployerTax?: number | null
    DiscountInTaxInEilat?: number | null
    TaxUnitNumber?: number | null
    FundPercentConstruction?: number | null
    Hour100?: number | null
    Hour125?: number | null
    Hour150?: number | null
    Hour175?: number | null
    Hour200?: number | null
    CreditCardMan?: number | null
    CreditCardWoman?: number | null
    CreditCardChild?: number | null
    CreditCardBaby?: number | null
    CreditCardInAddition?: number | null
    CreditCardLackMobilityChild?: number | null
    CreditCardImmigrant18?: number | null
    ControlingShareholder: boolean
    HealthInsuranceEmployeeLow?: number | null
    HealthInsuranceEmployeeAbove?: number | null
    HealthInsuranceEmployerLow?: number | null
    HealthInsuranceEmployerAbove?: number | null
    ValueOfVehicleUseHibberdDiscount?: number | null
    Deposit?: number | null
    ValueOfMobileUse?: number | null
    PensionCeiling?: number | null
    PensionCredit?: number | null
    DepositEmployerPrecent?: number | null
    DepositEmployeePrecent?: number | null
    TotalHourPerWeek?: number | null
    CreditCardAdultChild?: number | null
    CreditCardChild1_5?: number | null
    DepositEmployeePrecentExecption?: number | null
    SocialSecurity: SocialSecurityCreateNestedOneWithoutSocialSecurityDetileInput
  }

  export type SocialSecurityDetileUncheckedCreateInput = {
    SocialSecurityDetailID?: number
    SocialSecurityID: number
    SocialYear: number
    SocialMonth: number
    Sector: number
    SocialSecurityCode: number
    AverageSalary?: number | null
    MinNationalInsByMony?: number | null
    MaxNationalInsByMony?: number | null
    MinDeductionNationalInsByMony?: number | null
    MinNationalInsByEmployee?: number | null
    MaxNationalInsByEmployee?: number | null
    MinNationalInsByEmployer?: number | null
    MaxNationalInsByEmployer?: number | null
    MaxNationalInsByMonyEmployee?: number | null
    AverageEmbodiment?: number | null
    DeductionMax?: number | null
    DeductionPercent?: number | null
    CreditPoint?: number | null
    FactorToReduction?: number | null
    MinHoursToPay?: number | null
    MinimumPayFor5Day?: number | null
    MinimumPayFor6Day?: number | null
    MaxPrecentReduction?: number | null
    hourPerDayfor5?: number | null
    hourPerDayfor6?: number | null
    hourInfridayDay?: number | null
    TaxPrecent?: number | null
    EmployerTax?: number | null
    DiscountInTaxInEilat?: number | null
    TaxUnitNumber?: number | null
    FundPercentConstruction?: number | null
    Hour100?: number | null
    Hour125?: number | null
    Hour150?: number | null
    Hour175?: number | null
    Hour200?: number | null
    CreditCardMan?: number | null
    CreditCardWoman?: number | null
    CreditCardChild?: number | null
    CreditCardBaby?: number | null
    CreditCardInAddition?: number | null
    CreditCardLackMobilityChild?: number | null
    CreditCardImmigrant18?: number | null
    ControlingShareholder: boolean
    HealthInsuranceEmployeeLow?: number | null
    HealthInsuranceEmployeeAbove?: number | null
    HealthInsuranceEmployerLow?: number | null
    HealthInsuranceEmployerAbove?: number | null
    ValueOfVehicleUseHibberdDiscount?: number | null
    Deposit?: number | null
    ValueOfMobileUse?: number | null
    PensionCeiling?: number | null
    PensionCredit?: number | null
    DepositEmployerPrecent?: number | null
    DepositEmployeePrecent?: number | null
    TotalHourPerWeek?: number | null
    CreditCardAdultChild?: number | null
    CreditCardChild1_5?: number | null
    DepositEmployeePrecentExecption?: number | null
  }

  export type SocialSecurityDetileUpdateInput = {
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    Sector?: IntFieldUpdateOperationsInput | number
    SocialSecurityCode?: IntFieldUpdateOperationsInput | number
    AverageSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinDeductionNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMonyEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    AverageEmbodiment?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionMax?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditPoint?: NullableFloatFieldUpdateOperationsInput | number | null
    FactorToReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    MinHoursToPay?: NullableIntFieldUpdateOperationsInput | number | null
    MinimumPayFor5Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MinimumPayFor6Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxPrecentReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor5?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor6?: NullableIntFieldUpdateOperationsInput | number | null
    hourInfridayDay?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployerTax?: NullableFloatFieldUpdateOperationsInput | number | null
    DiscountInTaxInEilat?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxUnitNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    FundPercentConstruction?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour100?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour125?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour150?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour175?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour200?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardMan?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardWoman?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardBaby?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardInAddition?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardLackMobilityChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardImmigrant18?: NullableFloatFieldUpdateOperationsInput | number | null
    ControlingShareholder?: BoolFieldUpdateOperationsInput | boolean
    HealthInsuranceEmployeeLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployeeAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfVehicleUseHibberdDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    Deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfMobileUse?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCeiling?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCredit?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployerPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalHourPerWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardAdultChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild1_5?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecentExecption?: NullableFloatFieldUpdateOperationsInput | number | null
    SocialSecurity?: SocialSecurityUpdateOneRequiredWithoutSocialSecurityDetileNestedInput
  }

  export type SocialSecurityDetileUncheckedUpdateInput = {
    SocialSecurityDetailID?: IntFieldUpdateOperationsInput | number
    SocialSecurityID?: IntFieldUpdateOperationsInput | number
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    Sector?: IntFieldUpdateOperationsInput | number
    SocialSecurityCode?: IntFieldUpdateOperationsInput | number
    AverageSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinDeductionNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMonyEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    AverageEmbodiment?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionMax?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditPoint?: NullableFloatFieldUpdateOperationsInput | number | null
    FactorToReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    MinHoursToPay?: NullableIntFieldUpdateOperationsInput | number | null
    MinimumPayFor5Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MinimumPayFor6Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxPrecentReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor5?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor6?: NullableIntFieldUpdateOperationsInput | number | null
    hourInfridayDay?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployerTax?: NullableFloatFieldUpdateOperationsInput | number | null
    DiscountInTaxInEilat?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxUnitNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    FundPercentConstruction?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour100?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour125?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour150?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour175?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour200?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardMan?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardWoman?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardBaby?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardInAddition?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardLackMobilityChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardImmigrant18?: NullableFloatFieldUpdateOperationsInput | number | null
    ControlingShareholder?: BoolFieldUpdateOperationsInput | boolean
    HealthInsuranceEmployeeLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployeeAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfVehicleUseHibberdDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    Deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfMobileUse?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCeiling?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCredit?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployerPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalHourPerWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardAdultChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild1_5?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecentExecption?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SocialSecurityDetileCreateManyInput = {
    SocialSecurityID: number
    SocialYear: number
    SocialMonth: number
    Sector: number
    SocialSecurityCode: number
    AverageSalary?: number | null
    MinNationalInsByMony?: number | null
    MaxNationalInsByMony?: number | null
    MinDeductionNationalInsByMony?: number | null
    MinNationalInsByEmployee?: number | null
    MaxNationalInsByEmployee?: number | null
    MinNationalInsByEmployer?: number | null
    MaxNationalInsByEmployer?: number | null
    MaxNationalInsByMonyEmployee?: number | null
    AverageEmbodiment?: number | null
    DeductionMax?: number | null
    DeductionPercent?: number | null
    CreditPoint?: number | null
    FactorToReduction?: number | null
    MinHoursToPay?: number | null
    MinimumPayFor5Day?: number | null
    MinimumPayFor6Day?: number | null
    MaxPrecentReduction?: number | null
    hourPerDayfor5?: number | null
    hourPerDayfor6?: number | null
    hourInfridayDay?: number | null
    TaxPrecent?: number | null
    EmployerTax?: number | null
    DiscountInTaxInEilat?: number | null
    TaxUnitNumber?: number | null
    FundPercentConstruction?: number | null
    Hour100?: number | null
    Hour125?: number | null
    Hour150?: number | null
    Hour175?: number | null
    Hour200?: number | null
    CreditCardMan?: number | null
    CreditCardWoman?: number | null
    CreditCardChild?: number | null
    CreditCardBaby?: number | null
    CreditCardInAddition?: number | null
    CreditCardLackMobilityChild?: number | null
    CreditCardImmigrant18?: number | null
    ControlingShareholder: boolean
    HealthInsuranceEmployeeLow?: number | null
    HealthInsuranceEmployeeAbove?: number | null
    HealthInsuranceEmployerLow?: number | null
    HealthInsuranceEmployerAbove?: number | null
    ValueOfVehicleUseHibberdDiscount?: number | null
    Deposit?: number | null
    ValueOfMobileUse?: number | null
    PensionCeiling?: number | null
    PensionCredit?: number | null
    DepositEmployerPrecent?: number | null
    DepositEmployeePrecent?: number | null
    TotalHourPerWeek?: number | null
    CreditCardAdultChild?: number | null
    CreditCardChild1_5?: number | null
    DepositEmployeePrecentExecption?: number | null
  }

  export type SocialSecurityDetileUpdateManyMutationInput = {
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    Sector?: IntFieldUpdateOperationsInput | number
    SocialSecurityCode?: IntFieldUpdateOperationsInput | number
    AverageSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinDeductionNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMonyEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    AverageEmbodiment?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionMax?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditPoint?: NullableFloatFieldUpdateOperationsInput | number | null
    FactorToReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    MinHoursToPay?: NullableIntFieldUpdateOperationsInput | number | null
    MinimumPayFor5Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MinimumPayFor6Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxPrecentReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor5?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor6?: NullableIntFieldUpdateOperationsInput | number | null
    hourInfridayDay?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployerTax?: NullableFloatFieldUpdateOperationsInput | number | null
    DiscountInTaxInEilat?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxUnitNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    FundPercentConstruction?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour100?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour125?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour150?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour175?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour200?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardMan?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardWoman?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardBaby?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardInAddition?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardLackMobilityChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardImmigrant18?: NullableFloatFieldUpdateOperationsInput | number | null
    ControlingShareholder?: BoolFieldUpdateOperationsInput | boolean
    HealthInsuranceEmployeeLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployeeAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfVehicleUseHibberdDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    Deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfMobileUse?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCeiling?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCredit?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployerPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalHourPerWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardAdultChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild1_5?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecentExecption?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SocialSecurityDetileUncheckedUpdateManyInput = {
    SocialSecurityDetailID?: IntFieldUpdateOperationsInput | number
    SocialSecurityID?: IntFieldUpdateOperationsInput | number
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    Sector?: IntFieldUpdateOperationsInput | number
    SocialSecurityCode?: IntFieldUpdateOperationsInput | number
    AverageSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinDeductionNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMonyEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    AverageEmbodiment?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionMax?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditPoint?: NullableFloatFieldUpdateOperationsInput | number | null
    FactorToReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    MinHoursToPay?: NullableIntFieldUpdateOperationsInput | number | null
    MinimumPayFor5Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MinimumPayFor6Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxPrecentReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor5?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor6?: NullableIntFieldUpdateOperationsInput | number | null
    hourInfridayDay?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployerTax?: NullableFloatFieldUpdateOperationsInput | number | null
    DiscountInTaxInEilat?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxUnitNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    FundPercentConstruction?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour100?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour125?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour150?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour175?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour200?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardMan?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardWoman?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardBaby?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardInAddition?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardLackMobilityChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardImmigrant18?: NullableFloatFieldUpdateOperationsInput | number | null
    ControlingShareholder?: BoolFieldUpdateOperationsInput | boolean
    HealthInsuranceEmployeeLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployeeAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfVehicleUseHibberdDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    Deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfMobileUse?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCeiling?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCredit?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployerPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalHourPerWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardAdultChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild1_5?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecentExecption?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type sysdiagramsCreateInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUncheckedCreateInput = {
    name: string
    principal_id: number
    diagram_id?: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsCreateManyInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type SystemDefinitionCreateInput = {
    SystemDefinitionId?: string
    CreatedAt?: Date | string | null
    FieldDescription?: string | null
    FieldValue?: string | null
  }

  export type SystemDefinitionUncheckedCreateInput = {
    SystemDefinitionId?: string
    CreatedAt?: Date | string | null
    FieldDescription?: string | null
    FieldValue?: string | null
  }

  export type SystemDefinitionUpdateInput = {
    SystemDefinitionId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FieldDescription?: NullableStringFieldUpdateOperationsInput | string | null
    FieldValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemDefinitionUncheckedUpdateInput = {
    SystemDefinitionId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FieldDescription?: NullableStringFieldUpdateOperationsInput | string | null
    FieldValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemDefinitionCreateManyInput = {
    SystemDefinitionId?: string
    CreatedAt?: Date | string | null
    FieldDescription?: string | null
    FieldValue?: string | null
  }

  export type SystemDefinitionUpdateManyMutationInput = {
    SystemDefinitionId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FieldDescription?: NullableStringFieldUpdateOperationsInput | string | null
    FieldValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemDefinitionUncheckedUpdateManyInput = {
    SystemDefinitionId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FieldDescription?: NullableStringFieldUpdateOperationsInput | string | null
    FieldValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemMaintenancCreateInput = {
    UserMsg: string
    LogOutFrequency: number
    SystemMaintenanc: boolean
  }

  export type SystemMaintenancUncheckedCreateInput = {
    SystemMaintenancID?: number
    UserMsg: string
    LogOutFrequency: number
    SystemMaintenanc: boolean
  }

  export type SystemMaintenancUpdateInput = {
    UserMsg?: StringFieldUpdateOperationsInput | string
    LogOutFrequency?: IntFieldUpdateOperationsInput | number
    SystemMaintenanc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SystemMaintenancUncheckedUpdateInput = {
    SystemMaintenancID?: IntFieldUpdateOperationsInput | number
    UserMsg?: StringFieldUpdateOperationsInput | string
    LogOutFrequency?: IntFieldUpdateOperationsInput | number
    SystemMaintenanc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SystemMaintenancCreateManyInput = {
    UserMsg: string
    LogOutFrequency: number
    SystemMaintenanc: boolean
  }

  export type SystemMaintenancUpdateManyMutationInput = {
    UserMsg?: StringFieldUpdateOperationsInput | string
    LogOutFrequency?: IntFieldUpdateOperationsInput | number
    SystemMaintenanc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SystemMaintenancUncheckedUpdateManyInput = {
    SystemMaintenancID?: IntFieldUpdateOperationsInput | number
    UserMsg?: StringFieldUpdateOperationsInput | string
    LogOutFrequency?: IntFieldUpdateOperationsInput | number
    SystemMaintenanc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaxStepDetileCreateInput = {
    TaxYear: number
    TaxMonth: number
    StepNumber?: number | null
    TaxStap?: number | null
    TaxStapPercent?: number | null
    TaxSteps: TaxStepsCreateNestedOneWithoutTaxStepDetileInput
  }

  export type TaxStepDetileUncheckedCreateInput = {
    TaxStepDetileID?: number
    TaxStapID: number
    TaxYear: number
    TaxMonth: number
    StepNumber?: number | null
    TaxStap?: number | null
    TaxStapPercent?: number | null
  }

  export type TaxStepDetileUpdateInput = {
    TaxYear?: IntFieldUpdateOperationsInput | number
    TaxMonth?: IntFieldUpdateOperationsInput | number
    StepNumber?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStap?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStapPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxSteps?: TaxStepsUpdateOneRequiredWithoutTaxStepDetileNestedInput
  }

  export type TaxStepDetileUncheckedUpdateInput = {
    TaxStepDetileID?: IntFieldUpdateOperationsInput | number
    TaxStapID?: IntFieldUpdateOperationsInput | number
    TaxYear?: IntFieldUpdateOperationsInput | number
    TaxMonth?: IntFieldUpdateOperationsInput | number
    StepNumber?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStap?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStapPercent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TaxStepDetileCreateManyInput = {
    TaxStapID: number
    TaxYear: number
    TaxMonth: number
    StepNumber?: number | null
    TaxStap?: number | null
    TaxStapPercent?: number | null
  }

  export type TaxStepDetileUpdateManyMutationInput = {
    TaxYear?: IntFieldUpdateOperationsInput | number
    TaxMonth?: IntFieldUpdateOperationsInput | number
    StepNumber?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStap?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStapPercent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TaxStepDetileUncheckedUpdateManyInput = {
    TaxStepDetileID?: IntFieldUpdateOperationsInput | number
    TaxStapID?: IntFieldUpdateOperationsInput | number
    TaxYear?: IntFieldUpdateOperationsInput | number
    TaxMonth?: IntFieldUpdateOperationsInput | number
    StepNumber?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStap?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStapPercent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TaxStepsCreateInput = {
    TaxMonth: number
    TaxYear: number
    CurrentTaxStep: boolean
    TaxStepDetile?: TaxStepDetileCreateNestedManyWithoutTaxStepsInput
  }

  export type TaxStepsUncheckedCreateInput = {
    TaxStapID?: number
    TaxMonth: number
    TaxYear: number
    CurrentTaxStep: boolean
    TaxStepDetile?: TaxStepDetileUncheckedCreateNestedManyWithoutTaxStepsInput
  }

  export type TaxStepsUpdateInput = {
    TaxMonth?: IntFieldUpdateOperationsInput | number
    TaxYear?: IntFieldUpdateOperationsInput | number
    CurrentTaxStep?: BoolFieldUpdateOperationsInput | boolean
    TaxStepDetile?: TaxStepDetileUpdateManyWithoutTaxStepsNestedInput
  }

  export type TaxStepsUncheckedUpdateInput = {
    TaxStapID?: IntFieldUpdateOperationsInput | number
    TaxMonth?: IntFieldUpdateOperationsInput | number
    TaxYear?: IntFieldUpdateOperationsInput | number
    CurrentTaxStep?: BoolFieldUpdateOperationsInput | boolean
    TaxStepDetile?: TaxStepDetileUncheckedUpdateManyWithoutTaxStepsNestedInput
  }

  export type TaxStepsCreateManyInput = {
    TaxMonth: number
    TaxYear: number
    CurrentTaxStep: boolean
  }

  export type TaxStepsUpdateManyMutationInput = {
    TaxMonth?: IntFieldUpdateOperationsInput | number
    TaxYear?: IntFieldUpdateOperationsInput | number
    CurrentTaxStep?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaxStepsUncheckedUpdateManyInput = {
    TaxStapID?: IntFieldUpdateOperationsInput | number
    TaxMonth?: IntFieldUpdateOperationsInput | number
    TaxYear?: IntFieldUpdateOperationsInput | number
    CurrentTaxStep?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UnionFeeCreateInput = {
    ID: number
    UnionCode: number
    UnionName: string
    UnionFeeDetile?: UnionFeeDetileCreateNestedManyWithoutUnionFeeInput
  }

  export type UnionFeeUncheckedCreateInput = {
    ID: number
    UnionCode: number
    UnionName: string
    UnionFeeDetile?: UnionFeeDetileUncheckedCreateNestedManyWithoutUnionFeeInput
  }

  export type UnionFeeUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UnionCode?: IntFieldUpdateOperationsInput | number
    UnionName?: StringFieldUpdateOperationsInput | string
    UnionFeeDetile?: UnionFeeDetileUpdateManyWithoutUnionFeeNestedInput
  }

  export type UnionFeeUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UnionCode?: IntFieldUpdateOperationsInput | number
    UnionName?: StringFieldUpdateOperationsInput | string
    UnionFeeDetile?: UnionFeeDetileUncheckedUpdateManyWithoutUnionFeeNestedInput
  }

  export type UnionFeeCreateManyInput = {
    ID: number
    UnionCode: number
    UnionName: string
  }

  export type UnionFeeUpdateManyMutationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UnionCode?: IntFieldUpdateOperationsInput | number
    UnionName?: StringFieldUpdateOperationsInput | string
  }

  export type UnionFeeUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UnionCode?: IntFieldUpdateOperationsInput | number
    UnionName?: StringFieldUpdateOperationsInput | string
  }

  export type UnionFeeDetileCreateInput = {
    SocialYear: number
    SocialMonth: number
    FeePercentage_No?: number | null
    FeePercentage_Yes?: number | null
    MaxFee?: number | null
    MaxAdminFee?: number | null
    UnionFee: UnionFeeCreateNestedOneWithoutUnionFeeDetileInput
  }

  export type UnionFeeDetileUncheckedCreateInput = {
    ID?: number
    UnionCode: number
    SocialYear: number
    SocialMonth: number
    FeePercentage_No?: number | null
    FeePercentage_Yes?: number | null
    MaxFee?: number | null
    MaxAdminFee?: number | null
  }

  export type UnionFeeDetileUpdateInput = {
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    FeePercentage_No?: NullableFloatFieldUpdateOperationsInput | number | null
    FeePercentage_Yes?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxFee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxAdminFee?: NullableFloatFieldUpdateOperationsInput | number | null
    UnionFee?: UnionFeeUpdateOneRequiredWithoutUnionFeeDetileNestedInput
  }

  export type UnionFeeDetileUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UnionCode?: IntFieldUpdateOperationsInput | number
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    FeePercentage_No?: NullableFloatFieldUpdateOperationsInput | number | null
    FeePercentage_Yes?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxFee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxAdminFee?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UnionFeeDetileCreateManyInput = {
    UnionCode: number
    SocialYear: number
    SocialMonth: number
    FeePercentage_No?: number | null
    FeePercentage_Yes?: number | null
    MaxFee?: number | null
    MaxAdminFee?: number | null
  }

  export type UnionFeeDetileUpdateManyMutationInput = {
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    FeePercentage_No?: NullableFloatFieldUpdateOperationsInput | number | null
    FeePercentage_Yes?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxFee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxAdminFee?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UnionFeeDetileUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UnionCode?: IntFieldUpdateOperationsInput | number
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    FeePercentage_No?: NullableFloatFieldUpdateOperationsInput | number | null
    FeePercentage_Yes?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxFee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxAdminFee?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type VacationDefinitionDetailsCreateInput = {
    StartMonthReward?: number | null
    EndMonthrReward?: number | null
    DayQuantity6days?: number | null
    DayQuantity5days?: number | null
    SocialYearDescription?: string | null
    DayQuantity?: number | null
    VacationlDefinition?: VacationlDefinitionCreateNestedOneWithoutVacationDefinitionDetailsInput
  }

  export type VacationDefinitionDetailsUncheckedCreateInput = {
    VacationlDefinitionDetaillID?: number
    VacationlDefinitionID?: number | null
    StartMonthReward?: number | null
    EndMonthrReward?: number | null
    DayQuantity6days?: number | null
    DayQuantity5days?: number | null
    SocialYearDescription?: string | null
    DayQuantity?: number | null
  }

  export type VacationDefinitionDetailsUpdateInput = {
    StartMonthReward?: NullableFloatFieldUpdateOperationsInput | number | null
    EndMonthrReward?: NullableFloatFieldUpdateOperationsInput | number | null
    DayQuantity6days?: NullableIntFieldUpdateOperationsInput | number | null
    DayQuantity5days?: NullableIntFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
    DayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    VacationlDefinition?: VacationlDefinitionUpdateOneWithoutVacationDefinitionDetailsNestedInput
  }

  export type VacationDefinitionDetailsUncheckedUpdateInput = {
    VacationlDefinitionDetaillID?: IntFieldUpdateOperationsInput | number
    VacationlDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    StartMonthReward?: NullableFloatFieldUpdateOperationsInput | number | null
    EndMonthrReward?: NullableFloatFieldUpdateOperationsInput | number | null
    DayQuantity6days?: NullableIntFieldUpdateOperationsInput | number | null
    DayQuantity5days?: NullableIntFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
    DayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VacationDefinitionDetailsCreateManyInput = {
    VacationlDefinitionID?: number | null
    StartMonthReward?: number | null
    EndMonthrReward?: number | null
    DayQuantity6days?: number | null
    DayQuantity5days?: number | null
    SocialYearDescription?: string | null
    DayQuantity?: number | null
  }

  export type VacationDefinitionDetailsUpdateManyMutationInput = {
    StartMonthReward?: NullableFloatFieldUpdateOperationsInput | number | null
    EndMonthrReward?: NullableFloatFieldUpdateOperationsInput | number | null
    DayQuantity6days?: NullableIntFieldUpdateOperationsInput | number | null
    DayQuantity5days?: NullableIntFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
    DayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VacationDefinitionDetailsUncheckedUpdateManyInput = {
    VacationlDefinitionDetaillID?: IntFieldUpdateOperationsInput | number
    VacationlDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    StartMonthReward?: NullableFloatFieldUpdateOperationsInput | number | null
    EndMonthrReward?: NullableFloatFieldUpdateOperationsInput | number | null
    DayQuantity6days?: NullableIntFieldUpdateOperationsInput | number | null
    DayQuantity5days?: NullableIntFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
    DayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VacationlDefinitionCreateInput = {
    VacationlDefinitionName: string
    VacationDefinitionDetails?: VacationDefinitionDetailsCreateNestedManyWithoutVacationlDefinitionInput
  }

  export type VacationlDefinitionUncheckedCreateInput = {
    VacationlDefinitionID?: number
    VacationlDefinitionName: string
    VacationDefinitionDetails?: VacationDefinitionDetailsUncheckedCreateNestedManyWithoutVacationlDefinitionInput
  }

  export type VacationlDefinitionUpdateInput = {
    VacationlDefinitionName?: StringFieldUpdateOperationsInput | string
    VacationDefinitionDetails?: VacationDefinitionDetailsUpdateManyWithoutVacationlDefinitionNestedInput
  }

  export type VacationlDefinitionUncheckedUpdateInput = {
    VacationlDefinitionID?: IntFieldUpdateOperationsInput | number
    VacationlDefinitionName?: StringFieldUpdateOperationsInput | string
    VacationDefinitionDetails?: VacationDefinitionDetailsUncheckedUpdateManyWithoutVacationlDefinitionNestedInput
  }

  export type VacationlDefinitionCreateManyInput = {
    VacationlDefinitionName: string
  }

  export type VacationlDefinitionUpdateManyMutationInput = {
    VacationlDefinitionName?: StringFieldUpdateOperationsInput | string
  }

  export type VacationlDefinitionUncheckedUpdateManyInput = {
    VacationlDefinitionID?: IntFieldUpdateOperationsInput | number
    VacationlDefinitionName?: StringFieldUpdateOperationsInput | string
  }

  export type ValueOfVehicleUseCreateInput = {
    Year?: number | null
    Month?: number | null
    GroupOfVehicle: number
    Value?: number | null
  }

  export type ValueOfVehicleUseUncheckedCreateInput = {
    ValueOfVehicleUselID?: number
    Year?: number | null
    Month?: number | null
    GroupOfVehicle: number
    Value?: number | null
  }

  export type ValueOfVehicleUseUpdateInput = {
    Year?: NullableIntFieldUpdateOperationsInput | number | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    GroupOfVehicle?: IntFieldUpdateOperationsInput | number
    Value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ValueOfVehicleUseUncheckedUpdateInput = {
    ValueOfVehicleUselID?: IntFieldUpdateOperationsInput | number
    Year?: NullableIntFieldUpdateOperationsInput | number | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    GroupOfVehicle?: IntFieldUpdateOperationsInput | number
    Value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ValueOfVehicleUseCreateManyInput = {
    Year?: number | null
    Month?: number | null
    GroupOfVehicle: number
    Value?: number | null
  }

  export type ValueOfVehicleUseUpdateManyMutationInput = {
    Year?: NullableIntFieldUpdateOperationsInput | number | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    GroupOfVehicle?: IntFieldUpdateOperationsInput | number
    Value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ValueOfVehicleUseUncheckedUpdateManyInput = {
    ValueOfVehicleUselID?: IntFieldUpdateOperationsInput | number
    Year?: NullableIntFieldUpdateOperationsInput | number | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    GroupOfVehicle?: IntFieldUpdateOperationsInput | number
    Value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ValueOfVehicleUseByDetileCreateInput = {
    Year: number
    RegistryYear: number
    VehicleCode: number
    ProductCode: number
    ProductName: string
    ModelCode: number
    ModelName: string
    FuelType?: number | null
    CommercialName?: string | null
    Automatic?: number | null
    Hybrid?: number | null
    GreenGrade?: number | null
    PolutionGrade?: number | null
    EngineVolume?: number | null
    Weight?: number | null
    BeginDate?: Date | string | null
    ListPrice?: number | null
    AjustedPrice?: number | null
    Value?: number | null
  }

  export type ValueOfVehicleUseByDetileUncheckedCreateInput = {
    ID?: number
    Year: number
    RegistryYear: number
    VehicleCode: number
    ProductCode: number
    ProductName: string
    ModelCode: number
    ModelName: string
    FuelType?: number | null
    CommercialName?: string | null
    Automatic?: number | null
    Hybrid?: number | null
    GreenGrade?: number | null
    PolutionGrade?: number | null
    EngineVolume?: number | null
    Weight?: number | null
    BeginDate?: Date | string | null
    ListPrice?: number | null
    AjustedPrice?: number | null
    Value?: number | null
  }

  export type ValueOfVehicleUseByDetileUpdateInput = {
    Year?: FloatFieldUpdateOperationsInput | number
    RegistryYear?: IntFieldUpdateOperationsInput | number
    VehicleCode?: IntFieldUpdateOperationsInput | number
    ProductCode?: IntFieldUpdateOperationsInput | number
    ProductName?: StringFieldUpdateOperationsInput | string
    ModelCode?: IntFieldUpdateOperationsInput | number
    ModelName?: StringFieldUpdateOperationsInput | string
    FuelType?: NullableIntFieldUpdateOperationsInput | number | null
    CommercialName?: NullableStringFieldUpdateOperationsInput | string | null
    Automatic?: NullableIntFieldUpdateOperationsInput | number | null
    Hybrid?: NullableIntFieldUpdateOperationsInput | number | null
    GreenGrade?: NullableIntFieldUpdateOperationsInput | number | null
    PolutionGrade?: NullableIntFieldUpdateOperationsInput | number | null
    EngineVolume?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BeginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ListPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    AjustedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    Value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ValueOfVehicleUseByDetileUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Year?: FloatFieldUpdateOperationsInput | number
    RegistryYear?: IntFieldUpdateOperationsInput | number
    VehicleCode?: IntFieldUpdateOperationsInput | number
    ProductCode?: IntFieldUpdateOperationsInput | number
    ProductName?: StringFieldUpdateOperationsInput | string
    ModelCode?: IntFieldUpdateOperationsInput | number
    ModelName?: StringFieldUpdateOperationsInput | string
    FuelType?: NullableIntFieldUpdateOperationsInput | number | null
    CommercialName?: NullableStringFieldUpdateOperationsInput | string | null
    Automatic?: NullableIntFieldUpdateOperationsInput | number | null
    Hybrid?: NullableIntFieldUpdateOperationsInput | number | null
    GreenGrade?: NullableIntFieldUpdateOperationsInput | number | null
    PolutionGrade?: NullableIntFieldUpdateOperationsInput | number | null
    EngineVolume?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BeginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ListPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    AjustedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    Value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ValueOfVehicleUseByDetileCreateManyInput = {
    Year: number
    RegistryYear: number
    VehicleCode: number
    ProductCode: number
    ProductName: string
    ModelCode: number
    ModelName: string
    FuelType?: number | null
    CommercialName?: string | null
    Automatic?: number | null
    Hybrid?: number | null
    GreenGrade?: number | null
    PolutionGrade?: number | null
    EngineVolume?: number | null
    Weight?: number | null
    BeginDate?: Date | string | null
    ListPrice?: number | null
    AjustedPrice?: number | null
    Value?: number | null
  }

  export type ValueOfVehicleUseByDetileUpdateManyMutationInput = {
    Year?: FloatFieldUpdateOperationsInput | number
    RegistryYear?: IntFieldUpdateOperationsInput | number
    VehicleCode?: IntFieldUpdateOperationsInput | number
    ProductCode?: IntFieldUpdateOperationsInput | number
    ProductName?: StringFieldUpdateOperationsInput | string
    ModelCode?: IntFieldUpdateOperationsInput | number
    ModelName?: StringFieldUpdateOperationsInput | string
    FuelType?: NullableIntFieldUpdateOperationsInput | number | null
    CommercialName?: NullableStringFieldUpdateOperationsInput | string | null
    Automatic?: NullableIntFieldUpdateOperationsInput | number | null
    Hybrid?: NullableIntFieldUpdateOperationsInput | number | null
    GreenGrade?: NullableIntFieldUpdateOperationsInput | number | null
    PolutionGrade?: NullableIntFieldUpdateOperationsInput | number | null
    EngineVolume?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BeginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ListPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    AjustedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    Value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ValueOfVehicleUseByDetileUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Year?: FloatFieldUpdateOperationsInput | number
    RegistryYear?: IntFieldUpdateOperationsInput | number
    VehicleCode?: IntFieldUpdateOperationsInput | number
    ProductCode?: IntFieldUpdateOperationsInput | number
    ProductName?: StringFieldUpdateOperationsInput | string
    ModelCode?: IntFieldUpdateOperationsInput | number
    ModelName?: StringFieldUpdateOperationsInput | string
    FuelType?: NullableIntFieldUpdateOperationsInput | number | null
    CommercialName?: NullableStringFieldUpdateOperationsInput | string | null
    Automatic?: NullableIntFieldUpdateOperationsInput | number | null
    Hybrid?: NullableIntFieldUpdateOperationsInput | number | null
    GreenGrade?: NullableIntFieldUpdateOperationsInput | number | null
    PolutionGrade?: NullableIntFieldUpdateOperationsInput | number | null
    EngineVolume?: NullableIntFieldUpdateOperationsInput | number | null
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    BeginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ListPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    AjustedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    Value?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdvanceNoticeCountOrderByAggregateInput = {
    AdvanceNoticeID?: SortOrder
    StartPeriod?: SortOrder
    EndPeriod?: SortOrder
    DaysOfNotice?: SortOrder
  }

  export type AdvanceNoticeAvgOrderByAggregateInput = {
    AdvanceNoticeID?: SortOrder
    StartPeriod?: SortOrder
    EndPeriod?: SortOrder
    DaysOfNotice?: SortOrder
  }

  export type AdvanceNoticeMaxOrderByAggregateInput = {
    AdvanceNoticeID?: SortOrder
    StartPeriod?: SortOrder
    EndPeriod?: SortOrder
    DaysOfNotice?: SortOrder
  }

  export type AdvanceNoticeMinOrderByAggregateInput = {
    AdvanceNoticeID?: SortOrder
    StartPeriod?: SortOrder
    EndPeriod?: SortOrder
    DaysOfNotice?: SortOrder
  }

  export type AdvanceNoticeSumOrderByAggregateInput = {
    AdvanceNoticeID?: SortOrder
    StartPeriod?: SortOrder
    EndPeriod?: SortOrder
    DaysOfNotice?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AutoWordReportSubListRelationFilter = {
    every?: AutoWordReportSubWhereInput
    some?: AutoWordReportSubWhereInput
    none?: AutoWordReportSubWhereInput
  }

  export type AutoWordReportSubOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutoWordReportCountOrderByAggregateInput = {
    ReportID?: SortOrder
    ReportName?: SortOrder
    ReportTemplateName?: SortOrder
    IsEmployee?: SortOrder
    IsCustomer?: SortOrder
    StrSQL?: SortOrder
    IsChossCustomerOrEmployee?: SortOrder
    SaveInArchive?: SortOrder
    IsView?: SortOrder
  }

  export type AutoWordReportAvgOrderByAggregateInput = {
    ReportID?: SortOrder
    SaveInArchive?: SortOrder
  }

  export type AutoWordReportMaxOrderByAggregateInput = {
    ReportID?: SortOrder
    ReportName?: SortOrder
    ReportTemplateName?: SortOrder
    IsEmployee?: SortOrder
    IsCustomer?: SortOrder
    StrSQL?: SortOrder
    IsChossCustomerOrEmployee?: SortOrder
    SaveInArchive?: SortOrder
    IsView?: SortOrder
  }

  export type AutoWordReportMinOrderByAggregateInput = {
    ReportID?: SortOrder
    ReportName?: SortOrder
    ReportTemplateName?: SortOrder
    IsEmployee?: SortOrder
    IsCustomer?: SortOrder
    StrSQL?: SortOrder
    IsChossCustomerOrEmployee?: SortOrder
    SaveInArchive?: SortOrder
    IsView?: SortOrder
  }

  export type AutoWordReportSumOrderByAggregateInput = {
    ReportID?: SortOrder
    SaveInArchive?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AutoWordReportNullableScalarRelationFilter = {
    is?: AutoWordReportWhereInput | null
    isNot?: AutoWordReportWhereInput | null
  }

  export type AutoWordReportSubCountOrderByAggregateInput = {
    ReportSubID?: SortOrder
    ReportID?: SortOrder
    FieldNameTB?: SortOrder
    FieldNameReport?: SortOrder
  }

  export type AutoWordReportSubAvgOrderByAggregateInput = {
    ReportSubID?: SortOrder
    ReportID?: SortOrder
  }

  export type AutoWordReportSubMaxOrderByAggregateInput = {
    ReportSubID?: SortOrder
    ReportID?: SortOrder
    FieldNameTB?: SortOrder
    FieldNameReport?: SortOrder
  }

  export type AutoWordReportSubMinOrderByAggregateInput = {
    ReportSubID?: SortOrder
    ReportID?: SortOrder
    FieldNameTB?: SortOrder
    FieldNameReport?: SortOrder
  }

  export type AutoWordReportSubSumOrderByAggregateInput = {
    ReportSubID?: SortOrder
    ReportID?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ChangeHistoryCountOrderByAggregateInput = {
    ChangeHistoryID?: SortOrder
    Application_Name?: SortOrder
    ChangeDate?: SortOrder
    Version_Number?: SortOrder
    ChangeDescription?: SortOrder
    ConvertDatabase?: SortOrder
  }

  export type ChangeHistoryAvgOrderByAggregateInput = {
    ChangeHistoryID?: SortOrder
  }

  export type ChangeHistoryMaxOrderByAggregateInput = {
    ChangeHistoryID?: SortOrder
    Application_Name?: SortOrder
    ChangeDate?: SortOrder
    Version_Number?: SortOrder
    ChangeDescription?: SortOrder
    ConvertDatabase?: SortOrder
  }

  export type ChangeHistoryMinOrderByAggregateInput = {
    ChangeHistoryID?: SortOrder
    Application_Name?: SortOrder
    ChangeDate?: SortOrder
    Version_Number?: SortOrder
    ChangeDescription?: SortOrder
    ConvertDatabase?: SortOrder
  }

  export type ChangeHistorySumOrderByAggregateInput = {
    ChangeHistoryID?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type CitysIncomeTaxDiscountCountOrderByAggregateInput = {
    ID?: SortOrder
    Year?: SortOrder
    GroupCode?: SortOrder
    CityName?: SortOrder
    DiscountPercent?: SortOrder
    MaximumIncome?: SortOrder
    MaximumIncomePerMonth?: SortOrder
  }

  export type CitysIncomeTaxDiscountAvgOrderByAggregateInput = {
    ID?: SortOrder
    Year?: SortOrder
    GroupCode?: SortOrder
    DiscountPercent?: SortOrder
    MaximumIncome?: SortOrder
    MaximumIncomePerMonth?: SortOrder
  }

  export type CitysIncomeTaxDiscountMaxOrderByAggregateInput = {
    ID?: SortOrder
    Year?: SortOrder
    GroupCode?: SortOrder
    CityName?: SortOrder
    DiscountPercent?: SortOrder
    MaximumIncome?: SortOrder
    MaximumIncomePerMonth?: SortOrder
  }

  export type CitysIncomeTaxDiscountMinOrderByAggregateInput = {
    ID?: SortOrder
    Year?: SortOrder
    GroupCode?: SortOrder
    CityName?: SortOrder
    DiscountPercent?: SortOrder
    MaximumIncome?: SortOrder
    MaximumIncomePerMonth?: SortOrder
  }

  export type CitysIncomeTaxDiscountSumOrderByAggregateInput = {
    ID?: SortOrder
    Year?: SortOrder
    GroupCode?: SortOrder
    DiscountPercent?: SortOrder
    MaximumIncome?: SortOrder
    MaximumIncomePerMonth?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type CompaniesTypeScalarRelationFilter = {
    is?: CompaniesTypeWhereInput
    isNot?: CompaniesTypeWhereInput
  }

  export type CompaniesUsersNullableScalarRelationFilter = {
    is?: CompaniesUsersWhereInput | null
    isNot?: CompaniesUsersWhereInput | null
  }

  export type CompaniesProductsListRelationFilter = {
    every?: CompaniesProductsWhereInput
    some?: CompaniesProductsWhereInput
    none?: CompaniesProductsWhereInput
  }

  export type CompaniesProductsExpireDatesListRelationFilter = {
    every?: CompaniesProductsExpireDatesWhereInput
    some?: CompaniesProductsExpireDatesWhereInput
    none?: CompaniesProductsExpireDatesWhereInput
  }

  export type CompaniesUsersListRelationFilter = {
    every?: CompaniesUsersWhereInput
    some?: CompaniesUsersWhereInput
    none?: CompaniesUsersWhereInput
  }

  export type CompaniesUsersProductsExpireDatesListRelationFilter = {
    every?: CompaniesUsersProductsExpireDatesWhereInput
    some?: CompaniesUsersProductsExpireDatesWhereInput
    none?: CompaniesUsersProductsExpireDatesWhereInput
  }

  export type LandPagesNullableScalarRelationFilter = {
    is?: LandPagesWhereInput | null
    isNot?: LandPagesWhereInput | null
  }

  export type CompaniesProductsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompaniesProductsExpireDatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompaniesUsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompaniesUsersProductsExpireDatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompaniesCountOrderByAggregateInput = {
    CompanyID?: SortOrder
    CompanyID_OLD?: SortOrder
    CompanyNumber?: SortOrder
    DeductionsNumber?: SortOrder
    AgencyNumber?: SortOrder
    CompanyName?: SortOrder
    CompanyNameEng?: SortOrder
    Address?: SortOrder
    CityID?: SortOrder
    ZipCode?: SortOrder
    POB?: SortOrder
    POB_ZipCode?: SortOrder
    Email?: SortOrder
    WebSite?: SortOrder
    Phone?: SortOrder
    Fax?: SortOrder
    NumOfPaySlipDisplay?: SortOrder
    PaySlipDefinitionID?: SortOrder
    DbPathOnCloud?: SortOrder
    DocFilesPathOnCloud?: SortOrder
    DbPathAgricultureCRM?: SortOrder
    DisplayTypeID?: SortOrder
    IsSuperAdminCompany?: SortOrder
    IsActive?: SortOrder
    IsExportAccounts?: SortOrder
    TaxAccountsToken?: SortOrder
    IsGetTaxAccountsCode?: SortOrder
    CompanyTaxAutoLink?: SortOrder
    UserId?: SortOrder
    CompanyTypeID?: SortOrder
  }

  export type CompaniesAvgOrderByAggregateInput = {
    CompanyID_OLD?: SortOrder
    CompanyNumber?: SortOrder
    DeductionsNumber?: SortOrder
    AgencyNumber?: SortOrder
    CityID?: SortOrder
    NumOfPaySlipDisplay?: SortOrder
    PaySlipDefinitionID?: SortOrder
    DisplayTypeID?: SortOrder
    IsSuperAdminCompany?: SortOrder
    IsActive?: SortOrder
    IsExportAccounts?: SortOrder
    IsGetTaxAccountsCode?: SortOrder
  }

  export type CompaniesMaxOrderByAggregateInput = {
    CompanyID?: SortOrder
    CompanyID_OLD?: SortOrder
    CompanyNumber?: SortOrder
    DeductionsNumber?: SortOrder
    AgencyNumber?: SortOrder
    CompanyName?: SortOrder
    CompanyNameEng?: SortOrder
    Address?: SortOrder
    CityID?: SortOrder
    ZipCode?: SortOrder
    POB?: SortOrder
    POB_ZipCode?: SortOrder
    Email?: SortOrder
    WebSite?: SortOrder
    Phone?: SortOrder
    Fax?: SortOrder
    NumOfPaySlipDisplay?: SortOrder
    PaySlipDefinitionID?: SortOrder
    DbPathOnCloud?: SortOrder
    DocFilesPathOnCloud?: SortOrder
    DbPathAgricultureCRM?: SortOrder
    DisplayTypeID?: SortOrder
    IsSuperAdminCompany?: SortOrder
    IsActive?: SortOrder
    IsExportAccounts?: SortOrder
    TaxAccountsToken?: SortOrder
    IsGetTaxAccountsCode?: SortOrder
    CompanyTaxAutoLink?: SortOrder
    UserId?: SortOrder
    CompanyTypeID?: SortOrder
  }

  export type CompaniesMinOrderByAggregateInput = {
    CompanyID?: SortOrder
    CompanyID_OLD?: SortOrder
    CompanyNumber?: SortOrder
    DeductionsNumber?: SortOrder
    AgencyNumber?: SortOrder
    CompanyName?: SortOrder
    CompanyNameEng?: SortOrder
    Address?: SortOrder
    CityID?: SortOrder
    ZipCode?: SortOrder
    POB?: SortOrder
    POB_ZipCode?: SortOrder
    Email?: SortOrder
    WebSite?: SortOrder
    Phone?: SortOrder
    Fax?: SortOrder
    NumOfPaySlipDisplay?: SortOrder
    PaySlipDefinitionID?: SortOrder
    DbPathOnCloud?: SortOrder
    DocFilesPathOnCloud?: SortOrder
    DbPathAgricultureCRM?: SortOrder
    DisplayTypeID?: SortOrder
    IsSuperAdminCompany?: SortOrder
    IsActive?: SortOrder
    IsExportAccounts?: SortOrder
    TaxAccountsToken?: SortOrder
    IsGetTaxAccountsCode?: SortOrder
    CompanyTaxAutoLink?: SortOrder
    UserId?: SortOrder
    CompanyTypeID?: SortOrder
  }

  export type CompaniesSumOrderByAggregateInput = {
    CompanyID_OLD?: SortOrder
    CompanyNumber?: SortOrder
    DeductionsNumber?: SortOrder
    AgencyNumber?: SortOrder
    CityID?: SortOrder
    NumOfPaySlipDisplay?: SortOrder
    PaySlipDefinitionID?: SortOrder
    DisplayTypeID?: SortOrder
    IsSuperAdminCompany?: SortOrder
    IsActive?: SortOrder
    IsExportAccounts?: SortOrder
    IsGetTaxAccountsCode?: SortOrder
  }

  export type CompaniesScalarRelationFilter = {
    is?: CompaniesWhereInput
    isNot?: CompaniesWhereInput
  }

  export type ProductsScalarRelationFilter = {
    is?: ProductsWhereInput
    isNot?: ProductsWhereInput
  }

  export type CompaniesProductsCountOrderByAggregateInput = {
    CompaniesProductsId?: SortOrder
    CreatedAt?: SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    UserId?: SortOrder
    LastVersionDate_Salary?: SortOrder
    LastVersionDate_ManPower?: SortOrder
  }

  export type CompaniesProductsMaxOrderByAggregateInput = {
    CompaniesProductsId?: SortOrder
    CreatedAt?: SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    UserId?: SortOrder
    LastVersionDate_Salary?: SortOrder
    LastVersionDate_ManPower?: SortOrder
  }

  export type CompaniesProductsMinOrderByAggregateInput = {
    CompaniesProductsId?: SortOrder
    CreatedAt?: SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    UserId?: SortOrder
    LastVersionDate_Salary?: SortOrder
    LastVersionDate_ManPower?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CompaniesProductsExpireDatesCountOrderByAggregateInput = {
    CompaniesProductsExpireDateId?: SortOrder
    CreatedAt?: SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Comments?: SortOrder
    UserId?: SortOrder
  }

  export type CompaniesProductsExpireDatesMaxOrderByAggregateInput = {
    CompaniesProductsExpireDateId?: SortOrder
    CreatedAt?: SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Comments?: SortOrder
    UserId?: SortOrder
  }

  export type CompaniesProductsExpireDatesMinOrderByAggregateInput = {
    CompaniesProductsExpireDateId?: SortOrder
    CreatedAt?: SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    Comments?: SortOrder
    UserId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CompaniesListRelationFilter = {
    every?: CompaniesWhereInput
    some?: CompaniesWhereInput
    none?: CompaniesWhereInput
  }

  export type CompaniesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompaniesTypeCountOrderByAggregateInput = {
    CompaniesTypeID?: SortOrder
    CompaniesType?: SortOrder
  }

  export type CompaniesTypeMaxOrderByAggregateInput = {
    CompaniesTypeID?: SortOrder
    CompaniesType?: SortOrder
  }

  export type CompaniesTypeMinOrderByAggregateInput = {
    CompaniesTypeID?: SortOrder
    CompaniesType?: SortOrder
  }

  export type CompaniesUsersCountOrderByAggregateInput = {
    CompaniesUsersID?: SortOrder
    CompanyID?: SortOrder
    CompanyID_OLD?: SortOrder
    EmployeeIdentity?: SortOrder
    BirthDate?: SortOrder
    LastName?: SortOrder
    FirstName?: SortOrder
    JobsID?: SortOrder
    Gender?: SortOrder
    MobileNumber?: SortOrder
    Phone?: SortOrder
    Fax?: SortOrder
    Email?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    AreaMan?: SortOrder
    IsAdmin?: SortOrder
    LastEntry?: SortOrder
    IsAllowAccess2WebSite?: SortOrder
    UserId?: SortOrder
    CreatedAt?: SortOrder
    TwoFactorBase32Secret?: SortOrder
    DeviceData?: SortOrder
  }

  export type CompaniesUsersAvgOrderByAggregateInput = {
    CompanyID_OLD?: SortOrder
    JobsID?: SortOrder
    Gender?: SortOrder
    IsAdmin?: SortOrder
    IsAllowAccess2WebSite?: SortOrder
  }

  export type CompaniesUsersMaxOrderByAggregateInput = {
    CompaniesUsersID?: SortOrder
    CompanyID?: SortOrder
    CompanyID_OLD?: SortOrder
    EmployeeIdentity?: SortOrder
    BirthDate?: SortOrder
    LastName?: SortOrder
    FirstName?: SortOrder
    JobsID?: SortOrder
    Gender?: SortOrder
    MobileNumber?: SortOrder
    Phone?: SortOrder
    Fax?: SortOrder
    Email?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    AreaMan?: SortOrder
    IsAdmin?: SortOrder
    LastEntry?: SortOrder
    IsAllowAccess2WebSite?: SortOrder
    UserId?: SortOrder
    CreatedAt?: SortOrder
    TwoFactorBase32Secret?: SortOrder
    DeviceData?: SortOrder
  }

  export type CompaniesUsersMinOrderByAggregateInput = {
    CompaniesUsersID?: SortOrder
    CompanyID?: SortOrder
    CompanyID_OLD?: SortOrder
    EmployeeIdentity?: SortOrder
    BirthDate?: SortOrder
    LastName?: SortOrder
    FirstName?: SortOrder
    JobsID?: SortOrder
    Gender?: SortOrder
    MobileNumber?: SortOrder
    Phone?: SortOrder
    Fax?: SortOrder
    Email?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    AreaMan?: SortOrder
    IsAdmin?: SortOrder
    LastEntry?: SortOrder
    IsAllowAccess2WebSite?: SortOrder
    UserId?: SortOrder
    CreatedAt?: SortOrder
    TwoFactorBase32Secret?: SortOrder
    DeviceData?: SortOrder
  }

  export type CompaniesUsersSumOrderByAggregateInput = {
    CompanyID_OLD?: SortOrder
    JobsID?: SortOrder
    Gender?: SortOrder
    IsAdmin?: SortOrder
    IsAllowAccess2WebSite?: SortOrder
  }

  export type CompaniesUsersScalarRelationFilter = {
    is?: CompaniesUsersWhereInput
    isNot?: CompaniesUsersWhereInput
  }

  export type CompaniesUsersProductsExpireDatesCountOrderByAggregateInput = {
    CompaniesUsersProductsExpireDateId?: SortOrder
    CreatedAt?: SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    CompaniesUsersID?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    UserId?: SortOrder
    Comments?: SortOrder
  }

  export type CompaniesUsersProductsExpireDatesMaxOrderByAggregateInput = {
    CompaniesUsersProductsExpireDateId?: SortOrder
    CreatedAt?: SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    CompaniesUsersID?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    UserId?: SortOrder
    Comments?: SortOrder
  }

  export type CompaniesUsersProductsExpireDatesMinOrderByAggregateInput = {
    CompaniesUsersProductsExpireDateId?: SortOrder
    CreatedAt?: SortOrder
    ProductId?: SortOrder
    CompanyID?: SortOrder
    CompaniesUsersID?: SortOrder
    StartDate?: SortOrder
    EndDate?: SortOrder
    UserId?: SortOrder
    Comments?: SortOrder
  }

  export type CopyrightCountOrderByAggregateInput = {
    CopyrightID?: SortOrder
    Copyright?: SortOrder
    DbGeneralVer?: SortOrder
  }

  export type CopyrightAvgOrderByAggregateInput = {
    CopyrightID?: SortOrder
    DbGeneralVer?: SortOrder
  }

  export type CopyrightMaxOrderByAggregateInput = {
    CopyrightID?: SortOrder
    Copyright?: SortOrder
    DbGeneralVer?: SortOrder
  }

  export type CopyrightMinOrderByAggregateInput = {
    CopyrightID?: SortOrder
    Copyright?: SortOrder
    DbGeneralVer?: SortOrder
  }

  export type CopyrightSumOrderByAggregateInput = {
    CopyrightID?: SortOrder
    DbGeneralVer?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type CountriesCountOrderByAggregateInput = {
    CountryID?: SortOrder
    CountryCode?: SortOrder
    CountryName?: SortOrder
    CountryNameEnglish?: SortOrder
    MultipleSelect?: SortOrder
    CommentPayslip?: SortOrder
    CommentHour?: SortOrder
    DefaultLanguageCol?: SortOrder
  }

  export type CountriesAvgOrderByAggregateInput = {
    CountryID?: SortOrder
    CountryCode?: SortOrder
  }

  export type CountriesMaxOrderByAggregateInput = {
    CountryID?: SortOrder
    CountryCode?: SortOrder
    CountryName?: SortOrder
    CountryNameEnglish?: SortOrder
    MultipleSelect?: SortOrder
    CommentPayslip?: SortOrder
    CommentHour?: SortOrder
    DefaultLanguageCol?: SortOrder
  }

  export type CountriesMinOrderByAggregateInput = {
    CountryID?: SortOrder
    CountryCode?: SortOrder
    CountryName?: SortOrder
    CountryNameEnglish?: SortOrder
    MultipleSelect?: SortOrder
    CommentPayslip?: SortOrder
    CommentHour?: SortOrder
    DefaultLanguageCol?: SortOrder
  }

  export type CountriesSumOrderByAggregateInput = {
    CountryID?: SortOrder
    CountryCode?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type CreditShiftCountOrderByAggregateInput = {
    CreditShiftID?: SortOrder
    CreditShiftDate?: SortOrder
    MaxCreditShiftPrecent?: SortOrder
    MaxCreditShiftLimit?: SortOrder
    CreditPrecent?: SortOrder
  }

  export type CreditShiftAvgOrderByAggregateInput = {
    CreditShiftID?: SortOrder
    MaxCreditShiftPrecent?: SortOrder
    MaxCreditShiftLimit?: SortOrder
    CreditPrecent?: SortOrder
  }

  export type CreditShiftMaxOrderByAggregateInput = {
    CreditShiftID?: SortOrder
    CreditShiftDate?: SortOrder
    MaxCreditShiftPrecent?: SortOrder
    MaxCreditShiftLimit?: SortOrder
    CreditPrecent?: SortOrder
  }

  export type CreditShiftMinOrderByAggregateInput = {
    CreditShiftID?: SortOrder
    CreditShiftDate?: SortOrder
    MaxCreditShiftPrecent?: SortOrder
    MaxCreditShiftLimit?: SortOrder
    CreditPrecent?: SortOrder
  }

  export type CreditShiftSumOrderByAggregateInput = {
    CreditShiftID?: SortOrder
    MaxCreditShiftPrecent?: SortOrder
    MaxCreditShiftLimit?: SortOrder
    CreditPrecent?: SortOrder
  }

  export type DaysInMonthCountOrderByAggregateInput = {
    DateManagedID?: SortOrder
    DateManaged?: SortOrder
    YearManaged?: SortOrder
    MonthManaged?: SortOrder
    DayInMonth?: SortOrder
    DayInWeek?: SortOrder
    WeekInYear?: SortOrder
    WeekInMonth?: SortOrder
    DayTypeID?: SortOrder
    StartEndTimeSabat?: SortOrder
    HolidayName?: SortOrder
  }

  export type DaysInMonthAvgOrderByAggregateInput = {
    DateManagedID?: SortOrder
    YearManaged?: SortOrder
    MonthManaged?: SortOrder
    DayInMonth?: SortOrder
    DayInWeek?: SortOrder
    WeekInYear?: SortOrder
    WeekInMonth?: SortOrder
    DayTypeID?: SortOrder
  }

  export type DaysInMonthMaxOrderByAggregateInput = {
    DateManagedID?: SortOrder
    DateManaged?: SortOrder
    YearManaged?: SortOrder
    MonthManaged?: SortOrder
    DayInMonth?: SortOrder
    DayInWeek?: SortOrder
    WeekInYear?: SortOrder
    WeekInMonth?: SortOrder
    DayTypeID?: SortOrder
    StartEndTimeSabat?: SortOrder
    HolidayName?: SortOrder
  }

  export type DaysInMonthMinOrderByAggregateInput = {
    DateManagedID?: SortOrder
    DateManaged?: SortOrder
    YearManaged?: SortOrder
    MonthManaged?: SortOrder
    DayInMonth?: SortOrder
    DayInWeek?: SortOrder
    WeekInYear?: SortOrder
    WeekInMonth?: SortOrder
    DayTypeID?: SortOrder
    StartEndTimeSabat?: SortOrder
    HolidayName?: SortOrder
  }

  export type DaysInMonthSumOrderByAggregateInput = {
    DateManagedID?: SortOrder
    YearManaged?: SortOrder
    MonthManaged?: SortOrder
    DayInMonth?: SortOrder
    DayInWeek?: SortOrder
    WeekInYear?: SortOrder
    WeekInMonth?: SortOrder
    DayTypeID?: SortOrder
  }

  export type DaysInMonth_NewYearCountOrderByAggregateInput = {
    DateManagedID?: SortOrder
    DateManaged?: SortOrder
    YearManaged?: SortOrder
    MonthManaged?: SortOrder
    DayInMonth?: SortOrder
    DayInWeek?: SortOrder
    WeekInYear?: SortOrder
    WeekInMonth?: SortOrder
    DayTypeID?: SortOrder
    StartEndTimeSabat?: SortOrder
    HolidayName?: SortOrder
  }

  export type DaysInMonth_NewYearAvgOrderByAggregateInput = {
    DateManagedID?: SortOrder
    YearManaged?: SortOrder
    MonthManaged?: SortOrder
    DayInMonth?: SortOrder
    DayInWeek?: SortOrder
    WeekInYear?: SortOrder
    WeekInMonth?: SortOrder
    DayTypeID?: SortOrder
  }

  export type DaysInMonth_NewYearMaxOrderByAggregateInput = {
    DateManagedID?: SortOrder
    DateManaged?: SortOrder
    YearManaged?: SortOrder
    MonthManaged?: SortOrder
    DayInMonth?: SortOrder
    DayInWeek?: SortOrder
    WeekInYear?: SortOrder
    WeekInMonth?: SortOrder
    DayTypeID?: SortOrder
    StartEndTimeSabat?: SortOrder
    HolidayName?: SortOrder
  }

  export type DaysInMonth_NewYearMinOrderByAggregateInput = {
    DateManagedID?: SortOrder
    DateManaged?: SortOrder
    YearManaged?: SortOrder
    MonthManaged?: SortOrder
    DayInMonth?: SortOrder
    DayInWeek?: SortOrder
    WeekInYear?: SortOrder
    WeekInMonth?: SortOrder
    DayTypeID?: SortOrder
    StartEndTimeSabat?: SortOrder
    HolidayName?: SortOrder
  }

  export type DaysInMonth_NewYearSumOrderByAggregateInput = {
    DateManagedID?: SortOrder
    YearManaged?: SortOrder
    MonthManaged?: SortOrder
    DayInMonth?: SortOrder
    DayInWeek?: SortOrder
    WeekInYear?: SortOrder
    WeekInMonth?: SortOrder
    DayTypeID?: SortOrder
  }

  export type DayTypeCountOrderByAggregateInput = {
    DayTypeID?: SortOrder
    DayTypeName?: SortOrder
    SetOrder?: SortOrder
  }

  export type DayTypeAvgOrderByAggregateInput = {
    DayTypeID?: SortOrder
    SetOrder?: SortOrder
  }

  export type DayTypeMaxOrderByAggregateInput = {
    DayTypeID?: SortOrder
    DayTypeName?: SortOrder
    SetOrder?: SortOrder
  }

  export type DayTypeMinOrderByAggregateInput = {
    DayTypeID?: SortOrder
    DayTypeName?: SortOrder
    SetOrder?: SortOrder
  }

  export type DayTypeSumOrderByAggregateInput = {
    DayTypeID?: SortOrder
    SetOrder?: SortOrder
  }

  export type DisplayTypeCountOrderByAggregateInput = {
    DisplayTypeID?: SortOrder
    DisplayType?: SortOrder
    URL?: SortOrder
    IsShowInDanzarCRM?: SortOrder
  }

  export type DisplayTypeAvgOrderByAggregateInput = {
    DisplayTypeID?: SortOrder
    IsShowInDanzarCRM?: SortOrder
  }

  export type DisplayTypeMaxOrderByAggregateInput = {
    DisplayTypeID?: SortOrder
    DisplayType?: SortOrder
    URL?: SortOrder
    IsShowInDanzarCRM?: SortOrder
  }

  export type DisplayTypeMinOrderByAggregateInput = {
    DisplayTypeID?: SortOrder
    DisplayType?: SortOrder
    URL?: SortOrder
    IsShowInDanzarCRM?: SortOrder
  }

  export type DisplayTypeSumOrderByAggregateInput = {
    DisplayTypeID?: SortOrder
    IsShowInDanzarCRM?: SortOrder
  }

  export type HashIndexGeneralCountOrderByAggregateInput = {
    HashCode?: SortOrder
    HashName?: SortOrder
  }

  export type HashIndexGeneralAvgOrderByAggregateInput = {
    HashCode?: SortOrder
  }

  export type HashIndexGeneralMaxOrderByAggregateInput = {
    HashCode?: SortOrder
    HashName?: SortOrder
  }

  export type HashIndexGeneralMinOrderByAggregateInput = {
    HashCode?: SortOrder
    HashName?: SortOrder
  }

  export type HashIndexGeneralSumOrderByAggregateInput = {
    HashCode?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type HashSecurityCountOrderByAggregateInput = {
    HashID?: SortOrder
    HashCode?: SortOrder
    IsUse?: SortOrder
  }

  export type HashSecurityAvgOrderByAggregateInput = {
    HashCode?: SortOrder
    IsUse?: SortOrder
  }

  export type HashSecurityMaxOrderByAggregateInput = {
    HashID?: SortOrder
    HashCode?: SortOrder
    IsUse?: SortOrder
  }

  export type HashSecurityMinOrderByAggregateInput = {
    HashID?: SortOrder
    HashCode?: SortOrder
    IsUse?: SortOrder
  }

  export type HashSecuritySumOrderByAggregateInput = {
    HashCode?: SortOrder
    IsUse?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type JobsCountOrderByAggregateInput = {
    JobsID?: SortOrder
    JobTitle?: SortOrder
  }

  export type JobsAvgOrderByAggregateInput = {
    JobsID?: SortOrder
  }

  export type JobsMaxOrderByAggregateInput = {
    JobsID?: SortOrder
    JobTitle?: SortOrder
  }

  export type JobsMinOrderByAggregateInput = {
    JobsID?: SortOrder
    JobTitle?: SortOrder
  }

  export type JobsSumOrderByAggregateInput = {
    JobsID?: SortOrder
  }

  export type KupaGemelCountOrderByAggregateInput = {
    KupaID?: SortOrder
    KupaName?: SortOrder
    AllowanceEmployeePercent?: SortOrder
    AllowanceEmployerPercent?: SortOrder
    AllowanceCompensationPercen?: SortOrder
    IsAndromedaRecord?: SortOrder
    EducationFundPercentEmp?: SortOrder
    EducationFundPercentEmpoyer?: SortOrder
  }

  export type KupaGemelAvgOrderByAggregateInput = {
    KupaID?: SortOrder
    AllowanceEmployeePercent?: SortOrder
    AllowanceEmployerPercent?: SortOrder
    AllowanceCompensationPercen?: SortOrder
    EducationFundPercentEmp?: SortOrder
    EducationFundPercentEmpoyer?: SortOrder
  }

  export type KupaGemelMaxOrderByAggregateInput = {
    KupaID?: SortOrder
    KupaName?: SortOrder
    AllowanceEmployeePercent?: SortOrder
    AllowanceEmployerPercent?: SortOrder
    AllowanceCompensationPercen?: SortOrder
    IsAndromedaRecord?: SortOrder
    EducationFundPercentEmp?: SortOrder
    EducationFundPercentEmpoyer?: SortOrder
  }

  export type KupaGemelMinOrderByAggregateInput = {
    KupaID?: SortOrder
    KupaName?: SortOrder
    AllowanceEmployeePercent?: SortOrder
    AllowanceEmployerPercent?: SortOrder
    AllowanceCompensationPercen?: SortOrder
    IsAndromedaRecord?: SortOrder
    EducationFundPercentEmp?: SortOrder
    EducationFundPercentEmpoyer?: SortOrder
  }

  export type KupaGemelSumOrderByAggregateInput = {
    KupaID?: SortOrder
    AllowanceEmployeePercent?: SortOrder
    AllowanceEmployerPercent?: SortOrder
    AllowanceCompensationPercen?: SortOrder
    EducationFundPercentEmp?: SortOrder
    EducationFundPercentEmpoyer?: SortOrder
  }

  export type LandPagesCountOrderByAggregateInput = {
    LandPageRowId?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrder
    JsonData?: SortOrder
    ViewDate?: SortOrder
    CompletedDate?: SortOrder
  }

  export type LandPagesMaxOrderByAggregateInput = {
    LandPageRowId?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrder
    JsonData?: SortOrder
    ViewDate?: SortOrder
    CompletedDate?: SortOrder
  }

  export type LandPagesMinOrderByAggregateInput = {
    LandPageRowId?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrder
    JsonData?: SortOrder
    ViewDate?: SortOrder
    CompletedDate?: SortOrder
  }

  export type LanguageDefinitionCountOrderByAggregateInput = {
    LanguageDefinitionID?: SortOrder
    ObjectName?: SortOrder
    ControlTypeID?: SortOrder
    ControlName?: SortOrder
    CaptionEnglish?: SortOrder
    CaptionHebrow?: SortOrder
    CaptionRomanian?: SortOrder
    CaptionRussian?: SortOrder
    CaptionChinese?: SortOrder
    CaptionTurkish?: SortOrder
  }

  export type LanguageDefinitionAvgOrderByAggregateInput = {
    LanguageDefinitionID?: SortOrder
    ControlTypeID?: SortOrder
  }

  export type LanguageDefinitionMaxOrderByAggregateInput = {
    LanguageDefinitionID?: SortOrder
    ObjectName?: SortOrder
    ControlTypeID?: SortOrder
    ControlName?: SortOrder
    CaptionEnglish?: SortOrder
    CaptionHebrow?: SortOrder
    CaptionRomanian?: SortOrder
    CaptionRussian?: SortOrder
    CaptionChinese?: SortOrder
    CaptionTurkish?: SortOrder
  }

  export type LanguageDefinitionMinOrderByAggregateInput = {
    LanguageDefinitionID?: SortOrder
    ObjectName?: SortOrder
    ControlTypeID?: SortOrder
    ControlName?: SortOrder
    CaptionEnglish?: SortOrder
    CaptionHebrow?: SortOrder
    CaptionRomanian?: SortOrder
    CaptionRussian?: SortOrder
    CaptionChinese?: SortOrder
    CaptionTurkish?: SortOrder
  }

  export type LanguageDefinitionSumOrderByAggregateInput = {
    LanguageDefinitionID?: SortOrder
    ControlTypeID?: SortOrder
  }

  export type Lkup_AreaCountOrderByAggregateInput = {
    AreaID?: SortOrder
    AreaCode?: SortOrder
    AreaName?: SortOrder
    Amount?: SortOrder
  }

  export type Lkup_AreaAvgOrderByAggregateInput = {
    AreaID?: SortOrder
    AreaCode?: SortOrder
    Amount?: SortOrder
  }

  export type Lkup_AreaMaxOrderByAggregateInput = {
    AreaID?: SortOrder
    AreaCode?: SortOrder
    AreaName?: SortOrder
    Amount?: SortOrder
  }

  export type Lkup_AreaMinOrderByAggregateInput = {
    AreaID?: SortOrder
    AreaCode?: SortOrder
    AreaName?: SortOrder
    Amount?: SortOrder
  }

  export type Lkup_AreaSumOrderByAggregateInput = {
    AreaID?: SortOrder
    AreaCode?: SortOrder
    Amount?: SortOrder
  }

  export type Lkup_BanksCountOrderByAggregateInput = {
    BankID?: SortOrder
    BankName?: SortOrder
    BankNumber?: SortOrder
    CountryID?: SortOrder
  }

  export type Lkup_BanksAvgOrderByAggregateInput = {
    BankID?: SortOrder
    BankNumber?: SortOrder
    CountryID?: SortOrder
  }

  export type Lkup_BanksMaxOrderByAggregateInput = {
    BankID?: SortOrder
    BankName?: SortOrder
    BankNumber?: SortOrder
    CountryID?: SortOrder
  }

  export type Lkup_BanksMinOrderByAggregateInput = {
    BankID?: SortOrder
    BankName?: SortOrder
    BankNumber?: SortOrder
    CountryID?: SortOrder
  }

  export type Lkup_BanksSumOrderByAggregateInput = {
    BankID?: SortOrder
    BankNumber?: SortOrder
    CountryID?: SortOrder
  }

  export type Lkup_BanksVerBranchBranchCodeBankIDCompoundUniqueInput = {
    BranchCode: string
    BankID: number
  }

  export type Lkup_BanksVerBranchCountOrderByAggregateInput = {
    BranchID?: SortOrder
    BankID?: SortOrder
    BranchName?: SortOrder
    BranchCode?: SortOrder
    Address?: SortOrder
    SortCode?: SortOrder
    Phone_1?: SortOrder
    Phone_2?: SortOrder
    FaxNumber?: SortOrder
    EMail?: SortOrder
    Comment?: SortOrder
  }

  export type Lkup_BanksVerBranchAvgOrderByAggregateInput = {
    BranchID?: SortOrder
    BankID?: SortOrder
  }

  export type Lkup_BanksVerBranchMaxOrderByAggregateInput = {
    BranchID?: SortOrder
    BankID?: SortOrder
    BranchName?: SortOrder
    BranchCode?: SortOrder
    Address?: SortOrder
    SortCode?: SortOrder
    Phone_1?: SortOrder
    Phone_2?: SortOrder
    FaxNumber?: SortOrder
    EMail?: SortOrder
    Comment?: SortOrder
  }

  export type Lkup_BanksVerBranchMinOrderByAggregateInput = {
    BranchID?: SortOrder
    BankID?: SortOrder
    BranchName?: SortOrder
    BranchCode?: SortOrder
    Address?: SortOrder
    SortCode?: SortOrder
    Phone_1?: SortOrder
    Phone_2?: SortOrder
    FaxNumber?: SortOrder
    EMail?: SortOrder
    Comment?: SortOrder
  }

  export type Lkup_BanksVerBranchSumOrderByAggregateInput = {
    BranchID?: SortOrder
    BankID?: SortOrder
  }

  export type Lkup_CityCountOrderByAggregateInput = {
    CityID?: SortOrder
    CityCode?: SortOrder
    CityName?: SortOrder
    CityNameEng?: SortOrder
  }

  export type Lkup_CityAvgOrderByAggregateInput = {
    CityID?: SortOrder
    CityCode?: SortOrder
  }

  export type Lkup_CityMaxOrderByAggregateInput = {
    CityID?: SortOrder
    CityCode?: SortOrder
    CityName?: SortOrder
    CityNameEng?: SortOrder
  }

  export type Lkup_CityMinOrderByAggregateInput = {
    CityID?: SortOrder
    CityCode?: SortOrder
    CityName?: SortOrder
    CityNameEng?: SortOrder
  }

  export type Lkup_CitySumOrderByAggregateInput = {
    CityID?: SortOrder
    CityCode?: SortOrder
  }

  export type Lkup_CorporationCountOrderByAggregateInput = {
    CorporationID?: SortOrder
    CorporationName?: SortOrder
    IsActive?: SortOrder
    CorporationNumber?: SortOrder
    Address?: SortOrder
    Email?: SortOrder
    Phone?: SortOrder
    Cfo_email?: SortOrder
    Contact_name?: SortOrder
    Contact_phone?: SortOrder
    Ops_email?: SortOrder
    SoftTalkTaxToken?: SortOrder
    CorporationAutoLink?: SortOrder
  }

  export type Lkup_CorporationAvgOrderByAggregateInput = {
    CorporationID?: SortOrder
    IsActive?: SortOrder
    CorporationNumber?: SortOrder
  }

  export type Lkup_CorporationMaxOrderByAggregateInput = {
    CorporationID?: SortOrder
    CorporationName?: SortOrder
    IsActive?: SortOrder
    CorporationNumber?: SortOrder
    Address?: SortOrder
    Email?: SortOrder
    Phone?: SortOrder
    Cfo_email?: SortOrder
    Contact_name?: SortOrder
    Contact_phone?: SortOrder
    Ops_email?: SortOrder
    SoftTalkTaxToken?: SortOrder
    CorporationAutoLink?: SortOrder
  }

  export type Lkup_CorporationMinOrderByAggregateInput = {
    CorporationID?: SortOrder
    CorporationName?: SortOrder
    IsActive?: SortOrder
    CorporationNumber?: SortOrder
    Address?: SortOrder
    Email?: SortOrder
    Phone?: SortOrder
    Cfo_email?: SortOrder
    Contact_name?: SortOrder
    Contact_phone?: SortOrder
    Ops_email?: SortOrder
    SoftTalkTaxToken?: SortOrder
    CorporationAutoLink?: SortOrder
  }

  export type Lkup_CorporationSumOrderByAggregateInput = {
    CorporationID?: SortOrder
    IsActive?: SortOrder
    CorporationNumber?: SortOrder
  }

  export type Lkup_CountryCountOrderByAggregateInput = {
    CountryID?: SortOrder
    CountryCode?: SortOrder
    CountryName?: SortOrder
    CountryNameEnglish?: SortOrder
    MultipleSelect?: SortOrder
  }

  export type Lkup_CountryAvgOrderByAggregateInput = {
    CountryID?: SortOrder
    MultipleSelect?: SortOrder
  }

  export type Lkup_CountryMaxOrderByAggregateInput = {
    CountryID?: SortOrder
    CountryCode?: SortOrder
    CountryName?: SortOrder
    CountryNameEnglish?: SortOrder
    MultipleSelect?: SortOrder
  }

  export type Lkup_CountryMinOrderByAggregateInput = {
    CountryID?: SortOrder
    CountryCode?: SortOrder
    CountryName?: SortOrder
    CountryNameEnglish?: SortOrder
    MultipleSelect?: SortOrder
  }

  export type Lkup_CountrySumOrderByAggregateInput = {
    CountryID?: SortOrder
    MultipleSelect?: SortOrder
  }

  export type Lkup_CreaditCardCountOrderByAggregateInput = {
    CardID?: SortOrder
    CardName?: SortOrder
    CardCode?: SortOrder
  }

  export type Lkup_CreaditCardAvgOrderByAggregateInput = {
    CardID?: SortOrder
    CardCode?: SortOrder
  }

  export type Lkup_CreaditCardMaxOrderByAggregateInput = {
    CardID?: SortOrder
    CardName?: SortOrder
    CardCode?: SortOrder
  }

  export type Lkup_CreaditCardMinOrderByAggregateInput = {
    CardID?: SortOrder
    CardName?: SortOrder
    CardCode?: SortOrder
  }

  export type Lkup_CreaditCardSumOrderByAggregateInput = {
    CardID?: SortOrder
    CardCode?: SortOrder
  }

  export type Lkup_EmployeesTypeCountOrderByAggregateInput = {
    TypeID?: SortOrder
    TypeName?: SortOrder
  }

  export type Lkup_EmployeesTypeAvgOrderByAggregateInput = {
    TypeID?: SortOrder
  }

  export type Lkup_EmployeesTypeMaxOrderByAggregateInput = {
    TypeID?: SortOrder
    TypeName?: SortOrder
  }

  export type Lkup_EmployeesTypeMinOrderByAggregateInput = {
    TypeID?: SortOrder
    TypeName?: SortOrder
  }

  export type Lkup_EmployeesTypeSumOrderByAggregateInput = {
    TypeID?: SortOrder
  }

  export type Lkup_LanguageCountOrderByAggregateInput = {
    LanguageID?: SortOrder
    LanguageName?: SortOrder
  }

  export type Lkup_LanguageAvgOrderByAggregateInput = {
    LanguageID?: SortOrder
  }

  export type Lkup_LanguageMaxOrderByAggregateInput = {
    LanguageID?: SortOrder
    LanguageName?: SortOrder
  }

  export type Lkup_LanguageMinOrderByAggregateInput = {
    LanguageID?: SortOrder
    LanguageName?: SortOrder
  }

  export type Lkup_LanguageSumOrderByAggregateInput = {
    LanguageID?: SortOrder
  }

  export type Lkup_PaySlipCountOrderByAggregateInput = {
    PaySlipCode?: SortOrder
    PaySlipName?: SortOrder
    PaySlipNameSource?: SortOrder
    IsTytle?: SortOrder
  }

  export type Lkup_PaySlipAvgOrderByAggregateInput = {
    PaySlipCode?: SortOrder
  }

  export type Lkup_PaySlipMaxOrderByAggregateInput = {
    PaySlipCode?: SortOrder
    PaySlipName?: SortOrder
    PaySlipNameSource?: SortOrder
    IsTytle?: SortOrder
  }

  export type Lkup_PaySlipMinOrderByAggregateInput = {
    PaySlipCode?: SortOrder
    PaySlipName?: SortOrder
    PaySlipNameSource?: SortOrder
    IsTytle?: SortOrder
  }

  export type Lkup_PaySlipSumOrderByAggregateInput = {
    PaySlipCode?: SortOrder
  }

  export type Lkup_SectorCountOrderByAggregateInput = {
    SectorID?: SortOrder
    SectorCode?: SortOrder
    SectorName?: SortOrder
  }

  export type Lkup_SectorAvgOrderByAggregateInput = {
    SectorID?: SortOrder
    SectorCode?: SortOrder
  }

  export type Lkup_SectorMaxOrderByAggregateInput = {
    SectorID?: SortOrder
    SectorCode?: SortOrder
    SectorName?: SortOrder
  }

  export type Lkup_SectorMinOrderByAggregateInput = {
    SectorID?: SortOrder
    SectorCode?: SortOrder
    SectorName?: SortOrder
  }

  export type Lkup_SectorSumOrderByAggregateInput = {
    SectorID?: SortOrder
    SectorCode?: SortOrder
  }

  export type Lkup_SocialSecuritySectorCountOrderByAggregateInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityCode?: SortOrder
    SocialSecurityName?: SortOrder
  }

  export type Lkup_SocialSecuritySectorAvgOrderByAggregateInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityCode?: SortOrder
  }

  export type Lkup_SocialSecuritySectorMaxOrderByAggregateInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityCode?: SortOrder
    SocialSecurityName?: SortOrder
  }

  export type Lkup_SocialSecuritySectorMinOrderByAggregateInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityCode?: SortOrder
    SocialSecurityName?: SortOrder
  }

  export type Lkup_SocialSecuritySectorSumOrderByAggregateInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityCode?: SortOrder
  }

  export type Lkup_streetCountOrderByAggregateInput = {
    StrretID?: SortOrder
    StreetName?: SortOrder
    StreetCode?: SortOrder
    Citycode?: SortOrder
    StreetNameEng?: SortOrder
  }

  export type Lkup_streetAvgOrderByAggregateInput = {
    StrretID?: SortOrder
    StreetCode?: SortOrder
    Citycode?: SortOrder
  }

  export type Lkup_streetMaxOrderByAggregateInput = {
    StrretID?: SortOrder
    StreetName?: SortOrder
    StreetCode?: SortOrder
    Citycode?: SortOrder
    StreetNameEng?: SortOrder
  }

  export type Lkup_streetMinOrderByAggregateInput = {
    StrretID?: SortOrder
    StreetName?: SortOrder
    StreetCode?: SortOrder
    Citycode?: SortOrder
    StreetNameEng?: SortOrder
  }

  export type Lkup_streetSumOrderByAggregateInput = {
    StrretID?: SortOrder
    StreetCode?: SortOrder
    Citycode?: SortOrder
  }

  export type PensionDetailCountOrderByAggregateInput = {
    PensionDetailID?: SortOrder
    TypePension?: SortOrder
    StartYearPension?: SortOrder
    EmployerRate?: SortOrder
    EmployeeRate?: SortOrder
    EmployerCompensationRate?: SortOrder
    TotalPensionRate?: SortOrder
    AvarageSalaryPension?: SortOrder
    Deposit?: SortOrder
  }

  export type PensionDetailAvgOrderByAggregateInput = {
    PensionDetailID?: SortOrder
    TypePension?: SortOrder
    StartYearPension?: SortOrder
    EmployerRate?: SortOrder
    EmployeeRate?: SortOrder
    EmployerCompensationRate?: SortOrder
    TotalPensionRate?: SortOrder
    AvarageSalaryPension?: SortOrder
    Deposit?: SortOrder
  }

  export type PensionDetailMaxOrderByAggregateInput = {
    PensionDetailID?: SortOrder
    TypePension?: SortOrder
    StartYearPension?: SortOrder
    EmployerRate?: SortOrder
    EmployeeRate?: SortOrder
    EmployerCompensationRate?: SortOrder
    TotalPensionRate?: SortOrder
    AvarageSalaryPension?: SortOrder
    Deposit?: SortOrder
  }

  export type PensionDetailMinOrderByAggregateInput = {
    PensionDetailID?: SortOrder
    TypePension?: SortOrder
    StartYearPension?: SortOrder
    EmployerRate?: SortOrder
    EmployeeRate?: SortOrder
    EmployerCompensationRate?: SortOrder
    TotalPensionRate?: SortOrder
    AvarageSalaryPension?: SortOrder
    Deposit?: SortOrder
  }

  export type PensionDetailSumOrderByAggregateInput = {
    PensionDetailID?: SortOrder
    TypePension?: SortOrder
    StartYearPension?: SortOrder
    EmployerRate?: SortOrder
    EmployeeRate?: SortOrder
    EmployerCompensationRate?: SortOrder
    TotalPensionRate?: SortOrder
    AvarageSalaryPension?: SortOrder
    Deposit?: SortOrder
  }

  export type ProductsCountOrderByAggregateInput = {
    ProductsId?: SortOrder
    ProductName?: SortOrder
    ProductDescription?: SortOrder
  }

  export type ProductsMaxOrderByAggregateInput = {
    ProductsId?: SortOrder
    ProductName?: SortOrder
    ProductDescription?: SortOrder
  }

  export type ProductsMinOrderByAggregateInput = {
    ProductsId?: SortOrder
    ProductName?: SortOrder
    ProductDescription?: SortOrder
  }

  export type RankCountOrderByAggregateInput = {
    RankID?: SortOrder
    SectorCode?: SortOrder
    RankYear?: SortOrder
    RankMonth?: SortOrder
    RankCode?: SortOrder
    RankName?: SortOrder
    Salary?: SortOrder
    RankNumber?: SortOrder
  }

  export type RankAvgOrderByAggregateInput = {
    RankID?: SortOrder
    SectorCode?: SortOrder
    RankYear?: SortOrder
    RankMonth?: SortOrder
    RankCode?: SortOrder
    Salary?: SortOrder
    RankNumber?: SortOrder
  }

  export type RankMaxOrderByAggregateInput = {
    RankID?: SortOrder
    SectorCode?: SortOrder
    RankYear?: SortOrder
    RankMonth?: SortOrder
    RankCode?: SortOrder
    RankName?: SortOrder
    Salary?: SortOrder
    RankNumber?: SortOrder
  }

  export type RankMinOrderByAggregateInput = {
    RankID?: SortOrder
    SectorCode?: SortOrder
    RankYear?: SortOrder
    RankMonth?: SortOrder
    RankCode?: SortOrder
    RankName?: SortOrder
    Salary?: SortOrder
    RankNumber?: SortOrder
  }

  export type RankSumOrderByAggregateInput = {
    RankID?: SortOrder
    SectorCode?: SortOrder
    RankYear?: SortOrder
    RankMonth?: SortOrder
    RankCode?: SortOrder
    Salary?: SortOrder
    RankNumber?: SortOrder
  }

  export type RecoveryDefinitionDetailsListRelationFilter = {
    every?: RecoveryDefinitionDetailsWhereInput
    some?: RecoveryDefinitionDetailsWhereInput
    none?: RecoveryDefinitionDetailsWhereInput
  }

  export type RecoveryDefinitionRateDetailsListRelationFilter = {
    every?: RecoveryDefinitionRateDetailsWhereInput
    some?: RecoveryDefinitionRateDetailsWhereInput
    none?: RecoveryDefinitionRateDetailsWhereInput
  }

  export type RecoveryDefinitionDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecoveryDefinitionRateDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecoveryDefinitionCountOrderByAggregateInput = {
    RecoveryDefinitionID?: SortOrder
    RecoveryDefinitionName?: SortOrder
    RecoveryYear?: SortOrder
  }

  export type RecoveryDefinitionAvgOrderByAggregateInput = {
    RecoveryDefinitionID?: SortOrder
  }

  export type RecoveryDefinitionMaxOrderByAggregateInput = {
    RecoveryDefinitionID?: SortOrder
    RecoveryDefinitionName?: SortOrder
    RecoveryYear?: SortOrder
  }

  export type RecoveryDefinitionMinOrderByAggregateInput = {
    RecoveryDefinitionID?: SortOrder
    RecoveryDefinitionName?: SortOrder
    RecoveryYear?: SortOrder
  }

  export type RecoveryDefinitionSumOrderByAggregateInput = {
    RecoveryDefinitionID?: SortOrder
  }

  export type RecoveryDefinitionNullableScalarRelationFilter = {
    is?: RecoveryDefinitionWhereInput | null
    isNot?: RecoveryDefinitionWhereInput | null
  }

  export type RecoveryDefinitionDetailsCountOrderByAggregateInput = {
    RewardRecoveryVectorID?: SortOrder
    RecoveryDefinitionID?: SortOrder
    StartYearRewardRecovery?: SortOrder
    EndYearRewardRecovery?: SortOrder
    RecoveryDayQuantity?: SortOrder
    RecoveryYearDescription?: SortOrder
  }

  export type RecoveryDefinitionDetailsAvgOrderByAggregateInput = {
    RewardRecoveryVectorID?: SortOrder
    RecoveryDefinitionID?: SortOrder
    StartYearRewardRecovery?: SortOrder
    EndYearRewardRecovery?: SortOrder
    RecoveryDayQuantity?: SortOrder
  }

  export type RecoveryDefinitionDetailsMaxOrderByAggregateInput = {
    RewardRecoveryVectorID?: SortOrder
    RecoveryDefinitionID?: SortOrder
    StartYearRewardRecovery?: SortOrder
    EndYearRewardRecovery?: SortOrder
    RecoveryDayQuantity?: SortOrder
    RecoveryYearDescription?: SortOrder
  }

  export type RecoveryDefinitionDetailsMinOrderByAggregateInput = {
    RewardRecoveryVectorID?: SortOrder
    RecoveryDefinitionID?: SortOrder
    StartYearRewardRecovery?: SortOrder
    EndYearRewardRecovery?: SortOrder
    RecoveryDayQuantity?: SortOrder
    RecoveryYearDescription?: SortOrder
  }

  export type RecoveryDefinitionDetailsSumOrderByAggregateInput = {
    RewardRecoveryVectorID?: SortOrder
    RecoveryDefinitionID?: SortOrder
    StartYearRewardRecovery?: SortOrder
    EndYearRewardRecovery?: SortOrder
    RecoveryDayQuantity?: SortOrder
  }

  export type RecoveryDefinitionRateDetailsCountOrderByAggregateInput = {
    RecoveryRewardID?: SortOrder
    RecoveryDefinitionID?: SortOrder
    RewardYearMonth?: SortOrder
    RecoveryRewardRatePerDay?: SortOrder
  }

  export type RecoveryDefinitionRateDetailsAvgOrderByAggregateInput = {
    RecoveryRewardID?: SortOrder
    RecoveryDefinitionID?: SortOrder
    RecoveryRewardRatePerDay?: SortOrder
  }

  export type RecoveryDefinitionRateDetailsMaxOrderByAggregateInput = {
    RecoveryRewardID?: SortOrder
    RecoveryDefinitionID?: SortOrder
    RewardYearMonth?: SortOrder
    RecoveryRewardRatePerDay?: SortOrder
  }

  export type RecoveryDefinitionRateDetailsMinOrderByAggregateInput = {
    RecoveryRewardID?: SortOrder
    RecoveryDefinitionID?: SortOrder
    RewardYearMonth?: SortOrder
    RecoveryRewardRatePerDay?: SortOrder
  }

  export type RecoveryDefinitionRateDetailsSumOrderByAggregateInput = {
    RecoveryRewardID?: SortOrder
    RecoveryDefinitionID?: SortOrder
    RecoveryRewardRatePerDay?: SortOrder
  }

  export type ReportDefinitionsReportNameFieldNameCompoundUniqueInput = {
    ReportName: string
    FieldName: string
  }

  export type ReportDefinitionsCountOrderByAggregateInput = {
    ReportID?: SortOrder
    ReportName?: SortOrder
    OrderBy?: SortOrder
    FieldName?: SortOrder
    Caption?: SortOrder
    Color?: SortOrder
    Background?: SortOrder
    ColumnWidth?: SortOrder
    FontStyle?: SortOrder
    FontSize?: SortOrder
    ReportTitle?: SortOrder
    IsSum?: SortOrder
    ColorIndex?: SortOrder
  }

  export type ReportDefinitionsAvgOrderByAggregateInput = {
    ReportID?: SortOrder
    OrderBy?: SortOrder
    Color?: SortOrder
    Background?: SortOrder
    ColumnWidth?: SortOrder
    FontSize?: SortOrder
    ColorIndex?: SortOrder
  }

  export type ReportDefinitionsMaxOrderByAggregateInput = {
    ReportID?: SortOrder
    ReportName?: SortOrder
    OrderBy?: SortOrder
    FieldName?: SortOrder
    Caption?: SortOrder
    Color?: SortOrder
    Background?: SortOrder
    ColumnWidth?: SortOrder
    FontStyle?: SortOrder
    FontSize?: SortOrder
    ReportTitle?: SortOrder
    IsSum?: SortOrder
    ColorIndex?: SortOrder
  }

  export type ReportDefinitionsMinOrderByAggregateInput = {
    ReportID?: SortOrder
    ReportName?: SortOrder
    OrderBy?: SortOrder
    FieldName?: SortOrder
    Caption?: SortOrder
    Color?: SortOrder
    Background?: SortOrder
    ColumnWidth?: SortOrder
    FontStyle?: SortOrder
    FontSize?: SortOrder
    ReportTitle?: SortOrder
    IsSum?: SortOrder
    ColorIndex?: SortOrder
  }

  export type ReportDefinitionsSumOrderByAggregateInput = {
    ReportID?: SortOrder
    OrderBy?: SortOrder
    Color?: SortOrder
    Background?: SortOrder
    ColumnWidth?: SortOrder
    FontSize?: SortOrder
    ColorIndex?: SortOrder
  }

  export type RewardRecoveryRateCountOrderByAggregateInput = {
    RecoveryRewardID?: SortOrder
    RewardYear?: SortOrder
    RecoveryRewardRatePerDay?: SortOrder
  }

  export type RewardRecoveryRateAvgOrderByAggregateInput = {
    RecoveryRewardID?: SortOrder
    RewardYear?: SortOrder
    RecoveryRewardRatePerDay?: SortOrder
  }

  export type RewardRecoveryRateMaxOrderByAggregateInput = {
    RecoveryRewardID?: SortOrder
    RewardYear?: SortOrder
    RecoveryRewardRatePerDay?: SortOrder
  }

  export type RewardRecoveryRateMinOrderByAggregateInput = {
    RecoveryRewardID?: SortOrder
    RewardYear?: SortOrder
    RecoveryRewardRatePerDay?: SortOrder
  }

  export type RewardRecoveryRateSumOrderByAggregateInput = {
    RecoveryRewardID?: SortOrder
    RewardYear?: SortOrder
    RecoveryRewardRatePerDay?: SortOrder
  }

  export type RewardRecoveryVectorCountOrderByAggregateInput = {
    RewardRecoveryVectorID?: SortOrder
    StartYearRewardRecovery?: SortOrder
    EndYearRewardRecovery?: SortOrder
    RecoveryDayQuantity?: SortOrder
  }

  export type RewardRecoveryVectorAvgOrderByAggregateInput = {
    RewardRecoveryVectorID?: SortOrder
    StartYearRewardRecovery?: SortOrder
    EndYearRewardRecovery?: SortOrder
    RecoveryDayQuantity?: SortOrder
  }

  export type RewardRecoveryVectorMaxOrderByAggregateInput = {
    RewardRecoveryVectorID?: SortOrder
    StartYearRewardRecovery?: SortOrder
    EndYearRewardRecovery?: SortOrder
    RecoveryDayQuantity?: SortOrder
  }

  export type RewardRecoveryVectorMinOrderByAggregateInput = {
    RewardRecoveryVectorID?: SortOrder
    StartYearRewardRecovery?: SortOrder
    EndYearRewardRecovery?: SortOrder
    RecoveryDayQuantity?: SortOrder
  }

  export type RewardRecoveryVectorSumOrderByAggregateInput = {
    RewardRecoveryVectorID?: SortOrder
    StartYearRewardRecovery?: SortOrder
    EndYearRewardRecovery?: SortOrder
    RecoveryDayQuantity?: SortOrder
  }

  export type RewardSickVectorCountOrderByAggregateInput = {
    RewardSickVectorID?: SortOrder
    StartYearRewardSick?: SortOrder
    EndYearRewardSick?: SortOrder
    SickDayQuantity?: SortOrder
  }

  export type RewardSickVectorAvgOrderByAggregateInput = {
    RewardSickVectorID?: SortOrder
    StartYearRewardSick?: SortOrder
    EndYearRewardSick?: SortOrder
    SickDayQuantity?: SortOrder
  }

  export type RewardSickVectorMaxOrderByAggregateInput = {
    RewardSickVectorID?: SortOrder
    StartYearRewardSick?: SortOrder
    EndYearRewardSick?: SortOrder
    SickDayQuantity?: SortOrder
  }

  export type RewardSickVectorMinOrderByAggregateInput = {
    RewardSickVectorID?: SortOrder
    StartYearRewardSick?: SortOrder
    EndYearRewardSick?: SortOrder
    SickDayQuantity?: SortOrder
  }

  export type RewardSickVectorSumOrderByAggregateInput = {
    RewardSickVectorID?: SortOrder
    StartYearRewardSick?: SortOrder
    EndYearRewardSick?: SortOrder
    SickDayQuantity?: SortOrder
  }

  export type RewardVacationVectorCountOrderByAggregateInput = {
    RewardVocationVectorID?: SortOrder
    StartYearRewardVocation?: SortOrder
    EndYearRewardVocation?: SortOrder
    VocationDayQuantity6days?: SortOrder
    VocationDayQuantity5days?: SortOrder
  }

  export type RewardVacationVectorAvgOrderByAggregateInput = {
    RewardVocationVectorID?: SortOrder
    StartYearRewardVocation?: SortOrder
    EndYearRewardVocation?: SortOrder
    VocationDayQuantity6days?: SortOrder
    VocationDayQuantity5days?: SortOrder
  }

  export type RewardVacationVectorMaxOrderByAggregateInput = {
    RewardVocationVectorID?: SortOrder
    StartYearRewardVocation?: SortOrder
    EndYearRewardVocation?: SortOrder
    VocationDayQuantity6days?: SortOrder
    VocationDayQuantity5days?: SortOrder
  }

  export type RewardVacationVectorMinOrderByAggregateInput = {
    RewardVocationVectorID?: SortOrder
    StartYearRewardVocation?: SortOrder
    EndYearRewardVocation?: SortOrder
    VocationDayQuantity6days?: SortOrder
    VocationDayQuantity5days?: SortOrder
  }

  export type RewardVacationVectorSumOrderByAggregateInput = {
    RewardVocationVectorID?: SortOrder
    StartYearRewardVocation?: SortOrder
    EndYearRewardVocation?: SortOrder
    VocationDayQuantity6days?: SortOrder
    VocationDayQuantity5days?: SortOrder
  }

  export type SickDefinitionDetailListRelationFilter = {
    every?: SickDefinitionDetailWhereInput
    some?: SickDefinitionDetailWhereInput
    none?: SickDefinitionDetailWhereInput
  }

  export type SickDefinitionDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SickDefinitionCountOrderByAggregateInput = {
    SickDefinitionID?: SortOrder
    SickDescription?: SortOrder
  }

  export type SickDefinitionAvgOrderByAggregateInput = {
    SickDefinitionID?: SortOrder
  }

  export type SickDefinitionMaxOrderByAggregateInput = {
    SickDefinitionID?: SortOrder
    SickDescription?: SortOrder
  }

  export type SickDefinitionMinOrderByAggregateInput = {
    SickDefinitionID?: SortOrder
    SickDescription?: SortOrder
  }

  export type SickDefinitionSumOrderByAggregateInput = {
    SickDefinitionID?: SortOrder
  }

  export type SickDefinitionScalarRelationFilter = {
    is?: SickDefinitionWhereInput
    isNot?: SickDefinitionWhereInput
  }

  export type SickDefinitionDetailCountOrderByAggregateInput = {
    RewardSickVectorID?: SortOrder
    SickDefinitionID?: SortOrder
    StartYearRewardSick?: SortOrder
    EndYearRewardSick?: SortOrder
    SickDayQuantity?: SortOrder
    SocialYearDescription?: SortOrder
  }

  export type SickDefinitionDetailAvgOrderByAggregateInput = {
    RewardSickVectorID?: SortOrder
    SickDefinitionID?: SortOrder
    StartYearRewardSick?: SortOrder
    EndYearRewardSick?: SortOrder
    SickDayQuantity?: SortOrder
  }

  export type SickDefinitionDetailMaxOrderByAggregateInput = {
    RewardSickVectorID?: SortOrder
    SickDefinitionID?: SortOrder
    StartYearRewardSick?: SortOrder
    EndYearRewardSick?: SortOrder
    SickDayQuantity?: SortOrder
    SocialYearDescription?: SortOrder
  }

  export type SickDefinitionDetailMinOrderByAggregateInput = {
    RewardSickVectorID?: SortOrder
    SickDefinitionID?: SortOrder
    StartYearRewardSick?: SortOrder
    EndYearRewardSick?: SortOrder
    SickDayQuantity?: SortOrder
    SocialYearDescription?: SortOrder
  }

  export type SickDefinitionDetailSumOrderByAggregateInput = {
    RewardSickVectorID?: SortOrder
    SickDefinitionID?: SortOrder
    StartYearRewardSick?: SortOrder
    EndYearRewardSick?: SortOrder
    SickDayQuantity?: SortOrder
  }

  export type SocialSecurityDetileListRelationFilter = {
    every?: SocialSecurityDetileWhereInput
    some?: SocialSecurityDetileWhereInput
    none?: SocialSecurityDetileWhereInput
  }

  export type SocialSecurityDetileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialSecurityCountOrderByAggregateInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityYear?: SortOrder
    SocialSecurityMonth?: SortOrder
    CurrentSocialSecurity?: SortOrder
    MinAccountTotalForDivuach?: SortOrder
  }

  export type SocialSecurityAvgOrderByAggregateInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityYear?: SortOrder
    SocialSecurityMonth?: SortOrder
    MinAccountTotalForDivuach?: SortOrder
  }

  export type SocialSecurityMaxOrderByAggregateInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityYear?: SortOrder
    SocialSecurityMonth?: SortOrder
    CurrentSocialSecurity?: SortOrder
    MinAccountTotalForDivuach?: SortOrder
  }

  export type SocialSecurityMinOrderByAggregateInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityYear?: SortOrder
    SocialSecurityMonth?: SortOrder
    CurrentSocialSecurity?: SortOrder
    MinAccountTotalForDivuach?: SortOrder
  }

  export type SocialSecuritySumOrderByAggregateInput = {
    SocialSecurityID?: SortOrder
    SocialSecurityYear?: SortOrder
    SocialSecurityMonth?: SortOrder
    MinAccountTotalForDivuach?: SortOrder
  }

  export type SocialSecurityScalarRelationFilter = {
    is?: SocialSecurityWhereInput
    isNot?: SocialSecurityWhereInput
  }

  export type SocialSecurityDetileCountOrderByAggregateInput = {
    SocialSecurityDetailID?: SortOrder
    SocialSecurityID?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    Sector?: SortOrder
    SocialSecurityCode?: SortOrder
    AverageSalary?: SortOrder
    MinNationalInsByMony?: SortOrder
    MaxNationalInsByMony?: SortOrder
    MinDeductionNationalInsByMony?: SortOrder
    MinNationalInsByEmployee?: SortOrder
    MaxNationalInsByEmployee?: SortOrder
    MinNationalInsByEmployer?: SortOrder
    MaxNationalInsByEmployer?: SortOrder
    MaxNationalInsByMonyEmployee?: SortOrder
    AverageEmbodiment?: SortOrder
    DeductionMax?: SortOrder
    DeductionPercent?: SortOrder
    CreditPoint?: SortOrder
    FactorToReduction?: SortOrder
    MinHoursToPay?: SortOrder
    MinimumPayFor5Day?: SortOrder
    MinimumPayFor6Day?: SortOrder
    MaxPrecentReduction?: SortOrder
    hourPerDayfor5?: SortOrder
    hourPerDayfor6?: SortOrder
    hourInfridayDay?: SortOrder
    TaxPrecent?: SortOrder
    EmployerTax?: SortOrder
    DiscountInTaxInEilat?: SortOrder
    TaxUnitNumber?: SortOrder
    FundPercentConstruction?: SortOrder
    Hour100?: SortOrder
    Hour125?: SortOrder
    Hour150?: SortOrder
    Hour175?: SortOrder
    Hour200?: SortOrder
    CreditCardMan?: SortOrder
    CreditCardWoman?: SortOrder
    CreditCardChild?: SortOrder
    CreditCardBaby?: SortOrder
    CreditCardInAddition?: SortOrder
    CreditCardLackMobilityChild?: SortOrder
    CreditCardImmigrant18?: SortOrder
    ControlingShareholder?: SortOrder
    HealthInsuranceEmployeeLow?: SortOrder
    HealthInsuranceEmployeeAbove?: SortOrder
    HealthInsuranceEmployerLow?: SortOrder
    HealthInsuranceEmployerAbove?: SortOrder
    ValueOfVehicleUseHibberdDiscount?: SortOrder
    Deposit?: SortOrder
    ValueOfMobileUse?: SortOrder
    PensionCeiling?: SortOrder
    PensionCredit?: SortOrder
    DepositEmployerPrecent?: SortOrder
    DepositEmployeePrecent?: SortOrder
    TotalHourPerWeek?: SortOrder
    CreditCardAdultChild?: SortOrder
    CreditCardChild1_5?: SortOrder
    DepositEmployeePrecentExecption?: SortOrder
  }

  export type SocialSecurityDetileAvgOrderByAggregateInput = {
    SocialSecurityDetailID?: SortOrder
    SocialSecurityID?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    Sector?: SortOrder
    SocialSecurityCode?: SortOrder
    AverageSalary?: SortOrder
    MinNationalInsByMony?: SortOrder
    MaxNationalInsByMony?: SortOrder
    MinDeductionNationalInsByMony?: SortOrder
    MinNationalInsByEmployee?: SortOrder
    MaxNationalInsByEmployee?: SortOrder
    MinNationalInsByEmployer?: SortOrder
    MaxNationalInsByEmployer?: SortOrder
    MaxNationalInsByMonyEmployee?: SortOrder
    AverageEmbodiment?: SortOrder
    DeductionMax?: SortOrder
    DeductionPercent?: SortOrder
    CreditPoint?: SortOrder
    FactorToReduction?: SortOrder
    MinHoursToPay?: SortOrder
    MinimumPayFor5Day?: SortOrder
    MinimumPayFor6Day?: SortOrder
    MaxPrecentReduction?: SortOrder
    hourPerDayfor5?: SortOrder
    hourPerDayfor6?: SortOrder
    hourInfridayDay?: SortOrder
    TaxPrecent?: SortOrder
    EmployerTax?: SortOrder
    DiscountInTaxInEilat?: SortOrder
    TaxUnitNumber?: SortOrder
    FundPercentConstruction?: SortOrder
    Hour100?: SortOrder
    Hour125?: SortOrder
    Hour150?: SortOrder
    Hour175?: SortOrder
    Hour200?: SortOrder
    CreditCardMan?: SortOrder
    CreditCardWoman?: SortOrder
    CreditCardChild?: SortOrder
    CreditCardBaby?: SortOrder
    CreditCardInAddition?: SortOrder
    CreditCardLackMobilityChild?: SortOrder
    CreditCardImmigrant18?: SortOrder
    HealthInsuranceEmployeeLow?: SortOrder
    HealthInsuranceEmployeeAbove?: SortOrder
    HealthInsuranceEmployerLow?: SortOrder
    HealthInsuranceEmployerAbove?: SortOrder
    ValueOfVehicleUseHibberdDiscount?: SortOrder
    Deposit?: SortOrder
    ValueOfMobileUse?: SortOrder
    PensionCeiling?: SortOrder
    PensionCredit?: SortOrder
    DepositEmployerPrecent?: SortOrder
    DepositEmployeePrecent?: SortOrder
    TotalHourPerWeek?: SortOrder
    CreditCardAdultChild?: SortOrder
    CreditCardChild1_5?: SortOrder
    DepositEmployeePrecentExecption?: SortOrder
  }

  export type SocialSecurityDetileMaxOrderByAggregateInput = {
    SocialSecurityDetailID?: SortOrder
    SocialSecurityID?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    Sector?: SortOrder
    SocialSecurityCode?: SortOrder
    AverageSalary?: SortOrder
    MinNationalInsByMony?: SortOrder
    MaxNationalInsByMony?: SortOrder
    MinDeductionNationalInsByMony?: SortOrder
    MinNationalInsByEmployee?: SortOrder
    MaxNationalInsByEmployee?: SortOrder
    MinNationalInsByEmployer?: SortOrder
    MaxNationalInsByEmployer?: SortOrder
    MaxNationalInsByMonyEmployee?: SortOrder
    AverageEmbodiment?: SortOrder
    DeductionMax?: SortOrder
    DeductionPercent?: SortOrder
    CreditPoint?: SortOrder
    FactorToReduction?: SortOrder
    MinHoursToPay?: SortOrder
    MinimumPayFor5Day?: SortOrder
    MinimumPayFor6Day?: SortOrder
    MaxPrecentReduction?: SortOrder
    hourPerDayfor5?: SortOrder
    hourPerDayfor6?: SortOrder
    hourInfridayDay?: SortOrder
    TaxPrecent?: SortOrder
    EmployerTax?: SortOrder
    DiscountInTaxInEilat?: SortOrder
    TaxUnitNumber?: SortOrder
    FundPercentConstruction?: SortOrder
    Hour100?: SortOrder
    Hour125?: SortOrder
    Hour150?: SortOrder
    Hour175?: SortOrder
    Hour200?: SortOrder
    CreditCardMan?: SortOrder
    CreditCardWoman?: SortOrder
    CreditCardChild?: SortOrder
    CreditCardBaby?: SortOrder
    CreditCardInAddition?: SortOrder
    CreditCardLackMobilityChild?: SortOrder
    CreditCardImmigrant18?: SortOrder
    ControlingShareholder?: SortOrder
    HealthInsuranceEmployeeLow?: SortOrder
    HealthInsuranceEmployeeAbove?: SortOrder
    HealthInsuranceEmployerLow?: SortOrder
    HealthInsuranceEmployerAbove?: SortOrder
    ValueOfVehicleUseHibberdDiscount?: SortOrder
    Deposit?: SortOrder
    ValueOfMobileUse?: SortOrder
    PensionCeiling?: SortOrder
    PensionCredit?: SortOrder
    DepositEmployerPrecent?: SortOrder
    DepositEmployeePrecent?: SortOrder
    TotalHourPerWeek?: SortOrder
    CreditCardAdultChild?: SortOrder
    CreditCardChild1_5?: SortOrder
    DepositEmployeePrecentExecption?: SortOrder
  }

  export type SocialSecurityDetileMinOrderByAggregateInput = {
    SocialSecurityDetailID?: SortOrder
    SocialSecurityID?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    Sector?: SortOrder
    SocialSecurityCode?: SortOrder
    AverageSalary?: SortOrder
    MinNationalInsByMony?: SortOrder
    MaxNationalInsByMony?: SortOrder
    MinDeductionNationalInsByMony?: SortOrder
    MinNationalInsByEmployee?: SortOrder
    MaxNationalInsByEmployee?: SortOrder
    MinNationalInsByEmployer?: SortOrder
    MaxNationalInsByEmployer?: SortOrder
    MaxNationalInsByMonyEmployee?: SortOrder
    AverageEmbodiment?: SortOrder
    DeductionMax?: SortOrder
    DeductionPercent?: SortOrder
    CreditPoint?: SortOrder
    FactorToReduction?: SortOrder
    MinHoursToPay?: SortOrder
    MinimumPayFor5Day?: SortOrder
    MinimumPayFor6Day?: SortOrder
    MaxPrecentReduction?: SortOrder
    hourPerDayfor5?: SortOrder
    hourPerDayfor6?: SortOrder
    hourInfridayDay?: SortOrder
    TaxPrecent?: SortOrder
    EmployerTax?: SortOrder
    DiscountInTaxInEilat?: SortOrder
    TaxUnitNumber?: SortOrder
    FundPercentConstruction?: SortOrder
    Hour100?: SortOrder
    Hour125?: SortOrder
    Hour150?: SortOrder
    Hour175?: SortOrder
    Hour200?: SortOrder
    CreditCardMan?: SortOrder
    CreditCardWoman?: SortOrder
    CreditCardChild?: SortOrder
    CreditCardBaby?: SortOrder
    CreditCardInAddition?: SortOrder
    CreditCardLackMobilityChild?: SortOrder
    CreditCardImmigrant18?: SortOrder
    ControlingShareholder?: SortOrder
    HealthInsuranceEmployeeLow?: SortOrder
    HealthInsuranceEmployeeAbove?: SortOrder
    HealthInsuranceEmployerLow?: SortOrder
    HealthInsuranceEmployerAbove?: SortOrder
    ValueOfVehicleUseHibberdDiscount?: SortOrder
    Deposit?: SortOrder
    ValueOfMobileUse?: SortOrder
    PensionCeiling?: SortOrder
    PensionCredit?: SortOrder
    DepositEmployerPrecent?: SortOrder
    DepositEmployeePrecent?: SortOrder
    TotalHourPerWeek?: SortOrder
    CreditCardAdultChild?: SortOrder
    CreditCardChild1_5?: SortOrder
    DepositEmployeePrecentExecption?: SortOrder
  }

  export type SocialSecurityDetileSumOrderByAggregateInput = {
    SocialSecurityDetailID?: SortOrder
    SocialSecurityID?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    Sector?: SortOrder
    SocialSecurityCode?: SortOrder
    AverageSalary?: SortOrder
    MinNationalInsByMony?: SortOrder
    MaxNationalInsByMony?: SortOrder
    MinDeductionNationalInsByMony?: SortOrder
    MinNationalInsByEmployee?: SortOrder
    MaxNationalInsByEmployee?: SortOrder
    MinNationalInsByEmployer?: SortOrder
    MaxNationalInsByEmployer?: SortOrder
    MaxNationalInsByMonyEmployee?: SortOrder
    AverageEmbodiment?: SortOrder
    DeductionMax?: SortOrder
    DeductionPercent?: SortOrder
    CreditPoint?: SortOrder
    FactorToReduction?: SortOrder
    MinHoursToPay?: SortOrder
    MinimumPayFor5Day?: SortOrder
    MinimumPayFor6Day?: SortOrder
    MaxPrecentReduction?: SortOrder
    hourPerDayfor5?: SortOrder
    hourPerDayfor6?: SortOrder
    hourInfridayDay?: SortOrder
    TaxPrecent?: SortOrder
    EmployerTax?: SortOrder
    DiscountInTaxInEilat?: SortOrder
    TaxUnitNumber?: SortOrder
    FundPercentConstruction?: SortOrder
    Hour100?: SortOrder
    Hour125?: SortOrder
    Hour150?: SortOrder
    Hour175?: SortOrder
    Hour200?: SortOrder
    CreditCardMan?: SortOrder
    CreditCardWoman?: SortOrder
    CreditCardChild?: SortOrder
    CreditCardBaby?: SortOrder
    CreditCardInAddition?: SortOrder
    CreditCardLackMobilityChild?: SortOrder
    CreditCardImmigrant18?: SortOrder
    HealthInsuranceEmployeeLow?: SortOrder
    HealthInsuranceEmployeeAbove?: SortOrder
    HealthInsuranceEmployerLow?: SortOrder
    HealthInsuranceEmployerAbove?: SortOrder
    ValueOfVehicleUseHibberdDiscount?: SortOrder
    Deposit?: SortOrder
    ValueOfMobileUse?: SortOrder
    PensionCeiling?: SortOrder
    PensionCredit?: SortOrder
    DepositEmployerPrecent?: SortOrder
    DepositEmployeePrecent?: SortOrder
    TotalHourPerWeek?: SortOrder
    CreditCardAdultChild?: SortOrder
    CreditCardChild1_5?: SortOrder
    DepositEmployeePrecentExecption?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type sysdiagramsPrincipal_idNameCompoundUniqueInput = {
    principal_id: number
    name: string
  }

  export type sysdiagramsCountOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsAvgOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type sysdiagramsMaxOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsMinOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsSumOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type SystemDefinitionCountOrderByAggregateInput = {
    SystemDefinitionId?: SortOrder
    CreatedAt?: SortOrder
    FieldDescription?: SortOrder
    FieldValue?: SortOrder
  }

  export type SystemDefinitionMaxOrderByAggregateInput = {
    SystemDefinitionId?: SortOrder
    CreatedAt?: SortOrder
    FieldDescription?: SortOrder
    FieldValue?: SortOrder
  }

  export type SystemDefinitionMinOrderByAggregateInput = {
    SystemDefinitionId?: SortOrder
    CreatedAt?: SortOrder
    FieldDescription?: SortOrder
    FieldValue?: SortOrder
  }

  export type SystemMaintenancCountOrderByAggregateInput = {
    SystemMaintenancID?: SortOrder
    UserMsg?: SortOrder
    LogOutFrequency?: SortOrder
    SystemMaintenanc?: SortOrder
  }

  export type SystemMaintenancAvgOrderByAggregateInput = {
    SystemMaintenancID?: SortOrder
    LogOutFrequency?: SortOrder
  }

  export type SystemMaintenancMaxOrderByAggregateInput = {
    SystemMaintenancID?: SortOrder
    UserMsg?: SortOrder
    LogOutFrequency?: SortOrder
    SystemMaintenanc?: SortOrder
  }

  export type SystemMaintenancMinOrderByAggregateInput = {
    SystemMaintenancID?: SortOrder
    UserMsg?: SortOrder
    LogOutFrequency?: SortOrder
    SystemMaintenanc?: SortOrder
  }

  export type SystemMaintenancSumOrderByAggregateInput = {
    SystemMaintenancID?: SortOrder
    LogOutFrequency?: SortOrder
  }

  export type TaxStepsScalarRelationFilter = {
    is?: TaxStepsWhereInput
    isNot?: TaxStepsWhereInput
  }

  export type TaxStepDetileCountOrderByAggregateInput = {
    TaxStepDetileID?: SortOrder
    TaxStapID?: SortOrder
    TaxYear?: SortOrder
    TaxMonth?: SortOrder
    StepNumber?: SortOrder
    TaxStap?: SortOrder
    TaxStapPercent?: SortOrder
  }

  export type TaxStepDetileAvgOrderByAggregateInput = {
    TaxStepDetileID?: SortOrder
    TaxStapID?: SortOrder
    TaxYear?: SortOrder
    TaxMonth?: SortOrder
    StepNumber?: SortOrder
    TaxStap?: SortOrder
    TaxStapPercent?: SortOrder
  }

  export type TaxStepDetileMaxOrderByAggregateInput = {
    TaxStepDetileID?: SortOrder
    TaxStapID?: SortOrder
    TaxYear?: SortOrder
    TaxMonth?: SortOrder
    StepNumber?: SortOrder
    TaxStap?: SortOrder
    TaxStapPercent?: SortOrder
  }

  export type TaxStepDetileMinOrderByAggregateInput = {
    TaxStepDetileID?: SortOrder
    TaxStapID?: SortOrder
    TaxYear?: SortOrder
    TaxMonth?: SortOrder
    StepNumber?: SortOrder
    TaxStap?: SortOrder
    TaxStapPercent?: SortOrder
  }

  export type TaxStepDetileSumOrderByAggregateInput = {
    TaxStepDetileID?: SortOrder
    TaxStapID?: SortOrder
    TaxYear?: SortOrder
    TaxMonth?: SortOrder
    StepNumber?: SortOrder
    TaxStap?: SortOrder
    TaxStapPercent?: SortOrder
  }

  export type TaxStepDetileListRelationFilter = {
    every?: TaxStepDetileWhereInput
    some?: TaxStepDetileWhereInput
    none?: TaxStepDetileWhereInput
  }

  export type TaxStepDetileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxStepsCountOrderByAggregateInput = {
    TaxStapID?: SortOrder
    TaxMonth?: SortOrder
    TaxYear?: SortOrder
    CurrentTaxStep?: SortOrder
  }

  export type TaxStepsAvgOrderByAggregateInput = {
    TaxStapID?: SortOrder
    TaxMonth?: SortOrder
    TaxYear?: SortOrder
  }

  export type TaxStepsMaxOrderByAggregateInput = {
    TaxStapID?: SortOrder
    TaxMonth?: SortOrder
    TaxYear?: SortOrder
    CurrentTaxStep?: SortOrder
  }

  export type TaxStepsMinOrderByAggregateInput = {
    TaxStapID?: SortOrder
    TaxMonth?: SortOrder
    TaxYear?: SortOrder
    CurrentTaxStep?: SortOrder
  }

  export type TaxStepsSumOrderByAggregateInput = {
    TaxStapID?: SortOrder
    TaxMonth?: SortOrder
    TaxYear?: SortOrder
  }

  export type UnionFeeDetileListRelationFilter = {
    every?: UnionFeeDetileWhereInput
    some?: UnionFeeDetileWhereInput
    none?: UnionFeeDetileWhereInput
  }

  export type UnionFeeDetileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnionFeeCountOrderByAggregateInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
    UnionName?: SortOrder
  }

  export type UnionFeeAvgOrderByAggregateInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
  }

  export type UnionFeeMaxOrderByAggregateInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
    UnionName?: SortOrder
  }

  export type UnionFeeMinOrderByAggregateInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
    UnionName?: SortOrder
  }

  export type UnionFeeSumOrderByAggregateInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
  }

  export type UnionFeeScalarRelationFilter = {
    is?: UnionFeeWhereInput
    isNot?: UnionFeeWhereInput
  }

  export type UnionFeeDetileCountOrderByAggregateInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    FeePercentage_No?: SortOrder
    FeePercentage_Yes?: SortOrder
    MaxFee?: SortOrder
    MaxAdminFee?: SortOrder
  }

  export type UnionFeeDetileAvgOrderByAggregateInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    FeePercentage_No?: SortOrder
    FeePercentage_Yes?: SortOrder
    MaxFee?: SortOrder
    MaxAdminFee?: SortOrder
  }

  export type UnionFeeDetileMaxOrderByAggregateInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    FeePercentage_No?: SortOrder
    FeePercentage_Yes?: SortOrder
    MaxFee?: SortOrder
    MaxAdminFee?: SortOrder
  }

  export type UnionFeeDetileMinOrderByAggregateInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    FeePercentage_No?: SortOrder
    FeePercentage_Yes?: SortOrder
    MaxFee?: SortOrder
    MaxAdminFee?: SortOrder
  }

  export type UnionFeeDetileSumOrderByAggregateInput = {
    ID?: SortOrder
    UnionCode?: SortOrder
    SocialYear?: SortOrder
    SocialMonth?: SortOrder
    FeePercentage_No?: SortOrder
    FeePercentage_Yes?: SortOrder
    MaxFee?: SortOrder
    MaxAdminFee?: SortOrder
  }

  export type VacationlDefinitionNullableScalarRelationFilter = {
    is?: VacationlDefinitionWhereInput | null
    isNot?: VacationlDefinitionWhereInput | null
  }

  export type VacationDefinitionDetailsCountOrderByAggregateInput = {
    VacationlDefinitionDetaillID?: SortOrder
    VacationlDefinitionID?: SortOrder
    StartMonthReward?: SortOrder
    EndMonthrReward?: SortOrder
    DayQuantity6days?: SortOrder
    DayQuantity5days?: SortOrder
    SocialYearDescription?: SortOrder
    DayQuantity?: SortOrder
  }

  export type VacationDefinitionDetailsAvgOrderByAggregateInput = {
    VacationlDefinitionDetaillID?: SortOrder
    VacationlDefinitionID?: SortOrder
    StartMonthReward?: SortOrder
    EndMonthrReward?: SortOrder
    DayQuantity6days?: SortOrder
    DayQuantity5days?: SortOrder
    DayQuantity?: SortOrder
  }

  export type VacationDefinitionDetailsMaxOrderByAggregateInput = {
    VacationlDefinitionDetaillID?: SortOrder
    VacationlDefinitionID?: SortOrder
    StartMonthReward?: SortOrder
    EndMonthrReward?: SortOrder
    DayQuantity6days?: SortOrder
    DayQuantity5days?: SortOrder
    SocialYearDescription?: SortOrder
    DayQuantity?: SortOrder
  }

  export type VacationDefinitionDetailsMinOrderByAggregateInput = {
    VacationlDefinitionDetaillID?: SortOrder
    VacationlDefinitionID?: SortOrder
    StartMonthReward?: SortOrder
    EndMonthrReward?: SortOrder
    DayQuantity6days?: SortOrder
    DayQuantity5days?: SortOrder
    SocialYearDescription?: SortOrder
    DayQuantity?: SortOrder
  }

  export type VacationDefinitionDetailsSumOrderByAggregateInput = {
    VacationlDefinitionDetaillID?: SortOrder
    VacationlDefinitionID?: SortOrder
    StartMonthReward?: SortOrder
    EndMonthrReward?: SortOrder
    DayQuantity6days?: SortOrder
    DayQuantity5days?: SortOrder
    DayQuantity?: SortOrder
  }

  export type VacationDefinitionDetailsListRelationFilter = {
    every?: VacationDefinitionDetailsWhereInput
    some?: VacationDefinitionDetailsWhereInput
    none?: VacationDefinitionDetailsWhereInput
  }

  export type VacationDefinitionDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VacationlDefinitionCountOrderByAggregateInput = {
    VacationlDefinitionID?: SortOrder
    VacationlDefinitionName?: SortOrder
  }

  export type VacationlDefinitionAvgOrderByAggregateInput = {
    VacationlDefinitionID?: SortOrder
  }

  export type VacationlDefinitionMaxOrderByAggregateInput = {
    VacationlDefinitionID?: SortOrder
    VacationlDefinitionName?: SortOrder
  }

  export type VacationlDefinitionMinOrderByAggregateInput = {
    VacationlDefinitionID?: SortOrder
    VacationlDefinitionName?: SortOrder
  }

  export type VacationlDefinitionSumOrderByAggregateInput = {
    VacationlDefinitionID?: SortOrder
  }

  export type ValueOfVehicleUseCountOrderByAggregateInput = {
    ValueOfVehicleUselID?: SortOrder
    Year?: SortOrder
    Month?: SortOrder
    GroupOfVehicle?: SortOrder
    Value?: SortOrder
  }

  export type ValueOfVehicleUseAvgOrderByAggregateInput = {
    ValueOfVehicleUselID?: SortOrder
    Year?: SortOrder
    Month?: SortOrder
    GroupOfVehicle?: SortOrder
    Value?: SortOrder
  }

  export type ValueOfVehicleUseMaxOrderByAggregateInput = {
    ValueOfVehicleUselID?: SortOrder
    Year?: SortOrder
    Month?: SortOrder
    GroupOfVehicle?: SortOrder
    Value?: SortOrder
  }

  export type ValueOfVehicleUseMinOrderByAggregateInput = {
    ValueOfVehicleUselID?: SortOrder
    Year?: SortOrder
    Month?: SortOrder
    GroupOfVehicle?: SortOrder
    Value?: SortOrder
  }

  export type ValueOfVehicleUseSumOrderByAggregateInput = {
    ValueOfVehicleUselID?: SortOrder
    Year?: SortOrder
    Month?: SortOrder
    GroupOfVehicle?: SortOrder
    Value?: SortOrder
  }

  export type ValueOfVehicleUseByDetileCountOrderByAggregateInput = {
    ID?: SortOrder
    Year?: SortOrder
    RegistryYear?: SortOrder
    VehicleCode?: SortOrder
    ProductCode?: SortOrder
    ProductName?: SortOrder
    ModelCode?: SortOrder
    ModelName?: SortOrder
    FuelType?: SortOrder
    CommercialName?: SortOrder
    Automatic?: SortOrder
    Hybrid?: SortOrder
    GreenGrade?: SortOrder
    PolutionGrade?: SortOrder
    EngineVolume?: SortOrder
    Weight?: SortOrder
    BeginDate?: SortOrder
    ListPrice?: SortOrder
    AjustedPrice?: SortOrder
    Value?: SortOrder
  }

  export type ValueOfVehicleUseByDetileAvgOrderByAggregateInput = {
    ID?: SortOrder
    Year?: SortOrder
    RegistryYear?: SortOrder
    VehicleCode?: SortOrder
    ProductCode?: SortOrder
    ModelCode?: SortOrder
    FuelType?: SortOrder
    Automatic?: SortOrder
    Hybrid?: SortOrder
    GreenGrade?: SortOrder
    PolutionGrade?: SortOrder
    EngineVolume?: SortOrder
    Weight?: SortOrder
    ListPrice?: SortOrder
    AjustedPrice?: SortOrder
    Value?: SortOrder
  }

  export type ValueOfVehicleUseByDetileMaxOrderByAggregateInput = {
    ID?: SortOrder
    Year?: SortOrder
    RegistryYear?: SortOrder
    VehicleCode?: SortOrder
    ProductCode?: SortOrder
    ProductName?: SortOrder
    ModelCode?: SortOrder
    ModelName?: SortOrder
    FuelType?: SortOrder
    CommercialName?: SortOrder
    Automatic?: SortOrder
    Hybrid?: SortOrder
    GreenGrade?: SortOrder
    PolutionGrade?: SortOrder
    EngineVolume?: SortOrder
    Weight?: SortOrder
    BeginDate?: SortOrder
    ListPrice?: SortOrder
    AjustedPrice?: SortOrder
    Value?: SortOrder
  }

  export type ValueOfVehicleUseByDetileMinOrderByAggregateInput = {
    ID?: SortOrder
    Year?: SortOrder
    RegistryYear?: SortOrder
    VehicleCode?: SortOrder
    ProductCode?: SortOrder
    ProductName?: SortOrder
    ModelCode?: SortOrder
    ModelName?: SortOrder
    FuelType?: SortOrder
    CommercialName?: SortOrder
    Automatic?: SortOrder
    Hybrid?: SortOrder
    GreenGrade?: SortOrder
    PolutionGrade?: SortOrder
    EngineVolume?: SortOrder
    Weight?: SortOrder
    BeginDate?: SortOrder
    ListPrice?: SortOrder
    AjustedPrice?: SortOrder
    Value?: SortOrder
  }

  export type ValueOfVehicleUseByDetileSumOrderByAggregateInput = {
    ID?: SortOrder
    Year?: SortOrder
    RegistryYear?: SortOrder
    VehicleCode?: SortOrder
    ProductCode?: SortOrder
    ModelCode?: SortOrder
    FuelType?: SortOrder
    Automatic?: SortOrder
    Hybrid?: SortOrder
    GreenGrade?: SortOrder
    PolutionGrade?: SortOrder
    EngineVolume?: SortOrder
    Weight?: SortOrder
    ListPrice?: SortOrder
    AjustedPrice?: SortOrder
    Value?: SortOrder
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AutoWordReportSubCreateNestedManyWithoutAutoWordReportInput = {
    create?: XOR<AutoWordReportSubCreateWithoutAutoWordReportInput, AutoWordReportSubUncheckedCreateWithoutAutoWordReportInput> | AutoWordReportSubCreateWithoutAutoWordReportInput[] | AutoWordReportSubUncheckedCreateWithoutAutoWordReportInput[]
    connectOrCreate?: AutoWordReportSubCreateOrConnectWithoutAutoWordReportInput | AutoWordReportSubCreateOrConnectWithoutAutoWordReportInput[]
    createMany?: AutoWordReportSubCreateManyAutoWordReportInputEnvelope
    connect?: AutoWordReportSubWhereUniqueInput | AutoWordReportSubWhereUniqueInput[]
  }

  export type AutoWordReportSubUncheckedCreateNestedManyWithoutAutoWordReportInput = {
    create?: XOR<AutoWordReportSubCreateWithoutAutoWordReportInput, AutoWordReportSubUncheckedCreateWithoutAutoWordReportInput> | AutoWordReportSubCreateWithoutAutoWordReportInput[] | AutoWordReportSubUncheckedCreateWithoutAutoWordReportInput[]
    connectOrCreate?: AutoWordReportSubCreateOrConnectWithoutAutoWordReportInput | AutoWordReportSubCreateOrConnectWithoutAutoWordReportInput[]
    createMany?: AutoWordReportSubCreateManyAutoWordReportInputEnvelope
    connect?: AutoWordReportSubWhereUniqueInput | AutoWordReportSubWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AutoWordReportSubUpdateManyWithoutAutoWordReportNestedInput = {
    create?: XOR<AutoWordReportSubCreateWithoutAutoWordReportInput, AutoWordReportSubUncheckedCreateWithoutAutoWordReportInput> | AutoWordReportSubCreateWithoutAutoWordReportInput[] | AutoWordReportSubUncheckedCreateWithoutAutoWordReportInput[]
    connectOrCreate?: AutoWordReportSubCreateOrConnectWithoutAutoWordReportInput | AutoWordReportSubCreateOrConnectWithoutAutoWordReportInput[]
    upsert?: AutoWordReportSubUpsertWithWhereUniqueWithoutAutoWordReportInput | AutoWordReportSubUpsertWithWhereUniqueWithoutAutoWordReportInput[]
    createMany?: AutoWordReportSubCreateManyAutoWordReportInputEnvelope
    set?: AutoWordReportSubWhereUniqueInput | AutoWordReportSubWhereUniqueInput[]
    disconnect?: AutoWordReportSubWhereUniqueInput | AutoWordReportSubWhereUniqueInput[]
    delete?: AutoWordReportSubWhereUniqueInput | AutoWordReportSubWhereUniqueInput[]
    connect?: AutoWordReportSubWhereUniqueInput | AutoWordReportSubWhereUniqueInput[]
    update?: AutoWordReportSubUpdateWithWhereUniqueWithoutAutoWordReportInput | AutoWordReportSubUpdateWithWhereUniqueWithoutAutoWordReportInput[]
    updateMany?: AutoWordReportSubUpdateManyWithWhereWithoutAutoWordReportInput | AutoWordReportSubUpdateManyWithWhereWithoutAutoWordReportInput[]
    deleteMany?: AutoWordReportSubScalarWhereInput | AutoWordReportSubScalarWhereInput[]
  }

  export type AutoWordReportSubUncheckedUpdateManyWithoutAutoWordReportNestedInput = {
    create?: XOR<AutoWordReportSubCreateWithoutAutoWordReportInput, AutoWordReportSubUncheckedCreateWithoutAutoWordReportInput> | AutoWordReportSubCreateWithoutAutoWordReportInput[] | AutoWordReportSubUncheckedCreateWithoutAutoWordReportInput[]
    connectOrCreate?: AutoWordReportSubCreateOrConnectWithoutAutoWordReportInput | AutoWordReportSubCreateOrConnectWithoutAutoWordReportInput[]
    upsert?: AutoWordReportSubUpsertWithWhereUniqueWithoutAutoWordReportInput | AutoWordReportSubUpsertWithWhereUniqueWithoutAutoWordReportInput[]
    createMany?: AutoWordReportSubCreateManyAutoWordReportInputEnvelope
    set?: AutoWordReportSubWhereUniqueInput | AutoWordReportSubWhereUniqueInput[]
    disconnect?: AutoWordReportSubWhereUniqueInput | AutoWordReportSubWhereUniqueInput[]
    delete?: AutoWordReportSubWhereUniqueInput | AutoWordReportSubWhereUniqueInput[]
    connect?: AutoWordReportSubWhereUniqueInput | AutoWordReportSubWhereUniqueInput[]
    update?: AutoWordReportSubUpdateWithWhereUniqueWithoutAutoWordReportInput | AutoWordReportSubUpdateWithWhereUniqueWithoutAutoWordReportInput[]
    updateMany?: AutoWordReportSubUpdateManyWithWhereWithoutAutoWordReportInput | AutoWordReportSubUpdateManyWithWhereWithoutAutoWordReportInput[]
    deleteMany?: AutoWordReportSubScalarWhereInput | AutoWordReportSubScalarWhereInput[]
  }

  export type AutoWordReportCreateNestedOneWithoutAutoWordReportSubInput = {
    create?: XOR<AutoWordReportCreateWithoutAutoWordReportSubInput, AutoWordReportUncheckedCreateWithoutAutoWordReportSubInput>
    connectOrCreate?: AutoWordReportCreateOrConnectWithoutAutoWordReportSubInput
    connect?: AutoWordReportWhereUniqueInput
  }

  export type AutoWordReportUpdateOneWithoutAutoWordReportSubNestedInput = {
    create?: XOR<AutoWordReportCreateWithoutAutoWordReportSubInput, AutoWordReportUncheckedCreateWithoutAutoWordReportSubInput>
    connectOrCreate?: AutoWordReportCreateOrConnectWithoutAutoWordReportSubInput
    upsert?: AutoWordReportUpsertWithoutAutoWordReportSubInput
    disconnect?: AutoWordReportWhereInput | boolean
    delete?: AutoWordReportWhereInput | boolean
    connect?: AutoWordReportWhereUniqueInput
    update?: XOR<XOR<AutoWordReportUpdateToOneWithWhereWithoutAutoWordReportSubInput, AutoWordReportUpdateWithoutAutoWordReportSubInput>, AutoWordReportUncheckedUpdateWithoutAutoWordReportSubInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type CompaniesTypeCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<CompaniesTypeCreateWithoutCompaniesInput, CompaniesTypeUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: CompaniesTypeCreateOrConnectWithoutCompaniesInput
    connect?: CompaniesTypeWhereUniqueInput
  }

  export type CompaniesUsersCreateNestedOneWithoutCompanies_Companies_UserIdToCompaniesUsersInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompanies_Companies_UserIdToCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompanies_Companies_UserIdToCompaniesUsersInput>
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompanies_Companies_UserIdToCompaniesUsersInput
    connect?: CompaniesUsersWhereUniqueInput
  }

  export type CompaniesProductsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<CompaniesProductsCreateWithoutCompaniesInput, CompaniesProductsUncheckedCreateWithoutCompaniesInput> | CompaniesProductsCreateWithoutCompaniesInput[] | CompaniesProductsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: CompaniesProductsCreateOrConnectWithoutCompaniesInput | CompaniesProductsCreateOrConnectWithoutCompaniesInput[]
    createMany?: CompaniesProductsCreateManyCompaniesInputEnvelope
    connect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
  }

  export type CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<CompaniesProductsExpireDatesCreateWithoutCompaniesInput, CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesInput> | CompaniesProductsExpireDatesCreateWithoutCompaniesInput[] | CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesInput | CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesInput[]
    createMany?: CompaniesProductsExpireDatesCreateManyCompaniesInputEnvelope
    connect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
  }

  export type CompaniesUsersCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUsersUncheckedCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput> | CompaniesUsersCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[] | CompaniesUsersUncheckedCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput | CompaniesUsersCreateOrConnectWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    createMany?: CompaniesUsersCreateManyCompanies_CompaniesUsers_CompanyIDToCompaniesInputEnvelope
    connect?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
  }

  export type CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesInput> | CompaniesUsersProductsExpireDatesCreateWithoutCompaniesInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyCompaniesInputEnvelope
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
  }

  export type LandPagesCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<LandPagesCreateWithoutCompaniesInput, LandPagesUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: LandPagesCreateOrConnectWithoutCompaniesInput
    connect?: LandPagesWhereUniqueInput
  }

  export type CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<CompaniesProductsCreateWithoutCompaniesInput, CompaniesProductsUncheckedCreateWithoutCompaniesInput> | CompaniesProductsCreateWithoutCompaniesInput[] | CompaniesProductsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: CompaniesProductsCreateOrConnectWithoutCompaniesInput | CompaniesProductsCreateOrConnectWithoutCompaniesInput[]
    createMany?: CompaniesProductsCreateManyCompaniesInputEnvelope
    connect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
  }

  export type CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<CompaniesProductsExpireDatesCreateWithoutCompaniesInput, CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesInput> | CompaniesProductsExpireDatesCreateWithoutCompaniesInput[] | CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesInput | CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesInput[]
    createMany?: CompaniesProductsExpireDatesCreateManyCompaniesInputEnvelope
    connect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
  }

  export type CompaniesUsersUncheckedCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUsersUncheckedCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput> | CompaniesUsersCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[] | CompaniesUsersUncheckedCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput | CompaniesUsersCreateOrConnectWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    createMany?: CompaniesUsersCreateManyCompanies_CompaniesUsers_CompanyIDToCompaniesInputEnvelope
    connect?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
  }

  export type CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesInput> | CompaniesUsersProductsExpireDatesCreateWithoutCompaniesInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyCompaniesInputEnvelope
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
  }

  export type LandPagesUncheckedCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<LandPagesCreateWithoutCompaniesInput, LandPagesUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: LandPagesCreateOrConnectWithoutCompaniesInput
    connect?: LandPagesWhereUniqueInput
  }

  export type CompaniesTypeUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<CompaniesTypeCreateWithoutCompaniesInput, CompaniesTypeUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: CompaniesTypeCreateOrConnectWithoutCompaniesInput
    upsert?: CompaniesTypeUpsertWithoutCompaniesInput
    connect?: CompaniesTypeWhereUniqueInput
    update?: XOR<XOR<CompaniesTypeUpdateToOneWithWhereWithoutCompaniesInput, CompaniesTypeUpdateWithoutCompaniesInput>, CompaniesTypeUncheckedUpdateWithoutCompaniesInput>
  }

  export type CompaniesUsersUpdateOneWithoutCompanies_Companies_UserIdToCompaniesUsersNestedInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompanies_Companies_UserIdToCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompanies_Companies_UserIdToCompaniesUsersInput>
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompanies_Companies_UserIdToCompaniesUsersInput
    upsert?: CompaniesUsersUpsertWithoutCompanies_Companies_UserIdToCompaniesUsersInput
    disconnect?: CompaniesUsersWhereInput | boolean
    delete?: CompaniesUsersWhereInput | boolean
    connect?: CompaniesUsersWhereUniqueInput
    update?: XOR<XOR<CompaniesUsersUpdateToOneWithWhereWithoutCompanies_Companies_UserIdToCompaniesUsersInput, CompaniesUsersUpdateWithoutCompanies_Companies_UserIdToCompaniesUsersInput>, CompaniesUsersUncheckedUpdateWithoutCompanies_Companies_UserIdToCompaniesUsersInput>
  }

  export type CompaniesProductsUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<CompaniesProductsCreateWithoutCompaniesInput, CompaniesProductsUncheckedCreateWithoutCompaniesInput> | CompaniesProductsCreateWithoutCompaniesInput[] | CompaniesProductsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: CompaniesProductsCreateOrConnectWithoutCompaniesInput | CompaniesProductsCreateOrConnectWithoutCompaniesInput[]
    upsert?: CompaniesProductsUpsertWithWhereUniqueWithoutCompaniesInput | CompaniesProductsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: CompaniesProductsCreateManyCompaniesInputEnvelope
    set?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    disconnect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    delete?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    connect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    update?: CompaniesProductsUpdateWithWhereUniqueWithoutCompaniesInput | CompaniesProductsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: CompaniesProductsUpdateManyWithWhereWithoutCompaniesInput | CompaniesProductsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: CompaniesProductsScalarWhereInput | CompaniesProductsScalarWhereInput[]
  }

  export type CompaniesProductsExpireDatesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<CompaniesProductsExpireDatesCreateWithoutCompaniesInput, CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesInput> | CompaniesProductsExpireDatesCreateWithoutCompaniesInput[] | CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesInput | CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesInput[]
    upsert?: CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesInput | CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: CompaniesProductsExpireDatesCreateManyCompaniesInputEnvelope
    set?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesInput | CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: CompaniesProductsExpireDatesUpdateManyWithWhereWithoutCompaniesInput | CompaniesProductsExpireDatesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: CompaniesProductsExpireDatesScalarWhereInput | CompaniesProductsExpireDatesScalarWhereInput[]
  }

  export type CompaniesUsersUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUsersUncheckedCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput> | CompaniesUsersCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[] | CompaniesUsersUncheckedCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput | CompaniesUsersCreateOrConnectWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    upsert?: CompaniesUsersUpsertWithWhereUniqueWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput | CompaniesUsersUpsertWithWhereUniqueWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    createMany?: CompaniesUsersCreateManyCompanies_CompaniesUsers_CompanyIDToCompaniesInputEnvelope
    set?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    disconnect?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    delete?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    connect?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    update?: CompaniesUsersUpdateWithWhereUniqueWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput | CompaniesUsersUpdateWithWhereUniqueWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    updateMany?: CompaniesUsersUpdateManyWithWhereWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput | CompaniesUsersUpdateManyWithWhereWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    deleteMany?: CompaniesUsersScalarWhereInput | CompaniesUsersScalarWhereInput[]
  }

  export type CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesInput> | CompaniesUsersProductsExpireDatesCreateWithoutCompaniesInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesInput[]
    upsert?: CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesInput | CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyCompaniesInputEnvelope
    set?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesInput | CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesInput | CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: CompaniesUsersProductsExpireDatesScalarWhereInput | CompaniesUsersProductsExpireDatesScalarWhereInput[]
  }

  export type LandPagesUpdateOneWithoutCompaniesNestedInput = {
    create?: XOR<LandPagesCreateWithoutCompaniesInput, LandPagesUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: LandPagesCreateOrConnectWithoutCompaniesInput
    upsert?: LandPagesUpsertWithoutCompaniesInput
    disconnect?: LandPagesWhereInput | boolean
    delete?: LandPagesWhereInput | boolean
    connect?: LandPagesWhereUniqueInput
    update?: XOR<XOR<LandPagesUpdateToOneWithWhereWithoutCompaniesInput, LandPagesUpdateWithoutCompaniesInput>, LandPagesUncheckedUpdateWithoutCompaniesInput>
  }

  export type CompaniesProductsUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<CompaniesProductsCreateWithoutCompaniesInput, CompaniesProductsUncheckedCreateWithoutCompaniesInput> | CompaniesProductsCreateWithoutCompaniesInput[] | CompaniesProductsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: CompaniesProductsCreateOrConnectWithoutCompaniesInput | CompaniesProductsCreateOrConnectWithoutCompaniesInput[]
    upsert?: CompaniesProductsUpsertWithWhereUniqueWithoutCompaniesInput | CompaniesProductsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: CompaniesProductsCreateManyCompaniesInputEnvelope
    set?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    disconnect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    delete?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    connect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    update?: CompaniesProductsUpdateWithWhereUniqueWithoutCompaniesInput | CompaniesProductsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: CompaniesProductsUpdateManyWithWhereWithoutCompaniesInput | CompaniesProductsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: CompaniesProductsScalarWhereInput | CompaniesProductsScalarWhereInput[]
  }

  export type CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<CompaniesProductsExpireDatesCreateWithoutCompaniesInput, CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesInput> | CompaniesProductsExpireDatesCreateWithoutCompaniesInput[] | CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesInput | CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesInput[]
    upsert?: CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesInput | CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: CompaniesProductsExpireDatesCreateManyCompaniesInputEnvelope
    set?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesInput | CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: CompaniesProductsExpireDatesUpdateManyWithWhereWithoutCompaniesInput | CompaniesProductsExpireDatesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: CompaniesProductsExpireDatesScalarWhereInput | CompaniesProductsExpireDatesScalarWhereInput[]
  }

  export type CompaniesUsersUncheckedUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUsersUncheckedCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput> | CompaniesUsersCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[] | CompaniesUsersUncheckedCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput | CompaniesUsersCreateOrConnectWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    upsert?: CompaniesUsersUpsertWithWhereUniqueWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput | CompaniesUsersUpsertWithWhereUniqueWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    createMany?: CompaniesUsersCreateManyCompanies_CompaniesUsers_CompanyIDToCompaniesInputEnvelope
    set?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    disconnect?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    delete?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    connect?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    update?: CompaniesUsersUpdateWithWhereUniqueWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput | CompaniesUsersUpdateWithWhereUniqueWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    updateMany?: CompaniesUsersUpdateManyWithWhereWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput | CompaniesUsersUpdateManyWithWhereWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
    deleteMany?: CompaniesUsersScalarWhereInput | CompaniesUsersScalarWhereInput[]
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesInput> | CompaniesUsersProductsExpireDatesCreateWithoutCompaniesInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesInput[]
    upsert?: CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesInput | CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyCompaniesInputEnvelope
    set?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesInput | CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesInput | CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: CompaniesUsersProductsExpireDatesScalarWhereInput | CompaniesUsersProductsExpireDatesScalarWhereInput[]
  }

  export type LandPagesUncheckedUpdateOneWithoutCompaniesNestedInput = {
    create?: XOR<LandPagesCreateWithoutCompaniesInput, LandPagesUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: LandPagesCreateOrConnectWithoutCompaniesInput
    upsert?: LandPagesUpsertWithoutCompaniesInput
    disconnect?: LandPagesWhereInput | boolean
    delete?: LandPagesWhereInput | boolean
    connect?: LandPagesWhereUniqueInput
    update?: XOR<XOR<LandPagesUpdateToOneWithWhereWithoutCompaniesInput, LandPagesUpdateWithoutCompaniesInput>, LandPagesUncheckedUpdateWithoutCompaniesInput>
  }

  export type CompaniesUsersCreateNestedOneWithoutCompaniesProductsInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompaniesProductsInput, CompaniesUsersUncheckedCreateWithoutCompaniesProductsInput>
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompaniesProductsInput
    connect?: CompaniesUsersWhereUniqueInput
  }

  export type CompaniesCreateNestedOneWithoutCompaniesProductsInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesProductsInput, CompaniesUncheckedCreateWithoutCompaniesProductsInput>
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesProductsInput
    connect?: CompaniesWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutCompaniesProductsInput = {
    create?: XOR<ProductsCreateWithoutCompaniesProductsInput, ProductsUncheckedCreateWithoutCompaniesProductsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutCompaniesProductsInput
    connect?: ProductsWhereUniqueInput
  }

  export type CompaniesUsersUpdateOneWithoutCompaniesProductsNestedInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompaniesProductsInput, CompaniesUsersUncheckedCreateWithoutCompaniesProductsInput>
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompaniesProductsInput
    upsert?: CompaniesUsersUpsertWithoutCompaniesProductsInput
    disconnect?: CompaniesUsersWhereInput | boolean
    delete?: CompaniesUsersWhereInput | boolean
    connect?: CompaniesUsersWhereUniqueInput
    update?: XOR<XOR<CompaniesUsersUpdateToOneWithWhereWithoutCompaniesProductsInput, CompaniesUsersUpdateWithoutCompaniesProductsInput>, CompaniesUsersUncheckedUpdateWithoutCompaniesProductsInput>
  }

  export type CompaniesUpdateOneRequiredWithoutCompaniesProductsNestedInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesProductsInput, CompaniesUncheckedCreateWithoutCompaniesProductsInput>
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesProductsInput
    upsert?: CompaniesUpsertWithoutCompaniesProductsInput
    connect?: CompaniesWhereUniqueInput
    update?: XOR<XOR<CompaniesUpdateToOneWithWhereWithoutCompaniesProductsInput, CompaniesUpdateWithoutCompaniesProductsInput>, CompaniesUncheckedUpdateWithoutCompaniesProductsInput>
  }

  export type ProductsUpdateOneRequiredWithoutCompaniesProductsNestedInput = {
    create?: XOR<ProductsCreateWithoutCompaniesProductsInput, ProductsUncheckedCreateWithoutCompaniesProductsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutCompaniesProductsInput
    upsert?: ProductsUpsertWithoutCompaniesProductsInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutCompaniesProductsInput, ProductsUpdateWithoutCompaniesProductsInput>, ProductsUncheckedUpdateWithoutCompaniesProductsInput>
  }

  export type CompaniesUsersCreateNestedOneWithoutCompaniesProductsExpireDatesInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompaniesProductsExpireDatesInput, CompaniesUsersUncheckedCreateWithoutCompaniesProductsExpireDatesInput>
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompaniesProductsExpireDatesInput
    connect?: CompaniesUsersWhereUniqueInput
  }

  export type CompaniesCreateNestedOneWithoutCompaniesProductsExpireDatesInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesProductsExpireDatesInput, CompaniesUncheckedCreateWithoutCompaniesProductsExpireDatesInput>
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesProductsExpireDatesInput
    connect?: CompaniesWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutCompaniesProductsExpireDatesInput = {
    create?: XOR<ProductsCreateWithoutCompaniesProductsExpireDatesInput, ProductsUncheckedCreateWithoutCompaniesProductsExpireDatesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutCompaniesProductsExpireDatesInput
    connect?: ProductsWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CompaniesUsersUpdateOneWithoutCompaniesProductsExpireDatesNestedInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompaniesProductsExpireDatesInput, CompaniesUsersUncheckedCreateWithoutCompaniesProductsExpireDatesInput>
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompaniesProductsExpireDatesInput
    upsert?: CompaniesUsersUpsertWithoutCompaniesProductsExpireDatesInput
    disconnect?: CompaniesUsersWhereInput | boolean
    delete?: CompaniesUsersWhereInput | boolean
    connect?: CompaniesUsersWhereUniqueInput
    update?: XOR<XOR<CompaniesUsersUpdateToOneWithWhereWithoutCompaniesProductsExpireDatesInput, CompaniesUsersUpdateWithoutCompaniesProductsExpireDatesInput>, CompaniesUsersUncheckedUpdateWithoutCompaniesProductsExpireDatesInput>
  }

  export type CompaniesUpdateOneRequiredWithoutCompaniesProductsExpireDatesNestedInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesProductsExpireDatesInput, CompaniesUncheckedCreateWithoutCompaniesProductsExpireDatesInput>
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesProductsExpireDatesInput
    upsert?: CompaniesUpsertWithoutCompaniesProductsExpireDatesInput
    connect?: CompaniesWhereUniqueInput
    update?: XOR<XOR<CompaniesUpdateToOneWithWhereWithoutCompaniesProductsExpireDatesInput, CompaniesUpdateWithoutCompaniesProductsExpireDatesInput>, CompaniesUncheckedUpdateWithoutCompaniesProductsExpireDatesInput>
  }

  export type ProductsUpdateOneRequiredWithoutCompaniesProductsExpireDatesNestedInput = {
    create?: XOR<ProductsCreateWithoutCompaniesProductsExpireDatesInput, ProductsUncheckedCreateWithoutCompaniesProductsExpireDatesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutCompaniesProductsExpireDatesInput
    upsert?: ProductsUpsertWithoutCompaniesProductsExpireDatesInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutCompaniesProductsExpireDatesInput, ProductsUpdateWithoutCompaniesProductsExpireDatesInput>, ProductsUncheckedUpdateWithoutCompaniesProductsExpireDatesInput>
  }

  export type CompaniesCreateNestedManyWithoutCompaniesTypeInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesTypeInput, CompaniesUncheckedCreateWithoutCompaniesTypeInput> | CompaniesCreateWithoutCompaniesTypeInput[] | CompaniesUncheckedCreateWithoutCompaniesTypeInput[]
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesTypeInput | CompaniesCreateOrConnectWithoutCompaniesTypeInput[]
    createMany?: CompaniesCreateManyCompaniesTypeInputEnvelope
    connect?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
  }

  export type CompaniesUncheckedCreateNestedManyWithoutCompaniesTypeInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesTypeInput, CompaniesUncheckedCreateWithoutCompaniesTypeInput> | CompaniesCreateWithoutCompaniesTypeInput[] | CompaniesUncheckedCreateWithoutCompaniesTypeInput[]
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesTypeInput | CompaniesCreateOrConnectWithoutCompaniesTypeInput[]
    createMany?: CompaniesCreateManyCompaniesTypeInputEnvelope
    connect?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
  }

  export type CompaniesUpdateManyWithoutCompaniesTypeNestedInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesTypeInput, CompaniesUncheckedCreateWithoutCompaniesTypeInput> | CompaniesCreateWithoutCompaniesTypeInput[] | CompaniesUncheckedCreateWithoutCompaniesTypeInput[]
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesTypeInput | CompaniesCreateOrConnectWithoutCompaniesTypeInput[]
    upsert?: CompaniesUpsertWithWhereUniqueWithoutCompaniesTypeInput | CompaniesUpsertWithWhereUniqueWithoutCompaniesTypeInput[]
    createMany?: CompaniesCreateManyCompaniesTypeInputEnvelope
    set?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    disconnect?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    delete?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    connect?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    update?: CompaniesUpdateWithWhereUniqueWithoutCompaniesTypeInput | CompaniesUpdateWithWhereUniqueWithoutCompaniesTypeInput[]
    updateMany?: CompaniesUpdateManyWithWhereWithoutCompaniesTypeInput | CompaniesUpdateManyWithWhereWithoutCompaniesTypeInput[]
    deleteMany?: CompaniesScalarWhereInput | CompaniesScalarWhereInput[]
  }

  export type CompaniesUncheckedUpdateManyWithoutCompaniesTypeNestedInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesTypeInput, CompaniesUncheckedCreateWithoutCompaniesTypeInput> | CompaniesCreateWithoutCompaniesTypeInput[] | CompaniesUncheckedCreateWithoutCompaniesTypeInput[]
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesTypeInput | CompaniesCreateOrConnectWithoutCompaniesTypeInput[]
    upsert?: CompaniesUpsertWithWhereUniqueWithoutCompaniesTypeInput | CompaniesUpsertWithWhereUniqueWithoutCompaniesTypeInput[]
    createMany?: CompaniesCreateManyCompaniesTypeInputEnvelope
    set?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    disconnect?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    delete?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    connect?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    update?: CompaniesUpdateWithWhereUniqueWithoutCompaniesTypeInput | CompaniesUpdateWithWhereUniqueWithoutCompaniesTypeInput[]
    updateMany?: CompaniesUpdateManyWithWhereWithoutCompaniesTypeInput | CompaniesUpdateManyWithWhereWithoutCompaniesTypeInput[]
    deleteMany?: CompaniesScalarWhereInput | CompaniesScalarWhereInput[]
  }

  export type CompaniesCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput, CompaniesUncheckedCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput> | CompaniesCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[] | CompaniesUncheckedCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput | CompaniesCreateOrConnectWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    createMany?: CompaniesCreateManyCompaniesUsers_Companies_UserIdToCompaniesUsersInputEnvelope
    connect?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
  }

  export type CompaniesProductsCreateNestedManyWithoutCompaniesUsersInput = {
    create?: XOR<CompaniesProductsCreateWithoutCompaniesUsersInput, CompaniesProductsUncheckedCreateWithoutCompaniesUsersInput> | CompaniesProductsCreateWithoutCompaniesUsersInput[] | CompaniesProductsUncheckedCreateWithoutCompaniesUsersInput[]
    connectOrCreate?: CompaniesProductsCreateOrConnectWithoutCompaniesUsersInput | CompaniesProductsCreateOrConnectWithoutCompaniesUsersInput[]
    createMany?: CompaniesProductsCreateManyCompaniesUsersInputEnvelope
    connect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
  }

  export type CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesUsersInput = {
    create?: XOR<CompaniesProductsExpireDatesCreateWithoutCompaniesUsersInput, CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesUsersInput> | CompaniesProductsExpireDatesCreateWithoutCompaniesUsersInput[] | CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesUsersInput[]
    connectOrCreate?: CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesUsersInput | CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesUsersInput[]
    createMany?: CompaniesProductsExpireDatesCreateManyCompaniesUsersInputEnvelope
    connect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
  }

  export type CompaniesUsersCreateNestedOneWithoutOther_CompaniesUsersInput = {
    create?: XOR<CompaniesUsersCreateWithoutOther_CompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutOther_CompaniesUsersInput>
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutOther_CompaniesUsersInput
    connect?: CompaniesUsersWhereUniqueInput
  }

  export type CompaniesUsersCreateNestedManyWithoutCompaniesUsersInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersInput> | CompaniesUsersCreateWithoutCompaniesUsersInput[] | CompaniesUsersUncheckedCreateWithoutCompaniesUsersInput[]
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompaniesUsersInput | CompaniesUsersCreateOrConnectWithoutCompaniesUsersInput[]
    createMany?: CompaniesUsersCreateManyCompaniesUsersInputEnvelope
    connect?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
  }

  export type CompaniesCreateNestedOneWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUncheckedCreateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput>
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput
    connect?: CompaniesWhereUniqueInput
  }

  export type CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput> | CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInputEnvelope
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
  }

  export type CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput> | CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInputEnvelope
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
  }

  export type CompaniesUncheckedCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput, CompaniesUncheckedCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput> | CompaniesCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[] | CompaniesUncheckedCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput | CompaniesCreateOrConnectWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    createMany?: CompaniesCreateManyCompaniesUsers_Companies_UserIdToCompaniesUsersInputEnvelope
    connect?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
  }

  export type CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesUsersInput = {
    create?: XOR<CompaniesProductsCreateWithoutCompaniesUsersInput, CompaniesProductsUncheckedCreateWithoutCompaniesUsersInput> | CompaniesProductsCreateWithoutCompaniesUsersInput[] | CompaniesProductsUncheckedCreateWithoutCompaniesUsersInput[]
    connectOrCreate?: CompaniesProductsCreateOrConnectWithoutCompaniesUsersInput | CompaniesProductsCreateOrConnectWithoutCompaniesUsersInput[]
    createMany?: CompaniesProductsCreateManyCompaniesUsersInputEnvelope
    connect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
  }

  export type CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsersInput = {
    create?: XOR<CompaniesProductsExpireDatesCreateWithoutCompaniesUsersInput, CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesUsersInput> | CompaniesProductsExpireDatesCreateWithoutCompaniesUsersInput[] | CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesUsersInput[]
    connectOrCreate?: CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesUsersInput | CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesUsersInput[]
    createMany?: CompaniesProductsExpireDatesCreateManyCompaniesUsersInputEnvelope
    connect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
  }

  export type CompaniesUsersUncheckedCreateNestedManyWithoutCompaniesUsersInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersInput> | CompaniesUsersCreateWithoutCompaniesUsersInput[] | CompaniesUsersUncheckedCreateWithoutCompaniesUsersInput[]
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompaniesUsersInput | CompaniesUsersCreateOrConnectWithoutCompaniesUsersInput[]
    createMany?: CompaniesUsersCreateManyCompaniesUsersInputEnvelope
    connect?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
  }

  export type CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput> | CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInputEnvelope
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
  }

  export type CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput> | CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInputEnvelope
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
  }

  export type CompaniesUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput, CompaniesUncheckedCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput> | CompaniesCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[] | CompaniesUncheckedCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput | CompaniesCreateOrConnectWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    upsert?: CompaniesUpsertWithWhereUniqueWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput | CompaniesUpsertWithWhereUniqueWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    createMany?: CompaniesCreateManyCompaniesUsers_Companies_UserIdToCompaniesUsersInputEnvelope
    set?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    disconnect?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    delete?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    connect?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    update?: CompaniesUpdateWithWhereUniqueWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput | CompaniesUpdateWithWhereUniqueWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    updateMany?: CompaniesUpdateManyWithWhereWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput | CompaniesUpdateManyWithWhereWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    deleteMany?: CompaniesScalarWhereInput | CompaniesScalarWhereInput[]
  }

  export type CompaniesProductsUpdateManyWithoutCompaniesUsersNestedInput = {
    create?: XOR<CompaniesProductsCreateWithoutCompaniesUsersInput, CompaniesProductsUncheckedCreateWithoutCompaniesUsersInput> | CompaniesProductsCreateWithoutCompaniesUsersInput[] | CompaniesProductsUncheckedCreateWithoutCompaniesUsersInput[]
    connectOrCreate?: CompaniesProductsCreateOrConnectWithoutCompaniesUsersInput | CompaniesProductsCreateOrConnectWithoutCompaniesUsersInput[]
    upsert?: CompaniesProductsUpsertWithWhereUniqueWithoutCompaniesUsersInput | CompaniesProductsUpsertWithWhereUniqueWithoutCompaniesUsersInput[]
    createMany?: CompaniesProductsCreateManyCompaniesUsersInputEnvelope
    set?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    disconnect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    delete?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    connect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    update?: CompaniesProductsUpdateWithWhereUniqueWithoutCompaniesUsersInput | CompaniesProductsUpdateWithWhereUniqueWithoutCompaniesUsersInput[]
    updateMany?: CompaniesProductsUpdateManyWithWhereWithoutCompaniesUsersInput | CompaniesProductsUpdateManyWithWhereWithoutCompaniesUsersInput[]
    deleteMany?: CompaniesProductsScalarWhereInput | CompaniesProductsScalarWhereInput[]
  }

  export type CompaniesProductsExpireDatesUpdateManyWithoutCompaniesUsersNestedInput = {
    create?: XOR<CompaniesProductsExpireDatesCreateWithoutCompaniesUsersInput, CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesUsersInput> | CompaniesProductsExpireDatesCreateWithoutCompaniesUsersInput[] | CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesUsersInput[]
    connectOrCreate?: CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesUsersInput | CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesUsersInput[]
    upsert?: CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsersInput | CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsersInput[]
    createMany?: CompaniesProductsExpireDatesCreateManyCompaniesUsersInputEnvelope
    set?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsersInput | CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsersInput[]
    updateMany?: CompaniesProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsersInput | CompaniesProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsersInput[]
    deleteMany?: CompaniesProductsExpireDatesScalarWhereInput | CompaniesProductsExpireDatesScalarWhereInput[]
  }

  export type CompaniesUsersUpdateOneWithoutOther_CompaniesUsersNestedInput = {
    create?: XOR<CompaniesUsersCreateWithoutOther_CompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutOther_CompaniesUsersInput>
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutOther_CompaniesUsersInput
    upsert?: CompaniesUsersUpsertWithoutOther_CompaniesUsersInput
    disconnect?: CompaniesUsersWhereInput | boolean
    delete?: CompaniesUsersWhereInput | boolean
    connect?: CompaniesUsersWhereUniqueInput
    update?: XOR<XOR<CompaniesUsersUpdateToOneWithWhereWithoutOther_CompaniesUsersInput, CompaniesUsersUpdateWithoutOther_CompaniesUsersInput>, CompaniesUsersUncheckedUpdateWithoutOther_CompaniesUsersInput>
  }

  export type CompaniesUsersUpdateManyWithoutCompaniesUsersNestedInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersInput> | CompaniesUsersCreateWithoutCompaniesUsersInput[] | CompaniesUsersUncheckedCreateWithoutCompaniesUsersInput[]
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompaniesUsersInput | CompaniesUsersCreateOrConnectWithoutCompaniesUsersInput[]
    upsert?: CompaniesUsersUpsertWithWhereUniqueWithoutCompaniesUsersInput | CompaniesUsersUpsertWithWhereUniqueWithoutCompaniesUsersInput[]
    createMany?: CompaniesUsersCreateManyCompaniesUsersInputEnvelope
    set?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    disconnect?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    delete?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    connect?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    update?: CompaniesUsersUpdateWithWhereUniqueWithoutCompaniesUsersInput | CompaniesUsersUpdateWithWhereUniqueWithoutCompaniesUsersInput[]
    updateMany?: CompaniesUsersUpdateManyWithWhereWithoutCompaniesUsersInput | CompaniesUsersUpdateManyWithWhereWithoutCompaniesUsersInput[]
    deleteMany?: CompaniesUsersScalarWhereInput | CompaniesUsersScalarWhereInput[]
  }

  export type CompaniesUpdateOneRequiredWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesNestedInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUncheckedCreateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput>
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput
    upsert?: CompaniesUpsertWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput
    connect?: CompaniesWhereUniqueInput
    update?: XOR<XOR<CompaniesUpdateToOneWithWhereWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUpdateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput>, CompaniesUncheckedUpdateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput>
  }

  export type CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput> | CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    upsert?: CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput | CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInputEnvelope
    set?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput | CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    updateMany?: CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput | CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    deleteMany?: CompaniesUsersProductsExpireDatesScalarWhereInput | CompaniesUsersProductsExpireDatesScalarWhereInput[]
  }

  export type CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput> | CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    upsert?: CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput | CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInputEnvelope
    set?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput | CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    updateMany?: CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput | CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    deleteMany?: CompaniesUsersProductsExpireDatesScalarWhereInput | CompaniesUsersProductsExpireDatesScalarWhereInput[]
  }

  export type CompaniesUncheckedUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput, CompaniesUncheckedCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput> | CompaniesCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[] | CompaniesUncheckedCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput | CompaniesCreateOrConnectWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    upsert?: CompaniesUpsertWithWhereUniqueWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput | CompaniesUpsertWithWhereUniqueWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    createMany?: CompaniesCreateManyCompaniesUsers_Companies_UserIdToCompaniesUsersInputEnvelope
    set?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    disconnect?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    delete?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    connect?: CompaniesWhereUniqueInput | CompaniesWhereUniqueInput[]
    update?: CompaniesUpdateWithWhereUniqueWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput | CompaniesUpdateWithWhereUniqueWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    updateMany?: CompaniesUpdateManyWithWhereWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput | CompaniesUpdateManyWithWhereWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
    deleteMany?: CompaniesScalarWhereInput | CompaniesScalarWhereInput[]
  }

  export type CompaniesProductsUncheckedUpdateManyWithoutCompaniesUsersNestedInput = {
    create?: XOR<CompaniesProductsCreateWithoutCompaniesUsersInput, CompaniesProductsUncheckedCreateWithoutCompaniesUsersInput> | CompaniesProductsCreateWithoutCompaniesUsersInput[] | CompaniesProductsUncheckedCreateWithoutCompaniesUsersInput[]
    connectOrCreate?: CompaniesProductsCreateOrConnectWithoutCompaniesUsersInput | CompaniesProductsCreateOrConnectWithoutCompaniesUsersInput[]
    upsert?: CompaniesProductsUpsertWithWhereUniqueWithoutCompaniesUsersInput | CompaniesProductsUpsertWithWhereUniqueWithoutCompaniesUsersInput[]
    createMany?: CompaniesProductsCreateManyCompaniesUsersInputEnvelope
    set?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    disconnect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    delete?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    connect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    update?: CompaniesProductsUpdateWithWhereUniqueWithoutCompaniesUsersInput | CompaniesProductsUpdateWithWhereUniqueWithoutCompaniesUsersInput[]
    updateMany?: CompaniesProductsUpdateManyWithWhereWithoutCompaniesUsersInput | CompaniesProductsUpdateManyWithWhereWithoutCompaniesUsersInput[]
    deleteMany?: CompaniesProductsScalarWhereInput | CompaniesProductsScalarWhereInput[]
  }

  export type CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsersNestedInput = {
    create?: XOR<CompaniesProductsExpireDatesCreateWithoutCompaniesUsersInput, CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesUsersInput> | CompaniesProductsExpireDatesCreateWithoutCompaniesUsersInput[] | CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesUsersInput[]
    connectOrCreate?: CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesUsersInput | CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesUsersInput[]
    upsert?: CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsersInput | CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsersInput[]
    createMany?: CompaniesProductsExpireDatesCreateManyCompaniesUsersInputEnvelope
    set?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsersInput | CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsersInput[]
    updateMany?: CompaniesProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsersInput | CompaniesProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsersInput[]
    deleteMany?: CompaniesProductsExpireDatesScalarWhereInput | CompaniesProductsExpireDatesScalarWhereInput[]
  }

  export type CompaniesUsersUncheckedUpdateManyWithoutCompaniesUsersNestedInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersInput> | CompaniesUsersCreateWithoutCompaniesUsersInput[] | CompaniesUsersUncheckedCreateWithoutCompaniesUsersInput[]
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompaniesUsersInput | CompaniesUsersCreateOrConnectWithoutCompaniesUsersInput[]
    upsert?: CompaniesUsersUpsertWithWhereUniqueWithoutCompaniesUsersInput | CompaniesUsersUpsertWithWhereUniqueWithoutCompaniesUsersInput[]
    createMany?: CompaniesUsersCreateManyCompaniesUsersInputEnvelope
    set?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    disconnect?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    delete?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    connect?: CompaniesUsersWhereUniqueInput | CompaniesUsersWhereUniqueInput[]
    update?: CompaniesUsersUpdateWithWhereUniqueWithoutCompaniesUsersInput | CompaniesUsersUpdateWithWhereUniqueWithoutCompaniesUsersInput[]
    updateMany?: CompaniesUsersUpdateManyWithWhereWithoutCompaniesUsersInput | CompaniesUsersUpdateManyWithWhereWithoutCompaniesUsersInput[]
    deleteMany?: CompaniesUsersScalarWhereInput | CompaniesUsersScalarWhereInput[]
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput> | CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    upsert?: CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput | CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInputEnvelope
    set?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput | CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    updateMany?: CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput | CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
    deleteMany?: CompaniesUsersProductsExpireDatesScalarWhereInput | CompaniesUsersProductsExpireDatesScalarWhereInput[]
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput> | CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    upsert?: CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput | CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInputEnvelope
    set?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput | CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    updateMany?: CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput | CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
    deleteMany?: CompaniesUsersProductsExpireDatesScalarWhereInput | CompaniesUsersProductsExpireDatesScalarWhereInput[]
  }

  export type CompaniesUsersCreateNestedOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    connect?: CompaniesUsersWhereUniqueInput
  }

  export type CompaniesCreateNestedOneWithoutCompaniesUsersProductsExpireDatesInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesUsersProductsExpireDatesInput, CompaniesUncheckedCreateWithoutCompaniesUsersProductsExpireDatesInput>
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesUsersProductsExpireDatesInput
    connect?: CompaniesWhereUniqueInput
  }

  export type CompaniesUsersCreateNestedOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
    connect?: CompaniesUsersWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutCompaniesUsersProductsExpireDatesInput = {
    create?: XOR<ProductsCreateWithoutCompaniesUsersProductsExpireDatesInput, ProductsUncheckedCreateWithoutCompaniesUsersProductsExpireDatesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutCompaniesUsersProductsExpireDatesInput
    connect?: ProductsWhereUniqueInput
  }

  export type CompaniesUsersUpdateOneRequiredWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    upsert?: CompaniesUsersUpsertWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    connect?: CompaniesUsersWhereUniqueInput
    update?: XOR<XOR<CompaniesUsersUpdateToOneWithWhereWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>, CompaniesUsersUncheckedUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>
  }

  export type CompaniesUpdateOneRequiredWithoutCompaniesUsersProductsExpireDatesNestedInput = {
    create?: XOR<CompaniesCreateWithoutCompaniesUsersProductsExpireDatesInput, CompaniesUncheckedCreateWithoutCompaniesUsersProductsExpireDatesInput>
    connectOrCreate?: CompaniesCreateOrConnectWithoutCompaniesUsersProductsExpireDatesInput
    upsert?: CompaniesUpsertWithoutCompaniesUsersProductsExpireDatesInput
    connect?: CompaniesWhereUniqueInput
    update?: XOR<XOR<CompaniesUpdateToOneWithWhereWithoutCompaniesUsersProductsExpireDatesInput, CompaniesUpdateWithoutCompaniesUsersProductsExpireDatesInput>, CompaniesUncheckedUpdateWithoutCompaniesUsersProductsExpireDatesInput>
  }

  export type CompaniesUsersUpdateOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput = {
    create?: XOR<CompaniesUsersCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>
    connectOrCreate?: CompaniesUsersCreateOrConnectWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
    upsert?: CompaniesUsersUpsertWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
    disconnect?: CompaniesUsersWhereInput | boolean
    delete?: CompaniesUsersWhereInput | boolean
    connect?: CompaniesUsersWhereUniqueInput
    update?: XOR<XOR<CompaniesUsersUpdateToOneWithWhereWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>, CompaniesUsersUncheckedUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>
  }

  export type ProductsUpdateOneRequiredWithoutCompaniesUsersProductsExpireDatesNestedInput = {
    create?: XOR<ProductsCreateWithoutCompaniesUsersProductsExpireDatesInput, ProductsUncheckedCreateWithoutCompaniesUsersProductsExpireDatesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutCompaniesUsersProductsExpireDatesInput
    upsert?: ProductsUpsertWithoutCompaniesUsersProductsExpireDatesInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutCompaniesUsersProductsExpireDatesInput, ProductsUpdateWithoutCompaniesUsersProductsExpireDatesInput>, ProductsUncheckedUpdateWithoutCompaniesUsersProductsExpireDatesInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type CompaniesCreateNestedOneWithoutLandPagesInput = {
    create?: XOR<CompaniesCreateWithoutLandPagesInput, CompaniesUncheckedCreateWithoutLandPagesInput>
    connectOrCreate?: CompaniesCreateOrConnectWithoutLandPagesInput
    connect?: CompaniesWhereUniqueInput
  }

  export type CompaniesUpdateOneRequiredWithoutLandPagesNestedInput = {
    create?: XOR<CompaniesCreateWithoutLandPagesInput, CompaniesUncheckedCreateWithoutLandPagesInput>
    connectOrCreate?: CompaniesCreateOrConnectWithoutLandPagesInput
    upsert?: CompaniesUpsertWithoutLandPagesInput
    connect?: CompaniesWhereUniqueInput
    update?: XOR<XOR<CompaniesUpdateToOneWithWhereWithoutLandPagesInput, CompaniesUpdateWithoutLandPagesInput>, CompaniesUncheckedUpdateWithoutLandPagesInput>
  }

  export type CompaniesProductsCreateNestedManyWithoutProductsInput = {
    create?: XOR<CompaniesProductsCreateWithoutProductsInput, CompaniesProductsUncheckedCreateWithoutProductsInput> | CompaniesProductsCreateWithoutProductsInput[] | CompaniesProductsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CompaniesProductsCreateOrConnectWithoutProductsInput | CompaniesProductsCreateOrConnectWithoutProductsInput[]
    createMany?: CompaniesProductsCreateManyProductsInputEnvelope
    connect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
  }

  export type CompaniesProductsExpireDatesCreateNestedManyWithoutProductsInput = {
    create?: XOR<CompaniesProductsExpireDatesCreateWithoutProductsInput, CompaniesProductsExpireDatesUncheckedCreateWithoutProductsInput> | CompaniesProductsExpireDatesCreateWithoutProductsInput[] | CompaniesProductsExpireDatesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CompaniesProductsExpireDatesCreateOrConnectWithoutProductsInput | CompaniesProductsExpireDatesCreateOrConnectWithoutProductsInput[]
    createMany?: CompaniesProductsExpireDatesCreateManyProductsInputEnvelope
    connect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
  }

  export type CompaniesUsersProductsExpireDatesCreateNestedManyWithoutProductsInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutProductsInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutProductsInput> | CompaniesUsersProductsExpireDatesCreateWithoutProductsInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutProductsInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutProductsInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyProductsInputEnvelope
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
  }

  export type CompaniesProductsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<CompaniesProductsCreateWithoutProductsInput, CompaniesProductsUncheckedCreateWithoutProductsInput> | CompaniesProductsCreateWithoutProductsInput[] | CompaniesProductsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CompaniesProductsCreateOrConnectWithoutProductsInput | CompaniesProductsCreateOrConnectWithoutProductsInput[]
    createMany?: CompaniesProductsCreateManyProductsInputEnvelope
    connect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
  }

  export type CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<CompaniesProductsExpireDatesCreateWithoutProductsInput, CompaniesProductsExpireDatesUncheckedCreateWithoutProductsInput> | CompaniesProductsExpireDatesCreateWithoutProductsInput[] | CompaniesProductsExpireDatesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CompaniesProductsExpireDatesCreateOrConnectWithoutProductsInput | CompaniesProductsExpireDatesCreateOrConnectWithoutProductsInput[]
    createMany?: CompaniesProductsExpireDatesCreateManyProductsInputEnvelope
    connect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
  }

  export type CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutProductsInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutProductsInput> | CompaniesUsersProductsExpireDatesCreateWithoutProductsInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutProductsInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutProductsInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyProductsInputEnvelope
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
  }

  export type CompaniesProductsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CompaniesProductsCreateWithoutProductsInput, CompaniesProductsUncheckedCreateWithoutProductsInput> | CompaniesProductsCreateWithoutProductsInput[] | CompaniesProductsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CompaniesProductsCreateOrConnectWithoutProductsInput | CompaniesProductsCreateOrConnectWithoutProductsInput[]
    upsert?: CompaniesProductsUpsertWithWhereUniqueWithoutProductsInput | CompaniesProductsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: CompaniesProductsCreateManyProductsInputEnvelope
    set?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    disconnect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    delete?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    connect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    update?: CompaniesProductsUpdateWithWhereUniqueWithoutProductsInput | CompaniesProductsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CompaniesProductsUpdateManyWithWhereWithoutProductsInput | CompaniesProductsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CompaniesProductsScalarWhereInput | CompaniesProductsScalarWhereInput[]
  }

  export type CompaniesProductsExpireDatesUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CompaniesProductsExpireDatesCreateWithoutProductsInput, CompaniesProductsExpireDatesUncheckedCreateWithoutProductsInput> | CompaniesProductsExpireDatesCreateWithoutProductsInput[] | CompaniesProductsExpireDatesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CompaniesProductsExpireDatesCreateOrConnectWithoutProductsInput | CompaniesProductsExpireDatesCreateOrConnectWithoutProductsInput[]
    upsert?: CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutProductsInput | CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: CompaniesProductsExpireDatesCreateManyProductsInputEnvelope
    set?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutProductsInput | CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CompaniesProductsExpireDatesUpdateManyWithWhereWithoutProductsInput | CompaniesProductsExpireDatesUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CompaniesProductsExpireDatesScalarWhereInput | CompaniesProductsExpireDatesScalarWhereInput[]
  }

  export type CompaniesUsersProductsExpireDatesUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutProductsInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutProductsInput> | CompaniesUsersProductsExpireDatesCreateWithoutProductsInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutProductsInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutProductsInput[]
    upsert?: CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutProductsInput | CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyProductsInputEnvelope
    set?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutProductsInput | CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutProductsInput | CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CompaniesUsersProductsExpireDatesScalarWhereInput | CompaniesUsersProductsExpireDatesScalarWhereInput[]
  }

  export type CompaniesProductsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CompaniesProductsCreateWithoutProductsInput, CompaniesProductsUncheckedCreateWithoutProductsInput> | CompaniesProductsCreateWithoutProductsInput[] | CompaniesProductsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CompaniesProductsCreateOrConnectWithoutProductsInput | CompaniesProductsCreateOrConnectWithoutProductsInput[]
    upsert?: CompaniesProductsUpsertWithWhereUniqueWithoutProductsInput | CompaniesProductsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: CompaniesProductsCreateManyProductsInputEnvelope
    set?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    disconnect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    delete?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    connect?: CompaniesProductsWhereUniqueInput | CompaniesProductsWhereUniqueInput[]
    update?: CompaniesProductsUpdateWithWhereUniqueWithoutProductsInput | CompaniesProductsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CompaniesProductsUpdateManyWithWhereWithoutProductsInput | CompaniesProductsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CompaniesProductsScalarWhereInput | CompaniesProductsScalarWhereInput[]
  }

  export type CompaniesProductsExpireDatesUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CompaniesProductsExpireDatesCreateWithoutProductsInput, CompaniesProductsExpireDatesUncheckedCreateWithoutProductsInput> | CompaniesProductsExpireDatesCreateWithoutProductsInput[] | CompaniesProductsExpireDatesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CompaniesProductsExpireDatesCreateOrConnectWithoutProductsInput | CompaniesProductsExpireDatesCreateOrConnectWithoutProductsInput[]
    upsert?: CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutProductsInput | CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: CompaniesProductsExpireDatesCreateManyProductsInputEnvelope
    set?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesProductsExpireDatesWhereUniqueInput | CompaniesProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutProductsInput | CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CompaniesProductsExpireDatesUpdateManyWithWhereWithoutProductsInput | CompaniesProductsExpireDatesUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CompaniesProductsExpireDatesScalarWhereInput | CompaniesProductsExpireDatesScalarWhereInput[]
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CompaniesUsersProductsExpireDatesCreateWithoutProductsInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutProductsInput> | CompaniesUsersProductsExpireDatesCreateWithoutProductsInput[] | CompaniesUsersProductsExpireDatesUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CompaniesUsersProductsExpireDatesCreateOrConnectWithoutProductsInput | CompaniesUsersProductsExpireDatesCreateOrConnectWithoutProductsInput[]
    upsert?: CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutProductsInput | CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: CompaniesUsersProductsExpireDatesCreateManyProductsInputEnvelope
    set?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    disconnect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    delete?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    connect?: CompaniesUsersProductsExpireDatesWhereUniqueInput | CompaniesUsersProductsExpireDatesWhereUniqueInput[]
    update?: CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutProductsInput | CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutProductsInput | CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CompaniesUsersProductsExpireDatesScalarWhereInput | CompaniesUsersProductsExpireDatesScalarWhereInput[]
  }

  export type RecoveryDefinitionDetailsCreateNestedManyWithoutRecoveryDefinitionInput = {
    create?: XOR<RecoveryDefinitionDetailsCreateWithoutRecoveryDefinitionInput, RecoveryDefinitionDetailsUncheckedCreateWithoutRecoveryDefinitionInput> | RecoveryDefinitionDetailsCreateWithoutRecoveryDefinitionInput[] | RecoveryDefinitionDetailsUncheckedCreateWithoutRecoveryDefinitionInput[]
    connectOrCreate?: RecoveryDefinitionDetailsCreateOrConnectWithoutRecoveryDefinitionInput | RecoveryDefinitionDetailsCreateOrConnectWithoutRecoveryDefinitionInput[]
    createMany?: RecoveryDefinitionDetailsCreateManyRecoveryDefinitionInputEnvelope
    connect?: RecoveryDefinitionDetailsWhereUniqueInput | RecoveryDefinitionDetailsWhereUniqueInput[]
  }

  export type RecoveryDefinitionRateDetailsCreateNestedManyWithoutRecoveryDefinitionInput = {
    create?: XOR<RecoveryDefinitionRateDetailsCreateWithoutRecoveryDefinitionInput, RecoveryDefinitionRateDetailsUncheckedCreateWithoutRecoveryDefinitionInput> | RecoveryDefinitionRateDetailsCreateWithoutRecoveryDefinitionInput[] | RecoveryDefinitionRateDetailsUncheckedCreateWithoutRecoveryDefinitionInput[]
    connectOrCreate?: RecoveryDefinitionRateDetailsCreateOrConnectWithoutRecoveryDefinitionInput | RecoveryDefinitionRateDetailsCreateOrConnectWithoutRecoveryDefinitionInput[]
    createMany?: RecoveryDefinitionRateDetailsCreateManyRecoveryDefinitionInputEnvelope
    connect?: RecoveryDefinitionRateDetailsWhereUniqueInput | RecoveryDefinitionRateDetailsWhereUniqueInput[]
  }

  export type RecoveryDefinitionDetailsUncheckedCreateNestedManyWithoutRecoveryDefinitionInput = {
    create?: XOR<RecoveryDefinitionDetailsCreateWithoutRecoveryDefinitionInput, RecoveryDefinitionDetailsUncheckedCreateWithoutRecoveryDefinitionInput> | RecoveryDefinitionDetailsCreateWithoutRecoveryDefinitionInput[] | RecoveryDefinitionDetailsUncheckedCreateWithoutRecoveryDefinitionInput[]
    connectOrCreate?: RecoveryDefinitionDetailsCreateOrConnectWithoutRecoveryDefinitionInput | RecoveryDefinitionDetailsCreateOrConnectWithoutRecoveryDefinitionInput[]
    createMany?: RecoveryDefinitionDetailsCreateManyRecoveryDefinitionInputEnvelope
    connect?: RecoveryDefinitionDetailsWhereUniqueInput | RecoveryDefinitionDetailsWhereUniqueInput[]
  }

  export type RecoveryDefinitionRateDetailsUncheckedCreateNestedManyWithoutRecoveryDefinitionInput = {
    create?: XOR<RecoveryDefinitionRateDetailsCreateWithoutRecoveryDefinitionInput, RecoveryDefinitionRateDetailsUncheckedCreateWithoutRecoveryDefinitionInput> | RecoveryDefinitionRateDetailsCreateWithoutRecoveryDefinitionInput[] | RecoveryDefinitionRateDetailsUncheckedCreateWithoutRecoveryDefinitionInput[]
    connectOrCreate?: RecoveryDefinitionRateDetailsCreateOrConnectWithoutRecoveryDefinitionInput | RecoveryDefinitionRateDetailsCreateOrConnectWithoutRecoveryDefinitionInput[]
    createMany?: RecoveryDefinitionRateDetailsCreateManyRecoveryDefinitionInputEnvelope
    connect?: RecoveryDefinitionRateDetailsWhereUniqueInput | RecoveryDefinitionRateDetailsWhereUniqueInput[]
  }

  export type RecoveryDefinitionDetailsUpdateManyWithoutRecoveryDefinitionNestedInput = {
    create?: XOR<RecoveryDefinitionDetailsCreateWithoutRecoveryDefinitionInput, RecoveryDefinitionDetailsUncheckedCreateWithoutRecoveryDefinitionInput> | RecoveryDefinitionDetailsCreateWithoutRecoveryDefinitionInput[] | RecoveryDefinitionDetailsUncheckedCreateWithoutRecoveryDefinitionInput[]
    connectOrCreate?: RecoveryDefinitionDetailsCreateOrConnectWithoutRecoveryDefinitionInput | RecoveryDefinitionDetailsCreateOrConnectWithoutRecoveryDefinitionInput[]
    upsert?: RecoveryDefinitionDetailsUpsertWithWhereUniqueWithoutRecoveryDefinitionInput | RecoveryDefinitionDetailsUpsertWithWhereUniqueWithoutRecoveryDefinitionInput[]
    createMany?: RecoveryDefinitionDetailsCreateManyRecoveryDefinitionInputEnvelope
    set?: RecoveryDefinitionDetailsWhereUniqueInput | RecoveryDefinitionDetailsWhereUniqueInput[]
    disconnect?: RecoveryDefinitionDetailsWhereUniqueInput | RecoveryDefinitionDetailsWhereUniqueInput[]
    delete?: RecoveryDefinitionDetailsWhereUniqueInput | RecoveryDefinitionDetailsWhereUniqueInput[]
    connect?: RecoveryDefinitionDetailsWhereUniqueInput | RecoveryDefinitionDetailsWhereUniqueInput[]
    update?: RecoveryDefinitionDetailsUpdateWithWhereUniqueWithoutRecoveryDefinitionInput | RecoveryDefinitionDetailsUpdateWithWhereUniqueWithoutRecoveryDefinitionInput[]
    updateMany?: RecoveryDefinitionDetailsUpdateManyWithWhereWithoutRecoveryDefinitionInput | RecoveryDefinitionDetailsUpdateManyWithWhereWithoutRecoveryDefinitionInput[]
    deleteMany?: RecoveryDefinitionDetailsScalarWhereInput | RecoveryDefinitionDetailsScalarWhereInput[]
  }

  export type RecoveryDefinitionRateDetailsUpdateManyWithoutRecoveryDefinitionNestedInput = {
    create?: XOR<RecoveryDefinitionRateDetailsCreateWithoutRecoveryDefinitionInput, RecoveryDefinitionRateDetailsUncheckedCreateWithoutRecoveryDefinitionInput> | RecoveryDefinitionRateDetailsCreateWithoutRecoveryDefinitionInput[] | RecoveryDefinitionRateDetailsUncheckedCreateWithoutRecoveryDefinitionInput[]
    connectOrCreate?: RecoveryDefinitionRateDetailsCreateOrConnectWithoutRecoveryDefinitionInput | RecoveryDefinitionRateDetailsCreateOrConnectWithoutRecoveryDefinitionInput[]
    upsert?: RecoveryDefinitionRateDetailsUpsertWithWhereUniqueWithoutRecoveryDefinitionInput | RecoveryDefinitionRateDetailsUpsertWithWhereUniqueWithoutRecoveryDefinitionInput[]
    createMany?: RecoveryDefinitionRateDetailsCreateManyRecoveryDefinitionInputEnvelope
    set?: RecoveryDefinitionRateDetailsWhereUniqueInput | RecoveryDefinitionRateDetailsWhereUniqueInput[]
    disconnect?: RecoveryDefinitionRateDetailsWhereUniqueInput | RecoveryDefinitionRateDetailsWhereUniqueInput[]
    delete?: RecoveryDefinitionRateDetailsWhereUniqueInput | RecoveryDefinitionRateDetailsWhereUniqueInput[]
    connect?: RecoveryDefinitionRateDetailsWhereUniqueInput | RecoveryDefinitionRateDetailsWhereUniqueInput[]
    update?: RecoveryDefinitionRateDetailsUpdateWithWhereUniqueWithoutRecoveryDefinitionInput | RecoveryDefinitionRateDetailsUpdateWithWhereUniqueWithoutRecoveryDefinitionInput[]
    updateMany?: RecoveryDefinitionRateDetailsUpdateManyWithWhereWithoutRecoveryDefinitionInput | RecoveryDefinitionRateDetailsUpdateManyWithWhereWithoutRecoveryDefinitionInput[]
    deleteMany?: RecoveryDefinitionRateDetailsScalarWhereInput | RecoveryDefinitionRateDetailsScalarWhereInput[]
  }

  export type RecoveryDefinitionDetailsUncheckedUpdateManyWithoutRecoveryDefinitionNestedInput = {
    create?: XOR<RecoveryDefinitionDetailsCreateWithoutRecoveryDefinitionInput, RecoveryDefinitionDetailsUncheckedCreateWithoutRecoveryDefinitionInput> | RecoveryDefinitionDetailsCreateWithoutRecoveryDefinitionInput[] | RecoveryDefinitionDetailsUncheckedCreateWithoutRecoveryDefinitionInput[]
    connectOrCreate?: RecoveryDefinitionDetailsCreateOrConnectWithoutRecoveryDefinitionInput | RecoveryDefinitionDetailsCreateOrConnectWithoutRecoveryDefinitionInput[]
    upsert?: RecoveryDefinitionDetailsUpsertWithWhereUniqueWithoutRecoveryDefinitionInput | RecoveryDefinitionDetailsUpsertWithWhereUniqueWithoutRecoveryDefinitionInput[]
    createMany?: RecoveryDefinitionDetailsCreateManyRecoveryDefinitionInputEnvelope
    set?: RecoveryDefinitionDetailsWhereUniqueInput | RecoveryDefinitionDetailsWhereUniqueInput[]
    disconnect?: RecoveryDefinitionDetailsWhereUniqueInput | RecoveryDefinitionDetailsWhereUniqueInput[]
    delete?: RecoveryDefinitionDetailsWhereUniqueInput | RecoveryDefinitionDetailsWhereUniqueInput[]
    connect?: RecoveryDefinitionDetailsWhereUniqueInput | RecoveryDefinitionDetailsWhereUniqueInput[]
    update?: RecoveryDefinitionDetailsUpdateWithWhereUniqueWithoutRecoveryDefinitionInput | RecoveryDefinitionDetailsUpdateWithWhereUniqueWithoutRecoveryDefinitionInput[]
    updateMany?: RecoveryDefinitionDetailsUpdateManyWithWhereWithoutRecoveryDefinitionInput | RecoveryDefinitionDetailsUpdateManyWithWhereWithoutRecoveryDefinitionInput[]
    deleteMany?: RecoveryDefinitionDetailsScalarWhereInput | RecoveryDefinitionDetailsScalarWhereInput[]
  }

  export type RecoveryDefinitionRateDetailsUncheckedUpdateManyWithoutRecoveryDefinitionNestedInput = {
    create?: XOR<RecoveryDefinitionRateDetailsCreateWithoutRecoveryDefinitionInput, RecoveryDefinitionRateDetailsUncheckedCreateWithoutRecoveryDefinitionInput> | RecoveryDefinitionRateDetailsCreateWithoutRecoveryDefinitionInput[] | RecoveryDefinitionRateDetailsUncheckedCreateWithoutRecoveryDefinitionInput[]
    connectOrCreate?: RecoveryDefinitionRateDetailsCreateOrConnectWithoutRecoveryDefinitionInput | RecoveryDefinitionRateDetailsCreateOrConnectWithoutRecoveryDefinitionInput[]
    upsert?: RecoveryDefinitionRateDetailsUpsertWithWhereUniqueWithoutRecoveryDefinitionInput | RecoveryDefinitionRateDetailsUpsertWithWhereUniqueWithoutRecoveryDefinitionInput[]
    createMany?: RecoveryDefinitionRateDetailsCreateManyRecoveryDefinitionInputEnvelope
    set?: RecoveryDefinitionRateDetailsWhereUniqueInput | RecoveryDefinitionRateDetailsWhereUniqueInput[]
    disconnect?: RecoveryDefinitionRateDetailsWhereUniqueInput | RecoveryDefinitionRateDetailsWhereUniqueInput[]
    delete?: RecoveryDefinitionRateDetailsWhereUniqueInput | RecoveryDefinitionRateDetailsWhereUniqueInput[]
    connect?: RecoveryDefinitionRateDetailsWhereUniqueInput | RecoveryDefinitionRateDetailsWhereUniqueInput[]
    update?: RecoveryDefinitionRateDetailsUpdateWithWhereUniqueWithoutRecoveryDefinitionInput | RecoveryDefinitionRateDetailsUpdateWithWhereUniqueWithoutRecoveryDefinitionInput[]
    updateMany?: RecoveryDefinitionRateDetailsUpdateManyWithWhereWithoutRecoveryDefinitionInput | RecoveryDefinitionRateDetailsUpdateManyWithWhereWithoutRecoveryDefinitionInput[]
    deleteMany?: RecoveryDefinitionRateDetailsScalarWhereInput | RecoveryDefinitionRateDetailsScalarWhereInput[]
  }

  export type RecoveryDefinitionCreateNestedOneWithoutRecoveryDefinitionDetailsInput = {
    create?: XOR<RecoveryDefinitionCreateWithoutRecoveryDefinitionDetailsInput, RecoveryDefinitionUncheckedCreateWithoutRecoveryDefinitionDetailsInput>
    connectOrCreate?: RecoveryDefinitionCreateOrConnectWithoutRecoveryDefinitionDetailsInput
    connect?: RecoveryDefinitionWhereUniqueInput
  }

  export type RecoveryDefinitionUpdateOneWithoutRecoveryDefinitionDetailsNestedInput = {
    create?: XOR<RecoveryDefinitionCreateWithoutRecoveryDefinitionDetailsInput, RecoveryDefinitionUncheckedCreateWithoutRecoveryDefinitionDetailsInput>
    connectOrCreate?: RecoveryDefinitionCreateOrConnectWithoutRecoveryDefinitionDetailsInput
    upsert?: RecoveryDefinitionUpsertWithoutRecoveryDefinitionDetailsInput
    disconnect?: RecoveryDefinitionWhereInput | boolean
    delete?: RecoveryDefinitionWhereInput | boolean
    connect?: RecoveryDefinitionWhereUniqueInput
    update?: XOR<XOR<RecoveryDefinitionUpdateToOneWithWhereWithoutRecoveryDefinitionDetailsInput, RecoveryDefinitionUpdateWithoutRecoveryDefinitionDetailsInput>, RecoveryDefinitionUncheckedUpdateWithoutRecoveryDefinitionDetailsInput>
  }

  export type RecoveryDefinitionCreateNestedOneWithoutRecoveryDefinitionRateDetailsInput = {
    create?: XOR<RecoveryDefinitionCreateWithoutRecoveryDefinitionRateDetailsInput, RecoveryDefinitionUncheckedCreateWithoutRecoveryDefinitionRateDetailsInput>
    connectOrCreate?: RecoveryDefinitionCreateOrConnectWithoutRecoveryDefinitionRateDetailsInput
    connect?: RecoveryDefinitionWhereUniqueInput
  }

  export type RecoveryDefinitionUpdateOneWithoutRecoveryDefinitionRateDetailsNestedInput = {
    create?: XOR<RecoveryDefinitionCreateWithoutRecoveryDefinitionRateDetailsInput, RecoveryDefinitionUncheckedCreateWithoutRecoveryDefinitionRateDetailsInput>
    connectOrCreate?: RecoveryDefinitionCreateOrConnectWithoutRecoveryDefinitionRateDetailsInput
    upsert?: RecoveryDefinitionUpsertWithoutRecoveryDefinitionRateDetailsInput
    disconnect?: RecoveryDefinitionWhereInput | boolean
    delete?: RecoveryDefinitionWhereInput | boolean
    connect?: RecoveryDefinitionWhereUniqueInput
    update?: XOR<XOR<RecoveryDefinitionUpdateToOneWithWhereWithoutRecoveryDefinitionRateDetailsInput, RecoveryDefinitionUpdateWithoutRecoveryDefinitionRateDetailsInput>, RecoveryDefinitionUncheckedUpdateWithoutRecoveryDefinitionRateDetailsInput>
  }

  export type SickDefinitionDetailCreateNestedManyWithoutSickDefinitionInput = {
    create?: XOR<SickDefinitionDetailCreateWithoutSickDefinitionInput, SickDefinitionDetailUncheckedCreateWithoutSickDefinitionInput> | SickDefinitionDetailCreateWithoutSickDefinitionInput[] | SickDefinitionDetailUncheckedCreateWithoutSickDefinitionInput[]
    connectOrCreate?: SickDefinitionDetailCreateOrConnectWithoutSickDefinitionInput | SickDefinitionDetailCreateOrConnectWithoutSickDefinitionInput[]
    createMany?: SickDefinitionDetailCreateManySickDefinitionInputEnvelope
    connect?: SickDefinitionDetailWhereUniqueInput | SickDefinitionDetailWhereUniqueInput[]
  }

  export type SickDefinitionDetailUncheckedCreateNestedManyWithoutSickDefinitionInput = {
    create?: XOR<SickDefinitionDetailCreateWithoutSickDefinitionInput, SickDefinitionDetailUncheckedCreateWithoutSickDefinitionInput> | SickDefinitionDetailCreateWithoutSickDefinitionInput[] | SickDefinitionDetailUncheckedCreateWithoutSickDefinitionInput[]
    connectOrCreate?: SickDefinitionDetailCreateOrConnectWithoutSickDefinitionInput | SickDefinitionDetailCreateOrConnectWithoutSickDefinitionInput[]
    createMany?: SickDefinitionDetailCreateManySickDefinitionInputEnvelope
    connect?: SickDefinitionDetailWhereUniqueInput | SickDefinitionDetailWhereUniqueInput[]
  }

  export type SickDefinitionDetailUpdateManyWithoutSickDefinitionNestedInput = {
    create?: XOR<SickDefinitionDetailCreateWithoutSickDefinitionInput, SickDefinitionDetailUncheckedCreateWithoutSickDefinitionInput> | SickDefinitionDetailCreateWithoutSickDefinitionInput[] | SickDefinitionDetailUncheckedCreateWithoutSickDefinitionInput[]
    connectOrCreate?: SickDefinitionDetailCreateOrConnectWithoutSickDefinitionInput | SickDefinitionDetailCreateOrConnectWithoutSickDefinitionInput[]
    upsert?: SickDefinitionDetailUpsertWithWhereUniqueWithoutSickDefinitionInput | SickDefinitionDetailUpsertWithWhereUniqueWithoutSickDefinitionInput[]
    createMany?: SickDefinitionDetailCreateManySickDefinitionInputEnvelope
    set?: SickDefinitionDetailWhereUniqueInput | SickDefinitionDetailWhereUniqueInput[]
    disconnect?: SickDefinitionDetailWhereUniqueInput | SickDefinitionDetailWhereUniqueInput[]
    delete?: SickDefinitionDetailWhereUniqueInput | SickDefinitionDetailWhereUniqueInput[]
    connect?: SickDefinitionDetailWhereUniqueInput | SickDefinitionDetailWhereUniqueInput[]
    update?: SickDefinitionDetailUpdateWithWhereUniqueWithoutSickDefinitionInput | SickDefinitionDetailUpdateWithWhereUniqueWithoutSickDefinitionInput[]
    updateMany?: SickDefinitionDetailUpdateManyWithWhereWithoutSickDefinitionInput | SickDefinitionDetailUpdateManyWithWhereWithoutSickDefinitionInput[]
    deleteMany?: SickDefinitionDetailScalarWhereInput | SickDefinitionDetailScalarWhereInput[]
  }

  export type SickDefinitionDetailUncheckedUpdateManyWithoutSickDefinitionNestedInput = {
    create?: XOR<SickDefinitionDetailCreateWithoutSickDefinitionInput, SickDefinitionDetailUncheckedCreateWithoutSickDefinitionInput> | SickDefinitionDetailCreateWithoutSickDefinitionInput[] | SickDefinitionDetailUncheckedCreateWithoutSickDefinitionInput[]
    connectOrCreate?: SickDefinitionDetailCreateOrConnectWithoutSickDefinitionInput | SickDefinitionDetailCreateOrConnectWithoutSickDefinitionInput[]
    upsert?: SickDefinitionDetailUpsertWithWhereUniqueWithoutSickDefinitionInput | SickDefinitionDetailUpsertWithWhereUniqueWithoutSickDefinitionInput[]
    createMany?: SickDefinitionDetailCreateManySickDefinitionInputEnvelope
    set?: SickDefinitionDetailWhereUniqueInput | SickDefinitionDetailWhereUniqueInput[]
    disconnect?: SickDefinitionDetailWhereUniqueInput | SickDefinitionDetailWhereUniqueInput[]
    delete?: SickDefinitionDetailWhereUniqueInput | SickDefinitionDetailWhereUniqueInput[]
    connect?: SickDefinitionDetailWhereUniqueInput | SickDefinitionDetailWhereUniqueInput[]
    update?: SickDefinitionDetailUpdateWithWhereUniqueWithoutSickDefinitionInput | SickDefinitionDetailUpdateWithWhereUniqueWithoutSickDefinitionInput[]
    updateMany?: SickDefinitionDetailUpdateManyWithWhereWithoutSickDefinitionInput | SickDefinitionDetailUpdateManyWithWhereWithoutSickDefinitionInput[]
    deleteMany?: SickDefinitionDetailScalarWhereInput | SickDefinitionDetailScalarWhereInput[]
  }

  export type SickDefinitionCreateNestedOneWithoutSickDefinitionDetailInput = {
    create?: XOR<SickDefinitionCreateWithoutSickDefinitionDetailInput, SickDefinitionUncheckedCreateWithoutSickDefinitionDetailInput>
    connectOrCreate?: SickDefinitionCreateOrConnectWithoutSickDefinitionDetailInput
    connect?: SickDefinitionWhereUniqueInput
  }

  export type SickDefinitionUpdateOneRequiredWithoutSickDefinitionDetailNestedInput = {
    create?: XOR<SickDefinitionCreateWithoutSickDefinitionDetailInput, SickDefinitionUncheckedCreateWithoutSickDefinitionDetailInput>
    connectOrCreate?: SickDefinitionCreateOrConnectWithoutSickDefinitionDetailInput
    upsert?: SickDefinitionUpsertWithoutSickDefinitionDetailInput
    connect?: SickDefinitionWhereUniqueInput
    update?: XOR<XOR<SickDefinitionUpdateToOneWithWhereWithoutSickDefinitionDetailInput, SickDefinitionUpdateWithoutSickDefinitionDetailInput>, SickDefinitionUncheckedUpdateWithoutSickDefinitionDetailInput>
  }

  export type SocialSecurityDetileCreateNestedManyWithoutSocialSecurityInput = {
    create?: XOR<SocialSecurityDetileCreateWithoutSocialSecurityInput, SocialSecurityDetileUncheckedCreateWithoutSocialSecurityInput> | SocialSecurityDetileCreateWithoutSocialSecurityInput[] | SocialSecurityDetileUncheckedCreateWithoutSocialSecurityInput[]
    connectOrCreate?: SocialSecurityDetileCreateOrConnectWithoutSocialSecurityInput | SocialSecurityDetileCreateOrConnectWithoutSocialSecurityInput[]
    createMany?: SocialSecurityDetileCreateManySocialSecurityInputEnvelope
    connect?: SocialSecurityDetileWhereUniqueInput | SocialSecurityDetileWhereUniqueInput[]
  }

  export type SocialSecurityDetileUncheckedCreateNestedManyWithoutSocialSecurityInput = {
    create?: XOR<SocialSecurityDetileCreateWithoutSocialSecurityInput, SocialSecurityDetileUncheckedCreateWithoutSocialSecurityInput> | SocialSecurityDetileCreateWithoutSocialSecurityInput[] | SocialSecurityDetileUncheckedCreateWithoutSocialSecurityInput[]
    connectOrCreate?: SocialSecurityDetileCreateOrConnectWithoutSocialSecurityInput | SocialSecurityDetileCreateOrConnectWithoutSocialSecurityInput[]
    createMany?: SocialSecurityDetileCreateManySocialSecurityInputEnvelope
    connect?: SocialSecurityDetileWhereUniqueInput | SocialSecurityDetileWhereUniqueInput[]
  }

  export type SocialSecurityDetileUpdateManyWithoutSocialSecurityNestedInput = {
    create?: XOR<SocialSecurityDetileCreateWithoutSocialSecurityInput, SocialSecurityDetileUncheckedCreateWithoutSocialSecurityInput> | SocialSecurityDetileCreateWithoutSocialSecurityInput[] | SocialSecurityDetileUncheckedCreateWithoutSocialSecurityInput[]
    connectOrCreate?: SocialSecurityDetileCreateOrConnectWithoutSocialSecurityInput | SocialSecurityDetileCreateOrConnectWithoutSocialSecurityInput[]
    upsert?: SocialSecurityDetileUpsertWithWhereUniqueWithoutSocialSecurityInput | SocialSecurityDetileUpsertWithWhereUniqueWithoutSocialSecurityInput[]
    createMany?: SocialSecurityDetileCreateManySocialSecurityInputEnvelope
    set?: SocialSecurityDetileWhereUniqueInput | SocialSecurityDetileWhereUniqueInput[]
    disconnect?: SocialSecurityDetileWhereUniqueInput | SocialSecurityDetileWhereUniqueInput[]
    delete?: SocialSecurityDetileWhereUniqueInput | SocialSecurityDetileWhereUniqueInput[]
    connect?: SocialSecurityDetileWhereUniqueInput | SocialSecurityDetileWhereUniqueInput[]
    update?: SocialSecurityDetileUpdateWithWhereUniqueWithoutSocialSecurityInput | SocialSecurityDetileUpdateWithWhereUniqueWithoutSocialSecurityInput[]
    updateMany?: SocialSecurityDetileUpdateManyWithWhereWithoutSocialSecurityInput | SocialSecurityDetileUpdateManyWithWhereWithoutSocialSecurityInput[]
    deleteMany?: SocialSecurityDetileScalarWhereInput | SocialSecurityDetileScalarWhereInput[]
  }

  export type SocialSecurityDetileUncheckedUpdateManyWithoutSocialSecurityNestedInput = {
    create?: XOR<SocialSecurityDetileCreateWithoutSocialSecurityInput, SocialSecurityDetileUncheckedCreateWithoutSocialSecurityInput> | SocialSecurityDetileCreateWithoutSocialSecurityInput[] | SocialSecurityDetileUncheckedCreateWithoutSocialSecurityInput[]
    connectOrCreate?: SocialSecurityDetileCreateOrConnectWithoutSocialSecurityInput | SocialSecurityDetileCreateOrConnectWithoutSocialSecurityInput[]
    upsert?: SocialSecurityDetileUpsertWithWhereUniqueWithoutSocialSecurityInput | SocialSecurityDetileUpsertWithWhereUniqueWithoutSocialSecurityInput[]
    createMany?: SocialSecurityDetileCreateManySocialSecurityInputEnvelope
    set?: SocialSecurityDetileWhereUniqueInput | SocialSecurityDetileWhereUniqueInput[]
    disconnect?: SocialSecurityDetileWhereUniqueInput | SocialSecurityDetileWhereUniqueInput[]
    delete?: SocialSecurityDetileWhereUniqueInput | SocialSecurityDetileWhereUniqueInput[]
    connect?: SocialSecurityDetileWhereUniqueInput | SocialSecurityDetileWhereUniqueInput[]
    update?: SocialSecurityDetileUpdateWithWhereUniqueWithoutSocialSecurityInput | SocialSecurityDetileUpdateWithWhereUniqueWithoutSocialSecurityInput[]
    updateMany?: SocialSecurityDetileUpdateManyWithWhereWithoutSocialSecurityInput | SocialSecurityDetileUpdateManyWithWhereWithoutSocialSecurityInput[]
    deleteMany?: SocialSecurityDetileScalarWhereInput | SocialSecurityDetileScalarWhereInput[]
  }

  export type SocialSecurityCreateNestedOneWithoutSocialSecurityDetileInput = {
    create?: XOR<SocialSecurityCreateWithoutSocialSecurityDetileInput, SocialSecurityUncheckedCreateWithoutSocialSecurityDetileInput>
    connectOrCreate?: SocialSecurityCreateOrConnectWithoutSocialSecurityDetileInput
    connect?: SocialSecurityWhereUniqueInput
  }

  export type SocialSecurityUpdateOneRequiredWithoutSocialSecurityDetileNestedInput = {
    create?: XOR<SocialSecurityCreateWithoutSocialSecurityDetileInput, SocialSecurityUncheckedCreateWithoutSocialSecurityDetileInput>
    connectOrCreate?: SocialSecurityCreateOrConnectWithoutSocialSecurityDetileInput
    upsert?: SocialSecurityUpsertWithoutSocialSecurityDetileInput
    connect?: SocialSecurityWhereUniqueInput
    update?: XOR<XOR<SocialSecurityUpdateToOneWithWhereWithoutSocialSecurityDetileInput, SocialSecurityUpdateWithoutSocialSecurityDetileInput>, SocialSecurityUncheckedUpdateWithoutSocialSecurityDetileInput>
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type TaxStepsCreateNestedOneWithoutTaxStepDetileInput = {
    create?: XOR<TaxStepsCreateWithoutTaxStepDetileInput, TaxStepsUncheckedCreateWithoutTaxStepDetileInput>
    connectOrCreate?: TaxStepsCreateOrConnectWithoutTaxStepDetileInput
    connect?: TaxStepsWhereUniqueInput
  }

  export type TaxStepsUpdateOneRequiredWithoutTaxStepDetileNestedInput = {
    create?: XOR<TaxStepsCreateWithoutTaxStepDetileInput, TaxStepsUncheckedCreateWithoutTaxStepDetileInput>
    connectOrCreate?: TaxStepsCreateOrConnectWithoutTaxStepDetileInput
    upsert?: TaxStepsUpsertWithoutTaxStepDetileInput
    connect?: TaxStepsWhereUniqueInput
    update?: XOR<XOR<TaxStepsUpdateToOneWithWhereWithoutTaxStepDetileInput, TaxStepsUpdateWithoutTaxStepDetileInput>, TaxStepsUncheckedUpdateWithoutTaxStepDetileInput>
  }

  export type TaxStepDetileCreateNestedManyWithoutTaxStepsInput = {
    create?: XOR<TaxStepDetileCreateWithoutTaxStepsInput, TaxStepDetileUncheckedCreateWithoutTaxStepsInput> | TaxStepDetileCreateWithoutTaxStepsInput[] | TaxStepDetileUncheckedCreateWithoutTaxStepsInput[]
    connectOrCreate?: TaxStepDetileCreateOrConnectWithoutTaxStepsInput | TaxStepDetileCreateOrConnectWithoutTaxStepsInput[]
    createMany?: TaxStepDetileCreateManyTaxStepsInputEnvelope
    connect?: TaxStepDetileWhereUniqueInput | TaxStepDetileWhereUniqueInput[]
  }

  export type TaxStepDetileUncheckedCreateNestedManyWithoutTaxStepsInput = {
    create?: XOR<TaxStepDetileCreateWithoutTaxStepsInput, TaxStepDetileUncheckedCreateWithoutTaxStepsInput> | TaxStepDetileCreateWithoutTaxStepsInput[] | TaxStepDetileUncheckedCreateWithoutTaxStepsInput[]
    connectOrCreate?: TaxStepDetileCreateOrConnectWithoutTaxStepsInput | TaxStepDetileCreateOrConnectWithoutTaxStepsInput[]
    createMany?: TaxStepDetileCreateManyTaxStepsInputEnvelope
    connect?: TaxStepDetileWhereUniqueInput | TaxStepDetileWhereUniqueInput[]
  }

  export type TaxStepDetileUpdateManyWithoutTaxStepsNestedInput = {
    create?: XOR<TaxStepDetileCreateWithoutTaxStepsInput, TaxStepDetileUncheckedCreateWithoutTaxStepsInput> | TaxStepDetileCreateWithoutTaxStepsInput[] | TaxStepDetileUncheckedCreateWithoutTaxStepsInput[]
    connectOrCreate?: TaxStepDetileCreateOrConnectWithoutTaxStepsInput | TaxStepDetileCreateOrConnectWithoutTaxStepsInput[]
    upsert?: TaxStepDetileUpsertWithWhereUniqueWithoutTaxStepsInput | TaxStepDetileUpsertWithWhereUniqueWithoutTaxStepsInput[]
    createMany?: TaxStepDetileCreateManyTaxStepsInputEnvelope
    set?: TaxStepDetileWhereUniqueInput | TaxStepDetileWhereUniqueInput[]
    disconnect?: TaxStepDetileWhereUniqueInput | TaxStepDetileWhereUniqueInput[]
    delete?: TaxStepDetileWhereUniqueInput | TaxStepDetileWhereUniqueInput[]
    connect?: TaxStepDetileWhereUniqueInput | TaxStepDetileWhereUniqueInput[]
    update?: TaxStepDetileUpdateWithWhereUniqueWithoutTaxStepsInput | TaxStepDetileUpdateWithWhereUniqueWithoutTaxStepsInput[]
    updateMany?: TaxStepDetileUpdateManyWithWhereWithoutTaxStepsInput | TaxStepDetileUpdateManyWithWhereWithoutTaxStepsInput[]
    deleteMany?: TaxStepDetileScalarWhereInput | TaxStepDetileScalarWhereInput[]
  }

  export type TaxStepDetileUncheckedUpdateManyWithoutTaxStepsNestedInput = {
    create?: XOR<TaxStepDetileCreateWithoutTaxStepsInput, TaxStepDetileUncheckedCreateWithoutTaxStepsInput> | TaxStepDetileCreateWithoutTaxStepsInput[] | TaxStepDetileUncheckedCreateWithoutTaxStepsInput[]
    connectOrCreate?: TaxStepDetileCreateOrConnectWithoutTaxStepsInput | TaxStepDetileCreateOrConnectWithoutTaxStepsInput[]
    upsert?: TaxStepDetileUpsertWithWhereUniqueWithoutTaxStepsInput | TaxStepDetileUpsertWithWhereUniqueWithoutTaxStepsInput[]
    createMany?: TaxStepDetileCreateManyTaxStepsInputEnvelope
    set?: TaxStepDetileWhereUniqueInput | TaxStepDetileWhereUniqueInput[]
    disconnect?: TaxStepDetileWhereUniqueInput | TaxStepDetileWhereUniqueInput[]
    delete?: TaxStepDetileWhereUniqueInput | TaxStepDetileWhereUniqueInput[]
    connect?: TaxStepDetileWhereUniqueInput | TaxStepDetileWhereUniqueInput[]
    update?: TaxStepDetileUpdateWithWhereUniqueWithoutTaxStepsInput | TaxStepDetileUpdateWithWhereUniqueWithoutTaxStepsInput[]
    updateMany?: TaxStepDetileUpdateManyWithWhereWithoutTaxStepsInput | TaxStepDetileUpdateManyWithWhereWithoutTaxStepsInput[]
    deleteMany?: TaxStepDetileScalarWhereInput | TaxStepDetileScalarWhereInput[]
  }

  export type UnionFeeDetileCreateNestedManyWithoutUnionFeeInput = {
    create?: XOR<UnionFeeDetileCreateWithoutUnionFeeInput, UnionFeeDetileUncheckedCreateWithoutUnionFeeInput> | UnionFeeDetileCreateWithoutUnionFeeInput[] | UnionFeeDetileUncheckedCreateWithoutUnionFeeInput[]
    connectOrCreate?: UnionFeeDetileCreateOrConnectWithoutUnionFeeInput | UnionFeeDetileCreateOrConnectWithoutUnionFeeInput[]
    createMany?: UnionFeeDetileCreateManyUnionFeeInputEnvelope
    connect?: UnionFeeDetileWhereUniqueInput | UnionFeeDetileWhereUniqueInput[]
  }

  export type UnionFeeDetileUncheckedCreateNestedManyWithoutUnionFeeInput = {
    create?: XOR<UnionFeeDetileCreateWithoutUnionFeeInput, UnionFeeDetileUncheckedCreateWithoutUnionFeeInput> | UnionFeeDetileCreateWithoutUnionFeeInput[] | UnionFeeDetileUncheckedCreateWithoutUnionFeeInput[]
    connectOrCreate?: UnionFeeDetileCreateOrConnectWithoutUnionFeeInput | UnionFeeDetileCreateOrConnectWithoutUnionFeeInput[]
    createMany?: UnionFeeDetileCreateManyUnionFeeInputEnvelope
    connect?: UnionFeeDetileWhereUniqueInput | UnionFeeDetileWhereUniqueInput[]
  }

  export type UnionFeeDetileUpdateManyWithoutUnionFeeNestedInput = {
    create?: XOR<UnionFeeDetileCreateWithoutUnionFeeInput, UnionFeeDetileUncheckedCreateWithoutUnionFeeInput> | UnionFeeDetileCreateWithoutUnionFeeInput[] | UnionFeeDetileUncheckedCreateWithoutUnionFeeInput[]
    connectOrCreate?: UnionFeeDetileCreateOrConnectWithoutUnionFeeInput | UnionFeeDetileCreateOrConnectWithoutUnionFeeInput[]
    upsert?: UnionFeeDetileUpsertWithWhereUniqueWithoutUnionFeeInput | UnionFeeDetileUpsertWithWhereUniqueWithoutUnionFeeInput[]
    createMany?: UnionFeeDetileCreateManyUnionFeeInputEnvelope
    set?: UnionFeeDetileWhereUniqueInput | UnionFeeDetileWhereUniqueInput[]
    disconnect?: UnionFeeDetileWhereUniqueInput | UnionFeeDetileWhereUniqueInput[]
    delete?: UnionFeeDetileWhereUniqueInput | UnionFeeDetileWhereUniqueInput[]
    connect?: UnionFeeDetileWhereUniqueInput | UnionFeeDetileWhereUniqueInput[]
    update?: UnionFeeDetileUpdateWithWhereUniqueWithoutUnionFeeInput | UnionFeeDetileUpdateWithWhereUniqueWithoutUnionFeeInput[]
    updateMany?: UnionFeeDetileUpdateManyWithWhereWithoutUnionFeeInput | UnionFeeDetileUpdateManyWithWhereWithoutUnionFeeInput[]
    deleteMany?: UnionFeeDetileScalarWhereInput | UnionFeeDetileScalarWhereInput[]
  }

  export type UnionFeeDetileUncheckedUpdateManyWithoutUnionFeeNestedInput = {
    create?: XOR<UnionFeeDetileCreateWithoutUnionFeeInput, UnionFeeDetileUncheckedCreateWithoutUnionFeeInput> | UnionFeeDetileCreateWithoutUnionFeeInput[] | UnionFeeDetileUncheckedCreateWithoutUnionFeeInput[]
    connectOrCreate?: UnionFeeDetileCreateOrConnectWithoutUnionFeeInput | UnionFeeDetileCreateOrConnectWithoutUnionFeeInput[]
    upsert?: UnionFeeDetileUpsertWithWhereUniqueWithoutUnionFeeInput | UnionFeeDetileUpsertWithWhereUniqueWithoutUnionFeeInput[]
    createMany?: UnionFeeDetileCreateManyUnionFeeInputEnvelope
    set?: UnionFeeDetileWhereUniqueInput | UnionFeeDetileWhereUniqueInput[]
    disconnect?: UnionFeeDetileWhereUniqueInput | UnionFeeDetileWhereUniqueInput[]
    delete?: UnionFeeDetileWhereUniqueInput | UnionFeeDetileWhereUniqueInput[]
    connect?: UnionFeeDetileWhereUniqueInput | UnionFeeDetileWhereUniqueInput[]
    update?: UnionFeeDetileUpdateWithWhereUniqueWithoutUnionFeeInput | UnionFeeDetileUpdateWithWhereUniqueWithoutUnionFeeInput[]
    updateMany?: UnionFeeDetileUpdateManyWithWhereWithoutUnionFeeInput | UnionFeeDetileUpdateManyWithWhereWithoutUnionFeeInput[]
    deleteMany?: UnionFeeDetileScalarWhereInput | UnionFeeDetileScalarWhereInput[]
  }

  export type UnionFeeCreateNestedOneWithoutUnionFeeDetileInput = {
    create?: XOR<UnionFeeCreateWithoutUnionFeeDetileInput, UnionFeeUncheckedCreateWithoutUnionFeeDetileInput>
    connectOrCreate?: UnionFeeCreateOrConnectWithoutUnionFeeDetileInput
    connect?: UnionFeeWhereUniqueInput
  }

  export type UnionFeeUpdateOneRequiredWithoutUnionFeeDetileNestedInput = {
    create?: XOR<UnionFeeCreateWithoutUnionFeeDetileInput, UnionFeeUncheckedCreateWithoutUnionFeeDetileInput>
    connectOrCreate?: UnionFeeCreateOrConnectWithoutUnionFeeDetileInput
    upsert?: UnionFeeUpsertWithoutUnionFeeDetileInput
    connect?: UnionFeeWhereUniqueInput
    update?: XOR<XOR<UnionFeeUpdateToOneWithWhereWithoutUnionFeeDetileInput, UnionFeeUpdateWithoutUnionFeeDetileInput>, UnionFeeUncheckedUpdateWithoutUnionFeeDetileInput>
  }

  export type VacationlDefinitionCreateNestedOneWithoutVacationDefinitionDetailsInput = {
    create?: XOR<VacationlDefinitionCreateWithoutVacationDefinitionDetailsInput, VacationlDefinitionUncheckedCreateWithoutVacationDefinitionDetailsInput>
    connectOrCreate?: VacationlDefinitionCreateOrConnectWithoutVacationDefinitionDetailsInput
    connect?: VacationlDefinitionWhereUniqueInput
  }

  export type VacationlDefinitionUpdateOneWithoutVacationDefinitionDetailsNestedInput = {
    create?: XOR<VacationlDefinitionCreateWithoutVacationDefinitionDetailsInput, VacationlDefinitionUncheckedCreateWithoutVacationDefinitionDetailsInput>
    connectOrCreate?: VacationlDefinitionCreateOrConnectWithoutVacationDefinitionDetailsInput
    upsert?: VacationlDefinitionUpsertWithoutVacationDefinitionDetailsInput
    disconnect?: VacationlDefinitionWhereInput | boolean
    delete?: VacationlDefinitionWhereInput | boolean
    connect?: VacationlDefinitionWhereUniqueInput
    update?: XOR<XOR<VacationlDefinitionUpdateToOneWithWhereWithoutVacationDefinitionDetailsInput, VacationlDefinitionUpdateWithoutVacationDefinitionDetailsInput>, VacationlDefinitionUncheckedUpdateWithoutVacationDefinitionDetailsInput>
  }

  export type VacationDefinitionDetailsCreateNestedManyWithoutVacationlDefinitionInput = {
    create?: XOR<VacationDefinitionDetailsCreateWithoutVacationlDefinitionInput, VacationDefinitionDetailsUncheckedCreateWithoutVacationlDefinitionInput> | VacationDefinitionDetailsCreateWithoutVacationlDefinitionInput[] | VacationDefinitionDetailsUncheckedCreateWithoutVacationlDefinitionInput[]
    connectOrCreate?: VacationDefinitionDetailsCreateOrConnectWithoutVacationlDefinitionInput | VacationDefinitionDetailsCreateOrConnectWithoutVacationlDefinitionInput[]
    createMany?: VacationDefinitionDetailsCreateManyVacationlDefinitionInputEnvelope
    connect?: VacationDefinitionDetailsWhereUniqueInput | VacationDefinitionDetailsWhereUniqueInput[]
  }

  export type VacationDefinitionDetailsUncheckedCreateNestedManyWithoutVacationlDefinitionInput = {
    create?: XOR<VacationDefinitionDetailsCreateWithoutVacationlDefinitionInput, VacationDefinitionDetailsUncheckedCreateWithoutVacationlDefinitionInput> | VacationDefinitionDetailsCreateWithoutVacationlDefinitionInput[] | VacationDefinitionDetailsUncheckedCreateWithoutVacationlDefinitionInput[]
    connectOrCreate?: VacationDefinitionDetailsCreateOrConnectWithoutVacationlDefinitionInput | VacationDefinitionDetailsCreateOrConnectWithoutVacationlDefinitionInput[]
    createMany?: VacationDefinitionDetailsCreateManyVacationlDefinitionInputEnvelope
    connect?: VacationDefinitionDetailsWhereUniqueInput | VacationDefinitionDetailsWhereUniqueInput[]
  }

  export type VacationDefinitionDetailsUpdateManyWithoutVacationlDefinitionNestedInput = {
    create?: XOR<VacationDefinitionDetailsCreateWithoutVacationlDefinitionInput, VacationDefinitionDetailsUncheckedCreateWithoutVacationlDefinitionInput> | VacationDefinitionDetailsCreateWithoutVacationlDefinitionInput[] | VacationDefinitionDetailsUncheckedCreateWithoutVacationlDefinitionInput[]
    connectOrCreate?: VacationDefinitionDetailsCreateOrConnectWithoutVacationlDefinitionInput | VacationDefinitionDetailsCreateOrConnectWithoutVacationlDefinitionInput[]
    upsert?: VacationDefinitionDetailsUpsertWithWhereUniqueWithoutVacationlDefinitionInput | VacationDefinitionDetailsUpsertWithWhereUniqueWithoutVacationlDefinitionInput[]
    createMany?: VacationDefinitionDetailsCreateManyVacationlDefinitionInputEnvelope
    set?: VacationDefinitionDetailsWhereUniqueInput | VacationDefinitionDetailsWhereUniqueInput[]
    disconnect?: VacationDefinitionDetailsWhereUniqueInput | VacationDefinitionDetailsWhereUniqueInput[]
    delete?: VacationDefinitionDetailsWhereUniqueInput | VacationDefinitionDetailsWhereUniqueInput[]
    connect?: VacationDefinitionDetailsWhereUniqueInput | VacationDefinitionDetailsWhereUniqueInput[]
    update?: VacationDefinitionDetailsUpdateWithWhereUniqueWithoutVacationlDefinitionInput | VacationDefinitionDetailsUpdateWithWhereUniqueWithoutVacationlDefinitionInput[]
    updateMany?: VacationDefinitionDetailsUpdateManyWithWhereWithoutVacationlDefinitionInput | VacationDefinitionDetailsUpdateManyWithWhereWithoutVacationlDefinitionInput[]
    deleteMany?: VacationDefinitionDetailsScalarWhereInput | VacationDefinitionDetailsScalarWhereInput[]
  }

  export type VacationDefinitionDetailsUncheckedUpdateManyWithoutVacationlDefinitionNestedInput = {
    create?: XOR<VacationDefinitionDetailsCreateWithoutVacationlDefinitionInput, VacationDefinitionDetailsUncheckedCreateWithoutVacationlDefinitionInput> | VacationDefinitionDetailsCreateWithoutVacationlDefinitionInput[] | VacationDefinitionDetailsUncheckedCreateWithoutVacationlDefinitionInput[]
    connectOrCreate?: VacationDefinitionDetailsCreateOrConnectWithoutVacationlDefinitionInput | VacationDefinitionDetailsCreateOrConnectWithoutVacationlDefinitionInput[]
    upsert?: VacationDefinitionDetailsUpsertWithWhereUniqueWithoutVacationlDefinitionInput | VacationDefinitionDetailsUpsertWithWhereUniqueWithoutVacationlDefinitionInput[]
    createMany?: VacationDefinitionDetailsCreateManyVacationlDefinitionInputEnvelope
    set?: VacationDefinitionDetailsWhereUniqueInput | VacationDefinitionDetailsWhereUniqueInput[]
    disconnect?: VacationDefinitionDetailsWhereUniqueInput | VacationDefinitionDetailsWhereUniqueInput[]
    delete?: VacationDefinitionDetailsWhereUniqueInput | VacationDefinitionDetailsWhereUniqueInput[]
    connect?: VacationDefinitionDetailsWhereUniqueInput | VacationDefinitionDetailsWhereUniqueInput[]
    update?: VacationDefinitionDetailsUpdateWithWhereUniqueWithoutVacationlDefinitionInput | VacationDefinitionDetailsUpdateWithWhereUniqueWithoutVacationlDefinitionInput[]
    updateMany?: VacationDefinitionDetailsUpdateManyWithWhereWithoutVacationlDefinitionInput | VacationDefinitionDetailsUpdateManyWithWhereWithoutVacationlDefinitionInput[]
    deleteMany?: VacationDefinitionDetailsScalarWhereInput | VacationDefinitionDetailsScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type AutoWordReportSubCreateWithoutAutoWordReportInput = {
    FieldNameTB?: string | null
    FieldNameReport?: string | null
  }

  export type AutoWordReportSubUncheckedCreateWithoutAutoWordReportInput = {
    ReportSubID?: number
    FieldNameTB?: string | null
    FieldNameReport?: string | null
  }

  export type AutoWordReportSubCreateOrConnectWithoutAutoWordReportInput = {
    where: AutoWordReportSubWhereUniqueInput
    create: XOR<AutoWordReportSubCreateWithoutAutoWordReportInput, AutoWordReportSubUncheckedCreateWithoutAutoWordReportInput>
  }

  export type AutoWordReportSubCreateManyAutoWordReportInputEnvelope = {
    data: AutoWordReportSubCreateManyAutoWordReportInput | AutoWordReportSubCreateManyAutoWordReportInput[]
  }

  export type AutoWordReportSubUpsertWithWhereUniqueWithoutAutoWordReportInput = {
    where: AutoWordReportSubWhereUniqueInput
    update: XOR<AutoWordReportSubUpdateWithoutAutoWordReportInput, AutoWordReportSubUncheckedUpdateWithoutAutoWordReportInput>
    create: XOR<AutoWordReportSubCreateWithoutAutoWordReportInput, AutoWordReportSubUncheckedCreateWithoutAutoWordReportInput>
  }

  export type AutoWordReportSubUpdateWithWhereUniqueWithoutAutoWordReportInput = {
    where: AutoWordReportSubWhereUniqueInput
    data: XOR<AutoWordReportSubUpdateWithoutAutoWordReportInput, AutoWordReportSubUncheckedUpdateWithoutAutoWordReportInput>
  }

  export type AutoWordReportSubUpdateManyWithWhereWithoutAutoWordReportInput = {
    where: AutoWordReportSubScalarWhereInput
    data: XOR<AutoWordReportSubUpdateManyMutationInput, AutoWordReportSubUncheckedUpdateManyWithoutAutoWordReportInput>
  }

  export type AutoWordReportSubScalarWhereInput = {
    AND?: AutoWordReportSubScalarWhereInput | AutoWordReportSubScalarWhereInput[]
    OR?: AutoWordReportSubScalarWhereInput[]
    NOT?: AutoWordReportSubScalarWhereInput | AutoWordReportSubScalarWhereInput[]
    ReportSubID?: IntFilter<"AutoWordReportSub"> | number
    ReportID?: IntNullableFilter<"AutoWordReportSub"> | number | null
    FieldNameTB?: StringNullableFilter<"AutoWordReportSub"> | string | null
    FieldNameReport?: StringNullableFilter<"AutoWordReportSub"> | string | null
  }

  export type AutoWordReportCreateWithoutAutoWordReportSubInput = {
    ReportName?: string | null
    ReportTemplateName?: string | null
    IsEmployee: boolean
    IsCustomer: boolean
    StrSQL?: string | null
    IsChossCustomerOrEmployee: boolean
    SaveInArchive?: number | null
    IsView: boolean
  }

  export type AutoWordReportUncheckedCreateWithoutAutoWordReportSubInput = {
    ReportID?: number
    ReportName?: string | null
    ReportTemplateName?: string | null
    IsEmployee: boolean
    IsCustomer: boolean
    StrSQL?: string | null
    IsChossCustomerOrEmployee: boolean
    SaveInArchive?: number | null
    IsView: boolean
  }

  export type AutoWordReportCreateOrConnectWithoutAutoWordReportSubInput = {
    where: AutoWordReportWhereUniqueInput
    create: XOR<AutoWordReportCreateWithoutAutoWordReportSubInput, AutoWordReportUncheckedCreateWithoutAutoWordReportSubInput>
  }

  export type AutoWordReportUpsertWithoutAutoWordReportSubInput = {
    update: XOR<AutoWordReportUpdateWithoutAutoWordReportSubInput, AutoWordReportUncheckedUpdateWithoutAutoWordReportSubInput>
    create: XOR<AutoWordReportCreateWithoutAutoWordReportSubInput, AutoWordReportUncheckedCreateWithoutAutoWordReportSubInput>
    where?: AutoWordReportWhereInput
  }

  export type AutoWordReportUpdateToOneWithWhereWithoutAutoWordReportSubInput = {
    where?: AutoWordReportWhereInput
    data: XOR<AutoWordReportUpdateWithoutAutoWordReportSubInput, AutoWordReportUncheckedUpdateWithoutAutoWordReportSubInput>
  }

  export type AutoWordReportUpdateWithoutAutoWordReportSubInput = {
    ReportName?: NullableStringFieldUpdateOperationsInput | string | null
    ReportTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    IsEmployee?: BoolFieldUpdateOperationsInput | boolean
    IsCustomer?: BoolFieldUpdateOperationsInput | boolean
    StrSQL?: NullableStringFieldUpdateOperationsInput | string | null
    IsChossCustomerOrEmployee?: BoolFieldUpdateOperationsInput | boolean
    SaveInArchive?: NullableIntFieldUpdateOperationsInput | number | null
    IsView?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutoWordReportUncheckedUpdateWithoutAutoWordReportSubInput = {
    ReportID?: IntFieldUpdateOperationsInput | number
    ReportName?: NullableStringFieldUpdateOperationsInput | string | null
    ReportTemplateName?: NullableStringFieldUpdateOperationsInput | string | null
    IsEmployee?: BoolFieldUpdateOperationsInput | boolean
    IsCustomer?: BoolFieldUpdateOperationsInput | boolean
    StrSQL?: NullableStringFieldUpdateOperationsInput | string | null
    IsChossCustomerOrEmployee?: BoolFieldUpdateOperationsInput | boolean
    SaveInArchive?: NullableIntFieldUpdateOperationsInput | number | null
    IsView?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CompaniesTypeCreateWithoutCompaniesInput = {
    CompaniesTypeID?: string
    CompaniesType: string
  }

  export type CompaniesTypeUncheckedCreateWithoutCompaniesInput = {
    CompaniesTypeID?: string
    CompaniesType: string
  }

  export type CompaniesTypeCreateOrConnectWithoutCompaniesInput = {
    where: CompaniesTypeWhereUniqueInput
    create: XOR<CompaniesTypeCreateWithoutCompaniesInput, CompaniesTypeUncheckedCreateWithoutCompaniesInput>
  }

  export type CompaniesUsersCreateWithoutCompanies_Companies_UserIdToCompaniesUsersInput = {
    CompaniesUsersID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutOther_CompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersCreateNestedManyWithoutCompaniesUsersInput
    Companies_CompaniesUsers_CompanyIDToCompanies: CompaniesCreateNestedOneWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersUncheckedCreateWithoutCompanies_Companies_UserIdToCompaniesUsersInput = {
    CompaniesUsersID: string
    CompanyID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    UserId?: string | null
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersCreateOrConnectWithoutCompanies_Companies_UserIdToCompaniesUsersInput = {
    where: CompaniesUsersWhereUniqueInput
    create: XOR<CompaniesUsersCreateWithoutCompanies_Companies_UserIdToCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompanies_Companies_UserIdToCompaniesUsersInput>
  }

  export type CompaniesProductsCreateWithoutCompaniesInput = {
    CompaniesProductsId?: string
    CreatedAt?: Date | string | null
    LastVersionDate_Salary?: Date | string | null
    LastVersionDate_ManPower?: Date | string | null
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompaniesProductsInput
    Products: ProductsCreateNestedOneWithoutCompaniesProductsInput
  }

  export type CompaniesProductsUncheckedCreateWithoutCompaniesInput = {
    CompaniesProductsId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    UserId?: string | null
    LastVersionDate_Salary?: Date | string | null
    LastVersionDate_ManPower?: Date | string | null
  }

  export type CompaniesProductsCreateOrConnectWithoutCompaniesInput = {
    where: CompaniesProductsWhereUniqueInput
    create: XOR<CompaniesProductsCreateWithoutCompaniesInput, CompaniesProductsUncheckedCreateWithoutCompaniesInput>
  }

  export type CompaniesProductsCreateManyCompaniesInputEnvelope = {
    data: CompaniesProductsCreateManyCompaniesInput | CompaniesProductsCreateManyCompaniesInput[]
  }

  export type CompaniesProductsExpireDatesCreateWithoutCompaniesInput = {
    CompaniesProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompaniesProductsExpireDatesInput
    Products: ProductsCreateNestedOneWithoutCompaniesProductsExpireDatesInput
  }

  export type CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesInput = {
    CompaniesProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    UserId?: string | null
  }

  export type CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesInput = {
    where: CompaniesProductsExpireDatesWhereUniqueInput
    create: XOR<CompaniesProductsExpireDatesCreateWithoutCompaniesInput, CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesInput>
  }

  export type CompaniesProductsExpireDatesCreateManyCompaniesInputEnvelope = {
    data: CompaniesProductsExpireDatesCreateManyCompaniesInput | CompaniesProductsExpireDatesCreateManyCompaniesInput[]
  }

  export type CompaniesUsersCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput = {
    CompaniesUsersID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutOther_CompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersUncheckedCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput = {
    CompaniesUsersID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    UserId?: string | null
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersCreateOrConnectWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput = {
    where: CompaniesUsersWhereUniqueInput
    create: XOR<CompaniesUsersCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUsersUncheckedCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput>
  }

  export type CompaniesUsersCreateManyCompanies_CompaniesUsers_CompanyIDToCompaniesInputEnvelope = {
    data: CompaniesUsersCreateManyCompanies_CompaniesUsers_CompanyIDToCompaniesInput | CompaniesUsersCreateManyCompanies_CompaniesUsers_CompanyIDToCompaniesInput[]
  }

  export type CompaniesUsersProductsExpireDatesCreateWithoutCompaniesInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers: CompaniesUsersCreateNestedOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
    Products: ProductsCreateNestedOneWithoutCompaniesUsersProductsExpireDatesInput
  }

  export type CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompaniesUsersID: string
    StartDate: Date | string
    EndDate: Date | string
    UserId?: string | null
    Comments?: string | null
  }

  export type CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesInput = {
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    create: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesInput>
  }

  export type CompaniesUsersProductsExpireDatesCreateManyCompaniesInputEnvelope = {
    data: CompaniesUsersProductsExpireDatesCreateManyCompaniesInput | CompaniesUsersProductsExpireDatesCreateManyCompaniesInput[]
  }

  export type LandPagesCreateWithoutCompaniesInput = {
    LandPageRowId?: string
    CreatedAt?: Date | string | null
    JsonData?: string | null
    ViewDate?: Date | string | null
    CompletedDate?: Date | string | null
  }

  export type LandPagesUncheckedCreateWithoutCompaniesInput = {
    LandPageRowId?: string
    CreatedAt?: Date | string | null
    JsonData?: string | null
    ViewDate?: Date | string | null
    CompletedDate?: Date | string | null
  }

  export type LandPagesCreateOrConnectWithoutCompaniesInput = {
    where: LandPagesWhereUniqueInput
    create: XOR<LandPagesCreateWithoutCompaniesInput, LandPagesUncheckedCreateWithoutCompaniesInput>
  }

  export type CompaniesTypeUpsertWithoutCompaniesInput = {
    update: XOR<CompaniesTypeUpdateWithoutCompaniesInput, CompaniesTypeUncheckedUpdateWithoutCompaniesInput>
    create: XOR<CompaniesTypeCreateWithoutCompaniesInput, CompaniesTypeUncheckedCreateWithoutCompaniesInput>
    where?: CompaniesTypeWhereInput
  }

  export type CompaniesTypeUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: CompaniesTypeWhereInput
    data: XOR<CompaniesTypeUpdateWithoutCompaniesInput, CompaniesTypeUncheckedUpdateWithoutCompaniesInput>
  }

  export type CompaniesTypeUpdateWithoutCompaniesInput = {
    CompaniesTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesType?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesTypeUncheckedUpdateWithoutCompaniesInput = {
    CompaniesTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesType?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesUsersUpsertWithoutCompanies_Companies_UserIdToCompaniesUsersInput = {
    update: XOR<CompaniesUsersUpdateWithoutCompanies_Companies_UserIdToCompaniesUsersInput, CompaniesUsersUncheckedUpdateWithoutCompanies_Companies_UserIdToCompaniesUsersInput>
    create: XOR<CompaniesUsersCreateWithoutCompanies_Companies_UserIdToCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompanies_Companies_UserIdToCompaniesUsersInput>
    where?: CompaniesUsersWhereInput
  }

  export type CompaniesUsersUpdateToOneWithWhereWithoutCompanies_Companies_UserIdToCompaniesUsersInput = {
    where?: CompaniesUsersWhereInput
    data: XOR<CompaniesUsersUpdateWithoutCompanies_Companies_UserIdToCompaniesUsersInput, CompaniesUsersUncheckedUpdateWithoutCompanies_Companies_UserIdToCompaniesUsersInput>
  }

  export type CompaniesUsersUpdateWithoutCompanies_Companies_UserIdToCompaniesUsersInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutOther_CompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUpdateManyWithoutCompaniesUsersNestedInput
    Companies_CompaniesUsers_CompanyIDToCompanies?: CompaniesUpdateOneRequiredWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersUncheckedUpdateWithoutCompanies_Companies_UserIdToCompaniesUsersInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesProductsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: CompaniesProductsWhereUniqueInput
    update: XOR<CompaniesProductsUpdateWithoutCompaniesInput, CompaniesProductsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<CompaniesProductsCreateWithoutCompaniesInput, CompaniesProductsUncheckedCreateWithoutCompaniesInput>
  }

  export type CompaniesProductsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: CompaniesProductsWhereUniqueInput
    data: XOR<CompaniesProductsUpdateWithoutCompaniesInput, CompaniesProductsUncheckedUpdateWithoutCompaniesInput>
  }

  export type CompaniesProductsUpdateManyWithWhereWithoutCompaniesInput = {
    where: CompaniesProductsScalarWhereInput
    data: XOR<CompaniesProductsUpdateManyMutationInput, CompaniesProductsUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type CompaniesProductsScalarWhereInput = {
    AND?: CompaniesProductsScalarWhereInput | CompaniesProductsScalarWhereInput[]
    OR?: CompaniesProductsScalarWhereInput[]
    NOT?: CompaniesProductsScalarWhereInput | CompaniesProductsScalarWhereInput[]
    CompaniesProductsId?: StringFilter<"CompaniesProducts"> | string
    CreatedAt?: DateTimeNullableFilter<"CompaniesProducts"> | Date | string | null
    ProductId?: StringFilter<"CompaniesProducts"> | string
    CompanyID?: StringFilter<"CompaniesProducts"> | string
    UserId?: StringNullableFilter<"CompaniesProducts"> | string | null
    LastVersionDate_Salary?: DateTimeNullableFilter<"CompaniesProducts"> | Date | string | null
    LastVersionDate_ManPower?: DateTimeNullableFilter<"CompaniesProducts"> | Date | string | null
  }

  export type CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: CompaniesProductsExpireDatesWhereUniqueInput
    update: XOR<CompaniesProductsExpireDatesUpdateWithoutCompaniesInput, CompaniesProductsExpireDatesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<CompaniesProductsExpireDatesCreateWithoutCompaniesInput, CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesInput>
  }

  export type CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: CompaniesProductsExpireDatesWhereUniqueInput
    data: XOR<CompaniesProductsExpireDatesUpdateWithoutCompaniesInput, CompaniesProductsExpireDatesUncheckedUpdateWithoutCompaniesInput>
  }

  export type CompaniesProductsExpireDatesUpdateManyWithWhereWithoutCompaniesInput = {
    where: CompaniesProductsExpireDatesScalarWhereInput
    data: XOR<CompaniesProductsExpireDatesUpdateManyMutationInput, CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type CompaniesProductsExpireDatesScalarWhereInput = {
    AND?: CompaniesProductsExpireDatesScalarWhereInput | CompaniesProductsExpireDatesScalarWhereInput[]
    OR?: CompaniesProductsExpireDatesScalarWhereInput[]
    NOT?: CompaniesProductsExpireDatesScalarWhereInput | CompaniesProductsExpireDatesScalarWhereInput[]
    CompaniesProductsExpireDateId?: StringFilter<"CompaniesProductsExpireDates"> | string
    CreatedAt?: DateTimeNullableFilter<"CompaniesProductsExpireDates"> | Date | string | null
    ProductId?: StringFilter<"CompaniesProductsExpireDates"> | string
    CompanyID?: StringFilter<"CompaniesProductsExpireDates"> | string
    StartDate?: DateTimeFilter<"CompaniesProductsExpireDates"> | Date | string
    EndDate?: DateTimeFilter<"CompaniesProductsExpireDates"> | Date | string
    Comments?: StringNullableFilter<"CompaniesProductsExpireDates"> | string | null
    UserId?: StringNullableFilter<"CompaniesProductsExpireDates"> | string | null
  }

  export type CompaniesUsersUpsertWithWhereUniqueWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput = {
    where: CompaniesUsersWhereUniqueInput
    update: XOR<CompaniesUsersUpdateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUsersUncheckedUpdateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput>
    create: XOR<CompaniesUsersCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUsersUncheckedCreateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput>
  }

  export type CompaniesUsersUpdateWithWhereUniqueWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput = {
    where: CompaniesUsersWhereUniqueInput
    data: XOR<CompaniesUsersUpdateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUsersUncheckedUpdateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput>
  }

  export type CompaniesUsersUpdateManyWithWhereWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput = {
    where: CompaniesUsersScalarWhereInput
    data: XOR<CompaniesUsersUpdateManyMutationInput, CompaniesUsersUncheckedUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput>
  }

  export type CompaniesUsersScalarWhereInput = {
    AND?: CompaniesUsersScalarWhereInput | CompaniesUsersScalarWhereInput[]
    OR?: CompaniesUsersScalarWhereInput[]
    NOT?: CompaniesUsersScalarWhereInput | CompaniesUsersScalarWhereInput[]
    CompaniesUsersID?: StringFilter<"CompaniesUsers"> | string
    CompanyID?: StringFilter<"CompaniesUsers"> | string
    CompanyID_OLD?: IntFilter<"CompaniesUsers"> | number
    EmployeeIdentity?: StringFilter<"CompaniesUsers"> | string
    BirthDate?: DateTimeNullableFilter<"CompaniesUsers"> | Date | string | null
    LastName?: StringFilter<"CompaniesUsers"> | string
    FirstName?: StringFilter<"CompaniesUsers"> | string
    JobsID?: IntFilter<"CompaniesUsers"> | number
    Gender?: IntFilter<"CompaniesUsers"> | number
    MobileNumber?: StringFilter<"CompaniesUsers"> | string
    Phone?: StringNullableFilter<"CompaniesUsers"> | string | null
    Fax?: StringNullableFilter<"CompaniesUsers"> | string | null
    Email?: StringFilter<"CompaniesUsers"> | string
    UserName?: StringFilter<"CompaniesUsers"> | string
    Password?: StringFilter<"CompaniesUsers"> | string
    AreaMan?: StringNullableFilter<"CompaniesUsers"> | string | null
    IsAdmin?: IntFilter<"CompaniesUsers"> | number
    LastEntry?: DateTimeNullableFilter<"CompaniesUsers"> | Date | string | null
    IsAllowAccess2WebSite?: IntFilter<"CompaniesUsers"> | number
    UserId?: StringNullableFilter<"CompaniesUsers"> | string | null
    CreatedAt?: DateTimeNullableFilter<"CompaniesUsers"> | Date | string | null
    TwoFactorBase32Secret?: StringNullableFilter<"CompaniesUsers"> | string | null
    DeviceData?: StringNullableFilter<"CompaniesUsers"> | string | null
  }

  export type CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    update: XOR<CompaniesUsersProductsExpireDatesUpdateWithoutCompaniesInput, CompaniesUsersProductsExpireDatesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesInput>
  }

  export type CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    data: XOR<CompaniesUsersProductsExpireDatesUpdateWithoutCompaniesInput, CompaniesUsersProductsExpireDatesUncheckedUpdateWithoutCompaniesInput>
  }

  export type CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesInput = {
    where: CompaniesUsersProductsExpireDatesScalarWhereInput
    data: XOR<CompaniesUsersProductsExpireDatesUpdateManyMutationInput, CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type CompaniesUsersProductsExpireDatesScalarWhereInput = {
    AND?: CompaniesUsersProductsExpireDatesScalarWhereInput | CompaniesUsersProductsExpireDatesScalarWhereInput[]
    OR?: CompaniesUsersProductsExpireDatesScalarWhereInput[]
    NOT?: CompaniesUsersProductsExpireDatesScalarWhereInput | CompaniesUsersProductsExpireDatesScalarWhereInput[]
    CompaniesUsersProductsExpireDateId?: StringFilter<"CompaniesUsersProductsExpireDates"> | string
    CreatedAt?: DateTimeNullableFilter<"CompaniesUsersProductsExpireDates"> | Date | string | null
    ProductId?: StringFilter<"CompaniesUsersProductsExpireDates"> | string
    CompanyID?: StringFilter<"CompaniesUsersProductsExpireDates"> | string
    CompaniesUsersID?: StringFilter<"CompaniesUsersProductsExpireDates"> | string
    StartDate?: DateTimeFilter<"CompaniesUsersProductsExpireDates"> | Date | string
    EndDate?: DateTimeFilter<"CompaniesUsersProductsExpireDates"> | Date | string
    UserId?: StringNullableFilter<"CompaniesUsersProductsExpireDates"> | string | null
    Comments?: StringNullableFilter<"CompaniesUsersProductsExpireDates"> | string | null
  }

  export type LandPagesUpsertWithoutCompaniesInput = {
    update: XOR<LandPagesUpdateWithoutCompaniesInput, LandPagesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<LandPagesCreateWithoutCompaniesInput, LandPagesUncheckedCreateWithoutCompaniesInput>
    where?: LandPagesWhereInput
  }

  export type LandPagesUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: LandPagesWhereInput
    data: XOR<LandPagesUpdateWithoutCompaniesInput, LandPagesUncheckedUpdateWithoutCompaniesInput>
  }

  export type LandPagesUpdateWithoutCompaniesInput = {
    LandPageRowId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JsonData?: NullableStringFieldUpdateOperationsInput | string | null
    ViewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LandPagesUncheckedUpdateWithoutCompaniesInput = {
    LandPageRowId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JsonData?: NullableStringFieldUpdateOperationsInput | string | null
    ViewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompaniesUsersCreateWithoutCompaniesProductsInput = {
    CompaniesUsersID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutOther_CompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersCreateNestedManyWithoutCompaniesUsersInput
    Companies_CompaniesUsers_CompanyIDToCompanies: CompaniesCreateNestedOneWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersUncheckedCreateWithoutCompaniesProductsInput = {
    CompaniesUsersID: string
    CompanyID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    UserId?: string | null
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersCreateOrConnectWithoutCompaniesProductsInput = {
    where: CompaniesUsersWhereUniqueInput
    create: XOR<CompaniesUsersCreateWithoutCompaniesProductsInput, CompaniesUsersUncheckedCreateWithoutCompaniesProductsInput>
  }

  export type CompaniesCreateWithoutCompaniesProductsInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    CompaniesType?: CompaniesTypeCreateNestedOneWithoutCompaniesInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompanies_Companies_UserIdToCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    LandPages?: LandPagesCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesUncheckedCreateWithoutCompaniesProductsInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    UserId?: string | null
    CompanyTypeID?: string
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    LandPages?: LandPagesUncheckedCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesCreateOrConnectWithoutCompaniesProductsInput = {
    where: CompaniesWhereUniqueInput
    create: XOR<CompaniesCreateWithoutCompaniesProductsInput, CompaniesUncheckedCreateWithoutCompaniesProductsInput>
  }

  export type ProductsCreateWithoutCompaniesProductsInput = {
    ProductsId?: string
    ProductName: string
    ProductDescription?: string | null
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutProductsInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutCompaniesProductsInput = {
    ProductsId?: string
    ProductName: string
    ProductDescription?: string | null
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutProductsInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutCompaniesProductsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutCompaniesProductsInput, ProductsUncheckedCreateWithoutCompaniesProductsInput>
  }

  export type CompaniesUsersUpsertWithoutCompaniesProductsInput = {
    update: XOR<CompaniesUsersUpdateWithoutCompaniesProductsInput, CompaniesUsersUncheckedUpdateWithoutCompaniesProductsInput>
    create: XOR<CompaniesUsersCreateWithoutCompaniesProductsInput, CompaniesUsersUncheckedCreateWithoutCompaniesProductsInput>
    where?: CompaniesUsersWhereInput
  }

  export type CompaniesUsersUpdateToOneWithWhereWithoutCompaniesProductsInput = {
    where?: CompaniesUsersWhereInput
    data: XOR<CompaniesUsersUpdateWithoutCompaniesProductsInput, CompaniesUsersUncheckedUpdateWithoutCompaniesProductsInput>
  }

  export type CompaniesUsersUpdateWithoutCompaniesProductsInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutOther_CompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUpdateManyWithoutCompaniesUsersNestedInput
    Companies_CompaniesUsers_CompanyIDToCompanies?: CompaniesUpdateOneRequiredWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersUncheckedUpdateWithoutCompaniesProductsInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUpsertWithoutCompaniesProductsInput = {
    update: XOR<CompaniesUpdateWithoutCompaniesProductsInput, CompaniesUncheckedUpdateWithoutCompaniesProductsInput>
    create: XOR<CompaniesCreateWithoutCompaniesProductsInput, CompaniesUncheckedCreateWithoutCompaniesProductsInput>
    where?: CompaniesWhereInput
  }

  export type CompaniesUpdateToOneWithWhereWithoutCompaniesProductsInput = {
    where?: CompaniesWhereInput
    data: XOR<CompaniesUpdateWithoutCompaniesProductsInput, CompaniesUncheckedUpdateWithoutCompaniesProductsInput>
  }

  export type CompaniesUpdateWithoutCompaniesProductsInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesType?: CompaniesTypeUpdateOneRequiredWithoutCompaniesNestedInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersUpdateOneWithoutCompanies_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    LandPages?: LandPagesUpdateOneWithoutCompaniesNestedInput
  }

  export type CompaniesUncheckedUpdateWithoutCompaniesProductsInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    LandPages?: LandPagesUncheckedUpdateOneWithoutCompaniesNestedInput
  }

  export type ProductsUpsertWithoutCompaniesProductsInput = {
    update: XOR<ProductsUpdateWithoutCompaniesProductsInput, ProductsUncheckedUpdateWithoutCompaniesProductsInput>
    create: XOR<ProductsCreateWithoutCompaniesProductsInput, ProductsUncheckedCreateWithoutCompaniesProductsInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutCompaniesProductsInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutCompaniesProductsInput, ProductsUncheckedUpdateWithoutCompaniesProductsInput>
  }

  export type ProductsUpdateWithoutCompaniesProductsInput = {
    ProductsId?: StringFieldUpdateOperationsInput | string
    ProductName?: StringFieldUpdateOperationsInput | string
    ProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutProductsNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutCompaniesProductsInput = {
    ProductsId?: StringFieldUpdateOperationsInput | string
    ProductName?: StringFieldUpdateOperationsInput | string
    ProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutProductsNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CompaniesUsersCreateWithoutCompaniesProductsExpireDatesInput = {
    CompaniesUsersID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutOther_CompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersCreateNestedManyWithoutCompaniesUsersInput
    Companies_CompaniesUsers_CompanyIDToCompanies: CompaniesCreateNestedOneWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersUncheckedCreateWithoutCompaniesProductsExpireDatesInput = {
    CompaniesUsersID: string
    CompanyID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    UserId?: string | null
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersCreateOrConnectWithoutCompaniesProductsExpireDatesInput = {
    where: CompaniesUsersWhereUniqueInput
    create: XOR<CompaniesUsersCreateWithoutCompaniesProductsExpireDatesInput, CompaniesUsersUncheckedCreateWithoutCompaniesProductsExpireDatesInput>
  }

  export type CompaniesCreateWithoutCompaniesProductsExpireDatesInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    CompaniesType?: CompaniesTypeCreateNestedOneWithoutCompaniesInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompanies_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    LandPages?: LandPagesCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesUncheckedCreateWithoutCompaniesProductsExpireDatesInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    UserId?: string | null
    CompanyTypeID?: string
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    LandPages?: LandPagesUncheckedCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesCreateOrConnectWithoutCompaniesProductsExpireDatesInput = {
    where: CompaniesWhereUniqueInput
    create: XOR<CompaniesCreateWithoutCompaniesProductsExpireDatesInput, CompaniesUncheckedCreateWithoutCompaniesProductsExpireDatesInput>
  }

  export type ProductsCreateWithoutCompaniesProductsExpireDatesInput = {
    ProductsId?: string
    ProductName: string
    ProductDescription?: string | null
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutProductsInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutCompaniesProductsExpireDatesInput = {
    ProductsId?: string
    ProductName: string
    ProductDescription?: string | null
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutProductsInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutCompaniesProductsExpireDatesInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutCompaniesProductsExpireDatesInput, ProductsUncheckedCreateWithoutCompaniesProductsExpireDatesInput>
  }

  export type CompaniesUsersUpsertWithoutCompaniesProductsExpireDatesInput = {
    update: XOR<CompaniesUsersUpdateWithoutCompaniesProductsExpireDatesInput, CompaniesUsersUncheckedUpdateWithoutCompaniesProductsExpireDatesInput>
    create: XOR<CompaniesUsersCreateWithoutCompaniesProductsExpireDatesInput, CompaniesUsersUncheckedCreateWithoutCompaniesProductsExpireDatesInput>
    where?: CompaniesUsersWhereInput
  }

  export type CompaniesUsersUpdateToOneWithWhereWithoutCompaniesProductsExpireDatesInput = {
    where?: CompaniesUsersWhereInput
    data: XOR<CompaniesUsersUpdateWithoutCompaniesProductsExpireDatesInput, CompaniesUsersUncheckedUpdateWithoutCompaniesProductsExpireDatesInput>
  }

  export type CompaniesUsersUpdateWithoutCompaniesProductsExpireDatesInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutOther_CompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUpdateManyWithoutCompaniesUsersNestedInput
    Companies_CompaniesUsers_CompanyIDToCompanies?: CompaniesUpdateOneRequiredWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersUncheckedUpdateWithoutCompaniesProductsExpireDatesInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUpsertWithoutCompaniesProductsExpireDatesInput = {
    update: XOR<CompaniesUpdateWithoutCompaniesProductsExpireDatesInput, CompaniesUncheckedUpdateWithoutCompaniesProductsExpireDatesInput>
    create: XOR<CompaniesCreateWithoutCompaniesProductsExpireDatesInput, CompaniesUncheckedCreateWithoutCompaniesProductsExpireDatesInput>
    where?: CompaniesWhereInput
  }

  export type CompaniesUpdateToOneWithWhereWithoutCompaniesProductsExpireDatesInput = {
    where?: CompaniesWhereInput
    data: XOR<CompaniesUpdateWithoutCompaniesProductsExpireDatesInput, CompaniesUncheckedUpdateWithoutCompaniesProductsExpireDatesInput>
  }

  export type CompaniesUpdateWithoutCompaniesProductsExpireDatesInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesType?: CompaniesTypeUpdateOneRequiredWithoutCompaniesNestedInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersUpdateOneWithoutCompanies_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    LandPages?: LandPagesUpdateOneWithoutCompaniesNestedInput
  }

  export type CompaniesUncheckedUpdateWithoutCompaniesProductsExpireDatesInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    LandPages?: LandPagesUncheckedUpdateOneWithoutCompaniesNestedInput
  }

  export type ProductsUpsertWithoutCompaniesProductsExpireDatesInput = {
    update: XOR<ProductsUpdateWithoutCompaniesProductsExpireDatesInput, ProductsUncheckedUpdateWithoutCompaniesProductsExpireDatesInput>
    create: XOR<ProductsCreateWithoutCompaniesProductsExpireDatesInput, ProductsUncheckedCreateWithoutCompaniesProductsExpireDatesInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutCompaniesProductsExpireDatesInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutCompaniesProductsExpireDatesInput, ProductsUncheckedUpdateWithoutCompaniesProductsExpireDatesInput>
  }

  export type ProductsUpdateWithoutCompaniesProductsExpireDatesInput = {
    ProductsId?: StringFieldUpdateOperationsInput | string
    ProductName?: StringFieldUpdateOperationsInput | string
    ProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutProductsNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutCompaniesProductsExpireDatesInput = {
    ProductsId?: StringFieldUpdateOperationsInput | string
    ProductName?: StringFieldUpdateOperationsInput | string
    ProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutProductsNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CompaniesCreateWithoutCompaniesTypeInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompanies_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    LandPages?: LandPagesCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesUncheckedCreateWithoutCompaniesTypeInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    UserId?: string | null
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    LandPages?: LandPagesUncheckedCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesCreateOrConnectWithoutCompaniesTypeInput = {
    where: CompaniesWhereUniqueInput
    create: XOR<CompaniesCreateWithoutCompaniesTypeInput, CompaniesUncheckedCreateWithoutCompaniesTypeInput>
  }

  export type CompaniesCreateManyCompaniesTypeInputEnvelope = {
    data: CompaniesCreateManyCompaniesTypeInput | CompaniesCreateManyCompaniesTypeInput[]
  }

  export type CompaniesUpsertWithWhereUniqueWithoutCompaniesTypeInput = {
    where: CompaniesWhereUniqueInput
    update: XOR<CompaniesUpdateWithoutCompaniesTypeInput, CompaniesUncheckedUpdateWithoutCompaniesTypeInput>
    create: XOR<CompaniesCreateWithoutCompaniesTypeInput, CompaniesUncheckedCreateWithoutCompaniesTypeInput>
  }

  export type CompaniesUpdateWithWhereUniqueWithoutCompaniesTypeInput = {
    where: CompaniesWhereUniqueInput
    data: XOR<CompaniesUpdateWithoutCompaniesTypeInput, CompaniesUncheckedUpdateWithoutCompaniesTypeInput>
  }

  export type CompaniesUpdateManyWithWhereWithoutCompaniesTypeInput = {
    where: CompaniesScalarWhereInput
    data: XOR<CompaniesUpdateManyMutationInput, CompaniesUncheckedUpdateManyWithoutCompaniesTypeInput>
  }

  export type CompaniesScalarWhereInput = {
    AND?: CompaniesScalarWhereInput | CompaniesScalarWhereInput[]
    OR?: CompaniesScalarWhereInput[]
    NOT?: CompaniesScalarWhereInput | CompaniesScalarWhereInput[]
    CompanyID?: StringFilter<"Companies"> | string
    CompanyID_OLD?: IntFilter<"Companies"> | number
    CompanyNumber?: IntFilter<"Companies"> | number
    DeductionsNumber?: IntNullableFilter<"Companies"> | number | null
    AgencyNumber?: IntNullableFilter<"Companies"> | number | null
    CompanyName?: StringFilter<"Companies"> | string
    CompanyNameEng?: StringNullableFilter<"Companies"> | string | null
    Address?: StringNullableFilter<"Companies"> | string | null
    CityID?: IntNullableFilter<"Companies"> | number | null
    ZipCode?: StringNullableFilter<"Companies"> | string | null
    POB?: StringNullableFilter<"Companies"> | string | null
    POB_ZipCode?: StringNullableFilter<"Companies"> | string | null
    Email?: StringNullableFilter<"Companies"> | string | null
    WebSite?: StringNullableFilter<"Companies"> | string | null
    Phone?: StringNullableFilter<"Companies"> | string | null
    Fax?: StringNullableFilter<"Companies"> | string | null
    NumOfPaySlipDisplay?: IntFilter<"Companies"> | number
    PaySlipDefinitionID?: IntNullableFilter<"Companies"> | number | null
    DbPathOnCloud?: StringNullableFilter<"Companies"> | string | null
    DocFilesPathOnCloud?: StringNullableFilter<"Companies"> | string | null
    DbPathAgricultureCRM?: StringNullableFilter<"Companies"> | string | null
    DisplayTypeID?: IntFilter<"Companies"> | number
    IsSuperAdminCompany?: IntNullableFilter<"Companies"> | number | null
    IsActive?: IntNullableFilter<"Companies"> | number | null
    IsExportAccounts?: IntNullableFilter<"Companies"> | number | null
    TaxAccountsToken?: StringNullableFilter<"Companies"> | string | null
    IsGetTaxAccountsCode?: IntNullableFilter<"Companies"> | number | null
    CompanyTaxAutoLink?: StringNullableFilter<"Companies"> | string | null
    UserId?: StringNullableFilter<"Companies"> | string | null
    CompanyTypeID?: StringFilter<"Companies"> | string
  }

  export type CompaniesCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    CompaniesType?: CompaniesTypeCreateNestedOneWithoutCompaniesInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    LandPages?: LandPagesCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesUncheckedCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    CompanyTypeID?: string
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    LandPages?: LandPagesUncheckedCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesCreateOrConnectWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput = {
    where: CompaniesWhereUniqueInput
    create: XOR<CompaniesCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput, CompaniesUncheckedCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput>
  }

  export type CompaniesCreateManyCompaniesUsers_Companies_UserIdToCompaniesUsersInputEnvelope = {
    data: CompaniesCreateManyCompaniesUsers_Companies_UserIdToCompaniesUsersInput | CompaniesCreateManyCompaniesUsers_Companies_UserIdToCompaniesUsersInput[]
  }

  export type CompaniesProductsCreateWithoutCompaniesUsersInput = {
    CompaniesProductsId?: string
    CreatedAt?: Date | string | null
    LastVersionDate_Salary?: Date | string | null
    LastVersionDate_ManPower?: Date | string | null
    Companies: CompaniesCreateNestedOneWithoutCompaniesProductsInput
    Products: ProductsCreateNestedOneWithoutCompaniesProductsInput
  }

  export type CompaniesProductsUncheckedCreateWithoutCompaniesUsersInput = {
    CompaniesProductsId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    LastVersionDate_Salary?: Date | string | null
    LastVersionDate_ManPower?: Date | string | null
  }

  export type CompaniesProductsCreateOrConnectWithoutCompaniesUsersInput = {
    where: CompaniesProductsWhereUniqueInput
    create: XOR<CompaniesProductsCreateWithoutCompaniesUsersInput, CompaniesProductsUncheckedCreateWithoutCompaniesUsersInput>
  }

  export type CompaniesProductsCreateManyCompaniesUsersInputEnvelope = {
    data: CompaniesProductsCreateManyCompaniesUsersInput | CompaniesProductsCreateManyCompaniesUsersInput[]
  }

  export type CompaniesProductsExpireDatesCreateWithoutCompaniesUsersInput = {
    CompaniesProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    Companies: CompaniesCreateNestedOneWithoutCompaniesProductsExpireDatesInput
    Products: ProductsCreateNestedOneWithoutCompaniesProductsExpireDatesInput
  }

  export type CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesUsersInput = {
    CompaniesProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
  }

  export type CompaniesProductsExpireDatesCreateOrConnectWithoutCompaniesUsersInput = {
    where: CompaniesProductsExpireDatesWhereUniqueInput
    create: XOR<CompaniesProductsExpireDatesCreateWithoutCompaniesUsersInput, CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesUsersInput>
  }

  export type CompaniesProductsExpireDatesCreateManyCompaniesUsersInputEnvelope = {
    data: CompaniesProductsExpireDatesCreateManyCompaniesUsersInput | CompaniesProductsExpireDatesCreateManyCompaniesUsersInput[]
  }

  export type CompaniesUsersCreateWithoutOther_CompaniesUsersInput = {
    CompaniesUsersID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutOther_CompaniesUsersInput
    Companies_CompaniesUsers_CompanyIDToCompanies: CompaniesCreateNestedOneWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersUncheckedCreateWithoutOther_CompaniesUsersInput = {
    CompaniesUsersID: string
    CompanyID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    UserId?: string | null
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersCreateOrConnectWithoutOther_CompaniesUsersInput = {
    where: CompaniesUsersWhereUniqueInput
    create: XOR<CompaniesUsersCreateWithoutOther_CompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutOther_CompaniesUsersInput>
  }

  export type CompaniesUsersCreateWithoutCompaniesUsersInput = {
    CompaniesUsersID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersCreateNestedManyWithoutCompaniesUsersInput
    Companies_CompaniesUsers_CompanyIDToCompanies: CompaniesCreateNestedOneWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersUncheckedCreateWithoutCompaniesUsersInput = {
    CompaniesUsersID: string
    CompanyID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersCreateOrConnectWithoutCompaniesUsersInput = {
    where: CompaniesUsersWhereUniqueInput
    create: XOR<CompaniesUsersCreateWithoutCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersInput>
  }

  export type CompaniesUsersCreateManyCompaniesUsersInputEnvelope = {
    data: CompaniesUsersCreateManyCompaniesUsersInput | CompaniesUsersCreateManyCompaniesUsersInput[]
  }

  export type CompaniesCreateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    CompaniesType?: CompaniesTypeCreateNestedOneWithoutCompaniesInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompanies_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    LandPages?: LandPagesCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesUncheckedCreateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    UserId?: string | null
    CompanyTypeID?: string
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    LandPages?: LandPagesUncheckedCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesCreateOrConnectWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput = {
    where: CompaniesWhereUniqueInput
    create: XOR<CompaniesCreateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUncheckedCreateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput>
  }

  export type CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    Companies: CompaniesCreateNestedOneWithoutCompaniesUsersProductsExpireDatesInput
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
    Products: ProductsCreateNestedOneWithoutCompaniesUsersProductsExpireDatesInput
  }

  export type CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    StartDate: Date | string
    EndDate: Date | string
    UserId?: string | null
    Comments?: string | null
  }

  export type CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    create: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>
  }

  export type CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInputEnvelope = {
    data: CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput | CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput[]
  }

  export type CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers: CompaniesUsersCreateNestedOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    Companies: CompaniesCreateNestedOneWithoutCompaniesUsersProductsExpireDatesInput
    Products: ProductsCreateNestedOneWithoutCompaniesUsersProductsExpireDatesInput
  }

  export type CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    CompaniesUsersID: string
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
  }

  export type CompaniesUsersProductsExpireDatesCreateOrConnectWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    create: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>
  }

  export type CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInputEnvelope = {
    data: CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput | CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput[]
  }

  export type CompaniesUpsertWithWhereUniqueWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput = {
    where: CompaniesWhereUniqueInput
    update: XOR<CompaniesUpdateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput, CompaniesUncheckedUpdateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput>
    create: XOR<CompaniesCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput, CompaniesUncheckedCreateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput>
  }

  export type CompaniesUpdateWithWhereUniqueWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput = {
    where: CompaniesWhereUniqueInput
    data: XOR<CompaniesUpdateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput, CompaniesUncheckedUpdateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput>
  }

  export type CompaniesUpdateManyWithWhereWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput = {
    where: CompaniesScalarWhereInput
    data: XOR<CompaniesUpdateManyMutationInput, CompaniesUncheckedUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput>
  }

  export type CompaniesProductsUpsertWithWhereUniqueWithoutCompaniesUsersInput = {
    where: CompaniesProductsWhereUniqueInput
    update: XOR<CompaniesProductsUpdateWithoutCompaniesUsersInput, CompaniesProductsUncheckedUpdateWithoutCompaniesUsersInput>
    create: XOR<CompaniesProductsCreateWithoutCompaniesUsersInput, CompaniesProductsUncheckedCreateWithoutCompaniesUsersInput>
  }

  export type CompaniesProductsUpdateWithWhereUniqueWithoutCompaniesUsersInput = {
    where: CompaniesProductsWhereUniqueInput
    data: XOR<CompaniesProductsUpdateWithoutCompaniesUsersInput, CompaniesProductsUncheckedUpdateWithoutCompaniesUsersInput>
  }

  export type CompaniesProductsUpdateManyWithWhereWithoutCompaniesUsersInput = {
    where: CompaniesProductsScalarWhereInput
    data: XOR<CompaniesProductsUpdateManyMutationInput, CompaniesProductsUncheckedUpdateManyWithoutCompaniesUsersInput>
  }

  export type CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsersInput = {
    where: CompaniesProductsExpireDatesWhereUniqueInput
    update: XOR<CompaniesProductsExpireDatesUpdateWithoutCompaniesUsersInput, CompaniesProductsExpireDatesUncheckedUpdateWithoutCompaniesUsersInput>
    create: XOR<CompaniesProductsExpireDatesCreateWithoutCompaniesUsersInput, CompaniesProductsExpireDatesUncheckedCreateWithoutCompaniesUsersInput>
  }

  export type CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsersInput = {
    where: CompaniesProductsExpireDatesWhereUniqueInput
    data: XOR<CompaniesProductsExpireDatesUpdateWithoutCompaniesUsersInput, CompaniesProductsExpireDatesUncheckedUpdateWithoutCompaniesUsersInput>
  }

  export type CompaniesProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsersInput = {
    where: CompaniesProductsExpireDatesScalarWhereInput
    data: XOR<CompaniesProductsExpireDatesUpdateManyMutationInput, CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsersInput>
  }

  export type CompaniesUsersUpsertWithoutOther_CompaniesUsersInput = {
    update: XOR<CompaniesUsersUpdateWithoutOther_CompaniesUsersInput, CompaniesUsersUncheckedUpdateWithoutOther_CompaniesUsersInput>
    create: XOR<CompaniesUsersCreateWithoutOther_CompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutOther_CompaniesUsersInput>
    where?: CompaniesUsersWhereInput
  }

  export type CompaniesUsersUpdateToOneWithWhereWithoutOther_CompaniesUsersInput = {
    where?: CompaniesUsersWhereInput
    data: XOR<CompaniesUsersUpdateWithoutOther_CompaniesUsersInput, CompaniesUsersUncheckedUpdateWithoutOther_CompaniesUsersInput>
  }

  export type CompaniesUsersUpdateWithoutOther_CompaniesUsersInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutOther_CompaniesUsersNestedInput
    Companies_CompaniesUsers_CompanyIDToCompanies?: CompaniesUpdateOneRequiredWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersUncheckedUpdateWithoutOther_CompaniesUsersInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersUpsertWithWhereUniqueWithoutCompaniesUsersInput = {
    where: CompaniesUsersWhereUniqueInput
    update: XOR<CompaniesUsersUpdateWithoutCompaniesUsersInput, CompaniesUsersUncheckedUpdateWithoutCompaniesUsersInput>
    create: XOR<CompaniesUsersCreateWithoutCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersInput>
  }

  export type CompaniesUsersUpdateWithWhereUniqueWithoutCompaniesUsersInput = {
    where: CompaniesUsersWhereUniqueInput
    data: XOR<CompaniesUsersUpdateWithoutCompaniesUsersInput, CompaniesUsersUncheckedUpdateWithoutCompaniesUsersInput>
  }

  export type CompaniesUsersUpdateManyWithWhereWithoutCompaniesUsersInput = {
    where: CompaniesUsersScalarWhereInput
    data: XOR<CompaniesUsersUpdateManyMutationInput, CompaniesUsersUncheckedUpdateManyWithoutCompaniesUsersInput>
  }

  export type CompaniesUpsertWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput = {
    update: XOR<CompaniesUpdateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUncheckedUpdateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput>
    create: XOR<CompaniesCreateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUncheckedCreateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput>
    where?: CompaniesWhereInput
  }

  export type CompaniesUpdateToOneWithWhereWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput = {
    where?: CompaniesWhereInput
    data: XOR<CompaniesUpdateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput, CompaniesUncheckedUpdateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput>
  }

  export type CompaniesUpdateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesType?: CompaniesTypeUpdateOneRequiredWithoutCompaniesNestedInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersUpdateOneWithoutCompanies_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    LandPages?: LandPagesUpdateOneWithoutCompaniesNestedInput
  }

  export type CompaniesUncheckedUpdateWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    LandPages?: LandPagesUncheckedUpdateOneWithoutCompaniesNestedInput
  }

  export type CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    update: XOR<CompaniesUsersProductsExpireDatesUpdateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedUpdateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>
    create: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>
  }

  export type CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    data: XOR<CompaniesUsersProductsExpireDatesUpdateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedUpdateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>
  }

  export type CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    where: CompaniesUsersProductsExpireDatesScalarWhereInput
    data: XOR<CompaniesUsersProductsExpireDatesUpdateManyMutationInput, CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>
  }

  export type CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    update: XOR<CompaniesUsersProductsExpireDatesUpdateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedUpdateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>
    create: XOR<CompaniesUsersProductsExpireDatesCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>
  }

  export type CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    data: XOR<CompaniesUsersProductsExpireDatesUpdateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersProductsExpireDatesUncheckedUpdateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>
  }

  export type CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    where: CompaniesUsersProductsExpireDatesScalarWhereInput
    data: XOR<CompaniesUsersProductsExpireDatesUpdateManyMutationInput, CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>
  }

  export type CompaniesUsersCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    CompaniesUsersID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutOther_CompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersCreateNestedManyWithoutCompaniesUsersInput
    Companies_CompaniesUsers_CompanyIDToCompanies: CompaniesCreateNestedOneWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersUncheckedCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    CompaniesUsersID: string
    CompanyID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    UserId?: string | null
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersCreateOrConnectWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    where: CompaniesUsersWhereUniqueInput
    create: XOR<CompaniesUsersCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>
  }

  export type CompaniesCreateWithoutCompaniesUsersProductsExpireDatesInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    CompaniesType?: CompaniesTypeCreateNestedOneWithoutCompaniesInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompanies_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    LandPages?: LandPagesCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesUncheckedCreateWithoutCompaniesUsersProductsExpireDatesInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    UserId?: string | null
    CompanyTypeID?: string
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    LandPages?: LandPagesUncheckedCreateNestedOneWithoutCompaniesInput
  }

  export type CompaniesCreateOrConnectWithoutCompaniesUsersProductsExpireDatesInput = {
    where: CompaniesWhereUniqueInput
    create: XOR<CompaniesCreateWithoutCompaniesUsersProductsExpireDatesInput, CompaniesUncheckedCreateWithoutCompaniesUsersProductsExpireDatesInput>
  }

  export type CompaniesUsersCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    CompaniesUsersID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutOther_CompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersCreateNestedManyWithoutCompaniesUsersInput
    Companies_CompaniesUsers_CompanyIDToCompanies: CompaniesCreateNestedOneWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
  }

  export type CompaniesUsersUncheckedCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    CompaniesUsersID: string
    CompanyID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    UserId?: string | null
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedCreateNestedManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsersInput
    other_CompaniesUsers?: CompaniesUsersUncheckedCreateNestedManyWithoutCompaniesUsersInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
  }

  export type CompaniesUsersCreateOrConnectWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    where: CompaniesUsersWhereUniqueInput
    create: XOR<CompaniesUsersCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>
  }

  export type ProductsCreateWithoutCompaniesUsersProductsExpireDatesInput = {
    ProductsId?: string
    ProductName: string
    ProductDescription?: string | null
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutProductsInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutCompaniesUsersProductsExpireDatesInput = {
    ProductsId?: string
    ProductName: string
    ProductDescription?: string | null
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutProductsInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutCompaniesUsersProductsExpireDatesInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutCompaniesUsersProductsExpireDatesInput, ProductsUncheckedCreateWithoutCompaniesUsersProductsExpireDatesInput>
  }

  export type CompaniesUsersUpsertWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    update: XOR<CompaniesUsersUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersUncheckedUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>
    create: XOR<CompaniesUsersCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>
    where?: CompaniesUsersWhereInput
  }

  export type CompaniesUsersUpdateToOneWithWhereWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    where?: CompaniesUsersWhereInput
    data: XOR<CompaniesUsersUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput, CompaniesUsersUncheckedUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput>
  }

  export type CompaniesUsersUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutOther_CompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUpdateManyWithoutCompaniesUsersNestedInput
    Companies_CompaniesUsers_CompanyIDToCompanies?: CompaniesUpdateOneRequiredWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersUncheckedUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUpsertWithoutCompaniesUsersProductsExpireDatesInput = {
    update: XOR<CompaniesUpdateWithoutCompaniesUsersProductsExpireDatesInput, CompaniesUncheckedUpdateWithoutCompaniesUsersProductsExpireDatesInput>
    create: XOR<CompaniesCreateWithoutCompaniesUsersProductsExpireDatesInput, CompaniesUncheckedCreateWithoutCompaniesUsersProductsExpireDatesInput>
    where?: CompaniesWhereInput
  }

  export type CompaniesUpdateToOneWithWhereWithoutCompaniesUsersProductsExpireDatesInput = {
    where?: CompaniesWhereInput
    data: XOR<CompaniesUpdateWithoutCompaniesUsersProductsExpireDatesInput, CompaniesUncheckedUpdateWithoutCompaniesUsersProductsExpireDatesInput>
  }

  export type CompaniesUpdateWithoutCompaniesUsersProductsExpireDatesInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesType?: CompaniesTypeUpdateOneRequiredWithoutCompaniesNestedInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersUpdateOneWithoutCompanies_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    LandPages?: LandPagesUpdateOneWithoutCompaniesNestedInput
  }

  export type CompaniesUncheckedUpdateWithoutCompaniesUsersProductsExpireDatesInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    LandPages?: LandPagesUncheckedUpdateOneWithoutCompaniesNestedInput
  }

  export type CompaniesUsersUpsertWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    update: XOR<CompaniesUsersUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersUncheckedUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>
    create: XOR<CompaniesUsersCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersUncheckedCreateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>
    where?: CompaniesUsersWhereInput
  }

  export type CompaniesUsersUpdateToOneWithWhereWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    where?: CompaniesUsersWhereInput
    data: XOR<CompaniesUsersUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput, CompaniesUsersUncheckedUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput>
  }

  export type CompaniesUsersUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutOther_CompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUpdateManyWithoutCompaniesUsersNestedInput
    Companies_CompaniesUsers_CompanyIDToCompanies?: CompaniesUpdateOneRequiredWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
  }

  export type CompaniesUsersUncheckedUpdateWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
  }

  export type ProductsUpsertWithoutCompaniesUsersProductsExpireDatesInput = {
    update: XOR<ProductsUpdateWithoutCompaniesUsersProductsExpireDatesInput, ProductsUncheckedUpdateWithoutCompaniesUsersProductsExpireDatesInput>
    create: XOR<ProductsCreateWithoutCompaniesUsersProductsExpireDatesInput, ProductsUncheckedCreateWithoutCompaniesUsersProductsExpireDatesInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutCompaniesUsersProductsExpireDatesInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutCompaniesUsersProductsExpireDatesInput, ProductsUncheckedUpdateWithoutCompaniesUsersProductsExpireDatesInput>
  }

  export type ProductsUpdateWithoutCompaniesUsersProductsExpireDatesInput = {
    ProductsId?: StringFieldUpdateOperationsInput | string
    ProductName?: StringFieldUpdateOperationsInput | string
    ProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutProductsNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutCompaniesUsersProductsExpireDatesInput = {
    ProductsId?: StringFieldUpdateOperationsInput | string
    ProductName?: StringFieldUpdateOperationsInput | string
    ProductDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutProductsNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CompaniesCreateWithoutLandPagesInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    CompaniesType?: CompaniesTypeCreateNestedOneWithoutCompaniesInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompanies_Companies_UserIdToCompaniesUsersInput
    CompaniesProducts?: CompaniesProductsCreateNestedManyWithoutCompaniesInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesCreateNestedManyWithoutCompaniesInput
  }

  export type CompaniesUncheckedCreateWithoutLandPagesInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    UserId?: string | null
    CompanyTypeID?: string
    CompaniesProducts?: CompaniesProductsUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedCreateNestedManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type CompaniesCreateOrConnectWithoutLandPagesInput = {
    where: CompaniesWhereUniqueInput
    create: XOR<CompaniesCreateWithoutLandPagesInput, CompaniesUncheckedCreateWithoutLandPagesInput>
  }

  export type CompaniesUpsertWithoutLandPagesInput = {
    update: XOR<CompaniesUpdateWithoutLandPagesInput, CompaniesUncheckedUpdateWithoutLandPagesInput>
    create: XOR<CompaniesCreateWithoutLandPagesInput, CompaniesUncheckedCreateWithoutLandPagesInput>
    where?: CompaniesWhereInput
  }

  export type CompaniesUpdateToOneWithWhereWithoutLandPagesInput = {
    where?: CompaniesWhereInput
    data: XOR<CompaniesUpdateWithoutLandPagesInput, CompaniesUncheckedUpdateWithoutLandPagesInput>
  }

  export type CompaniesUpdateWithoutLandPagesInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesType?: CompaniesTypeUpdateOneRequiredWithoutCompaniesNestedInput
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersUpdateOneWithoutCompanies_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
  }

  export type CompaniesUncheckedUpdateWithoutLandPagesInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type CompaniesProductsCreateWithoutProductsInput = {
    CompaniesProductsId?: string
    CreatedAt?: Date | string | null
    LastVersionDate_Salary?: Date | string | null
    LastVersionDate_ManPower?: Date | string | null
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompaniesProductsInput
    Companies: CompaniesCreateNestedOneWithoutCompaniesProductsInput
  }

  export type CompaniesProductsUncheckedCreateWithoutProductsInput = {
    CompaniesProductsId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserId?: string | null
    LastVersionDate_Salary?: Date | string | null
    LastVersionDate_ManPower?: Date | string | null
  }

  export type CompaniesProductsCreateOrConnectWithoutProductsInput = {
    where: CompaniesProductsWhereUniqueInput
    create: XOR<CompaniesProductsCreateWithoutProductsInput, CompaniesProductsUncheckedCreateWithoutProductsInput>
  }

  export type CompaniesProductsCreateManyProductsInputEnvelope = {
    data: CompaniesProductsCreateManyProductsInput | CompaniesProductsCreateManyProductsInput[]
  }

  export type CompaniesProductsExpireDatesCreateWithoutProductsInput = {
    CompaniesProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    CompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompaniesProductsExpireDatesInput
    Companies: CompaniesCreateNestedOneWithoutCompaniesProductsExpireDatesInput
  }

  export type CompaniesProductsExpireDatesUncheckedCreateWithoutProductsInput = {
    CompaniesProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    UserId?: string | null
  }

  export type CompaniesProductsExpireDatesCreateOrConnectWithoutProductsInput = {
    where: CompaniesProductsExpireDatesWhereUniqueInput
    create: XOR<CompaniesProductsExpireDatesCreateWithoutProductsInput, CompaniesProductsExpireDatesUncheckedCreateWithoutProductsInput>
  }

  export type CompaniesProductsExpireDatesCreateManyProductsInputEnvelope = {
    data: CompaniesProductsExpireDatesCreateManyProductsInput | CompaniesProductsExpireDatesCreateManyProductsInput[]
  }

  export type CompaniesUsersProductsExpireDatesCreateWithoutProductsInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers: CompaniesUsersCreateNestedOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput
    Companies: CompaniesCreateNestedOneWithoutCompaniesUsersProductsExpireDatesInput
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersCreateNestedOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput
  }

  export type CompaniesUsersProductsExpireDatesUncheckedCreateWithoutProductsInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    CompaniesUsersID: string
    StartDate: Date | string
    EndDate: Date | string
    UserId?: string | null
    Comments?: string | null
  }

  export type CompaniesUsersProductsExpireDatesCreateOrConnectWithoutProductsInput = {
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    create: XOR<CompaniesUsersProductsExpireDatesCreateWithoutProductsInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutProductsInput>
  }

  export type CompaniesUsersProductsExpireDatesCreateManyProductsInputEnvelope = {
    data: CompaniesUsersProductsExpireDatesCreateManyProductsInput | CompaniesUsersProductsExpireDatesCreateManyProductsInput[]
  }

  export type CompaniesProductsUpsertWithWhereUniqueWithoutProductsInput = {
    where: CompaniesProductsWhereUniqueInput
    update: XOR<CompaniesProductsUpdateWithoutProductsInput, CompaniesProductsUncheckedUpdateWithoutProductsInput>
    create: XOR<CompaniesProductsCreateWithoutProductsInput, CompaniesProductsUncheckedCreateWithoutProductsInput>
  }

  export type CompaniesProductsUpdateWithWhereUniqueWithoutProductsInput = {
    where: CompaniesProductsWhereUniqueInput
    data: XOR<CompaniesProductsUpdateWithoutProductsInput, CompaniesProductsUncheckedUpdateWithoutProductsInput>
  }

  export type CompaniesProductsUpdateManyWithWhereWithoutProductsInput = {
    where: CompaniesProductsScalarWhereInput
    data: XOR<CompaniesProductsUpdateManyMutationInput, CompaniesProductsUncheckedUpdateManyWithoutProductsInput>
  }

  export type CompaniesProductsExpireDatesUpsertWithWhereUniqueWithoutProductsInput = {
    where: CompaniesProductsExpireDatesWhereUniqueInput
    update: XOR<CompaniesProductsExpireDatesUpdateWithoutProductsInput, CompaniesProductsExpireDatesUncheckedUpdateWithoutProductsInput>
    create: XOR<CompaniesProductsExpireDatesCreateWithoutProductsInput, CompaniesProductsExpireDatesUncheckedCreateWithoutProductsInput>
  }

  export type CompaniesProductsExpireDatesUpdateWithWhereUniqueWithoutProductsInput = {
    where: CompaniesProductsExpireDatesWhereUniqueInput
    data: XOR<CompaniesProductsExpireDatesUpdateWithoutProductsInput, CompaniesProductsExpireDatesUncheckedUpdateWithoutProductsInput>
  }

  export type CompaniesProductsExpireDatesUpdateManyWithWhereWithoutProductsInput = {
    where: CompaniesProductsExpireDatesScalarWhereInput
    data: XOR<CompaniesProductsExpireDatesUpdateManyMutationInput, CompaniesProductsExpireDatesUncheckedUpdateManyWithoutProductsInput>
  }

  export type CompaniesUsersProductsExpireDatesUpsertWithWhereUniqueWithoutProductsInput = {
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    update: XOR<CompaniesUsersProductsExpireDatesUpdateWithoutProductsInput, CompaniesUsersProductsExpireDatesUncheckedUpdateWithoutProductsInput>
    create: XOR<CompaniesUsersProductsExpireDatesCreateWithoutProductsInput, CompaniesUsersProductsExpireDatesUncheckedCreateWithoutProductsInput>
  }

  export type CompaniesUsersProductsExpireDatesUpdateWithWhereUniqueWithoutProductsInput = {
    where: CompaniesUsersProductsExpireDatesWhereUniqueInput
    data: XOR<CompaniesUsersProductsExpireDatesUpdateWithoutProductsInput, CompaniesUsersProductsExpireDatesUncheckedUpdateWithoutProductsInput>
  }

  export type CompaniesUsersProductsExpireDatesUpdateManyWithWhereWithoutProductsInput = {
    where: CompaniesUsersProductsExpireDatesScalarWhereInput
    data: XOR<CompaniesUsersProductsExpireDatesUpdateManyMutationInput, CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutProductsInput>
  }

  export type RecoveryDefinitionDetailsCreateWithoutRecoveryDefinitionInput = {
    StartYearRewardRecovery?: number | null
    EndYearRewardRecovery?: number | null
    RecoveryDayQuantity?: number | null
    RecoveryYearDescription?: string | null
  }

  export type RecoveryDefinitionDetailsUncheckedCreateWithoutRecoveryDefinitionInput = {
    RewardRecoveryVectorID?: number
    StartYearRewardRecovery?: number | null
    EndYearRewardRecovery?: number | null
    RecoveryDayQuantity?: number | null
    RecoveryYearDescription?: string | null
  }

  export type RecoveryDefinitionDetailsCreateOrConnectWithoutRecoveryDefinitionInput = {
    where: RecoveryDefinitionDetailsWhereUniqueInput
    create: XOR<RecoveryDefinitionDetailsCreateWithoutRecoveryDefinitionInput, RecoveryDefinitionDetailsUncheckedCreateWithoutRecoveryDefinitionInput>
  }

  export type RecoveryDefinitionDetailsCreateManyRecoveryDefinitionInputEnvelope = {
    data: RecoveryDefinitionDetailsCreateManyRecoveryDefinitionInput | RecoveryDefinitionDetailsCreateManyRecoveryDefinitionInput[]
  }

  export type RecoveryDefinitionRateDetailsCreateWithoutRecoveryDefinitionInput = {
    RecoveryRewardID: number
    RewardYearMonth?: Date | string | null
    RecoveryRewardRatePerDay?: number | null
  }

  export type RecoveryDefinitionRateDetailsUncheckedCreateWithoutRecoveryDefinitionInput = {
    RecoveryRewardID: number
    RewardYearMonth?: Date | string | null
    RecoveryRewardRatePerDay?: number | null
  }

  export type RecoveryDefinitionRateDetailsCreateOrConnectWithoutRecoveryDefinitionInput = {
    where: RecoveryDefinitionRateDetailsWhereUniqueInput
    create: XOR<RecoveryDefinitionRateDetailsCreateWithoutRecoveryDefinitionInput, RecoveryDefinitionRateDetailsUncheckedCreateWithoutRecoveryDefinitionInput>
  }

  export type RecoveryDefinitionRateDetailsCreateManyRecoveryDefinitionInputEnvelope = {
    data: RecoveryDefinitionRateDetailsCreateManyRecoveryDefinitionInput | RecoveryDefinitionRateDetailsCreateManyRecoveryDefinitionInput[]
  }

  export type RecoveryDefinitionDetailsUpsertWithWhereUniqueWithoutRecoveryDefinitionInput = {
    where: RecoveryDefinitionDetailsWhereUniqueInput
    update: XOR<RecoveryDefinitionDetailsUpdateWithoutRecoveryDefinitionInput, RecoveryDefinitionDetailsUncheckedUpdateWithoutRecoveryDefinitionInput>
    create: XOR<RecoveryDefinitionDetailsCreateWithoutRecoveryDefinitionInput, RecoveryDefinitionDetailsUncheckedCreateWithoutRecoveryDefinitionInput>
  }

  export type RecoveryDefinitionDetailsUpdateWithWhereUniqueWithoutRecoveryDefinitionInput = {
    where: RecoveryDefinitionDetailsWhereUniqueInput
    data: XOR<RecoveryDefinitionDetailsUpdateWithoutRecoveryDefinitionInput, RecoveryDefinitionDetailsUncheckedUpdateWithoutRecoveryDefinitionInput>
  }

  export type RecoveryDefinitionDetailsUpdateManyWithWhereWithoutRecoveryDefinitionInput = {
    where: RecoveryDefinitionDetailsScalarWhereInput
    data: XOR<RecoveryDefinitionDetailsUpdateManyMutationInput, RecoveryDefinitionDetailsUncheckedUpdateManyWithoutRecoveryDefinitionInput>
  }

  export type RecoveryDefinitionDetailsScalarWhereInput = {
    AND?: RecoveryDefinitionDetailsScalarWhereInput | RecoveryDefinitionDetailsScalarWhereInput[]
    OR?: RecoveryDefinitionDetailsScalarWhereInput[]
    NOT?: RecoveryDefinitionDetailsScalarWhereInput | RecoveryDefinitionDetailsScalarWhereInput[]
    RewardRecoveryVectorID?: IntFilter<"RecoveryDefinitionDetails"> | number
    RecoveryDefinitionID?: IntNullableFilter<"RecoveryDefinitionDetails"> | number | null
    StartYearRewardRecovery?: FloatNullableFilter<"RecoveryDefinitionDetails"> | number | null
    EndYearRewardRecovery?: FloatNullableFilter<"RecoveryDefinitionDetails"> | number | null
    RecoveryDayQuantity?: IntNullableFilter<"RecoveryDefinitionDetails"> | number | null
    RecoveryYearDescription?: StringNullableFilter<"RecoveryDefinitionDetails"> | string | null
  }

  export type RecoveryDefinitionRateDetailsUpsertWithWhereUniqueWithoutRecoveryDefinitionInput = {
    where: RecoveryDefinitionRateDetailsWhereUniqueInput
    update: XOR<RecoveryDefinitionRateDetailsUpdateWithoutRecoveryDefinitionInput, RecoveryDefinitionRateDetailsUncheckedUpdateWithoutRecoveryDefinitionInput>
    create: XOR<RecoveryDefinitionRateDetailsCreateWithoutRecoveryDefinitionInput, RecoveryDefinitionRateDetailsUncheckedCreateWithoutRecoveryDefinitionInput>
  }

  export type RecoveryDefinitionRateDetailsUpdateWithWhereUniqueWithoutRecoveryDefinitionInput = {
    where: RecoveryDefinitionRateDetailsWhereUniqueInput
    data: XOR<RecoveryDefinitionRateDetailsUpdateWithoutRecoveryDefinitionInput, RecoveryDefinitionRateDetailsUncheckedUpdateWithoutRecoveryDefinitionInput>
  }

  export type RecoveryDefinitionRateDetailsUpdateManyWithWhereWithoutRecoveryDefinitionInput = {
    where: RecoveryDefinitionRateDetailsScalarWhereInput
    data: XOR<RecoveryDefinitionRateDetailsUpdateManyMutationInput, RecoveryDefinitionRateDetailsUncheckedUpdateManyWithoutRecoveryDefinitionInput>
  }

  export type RecoveryDefinitionRateDetailsScalarWhereInput = {
    AND?: RecoveryDefinitionRateDetailsScalarWhereInput | RecoveryDefinitionRateDetailsScalarWhereInput[]
    OR?: RecoveryDefinitionRateDetailsScalarWhereInput[]
    NOT?: RecoveryDefinitionRateDetailsScalarWhereInput | RecoveryDefinitionRateDetailsScalarWhereInput[]
    RecoveryRewardID?: IntFilter<"RecoveryDefinitionRateDetails"> | number
    RecoveryDefinitionID?: IntNullableFilter<"RecoveryDefinitionRateDetails"> | number | null
    RewardYearMonth?: DateTimeNullableFilter<"RecoveryDefinitionRateDetails"> | Date | string | null
    RecoveryRewardRatePerDay?: FloatNullableFilter<"RecoveryDefinitionRateDetails"> | number | null
  }

  export type RecoveryDefinitionCreateWithoutRecoveryDefinitionDetailsInput = {
    RecoveryDefinitionName?: string | null
    RecoveryYear?: string | null
    RecoveryDefinitionRateDetails?: RecoveryDefinitionRateDetailsCreateNestedManyWithoutRecoveryDefinitionInput
  }

  export type RecoveryDefinitionUncheckedCreateWithoutRecoveryDefinitionDetailsInput = {
    RecoveryDefinitionID?: number
    RecoveryDefinitionName?: string | null
    RecoveryYear?: string | null
    RecoveryDefinitionRateDetails?: RecoveryDefinitionRateDetailsUncheckedCreateNestedManyWithoutRecoveryDefinitionInput
  }

  export type RecoveryDefinitionCreateOrConnectWithoutRecoveryDefinitionDetailsInput = {
    where: RecoveryDefinitionWhereUniqueInput
    create: XOR<RecoveryDefinitionCreateWithoutRecoveryDefinitionDetailsInput, RecoveryDefinitionUncheckedCreateWithoutRecoveryDefinitionDetailsInput>
  }

  export type RecoveryDefinitionUpsertWithoutRecoveryDefinitionDetailsInput = {
    update: XOR<RecoveryDefinitionUpdateWithoutRecoveryDefinitionDetailsInput, RecoveryDefinitionUncheckedUpdateWithoutRecoveryDefinitionDetailsInput>
    create: XOR<RecoveryDefinitionCreateWithoutRecoveryDefinitionDetailsInput, RecoveryDefinitionUncheckedCreateWithoutRecoveryDefinitionDetailsInput>
    where?: RecoveryDefinitionWhereInput
  }

  export type RecoveryDefinitionUpdateToOneWithWhereWithoutRecoveryDefinitionDetailsInput = {
    where?: RecoveryDefinitionWhereInput
    data: XOR<RecoveryDefinitionUpdateWithoutRecoveryDefinitionDetailsInput, RecoveryDefinitionUncheckedUpdateWithoutRecoveryDefinitionDetailsInput>
  }

  export type RecoveryDefinitionUpdateWithoutRecoveryDefinitionDetailsInput = {
    RecoveryDefinitionName?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryYear?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryDefinitionRateDetails?: RecoveryDefinitionRateDetailsUpdateManyWithoutRecoveryDefinitionNestedInput
  }

  export type RecoveryDefinitionUncheckedUpdateWithoutRecoveryDefinitionDetailsInput = {
    RecoveryDefinitionID?: IntFieldUpdateOperationsInput | number
    RecoveryDefinitionName?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryYear?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryDefinitionRateDetails?: RecoveryDefinitionRateDetailsUncheckedUpdateManyWithoutRecoveryDefinitionNestedInput
  }

  export type RecoveryDefinitionCreateWithoutRecoveryDefinitionRateDetailsInput = {
    RecoveryDefinitionName?: string | null
    RecoveryYear?: string | null
    RecoveryDefinitionDetails?: RecoveryDefinitionDetailsCreateNestedManyWithoutRecoveryDefinitionInput
  }

  export type RecoveryDefinitionUncheckedCreateWithoutRecoveryDefinitionRateDetailsInput = {
    RecoveryDefinitionID?: number
    RecoveryDefinitionName?: string | null
    RecoveryYear?: string | null
    RecoveryDefinitionDetails?: RecoveryDefinitionDetailsUncheckedCreateNestedManyWithoutRecoveryDefinitionInput
  }

  export type RecoveryDefinitionCreateOrConnectWithoutRecoveryDefinitionRateDetailsInput = {
    where: RecoveryDefinitionWhereUniqueInput
    create: XOR<RecoveryDefinitionCreateWithoutRecoveryDefinitionRateDetailsInput, RecoveryDefinitionUncheckedCreateWithoutRecoveryDefinitionRateDetailsInput>
  }

  export type RecoveryDefinitionUpsertWithoutRecoveryDefinitionRateDetailsInput = {
    update: XOR<RecoveryDefinitionUpdateWithoutRecoveryDefinitionRateDetailsInput, RecoveryDefinitionUncheckedUpdateWithoutRecoveryDefinitionRateDetailsInput>
    create: XOR<RecoveryDefinitionCreateWithoutRecoveryDefinitionRateDetailsInput, RecoveryDefinitionUncheckedCreateWithoutRecoveryDefinitionRateDetailsInput>
    where?: RecoveryDefinitionWhereInput
  }

  export type RecoveryDefinitionUpdateToOneWithWhereWithoutRecoveryDefinitionRateDetailsInput = {
    where?: RecoveryDefinitionWhereInput
    data: XOR<RecoveryDefinitionUpdateWithoutRecoveryDefinitionRateDetailsInput, RecoveryDefinitionUncheckedUpdateWithoutRecoveryDefinitionRateDetailsInput>
  }

  export type RecoveryDefinitionUpdateWithoutRecoveryDefinitionRateDetailsInput = {
    RecoveryDefinitionName?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryYear?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryDefinitionDetails?: RecoveryDefinitionDetailsUpdateManyWithoutRecoveryDefinitionNestedInput
  }

  export type RecoveryDefinitionUncheckedUpdateWithoutRecoveryDefinitionRateDetailsInput = {
    RecoveryDefinitionID?: IntFieldUpdateOperationsInput | number
    RecoveryDefinitionName?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryYear?: NullableStringFieldUpdateOperationsInput | string | null
    RecoveryDefinitionDetails?: RecoveryDefinitionDetailsUncheckedUpdateManyWithoutRecoveryDefinitionNestedInput
  }

  export type SickDefinitionDetailCreateWithoutSickDefinitionInput = {
    StartYearRewardSick?: number | null
    EndYearRewardSick?: number | null
    SickDayQuantity?: number | null
    SocialYearDescription?: string | null
  }

  export type SickDefinitionDetailUncheckedCreateWithoutSickDefinitionInput = {
    RewardSickVectorID?: number
    StartYearRewardSick?: number | null
    EndYearRewardSick?: number | null
    SickDayQuantity?: number | null
    SocialYearDescription?: string | null
  }

  export type SickDefinitionDetailCreateOrConnectWithoutSickDefinitionInput = {
    where: SickDefinitionDetailWhereUniqueInput
    create: XOR<SickDefinitionDetailCreateWithoutSickDefinitionInput, SickDefinitionDetailUncheckedCreateWithoutSickDefinitionInput>
  }

  export type SickDefinitionDetailCreateManySickDefinitionInputEnvelope = {
    data: SickDefinitionDetailCreateManySickDefinitionInput | SickDefinitionDetailCreateManySickDefinitionInput[]
  }

  export type SickDefinitionDetailUpsertWithWhereUniqueWithoutSickDefinitionInput = {
    where: SickDefinitionDetailWhereUniqueInput
    update: XOR<SickDefinitionDetailUpdateWithoutSickDefinitionInput, SickDefinitionDetailUncheckedUpdateWithoutSickDefinitionInput>
    create: XOR<SickDefinitionDetailCreateWithoutSickDefinitionInput, SickDefinitionDetailUncheckedCreateWithoutSickDefinitionInput>
  }

  export type SickDefinitionDetailUpdateWithWhereUniqueWithoutSickDefinitionInput = {
    where: SickDefinitionDetailWhereUniqueInput
    data: XOR<SickDefinitionDetailUpdateWithoutSickDefinitionInput, SickDefinitionDetailUncheckedUpdateWithoutSickDefinitionInput>
  }

  export type SickDefinitionDetailUpdateManyWithWhereWithoutSickDefinitionInput = {
    where: SickDefinitionDetailScalarWhereInput
    data: XOR<SickDefinitionDetailUpdateManyMutationInput, SickDefinitionDetailUncheckedUpdateManyWithoutSickDefinitionInput>
  }

  export type SickDefinitionDetailScalarWhereInput = {
    AND?: SickDefinitionDetailScalarWhereInput | SickDefinitionDetailScalarWhereInput[]
    OR?: SickDefinitionDetailScalarWhereInput[]
    NOT?: SickDefinitionDetailScalarWhereInput | SickDefinitionDetailScalarWhereInput[]
    RewardSickVectorID?: IntFilter<"SickDefinitionDetail"> | number
    SickDefinitionID?: IntFilter<"SickDefinitionDetail"> | number
    StartYearRewardSick?: IntNullableFilter<"SickDefinitionDetail"> | number | null
    EndYearRewardSick?: IntNullableFilter<"SickDefinitionDetail"> | number | null
    SickDayQuantity?: FloatNullableFilter<"SickDefinitionDetail"> | number | null
    SocialYearDescription?: StringNullableFilter<"SickDefinitionDetail"> | string | null
  }

  export type SickDefinitionCreateWithoutSickDefinitionDetailInput = {
    SickDefinitionID: number
    SickDescription?: string | null
  }

  export type SickDefinitionUncheckedCreateWithoutSickDefinitionDetailInput = {
    SickDefinitionID: number
    SickDescription?: string | null
  }

  export type SickDefinitionCreateOrConnectWithoutSickDefinitionDetailInput = {
    where: SickDefinitionWhereUniqueInput
    create: XOR<SickDefinitionCreateWithoutSickDefinitionDetailInput, SickDefinitionUncheckedCreateWithoutSickDefinitionDetailInput>
  }

  export type SickDefinitionUpsertWithoutSickDefinitionDetailInput = {
    update: XOR<SickDefinitionUpdateWithoutSickDefinitionDetailInput, SickDefinitionUncheckedUpdateWithoutSickDefinitionDetailInput>
    create: XOR<SickDefinitionCreateWithoutSickDefinitionDetailInput, SickDefinitionUncheckedCreateWithoutSickDefinitionDetailInput>
    where?: SickDefinitionWhereInput
  }

  export type SickDefinitionUpdateToOneWithWhereWithoutSickDefinitionDetailInput = {
    where?: SickDefinitionWhereInput
    data: XOR<SickDefinitionUpdateWithoutSickDefinitionDetailInput, SickDefinitionUncheckedUpdateWithoutSickDefinitionDetailInput>
  }

  export type SickDefinitionUpdateWithoutSickDefinitionDetailInput = {
    SickDefinitionID?: IntFieldUpdateOperationsInput | number
    SickDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SickDefinitionUncheckedUpdateWithoutSickDefinitionDetailInput = {
    SickDefinitionID?: IntFieldUpdateOperationsInput | number
    SickDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialSecurityDetileCreateWithoutSocialSecurityInput = {
    SocialYear: number
    SocialMonth: number
    Sector: number
    SocialSecurityCode: number
    AverageSalary?: number | null
    MinNationalInsByMony?: number | null
    MaxNationalInsByMony?: number | null
    MinDeductionNationalInsByMony?: number | null
    MinNationalInsByEmployee?: number | null
    MaxNationalInsByEmployee?: number | null
    MinNationalInsByEmployer?: number | null
    MaxNationalInsByEmployer?: number | null
    MaxNationalInsByMonyEmployee?: number | null
    AverageEmbodiment?: number | null
    DeductionMax?: number | null
    DeductionPercent?: number | null
    CreditPoint?: number | null
    FactorToReduction?: number | null
    MinHoursToPay?: number | null
    MinimumPayFor5Day?: number | null
    MinimumPayFor6Day?: number | null
    MaxPrecentReduction?: number | null
    hourPerDayfor5?: number | null
    hourPerDayfor6?: number | null
    hourInfridayDay?: number | null
    TaxPrecent?: number | null
    EmployerTax?: number | null
    DiscountInTaxInEilat?: number | null
    TaxUnitNumber?: number | null
    FundPercentConstruction?: number | null
    Hour100?: number | null
    Hour125?: number | null
    Hour150?: number | null
    Hour175?: number | null
    Hour200?: number | null
    CreditCardMan?: number | null
    CreditCardWoman?: number | null
    CreditCardChild?: number | null
    CreditCardBaby?: number | null
    CreditCardInAddition?: number | null
    CreditCardLackMobilityChild?: number | null
    CreditCardImmigrant18?: number | null
    ControlingShareholder: boolean
    HealthInsuranceEmployeeLow?: number | null
    HealthInsuranceEmployeeAbove?: number | null
    HealthInsuranceEmployerLow?: number | null
    HealthInsuranceEmployerAbove?: number | null
    ValueOfVehicleUseHibberdDiscount?: number | null
    Deposit?: number | null
    ValueOfMobileUse?: number | null
    PensionCeiling?: number | null
    PensionCredit?: number | null
    DepositEmployerPrecent?: number | null
    DepositEmployeePrecent?: number | null
    TotalHourPerWeek?: number | null
    CreditCardAdultChild?: number | null
    CreditCardChild1_5?: number | null
    DepositEmployeePrecentExecption?: number | null
  }

  export type SocialSecurityDetileUncheckedCreateWithoutSocialSecurityInput = {
    SocialSecurityDetailID?: number
    SocialYear: number
    SocialMonth: number
    Sector: number
    SocialSecurityCode: number
    AverageSalary?: number | null
    MinNationalInsByMony?: number | null
    MaxNationalInsByMony?: number | null
    MinDeductionNationalInsByMony?: number | null
    MinNationalInsByEmployee?: number | null
    MaxNationalInsByEmployee?: number | null
    MinNationalInsByEmployer?: number | null
    MaxNationalInsByEmployer?: number | null
    MaxNationalInsByMonyEmployee?: number | null
    AverageEmbodiment?: number | null
    DeductionMax?: number | null
    DeductionPercent?: number | null
    CreditPoint?: number | null
    FactorToReduction?: number | null
    MinHoursToPay?: number | null
    MinimumPayFor5Day?: number | null
    MinimumPayFor6Day?: number | null
    MaxPrecentReduction?: number | null
    hourPerDayfor5?: number | null
    hourPerDayfor6?: number | null
    hourInfridayDay?: number | null
    TaxPrecent?: number | null
    EmployerTax?: number | null
    DiscountInTaxInEilat?: number | null
    TaxUnitNumber?: number | null
    FundPercentConstruction?: number | null
    Hour100?: number | null
    Hour125?: number | null
    Hour150?: number | null
    Hour175?: number | null
    Hour200?: number | null
    CreditCardMan?: number | null
    CreditCardWoman?: number | null
    CreditCardChild?: number | null
    CreditCardBaby?: number | null
    CreditCardInAddition?: number | null
    CreditCardLackMobilityChild?: number | null
    CreditCardImmigrant18?: number | null
    ControlingShareholder: boolean
    HealthInsuranceEmployeeLow?: number | null
    HealthInsuranceEmployeeAbove?: number | null
    HealthInsuranceEmployerLow?: number | null
    HealthInsuranceEmployerAbove?: number | null
    ValueOfVehicleUseHibberdDiscount?: number | null
    Deposit?: number | null
    ValueOfMobileUse?: number | null
    PensionCeiling?: number | null
    PensionCredit?: number | null
    DepositEmployerPrecent?: number | null
    DepositEmployeePrecent?: number | null
    TotalHourPerWeek?: number | null
    CreditCardAdultChild?: number | null
    CreditCardChild1_5?: number | null
    DepositEmployeePrecentExecption?: number | null
  }

  export type SocialSecurityDetileCreateOrConnectWithoutSocialSecurityInput = {
    where: SocialSecurityDetileWhereUniqueInput
    create: XOR<SocialSecurityDetileCreateWithoutSocialSecurityInput, SocialSecurityDetileUncheckedCreateWithoutSocialSecurityInput>
  }

  export type SocialSecurityDetileCreateManySocialSecurityInputEnvelope = {
    data: SocialSecurityDetileCreateManySocialSecurityInput | SocialSecurityDetileCreateManySocialSecurityInput[]
  }

  export type SocialSecurityDetileUpsertWithWhereUniqueWithoutSocialSecurityInput = {
    where: SocialSecurityDetileWhereUniqueInput
    update: XOR<SocialSecurityDetileUpdateWithoutSocialSecurityInput, SocialSecurityDetileUncheckedUpdateWithoutSocialSecurityInput>
    create: XOR<SocialSecurityDetileCreateWithoutSocialSecurityInput, SocialSecurityDetileUncheckedCreateWithoutSocialSecurityInput>
  }

  export type SocialSecurityDetileUpdateWithWhereUniqueWithoutSocialSecurityInput = {
    where: SocialSecurityDetileWhereUniqueInput
    data: XOR<SocialSecurityDetileUpdateWithoutSocialSecurityInput, SocialSecurityDetileUncheckedUpdateWithoutSocialSecurityInput>
  }

  export type SocialSecurityDetileUpdateManyWithWhereWithoutSocialSecurityInput = {
    where: SocialSecurityDetileScalarWhereInput
    data: XOR<SocialSecurityDetileUpdateManyMutationInput, SocialSecurityDetileUncheckedUpdateManyWithoutSocialSecurityInput>
  }

  export type SocialSecurityDetileScalarWhereInput = {
    AND?: SocialSecurityDetileScalarWhereInput | SocialSecurityDetileScalarWhereInput[]
    OR?: SocialSecurityDetileScalarWhereInput[]
    NOT?: SocialSecurityDetileScalarWhereInput | SocialSecurityDetileScalarWhereInput[]
    SocialSecurityDetailID?: IntFilter<"SocialSecurityDetile"> | number
    SocialSecurityID?: IntFilter<"SocialSecurityDetile"> | number
    SocialYear?: IntFilter<"SocialSecurityDetile"> | number
    SocialMonth?: IntFilter<"SocialSecurityDetile"> | number
    Sector?: IntFilter<"SocialSecurityDetile"> | number
    SocialSecurityCode?: IntFilter<"SocialSecurityDetile"> | number
    AverageSalary?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinNationalInsByMony?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByMony?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinDeductionNationalInsByMony?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinNationalInsByEmployee?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByEmployee?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinNationalInsByEmployer?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByEmployer?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxNationalInsByMonyEmployee?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    AverageEmbodiment?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DeductionMax?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DeductionPercent?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditPoint?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    FactorToReduction?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinHoursToPay?: IntNullableFilter<"SocialSecurityDetile"> | number | null
    MinimumPayFor5Day?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MinimumPayFor6Day?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    MaxPrecentReduction?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    hourPerDayfor5?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    hourPerDayfor6?: IntNullableFilter<"SocialSecurityDetile"> | number | null
    hourInfridayDay?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    TaxPrecent?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    EmployerTax?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DiscountInTaxInEilat?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    TaxUnitNumber?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    FundPercentConstruction?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour100?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour125?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour150?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour175?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Hour200?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardMan?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardWoman?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardChild?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardBaby?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardInAddition?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardLackMobilityChild?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardImmigrant18?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    ControlingShareholder?: BoolFilter<"SocialSecurityDetile"> | boolean
    HealthInsuranceEmployeeLow?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    HealthInsuranceEmployeeAbove?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    HealthInsuranceEmployerLow?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    HealthInsuranceEmployerAbove?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    ValueOfVehicleUseHibberdDiscount?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    Deposit?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    ValueOfMobileUse?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    PensionCeiling?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    PensionCredit?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DepositEmployerPrecent?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DepositEmployeePrecent?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    TotalHourPerWeek?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardAdultChild?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    CreditCardChild1_5?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
    DepositEmployeePrecentExecption?: FloatNullableFilter<"SocialSecurityDetile"> | number | null
  }

  export type SocialSecurityCreateWithoutSocialSecurityDetileInput = {
    SocialSecurityID: number
    SocialSecurityYear: number
    SocialSecurityMonth: number
    CurrentSocialSecurity: boolean
    MinAccountTotalForDivuach?: number | null
  }

  export type SocialSecurityUncheckedCreateWithoutSocialSecurityDetileInput = {
    SocialSecurityID: number
    SocialSecurityYear: number
    SocialSecurityMonth: number
    CurrentSocialSecurity: boolean
    MinAccountTotalForDivuach?: number | null
  }

  export type SocialSecurityCreateOrConnectWithoutSocialSecurityDetileInput = {
    where: SocialSecurityWhereUniqueInput
    create: XOR<SocialSecurityCreateWithoutSocialSecurityDetileInput, SocialSecurityUncheckedCreateWithoutSocialSecurityDetileInput>
  }

  export type SocialSecurityUpsertWithoutSocialSecurityDetileInput = {
    update: XOR<SocialSecurityUpdateWithoutSocialSecurityDetileInput, SocialSecurityUncheckedUpdateWithoutSocialSecurityDetileInput>
    create: XOR<SocialSecurityCreateWithoutSocialSecurityDetileInput, SocialSecurityUncheckedCreateWithoutSocialSecurityDetileInput>
    where?: SocialSecurityWhereInput
  }

  export type SocialSecurityUpdateToOneWithWhereWithoutSocialSecurityDetileInput = {
    where?: SocialSecurityWhereInput
    data: XOR<SocialSecurityUpdateWithoutSocialSecurityDetileInput, SocialSecurityUncheckedUpdateWithoutSocialSecurityDetileInput>
  }

  export type SocialSecurityUpdateWithoutSocialSecurityDetileInput = {
    SocialSecurityID?: IntFieldUpdateOperationsInput | number
    SocialSecurityYear?: IntFieldUpdateOperationsInput | number
    SocialSecurityMonth?: IntFieldUpdateOperationsInput | number
    CurrentSocialSecurity?: BoolFieldUpdateOperationsInput | boolean
    MinAccountTotalForDivuach?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SocialSecurityUncheckedUpdateWithoutSocialSecurityDetileInput = {
    SocialSecurityID?: IntFieldUpdateOperationsInput | number
    SocialSecurityYear?: IntFieldUpdateOperationsInput | number
    SocialSecurityMonth?: IntFieldUpdateOperationsInput | number
    CurrentSocialSecurity?: BoolFieldUpdateOperationsInput | boolean
    MinAccountTotalForDivuach?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaxStepsCreateWithoutTaxStepDetileInput = {
    TaxMonth: number
    TaxYear: number
    CurrentTaxStep: boolean
  }

  export type TaxStepsUncheckedCreateWithoutTaxStepDetileInput = {
    TaxStapID?: number
    TaxMonth: number
    TaxYear: number
    CurrentTaxStep: boolean
  }

  export type TaxStepsCreateOrConnectWithoutTaxStepDetileInput = {
    where: TaxStepsWhereUniqueInput
    create: XOR<TaxStepsCreateWithoutTaxStepDetileInput, TaxStepsUncheckedCreateWithoutTaxStepDetileInput>
  }

  export type TaxStepsUpsertWithoutTaxStepDetileInput = {
    update: XOR<TaxStepsUpdateWithoutTaxStepDetileInput, TaxStepsUncheckedUpdateWithoutTaxStepDetileInput>
    create: XOR<TaxStepsCreateWithoutTaxStepDetileInput, TaxStepsUncheckedCreateWithoutTaxStepDetileInput>
    where?: TaxStepsWhereInput
  }

  export type TaxStepsUpdateToOneWithWhereWithoutTaxStepDetileInput = {
    where?: TaxStepsWhereInput
    data: XOR<TaxStepsUpdateWithoutTaxStepDetileInput, TaxStepsUncheckedUpdateWithoutTaxStepDetileInput>
  }

  export type TaxStepsUpdateWithoutTaxStepDetileInput = {
    TaxMonth?: IntFieldUpdateOperationsInput | number
    TaxYear?: IntFieldUpdateOperationsInput | number
    CurrentTaxStep?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaxStepsUncheckedUpdateWithoutTaxStepDetileInput = {
    TaxStapID?: IntFieldUpdateOperationsInput | number
    TaxMonth?: IntFieldUpdateOperationsInput | number
    TaxYear?: IntFieldUpdateOperationsInput | number
    CurrentTaxStep?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaxStepDetileCreateWithoutTaxStepsInput = {
    TaxYear: number
    TaxMonth: number
    StepNumber?: number | null
    TaxStap?: number | null
    TaxStapPercent?: number | null
  }

  export type TaxStepDetileUncheckedCreateWithoutTaxStepsInput = {
    TaxStepDetileID?: number
    TaxYear: number
    TaxMonth: number
    StepNumber?: number | null
    TaxStap?: number | null
    TaxStapPercent?: number | null
  }

  export type TaxStepDetileCreateOrConnectWithoutTaxStepsInput = {
    where: TaxStepDetileWhereUniqueInput
    create: XOR<TaxStepDetileCreateWithoutTaxStepsInput, TaxStepDetileUncheckedCreateWithoutTaxStepsInput>
  }

  export type TaxStepDetileCreateManyTaxStepsInputEnvelope = {
    data: TaxStepDetileCreateManyTaxStepsInput | TaxStepDetileCreateManyTaxStepsInput[]
  }

  export type TaxStepDetileUpsertWithWhereUniqueWithoutTaxStepsInput = {
    where: TaxStepDetileWhereUniqueInput
    update: XOR<TaxStepDetileUpdateWithoutTaxStepsInput, TaxStepDetileUncheckedUpdateWithoutTaxStepsInput>
    create: XOR<TaxStepDetileCreateWithoutTaxStepsInput, TaxStepDetileUncheckedCreateWithoutTaxStepsInput>
  }

  export type TaxStepDetileUpdateWithWhereUniqueWithoutTaxStepsInput = {
    where: TaxStepDetileWhereUniqueInput
    data: XOR<TaxStepDetileUpdateWithoutTaxStepsInput, TaxStepDetileUncheckedUpdateWithoutTaxStepsInput>
  }

  export type TaxStepDetileUpdateManyWithWhereWithoutTaxStepsInput = {
    where: TaxStepDetileScalarWhereInput
    data: XOR<TaxStepDetileUpdateManyMutationInput, TaxStepDetileUncheckedUpdateManyWithoutTaxStepsInput>
  }

  export type TaxStepDetileScalarWhereInput = {
    AND?: TaxStepDetileScalarWhereInput | TaxStepDetileScalarWhereInput[]
    OR?: TaxStepDetileScalarWhereInput[]
    NOT?: TaxStepDetileScalarWhereInput | TaxStepDetileScalarWhereInput[]
    TaxStepDetileID?: IntFilter<"TaxStepDetile"> | number
    TaxStapID?: IntFilter<"TaxStepDetile"> | number
    TaxYear?: IntFilter<"TaxStepDetile"> | number
    TaxMonth?: IntFilter<"TaxStepDetile"> | number
    StepNumber?: IntNullableFilter<"TaxStepDetile"> | number | null
    TaxStap?: IntNullableFilter<"TaxStepDetile"> | number | null
    TaxStapPercent?: FloatNullableFilter<"TaxStepDetile"> | number | null
  }

  export type UnionFeeDetileCreateWithoutUnionFeeInput = {
    SocialYear: number
    SocialMonth: number
    FeePercentage_No?: number | null
    FeePercentage_Yes?: number | null
    MaxFee?: number | null
    MaxAdminFee?: number | null
  }

  export type UnionFeeDetileUncheckedCreateWithoutUnionFeeInput = {
    ID?: number
    SocialYear: number
    SocialMonth: number
    FeePercentage_No?: number | null
    FeePercentage_Yes?: number | null
    MaxFee?: number | null
    MaxAdminFee?: number | null
  }

  export type UnionFeeDetileCreateOrConnectWithoutUnionFeeInput = {
    where: UnionFeeDetileWhereUniqueInput
    create: XOR<UnionFeeDetileCreateWithoutUnionFeeInput, UnionFeeDetileUncheckedCreateWithoutUnionFeeInput>
  }

  export type UnionFeeDetileCreateManyUnionFeeInputEnvelope = {
    data: UnionFeeDetileCreateManyUnionFeeInput | UnionFeeDetileCreateManyUnionFeeInput[]
  }

  export type UnionFeeDetileUpsertWithWhereUniqueWithoutUnionFeeInput = {
    where: UnionFeeDetileWhereUniqueInput
    update: XOR<UnionFeeDetileUpdateWithoutUnionFeeInput, UnionFeeDetileUncheckedUpdateWithoutUnionFeeInput>
    create: XOR<UnionFeeDetileCreateWithoutUnionFeeInput, UnionFeeDetileUncheckedCreateWithoutUnionFeeInput>
  }

  export type UnionFeeDetileUpdateWithWhereUniqueWithoutUnionFeeInput = {
    where: UnionFeeDetileWhereUniqueInput
    data: XOR<UnionFeeDetileUpdateWithoutUnionFeeInput, UnionFeeDetileUncheckedUpdateWithoutUnionFeeInput>
  }

  export type UnionFeeDetileUpdateManyWithWhereWithoutUnionFeeInput = {
    where: UnionFeeDetileScalarWhereInput
    data: XOR<UnionFeeDetileUpdateManyMutationInput, UnionFeeDetileUncheckedUpdateManyWithoutUnionFeeInput>
  }

  export type UnionFeeDetileScalarWhereInput = {
    AND?: UnionFeeDetileScalarWhereInput | UnionFeeDetileScalarWhereInput[]
    OR?: UnionFeeDetileScalarWhereInput[]
    NOT?: UnionFeeDetileScalarWhereInput | UnionFeeDetileScalarWhereInput[]
    ID?: IntFilter<"UnionFeeDetile"> | number
    UnionCode?: IntFilter<"UnionFeeDetile"> | number
    SocialYear?: IntFilter<"UnionFeeDetile"> | number
    SocialMonth?: IntFilter<"UnionFeeDetile"> | number
    FeePercentage_No?: FloatNullableFilter<"UnionFeeDetile"> | number | null
    FeePercentage_Yes?: FloatNullableFilter<"UnionFeeDetile"> | number | null
    MaxFee?: FloatNullableFilter<"UnionFeeDetile"> | number | null
    MaxAdminFee?: FloatNullableFilter<"UnionFeeDetile"> | number | null
  }

  export type UnionFeeCreateWithoutUnionFeeDetileInput = {
    ID: number
    UnionCode: number
    UnionName: string
  }

  export type UnionFeeUncheckedCreateWithoutUnionFeeDetileInput = {
    ID: number
    UnionCode: number
    UnionName: string
  }

  export type UnionFeeCreateOrConnectWithoutUnionFeeDetileInput = {
    where: UnionFeeWhereUniqueInput
    create: XOR<UnionFeeCreateWithoutUnionFeeDetileInput, UnionFeeUncheckedCreateWithoutUnionFeeDetileInput>
  }

  export type UnionFeeUpsertWithoutUnionFeeDetileInput = {
    update: XOR<UnionFeeUpdateWithoutUnionFeeDetileInput, UnionFeeUncheckedUpdateWithoutUnionFeeDetileInput>
    create: XOR<UnionFeeCreateWithoutUnionFeeDetileInput, UnionFeeUncheckedCreateWithoutUnionFeeDetileInput>
    where?: UnionFeeWhereInput
  }

  export type UnionFeeUpdateToOneWithWhereWithoutUnionFeeDetileInput = {
    where?: UnionFeeWhereInput
    data: XOR<UnionFeeUpdateWithoutUnionFeeDetileInput, UnionFeeUncheckedUpdateWithoutUnionFeeDetileInput>
  }

  export type UnionFeeUpdateWithoutUnionFeeDetileInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UnionCode?: IntFieldUpdateOperationsInput | number
    UnionName?: StringFieldUpdateOperationsInput | string
  }

  export type UnionFeeUncheckedUpdateWithoutUnionFeeDetileInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UnionCode?: IntFieldUpdateOperationsInput | number
    UnionName?: StringFieldUpdateOperationsInput | string
  }

  export type VacationlDefinitionCreateWithoutVacationDefinitionDetailsInput = {
    VacationlDefinitionName: string
  }

  export type VacationlDefinitionUncheckedCreateWithoutVacationDefinitionDetailsInput = {
    VacationlDefinitionID?: number
    VacationlDefinitionName: string
  }

  export type VacationlDefinitionCreateOrConnectWithoutVacationDefinitionDetailsInput = {
    where: VacationlDefinitionWhereUniqueInput
    create: XOR<VacationlDefinitionCreateWithoutVacationDefinitionDetailsInput, VacationlDefinitionUncheckedCreateWithoutVacationDefinitionDetailsInput>
  }

  export type VacationlDefinitionUpsertWithoutVacationDefinitionDetailsInput = {
    update: XOR<VacationlDefinitionUpdateWithoutVacationDefinitionDetailsInput, VacationlDefinitionUncheckedUpdateWithoutVacationDefinitionDetailsInput>
    create: XOR<VacationlDefinitionCreateWithoutVacationDefinitionDetailsInput, VacationlDefinitionUncheckedCreateWithoutVacationDefinitionDetailsInput>
    where?: VacationlDefinitionWhereInput
  }

  export type VacationlDefinitionUpdateToOneWithWhereWithoutVacationDefinitionDetailsInput = {
    where?: VacationlDefinitionWhereInput
    data: XOR<VacationlDefinitionUpdateWithoutVacationDefinitionDetailsInput, VacationlDefinitionUncheckedUpdateWithoutVacationDefinitionDetailsInput>
  }

  export type VacationlDefinitionUpdateWithoutVacationDefinitionDetailsInput = {
    VacationlDefinitionName?: StringFieldUpdateOperationsInput | string
  }

  export type VacationlDefinitionUncheckedUpdateWithoutVacationDefinitionDetailsInput = {
    VacationlDefinitionID?: IntFieldUpdateOperationsInput | number
    VacationlDefinitionName?: StringFieldUpdateOperationsInput | string
  }

  export type VacationDefinitionDetailsCreateWithoutVacationlDefinitionInput = {
    StartMonthReward?: number | null
    EndMonthrReward?: number | null
    DayQuantity6days?: number | null
    DayQuantity5days?: number | null
    SocialYearDescription?: string | null
    DayQuantity?: number | null
  }

  export type VacationDefinitionDetailsUncheckedCreateWithoutVacationlDefinitionInput = {
    VacationlDefinitionDetaillID?: number
    StartMonthReward?: number | null
    EndMonthrReward?: number | null
    DayQuantity6days?: number | null
    DayQuantity5days?: number | null
    SocialYearDescription?: string | null
    DayQuantity?: number | null
  }

  export type VacationDefinitionDetailsCreateOrConnectWithoutVacationlDefinitionInput = {
    where: VacationDefinitionDetailsWhereUniqueInput
    create: XOR<VacationDefinitionDetailsCreateWithoutVacationlDefinitionInput, VacationDefinitionDetailsUncheckedCreateWithoutVacationlDefinitionInput>
  }

  export type VacationDefinitionDetailsCreateManyVacationlDefinitionInputEnvelope = {
    data: VacationDefinitionDetailsCreateManyVacationlDefinitionInput | VacationDefinitionDetailsCreateManyVacationlDefinitionInput[]
  }

  export type VacationDefinitionDetailsUpsertWithWhereUniqueWithoutVacationlDefinitionInput = {
    where: VacationDefinitionDetailsWhereUniqueInput
    update: XOR<VacationDefinitionDetailsUpdateWithoutVacationlDefinitionInput, VacationDefinitionDetailsUncheckedUpdateWithoutVacationlDefinitionInput>
    create: XOR<VacationDefinitionDetailsCreateWithoutVacationlDefinitionInput, VacationDefinitionDetailsUncheckedCreateWithoutVacationlDefinitionInput>
  }

  export type VacationDefinitionDetailsUpdateWithWhereUniqueWithoutVacationlDefinitionInput = {
    where: VacationDefinitionDetailsWhereUniqueInput
    data: XOR<VacationDefinitionDetailsUpdateWithoutVacationlDefinitionInput, VacationDefinitionDetailsUncheckedUpdateWithoutVacationlDefinitionInput>
  }

  export type VacationDefinitionDetailsUpdateManyWithWhereWithoutVacationlDefinitionInput = {
    where: VacationDefinitionDetailsScalarWhereInput
    data: XOR<VacationDefinitionDetailsUpdateManyMutationInput, VacationDefinitionDetailsUncheckedUpdateManyWithoutVacationlDefinitionInput>
  }

  export type VacationDefinitionDetailsScalarWhereInput = {
    AND?: VacationDefinitionDetailsScalarWhereInput | VacationDefinitionDetailsScalarWhereInput[]
    OR?: VacationDefinitionDetailsScalarWhereInput[]
    NOT?: VacationDefinitionDetailsScalarWhereInput | VacationDefinitionDetailsScalarWhereInput[]
    VacationlDefinitionDetaillID?: IntFilter<"VacationDefinitionDetails"> | number
    VacationlDefinitionID?: IntNullableFilter<"VacationDefinitionDetails"> | number | null
    StartMonthReward?: FloatNullableFilter<"VacationDefinitionDetails"> | number | null
    EndMonthrReward?: FloatNullableFilter<"VacationDefinitionDetails"> | number | null
    DayQuantity6days?: IntNullableFilter<"VacationDefinitionDetails"> | number | null
    DayQuantity5days?: IntNullableFilter<"VacationDefinitionDetails"> | number | null
    SocialYearDescription?: StringNullableFilter<"VacationDefinitionDetails"> | string | null
    DayQuantity?: IntNullableFilter<"VacationDefinitionDetails"> | number | null
  }

  export type AutoWordReportSubCreateManyAutoWordReportInput = {
    FieldNameTB?: string | null
    FieldNameReport?: string | null
  }

  export type AutoWordReportSubUpdateWithoutAutoWordReportInput = {
    FieldNameTB?: NullableStringFieldUpdateOperationsInput | string | null
    FieldNameReport?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AutoWordReportSubUncheckedUpdateWithoutAutoWordReportInput = {
    ReportSubID?: IntFieldUpdateOperationsInput | number
    FieldNameTB?: NullableStringFieldUpdateOperationsInput | string | null
    FieldNameReport?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AutoWordReportSubUncheckedUpdateManyWithoutAutoWordReportInput = {
    ReportSubID?: IntFieldUpdateOperationsInput | number
    FieldNameTB?: NullableStringFieldUpdateOperationsInput | string | null
    FieldNameReport?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesProductsCreateManyCompaniesInput = {
    CompaniesProductsId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    UserId?: string | null
    LastVersionDate_Salary?: Date | string | null
    LastVersionDate_ManPower?: Date | string | null
  }

  export type CompaniesProductsExpireDatesCreateManyCompaniesInput = {
    CompaniesProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    UserId?: string | null
  }

  export type CompaniesUsersCreateManyCompanies_CompaniesUsers_CompanyIDToCompaniesInput = {
    CompaniesUsersID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    UserId?: string | null
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
  }

  export type CompaniesUsersProductsExpireDatesCreateManyCompaniesInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompaniesUsersID: string
    StartDate: Date | string
    EndDate: Date | string
    UserId?: string | null
    Comments?: string | null
  }

  export type CompaniesProductsUpdateWithoutCompaniesInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutCompaniesProductsNestedInput
    Products?: ProductsUpdateOneRequiredWithoutCompaniesProductsNestedInput
  }

  export type CompaniesProductsUncheckedUpdateWithoutCompaniesInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompaniesProductsUncheckedUpdateManyWithoutCompaniesInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompaniesProductsExpireDatesUpdateWithoutCompaniesInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutCompaniesProductsExpireDatesNestedInput
    Products?: ProductsUpdateOneRequiredWithoutCompaniesProductsExpireDatesNestedInput
  }

  export type CompaniesProductsExpireDatesUncheckedUpdateWithoutCompaniesInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersUpdateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutOther_CompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersUncheckedUpdateWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersUncheckedUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersProductsExpireDatesUpdateWithoutCompaniesInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersUpdateOneRequiredWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersUpdateOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
    Products?: ProductsUpdateOneRequiredWithoutCompaniesUsersProductsExpireDatesNestedInput
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateWithoutCompaniesInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesCreateManyCompaniesTypeInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    UserId?: string | null
  }

  export type CompaniesUpdateWithoutCompaniesTypeInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesUsers_Companies_UserIdToCompaniesUsers?: CompaniesUsersUpdateOneWithoutCompanies_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    LandPages?: LandPagesUpdateOneWithoutCompaniesNestedInput
  }

  export type CompaniesUncheckedUpdateWithoutCompaniesTypeInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    LandPages?: LandPagesUncheckedUpdateOneWithoutCompaniesNestedInput
  }

  export type CompaniesUncheckedUpdateManyWithoutCompaniesTypeInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesCreateManyCompaniesUsers_Companies_UserIdToCompaniesUsersInput = {
    CompanyID?: string
    CompanyID_OLD: number
    CompanyNumber: number
    DeductionsNumber?: number | null
    AgencyNumber?: number | null
    CompanyName: string
    CompanyNameEng?: string | null
    Address?: string | null
    CityID?: number | null
    ZipCode?: string | null
    POB?: string | null
    POB_ZipCode?: string | null
    Email?: string | null
    WebSite?: string | null
    Phone?: string | null
    Fax?: string | null
    NumOfPaySlipDisplay: number
    PaySlipDefinitionID?: number | null
    DbPathOnCloud?: string | null
    DocFilesPathOnCloud?: string | null
    DbPathAgricultureCRM?: string | null
    DisplayTypeID?: number
    IsSuperAdminCompany?: number | null
    IsActive?: number | null
    IsExportAccounts?: number | null
    TaxAccountsToken?: string | null
    IsGetTaxAccountsCode?: number | null
    CompanyTaxAutoLink?: string | null
    CompanyTypeID?: string
  }

  export type CompaniesProductsCreateManyCompaniesUsersInput = {
    CompaniesProductsId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    LastVersionDate_Salary?: Date | string | null
    LastVersionDate_ManPower?: Date | string | null
  }

  export type CompaniesProductsExpireDatesCreateManyCompaniesUsersInput = {
    CompaniesProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
  }

  export type CompaniesUsersCreateManyCompaniesUsersInput = {
    CompaniesUsersID: string
    CompanyID: string
    CompanyID_OLD: number
    EmployeeIdentity: string
    BirthDate?: Date | string | null
    LastName: string
    FirstName: string
    JobsID: number
    Gender: number
    MobileNumber: string
    Phone?: string | null
    Fax?: string | null
    Email: string
    UserName: string
    Password: string
    AreaMan?: string | null
    IsAdmin: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    CreatedAt?: Date | string | null
    TwoFactorBase32Secret?: string | null
    DeviceData?: string | null
  }

  export type CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    StartDate: Date | string
    EndDate: Date | string
    UserId?: string | null
    Comments?: string | null
  }

  export type CompaniesUsersProductsExpireDatesCreateManyCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    ProductId: string
    CompanyID: string
    CompaniesUsersID: string
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
  }

  export type CompaniesUpdateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesType?: CompaniesTypeUpdateOneRequiredWithoutCompaniesNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesNestedInput
    LandPages?: LandPagesUpdateOneWithoutCompaniesNestedInput
  }

  export type CompaniesUncheckedUpdateWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyTypeID?: StringFieldUpdateOperationsInput | string
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    CompaniesUsers_CompaniesUsers_CompanyIDToCompanies?: CompaniesUsersUncheckedUpdateManyWithoutCompanies_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesNestedInput
    LandPages?: LandPagesUncheckedUpdateOneWithoutCompaniesNestedInput
  }

  export type CompaniesUncheckedUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersInput = {
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    CompanyNumber?: IntFieldUpdateOperationsInput | number
    DeductionsNumber?: NullableIntFieldUpdateOperationsInput | number | null
    AgencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyName?: StringFieldUpdateOperationsInput | string
    CompanyNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    CityID?: NullableIntFieldUpdateOperationsInput | number | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    POB?: NullableStringFieldUpdateOperationsInput | string | null
    POB_ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    WebSite?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    NumOfPaySlipDisplay?: IntFieldUpdateOperationsInput | number
    PaySlipDefinitionID?: NullableIntFieldUpdateOperationsInput | number | null
    DbPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DocFilesPathOnCloud?: NullableStringFieldUpdateOperationsInput | string | null
    DbPathAgricultureCRM?: NullableStringFieldUpdateOperationsInput | string | null
    DisplayTypeID?: IntFieldUpdateOperationsInput | number
    IsSuperAdminCompany?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: NullableIntFieldUpdateOperationsInput | number | null
    IsExportAccounts?: NullableIntFieldUpdateOperationsInput | number | null
    TaxAccountsToken?: NullableStringFieldUpdateOperationsInput | string | null
    IsGetTaxAccountsCode?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyTaxAutoLink?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyTypeID?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesProductsUpdateWithoutCompaniesUsersInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Companies?: CompaniesUpdateOneRequiredWithoutCompaniesProductsNestedInput
    Products?: ProductsUpdateOneRequiredWithoutCompaniesProductsNestedInput
  }

  export type CompaniesProductsUncheckedUpdateWithoutCompaniesUsersInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompaniesProductsUncheckedUpdateManyWithoutCompaniesUsersInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompaniesProductsExpireDatesUpdateWithoutCompaniesUsersInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    Companies?: CompaniesUpdateOneRequiredWithoutCompaniesProductsExpireDatesNestedInput
    Products?: ProductsUpdateOneRequiredWithoutCompaniesProductsExpireDatesNestedInput
  }

  export type CompaniesProductsExpireDatesUncheckedUpdateWithoutCompaniesUsersInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsersInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersUpdateWithoutCompaniesUsersInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUpdateManyWithoutCompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUpdateManyWithoutCompaniesUsersNestedInput
    Companies_CompaniesUsers_CompanyIDToCompanies?: CompaniesUpdateOneRequiredWithoutCompaniesUsers_CompaniesUsers_CompanyIDToCompaniesNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersUncheckedUpdateWithoutCompaniesUsersInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
    Companies_Companies_UserIdToCompaniesUsers?: CompaniesUncheckedUpdateManyWithoutCompaniesUsers_Companies_UserIdToCompaniesUsersNestedInput
    CompaniesProducts?: CompaniesProductsUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesProductsExpireDates?: CompaniesProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    other_CompaniesUsers?: CompaniesUsersUncheckedUpdateManyWithoutCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    CompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersUncheckedUpdateManyWithoutCompaniesUsersInput = {
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompanyID_OLD?: IntFieldUpdateOperationsInput | number
    EmployeeIdentity?: StringFieldUpdateOperationsInput | string
    BirthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    JobsID?: IntFieldUpdateOperationsInput | number
    Gender?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TwoFactorBase32Secret?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersProductsExpireDatesUpdateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    Companies?: CompaniesUpdateOneRequiredWithoutCompaniesUsersProductsExpireDatesNestedInput
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersUpdateOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
    Products?: ProductsUpdateOneRequiredWithoutCompaniesUsersProductsExpireDatesNestedInput
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersProductsExpireDatesUpdateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersUpdateOneRequiredWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    Companies?: CompaniesUpdateOneRequiredWithoutCompaniesUsersProductsExpireDatesNestedInput
    Products?: ProductsUpdateOneRequiredWithoutCompaniesUsersProductsExpireDatesNestedInput
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutCompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesProductsCreateManyProductsInput = {
    CompaniesProductsId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserId?: string | null
    LastVersionDate_Salary?: Date | string | null
    LastVersionDate_ManPower?: Date | string | null
  }

  export type CompaniesProductsExpireDatesCreateManyProductsInput = {
    CompaniesProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    StartDate: Date | string
    EndDate: Date | string
    Comments?: string | null
    UserId?: string | null
  }

  export type CompaniesUsersProductsExpireDatesCreateManyProductsInput = {
    CompaniesUsersProductsExpireDateId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    CompaniesUsersID: string
    StartDate: Date | string
    EndDate: Date | string
    UserId?: string | null
    Comments?: string | null
  }

  export type CompaniesProductsUpdateWithoutProductsInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutCompaniesProductsNestedInput
    Companies?: CompaniesUpdateOneRequiredWithoutCompaniesProductsNestedInput
  }

  export type CompaniesProductsUncheckedUpdateWithoutProductsInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompaniesProductsUncheckedUpdateManyWithoutProductsInput = {
    CompaniesProductsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    LastVersionDate_Salary?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LastVersionDate_ManPower?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompaniesProductsExpireDatesUpdateWithoutProductsInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesUsers?: CompaniesUsersUpdateOneWithoutCompaniesProductsExpireDatesNestedInput
    Companies?: CompaniesUpdateOneRequiredWithoutCompaniesProductsExpireDatesNestedInput
  }

  export type CompaniesProductsExpireDatesUncheckedUpdateWithoutProductsInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesProductsExpireDatesUncheckedUpdateManyWithoutProductsInput = {
    CompaniesProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersProductsExpireDatesUpdateWithoutProductsInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    CompaniesUsers_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsers?: CompaniesUsersUpdateOneRequiredWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_CompaniesUsersIDToCompaniesUsersNestedInput
    Companies?: CompaniesUpdateOneRequiredWithoutCompaniesUsersProductsExpireDatesNestedInput
    CompaniesUsers_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsers?: CompaniesUsersUpdateOneWithoutCompaniesUsersProductsExpireDates_CompaniesUsersProductsExpireDates_UserIdToCompaniesUsersNestedInput
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateWithoutProductsInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompaniesUsersProductsExpireDatesUncheckedUpdateManyWithoutProductsInput = {
    CompaniesUsersProductsExpireDateId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    CompaniesUsersID?: StringFieldUpdateOperationsInput | string
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: NullableStringFieldUpdateOperationsInput | string | null
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecoveryDefinitionDetailsCreateManyRecoveryDefinitionInput = {
    StartYearRewardRecovery?: number | null
    EndYearRewardRecovery?: number | null
    RecoveryDayQuantity?: number | null
    RecoveryYearDescription?: string | null
  }

  export type RecoveryDefinitionRateDetailsCreateManyRecoveryDefinitionInput = {
    RecoveryRewardID: number
    RewardYearMonth?: Date | string | null
    RecoveryRewardRatePerDay?: number | null
  }

  export type RecoveryDefinitionDetailsUpdateWithoutRecoveryDefinitionInput = {
    StartYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    RecoveryDayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    RecoveryYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecoveryDefinitionDetailsUncheckedUpdateWithoutRecoveryDefinitionInput = {
    RewardRecoveryVectorID?: IntFieldUpdateOperationsInput | number
    StartYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    RecoveryDayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    RecoveryYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecoveryDefinitionDetailsUncheckedUpdateManyWithoutRecoveryDefinitionInput = {
    RewardRecoveryVectorID?: IntFieldUpdateOperationsInput | number
    StartYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    EndYearRewardRecovery?: NullableFloatFieldUpdateOperationsInput | number | null
    RecoveryDayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    RecoveryYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecoveryDefinitionRateDetailsUpdateWithoutRecoveryDefinitionInput = {
    RecoveryRewardID?: IntFieldUpdateOperationsInput | number
    RewardYearMonth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RecoveryRewardRatePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RecoveryDefinitionRateDetailsUncheckedUpdateWithoutRecoveryDefinitionInput = {
    RecoveryRewardID?: IntFieldUpdateOperationsInput | number
    RewardYearMonth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RecoveryRewardRatePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RecoveryDefinitionRateDetailsUncheckedUpdateManyWithoutRecoveryDefinitionInput = {
    RecoveryRewardID?: IntFieldUpdateOperationsInput | number
    RewardYearMonth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RecoveryRewardRatePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SickDefinitionDetailCreateManySickDefinitionInput = {
    StartYearRewardSick?: number | null
    EndYearRewardSick?: number | null
    SickDayQuantity?: number | null
    SocialYearDescription?: string | null
  }

  export type SickDefinitionDetailUpdateWithoutSickDefinitionInput = {
    StartYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    EndYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    SickDayQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SickDefinitionDetailUncheckedUpdateWithoutSickDefinitionInput = {
    RewardSickVectorID?: IntFieldUpdateOperationsInput | number
    StartYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    EndYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    SickDayQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SickDefinitionDetailUncheckedUpdateManyWithoutSickDefinitionInput = {
    RewardSickVectorID?: IntFieldUpdateOperationsInput | number
    StartYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    EndYearRewardSick?: NullableIntFieldUpdateOperationsInput | number | null
    SickDayQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialSecurityDetileCreateManySocialSecurityInput = {
    SocialYear: number
    SocialMonth: number
    Sector: number
    SocialSecurityCode: number
    AverageSalary?: number | null
    MinNationalInsByMony?: number | null
    MaxNationalInsByMony?: number | null
    MinDeductionNationalInsByMony?: number | null
    MinNationalInsByEmployee?: number | null
    MaxNationalInsByEmployee?: number | null
    MinNationalInsByEmployer?: number | null
    MaxNationalInsByEmployer?: number | null
    MaxNationalInsByMonyEmployee?: number | null
    AverageEmbodiment?: number | null
    DeductionMax?: number | null
    DeductionPercent?: number | null
    CreditPoint?: number | null
    FactorToReduction?: number | null
    MinHoursToPay?: number | null
    MinimumPayFor5Day?: number | null
    MinimumPayFor6Day?: number | null
    MaxPrecentReduction?: number | null
    hourPerDayfor5?: number | null
    hourPerDayfor6?: number | null
    hourInfridayDay?: number | null
    TaxPrecent?: number | null
    EmployerTax?: number | null
    DiscountInTaxInEilat?: number | null
    TaxUnitNumber?: number | null
    FundPercentConstruction?: number | null
    Hour100?: number | null
    Hour125?: number | null
    Hour150?: number | null
    Hour175?: number | null
    Hour200?: number | null
    CreditCardMan?: number | null
    CreditCardWoman?: number | null
    CreditCardChild?: number | null
    CreditCardBaby?: number | null
    CreditCardInAddition?: number | null
    CreditCardLackMobilityChild?: number | null
    CreditCardImmigrant18?: number | null
    ControlingShareholder: boolean
    HealthInsuranceEmployeeLow?: number | null
    HealthInsuranceEmployeeAbove?: number | null
    HealthInsuranceEmployerLow?: number | null
    HealthInsuranceEmployerAbove?: number | null
    ValueOfVehicleUseHibberdDiscount?: number | null
    Deposit?: number | null
    ValueOfMobileUse?: number | null
    PensionCeiling?: number | null
    PensionCredit?: number | null
    DepositEmployerPrecent?: number | null
    DepositEmployeePrecent?: number | null
    TotalHourPerWeek?: number | null
    CreditCardAdultChild?: number | null
    CreditCardChild1_5?: number | null
    DepositEmployeePrecentExecption?: number | null
  }

  export type SocialSecurityDetileUpdateWithoutSocialSecurityInput = {
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    Sector?: IntFieldUpdateOperationsInput | number
    SocialSecurityCode?: IntFieldUpdateOperationsInput | number
    AverageSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinDeductionNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMonyEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    AverageEmbodiment?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionMax?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditPoint?: NullableFloatFieldUpdateOperationsInput | number | null
    FactorToReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    MinHoursToPay?: NullableIntFieldUpdateOperationsInput | number | null
    MinimumPayFor5Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MinimumPayFor6Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxPrecentReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor5?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor6?: NullableIntFieldUpdateOperationsInput | number | null
    hourInfridayDay?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployerTax?: NullableFloatFieldUpdateOperationsInput | number | null
    DiscountInTaxInEilat?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxUnitNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    FundPercentConstruction?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour100?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour125?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour150?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour175?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour200?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardMan?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardWoman?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardBaby?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardInAddition?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardLackMobilityChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardImmigrant18?: NullableFloatFieldUpdateOperationsInput | number | null
    ControlingShareholder?: BoolFieldUpdateOperationsInput | boolean
    HealthInsuranceEmployeeLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployeeAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfVehicleUseHibberdDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    Deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfMobileUse?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCeiling?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCredit?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployerPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalHourPerWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardAdultChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild1_5?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecentExecption?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SocialSecurityDetileUncheckedUpdateWithoutSocialSecurityInput = {
    SocialSecurityDetailID?: IntFieldUpdateOperationsInput | number
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    Sector?: IntFieldUpdateOperationsInput | number
    SocialSecurityCode?: IntFieldUpdateOperationsInput | number
    AverageSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinDeductionNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMonyEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    AverageEmbodiment?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionMax?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditPoint?: NullableFloatFieldUpdateOperationsInput | number | null
    FactorToReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    MinHoursToPay?: NullableIntFieldUpdateOperationsInput | number | null
    MinimumPayFor5Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MinimumPayFor6Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxPrecentReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor5?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor6?: NullableIntFieldUpdateOperationsInput | number | null
    hourInfridayDay?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployerTax?: NullableFloatFieldUpdateOperationsInput | number | null
    DiscountInTaxInEilat?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxUnitNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    FundPercentConstruction?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour100?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour125?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour150?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour175?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour200?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardMan?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardWoman?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardBaby?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardInAddition?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardLackMobilityChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardImmigrant18?: NullableFloatFieldUpdateOperationsInput | number | null
    ControlingShareholder?: BoolFieldUpdateOperationsInput | boolean
    HealthInsuranceEmployeeLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployeeAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfVehicleUseHibberdDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    Deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfMobileUse?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCeiling?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCredit?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployerPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalHourPerWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardAdultChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild1_5?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecentExecption?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SocialSecurityDetileUncheckedUpdateManyWithoutSocialSecurityInput = {
    SocialSecurityDetailID?: IntFieldUpdateOperationsInput | number
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    Sector?: IntFieldUpdateOperationsInput | number
    SocialSecurityCode?: IntFieldUpdateOperationsInput | number
    AverageSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinDeductionNationalInsByMony?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    MinNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByEmployer?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxNationalInsByMonyEmployee?: NullableFloatFieldUpdateOperationsInput | number | null
    AverageEmbodiment?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionMax?: NullableFloatFieldUpdateOperationsInput | number | null
    DeductionPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditPoint?: NullableFloatFieldUpdateOperationsInput | number | null
    FactorToReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    MinHoursToPay?: NullableIntFieldUpdateOperationsInput | number | null
    MinimumPayFor5Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MinimumPayFor6Day?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxPrecentReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor5?: NullableFloatFieldUpdateOperationsInput | number | null
    hourPerDayfor6?: NullableIntFieldUpdateOperationsInput | number | null
    hourInfridayDay?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployerTax?: NullableFloatFieldUpdateOperationsInput | number | null
    DiscountInTaxInEilat?: NullableFloatFieldUpdateOperationsInput | number | null
    TaxUnitNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    FundPercentConstruction?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour100?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour125?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour150?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour175?: NullableFloatFieldUpdateOperationsInput | number | null
    Hour200?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardMan?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardWoman?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardBaby?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardInAddition?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardLackMobilityChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardImmigrant18?: NullableFloatFieldUpdateOperationsInput | number | null
    ControlingShareholder?: BoolFieldUpdateOperationsInput | boolean
    HealthInsuranceEmployeeLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployeeAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerLow?: NullableFloatFieldUpdateOperationsInput | number | null
    HealthInsuranceEmployerAbove?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfVehicleUseHibberdDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    Deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    ValueOfMobileUse?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCeiling?: NullableFloatFieldUpdateOperationsInput | number | null
    PensionCredit?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployerPrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecent?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalHourPerWeek?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardAdultChild?: NullableFloatFieldUpdateOperationsInput | number | null
    CreditCardChild1_5?: NullableFloatFieldUpdateOperationsInput | number | null
    DepositEmployeePrecentExecption?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TaxStepDetileCreateManyTaxStepsInput = {
    TaxYear: number
    TaxMonth: number
    StepNumber?: number | null
    TaxStap?: number | null
    TaxStapPercent?: number | null
  }

  export type TaxStepDetileUpdateWithoutTaxStepsInput = {
    TaxYear?: IntFieldUpdateOperationsInput | number
    TaxMonth?: IntFieldUpdateOperationsInput | number
    StepNumber?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStap?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStapPercent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TaxStepDetileUncheckedUpdateWithoutTaxStepsInput = {
    TaxStepDetileID?: IntFieldUpdateOperationsInput | number
    TaxYear?: IntFieldUpdateOperationsInput | number
    TaxMonth?: IntFieldUpdateOperationsInput | number
    StepNumber?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStap?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStapPercent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TaxStepDetileUncheckedUpdateManyWithoutTaxStepsInput = {
    TaxStepDetileID?: IntFieldUpdateOperationsInput | number
    TaxYear?: IntFieldUpdateOperationsInput | number
    TaxMonth?: IntFieldUpdateOperationsInput | number
    StepNumber?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStap?: NullableIntFieldUpdateOperationsInput | number | null
    TaxStapPercent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UnionFeeDetileCreateManyUnionFeeInput = {
    SocialYear: number
    SocialMonth: number
    FeePercentage_No?: number | null
    FeePercentage_Yes?: number | null
    MaxFee?: number | null
    MaxAdminFee?: number | null
  }

  export type UnionFeeDetileUpdateWithoutUnionFeeInput = {
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    FeePercentage_No?: NullableFloatFieldUpdateOperationsInput | number | null
    FeePercentage_Yes?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxFee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxAdminFee?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UnionFeeDetileUncheckedUpdateWithoutUnionFeeInput = {
    ID?: IntFieldUpdateOperationsInput | number
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    FeePercentage_No?: NullableFloatFieldUpdateOperationsInput | number | null
    FeePercentage_Yes?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxFee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxAdminFee?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UnionFeeDetileUncheckedUpdateManyWithoutUnionFeeInput = {
    ID?: IntFieldUpdateOperationsInput | number
    SocialYear?: IntFieldUpdateOperationsInput | number
    SocialMonth?: IntFieldUpdateOperationsInput | number
    FeePercentage_No?: NullableFloatFieldUpdateOperationsInput | number | null
    FeePercentage_Yes?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxFee?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxAdminFee?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type VacationDefinitionDetailsCreateManyVacationlDefinitionInput = {
    StartMonthReward?: number | null
    EndMonthrReward?: number | null
    DayQuantity6days?: number | null
    DayQuantity5days?: number | null
    SocialYearDescription?: string | null
    DayQuantity?: number | null
  }

  export type VacationDefinitionDetailsUpdateWithoutVacationlDefinitionInput = {
    StartMonthReward?: NullableFloatFieldUpdateOperationsInput | number | null
    EndMonthrReward?: NullableFloatFieldUpdateOperationsInput | number | null
    DayQuantity6days?: NullableIntFieldUpdateOperationsInput | number | null
    DayQuantity5days?: NullableIntFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
    DayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VacationDefinitionDetailsUncheckedUpdateWithoutVacationlDefinitionInput = {
    VacationlDefinitionDetaillID?: IntFieldUpdateOperationsInput | number
    StartMonthReward?: NullableFloatFieldUpdateOperationsInput | number | null
    EndMonthrReward?: NullableFloatFieldUpdateOperationsInput | number | null
    DayQuantity6days?: NullableIntFieldUpdateOperationsInput | number | null
    DayQuantity5days?: NullableIntFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
    DayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VacationDefinitionDetailsUncheckedUpdateManyWithoutVacationlDefinitionInput = {
    VacationlDefinitionDetaillID?: IntFieldUpdateOperationsInput | number
    StartMonthReward?: NullableFloatFieldUpdateOperationsInput | number | null
    EndMonthrReward?: NullableFloatFieldUpdateOperationsInput | number | null
    DayQuantity6days?: NullableIntFieldUpdateOperationsInput | number | null
    DayQuantity5days?: NullableIntFieldUpdateOperationsInput | number | null
    SocialYearDescription?: NullableStringFieldUpdateOperationsInput | string | null
    DayQuantity?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}