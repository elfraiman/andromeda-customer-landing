
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model CompaniesConfig
 * 
 */
export type CompaniesConfig = $Result.DefaultSelection<Prisma.$CompaniesConfigPayload>
/**
 * Model CompanyAdmin
 * 
 */
export type CompanyAdmin = $Result.DefaultSelection<Prisma.$CompanyAdminPayload>
/**
 * Model EmployeeHours
 * 
 */
export type EmployeeHours = $Result.DefaultSelection<Prisma.$EmployeeHoursPayload>
/**
 * Model EmployeeHoursByLocality
 * 
 */
export type EmployeeHoursByLocality = $Result.DefaultSelection<Prisma.$EmployeeHoursByLocalityPayload>
/**
 * Model EmployeeHoursByLocalityTotals
 * 
 */
export type EmployeeHoursByLocalityTotals = $Result.DefaultSelection<Prisma.$EmployeeHoursByLocalityTotalsPayload>
/**
 * Model EmployeeHoursByLocalityTotalsActionType
 * 
 */
export type EmployeeHoursByLocalityTotalsActionType = $Result.DefaultSelection<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload>
/**
 * Model EmployeeHoursCompaniesSmsAlert
 * 
 */
export type EmployeeHoursCompaniesSmsAlert = $Result.DefaultSelection<Prisma.$EmployeeHoursCompaniesSmsAlertPayload>
/**
 * Model EmployeeHoursContracts
 * 
 */
export type EmployeeHoursContracts = $Result.DefaultSelection<Prisma.$EmployeeHoursContractsPayload>
/**
 * Model EmployeeHoursForemansConfig
 * 
 */
export type EmployeeHoursForemansConfig = $Result.DefaultSelection<Prisma.$EmployeeHoursForemansConfigPayload>
/**
 * Model EmployeeHoursLocalities
 * 
 */
export type EmployeeHoursLocalities = $Result.DefaultSelection<Prisma.$EmployeeHoursLocalitiesPayload>
/**
 * Model EmployeeHoursUsers
 * 
 */
export type EmployeeHoursUsers = $Result.DefaultSelection<Prisma.$EmployeeHoursUsersPayload>
/**
 * Model EmployeesAccessDocumentsTemp
 * 
 */
export type EmployeesAccessDocumentsTemp = $Result.DefaultSelection<Prisma.$EmployeesAccessDocumentsTempPayload>
/**
 * Model EmployeesAccessHouseTemp
 * 
 */
export type EmployeesAccessHouseTemp = $Result.DefaultSelection<Prisma.$EmployeesAccessHouseTempPayload>
/**
 * Model EmployeesAccessLkupDocumentTypeTemp
 * 
 */
export type EmployeesAccessLkupDocumentTypeTemp = $Result.DefaultSelection<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload>
/**
 * Model EmployeesAccessTemp
 * 
 */
export type EmployeesAccessTemp = $Result.DefaultSelection<Prisma.$EmployeesAccessTempPayload>
/**
 * Model ErrorsPhpLogs
 * 
 */
export type ErrorsPhpLogs = $Result.DefaultSelection<Prisma.$ErrorsPhpLogsPayload>
/**
 * Model Lkup_ActionType
 * 
 */
export type Lkup_ActionType = $Result.DefaultSelection<Prisma.$Lkup_ActionTypePayload>
/**
 * Model LogEnterEmployee
 * 
 */
export type LogEnterEmployee = $Result.DefaultSelection<Prisma.$LogEnterEmployeePayload>
/**
 * Model LogSearchs
 * 
 */
export type LogSearchs = $Result.DefaultSelection<Prisma.$LogSearchsPayload>
/**
 * Model LogSignUp
 * 
 */
export type LogSignUp = $Result.DefaultSelection<Prisma.$LogSignUpPayload>
/**
 * Model MessagesEmployees
 * 
 */
export type MessagesEmployees = $Result.DefaultSelection<Prisma.$MessagesEmployeesPayload>
/**
 * Model MessagesStatus
 * 
 */
export type MessagesStatus = $Result.DefaultSelection<Prisma.$MessagesStatusPayload>
/**
 * Model SiteConfig
 * 
 */
export type SiteConfig = $Result.DefaultSelection<Prisma.$SiteConfigPayload>
/**
 * Model sysdiagrams
 * 
 */
export type sysdiagrams = $Result.DefaultSelection<Prisma.$sysdiagramsPayload>
/**
 * Model UsersLinkedViewRole
 * 
 */
export type UsersLinkedViewRole = $Result.DefaultSelection<Prisma.$UsersLinkedViewRolePayload>
/**
 * Model UserViewRoles
 * 
 */
export type UserViewRoles = $Result.DefaultSelection<Prisma.$UserViewRolesPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CompaniesConfigs
 * const companiesConfigs = await prisma.companiesConfig.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CompaniesConfigs
   * const companiesConfigs = await prisma.companiesConfig.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.companiesConfig`: Exposes CRUD operations for the **CompaniesConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompaniesConfigs
    * const companiesConfigs = await prisma.companiesConfig.findMany()
    * ```
    */
  get companiesConfig(): Prisma.CompaniesConfigDelegate<ExtArgs>;

  /**
   * `prisma.companyAdmin`: Exposes CRUD operations for the **CompanyAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyAdmins
    * const companyAdmins = await prisma.companyAdmin.findMany()
    * ```
    */
  get companyAdmin(): Prisma.CompanyAdminDelegate<ExtArgs>;

  /**
   * `prisma.employeeHours`: Exposes CRUD operations for the **EmployeeHours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeHours
    * const employeeHours = await prisma.employeeHours.findMany()
    * ```
    */
  get employeeHours(): Prisma.EmployeeHoursDelegate<ExtArgs>;

  /**
   * `prisma.employeeHoursByLocality`: Exposes CRUD operations for the **EmployeeHoursByLocality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeHoursByLocalities
    * const employeeHoursByLocalities = await prisma.employeeHoursByLocality.findMany()
    * ```
    */
  get employeeHoursByLocality(): Prisma.EmployeeHoursByLocalityDelegate<ExtArgs>;

  /**
   * `prisma.employeeHoursByLocalityTotals`: Exposes CRUD operations for the **EmployeeHoursByLocalityTotals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeHoursByLocalityTotals
    * const employeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.findMany()
    * ```
    */
  get employeeHoursByLocalityTotals(): Prisma.EmployeeHoursByLocalityTotalsDelegate<ExtArgs>;

  /**
   * `prisma.employeeHoursByLocalityTotalsActionType`: Exposes CRUD operations for the **EmployeeHoursByLocalityTotalsActionType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeHoursByLocalityTotalsActionTypes
    * const employeeHoursByLocalityTotalsActionTypes = await prisma.employeeHoursByLocalityTotalsActionType.findMany()
    * ```
    */
  get employeeHoursByLocalityTotalsActionType(): Prisma.EmployeeHoursByLocalityTotalsActionTypeDelegate<ExtArgs>;

  /**
   * `prisma.employeeHoursCompaniesSmsAlert`: Exposes CRUD operations for the **EmployeeHoursCompaniesSmsAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeHoursCompaniesSmsAlerts
    * const employeeHoursCompaniesSmsAlerts = await prisma.employeeHoursCompaniesSmsAlert.findMany()
    * ```
    */
  get employeeHoursCompaniesSmsAlert(): Prisma.EmployeeHoursCompaniesSmsAlertDelegate<ExtArgs>;

  /**
   * `prisma.employeeHoursContracts`: Exposes CRUD operations for the **EmployeeHoursContracts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeHoursContracts
    * const employeeHoursContracts = await prisma.employeeHoursContracts.findMany()
    * ```
    */
  get employeeHoursContracts(): Prisma.EmployeeHoursContractsDelegate<ExtArgs>;

  /**
   * `prisma.employeeHoursForemansConfig`: Exposes CRUD operations for the **EmployeeHoursForemansConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeHoursForemansConfigs
    * const employeeHoursForemansConfigs = await prisma.employeeHoursForemansConfig.findMany()
    * ```
    */
  get employeeHoursForemansConfig(): Prisma.EmployeeHoursForemansConfigDelegate<ExtArgs>;

  /**
   * `prisma.employeeHoursLocalities`: Exposes CRUD operations for the **EmployeeHoursLocalities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeHoursLocalities
    * const employeeHoursLocalities = await prisma.employeeHoursLocalities.findMany()
    * ```
    */
  get employeeHoursLocalities(): Prisma.EmployeeHoursLocalitiesDelegate<ExtArgs>;

  /**
   * `prisma.employeeHoursUsers`: Exposes CRUD operations for the **EmployeeHoursUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeHoursUsers
    * const employeeHoursUsers = await prisma.employeeHoursUsers.findMany()
    * ```
    */
  get employeeHoursUsers(): Prisma.EmployeeHoursUsersDelegate<ExtArgs>;

  /**
   * `prisma.employeesAccessDocumentsTemp`: Exposes CRUD operations for the **EmployeesAccessDocumentsTemp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeesAccessDocumentsTemps
    * const employeesAccessDocumentsTemps = await prisma.employeesAccessDocumentsTemp.findMany()
    * ```
    */
  get employeesAccessDocumentsTemp(): Prisma.EmployeesAccessDocumentsTempDelegate<ExtArgs>;

  /**
   * `prisma.employeesAccessHouseTemp`: Exposes CRUD operations for the **EmployeesAccessHouseTemp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeesAccessHouseTemps
    * const employeesAccessHouseTemps = await prisma.employeesAccessHouseTemp.findMany()
    * ```
    */
  get employeesAccessHouseTemp(): Prisma.EmployeesAccessHouseTempDelegate<ExtArgs>;

  /**
   * `prisma.employeesAccessLkupDocumentTypeTemp`: Exposes CRUD operations for the **EmployeesAccessLkupDocumentTypeTemp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeesAccessLkupDocumentTypeTemps
    * const employeesAccessLkupDocumentTypeTemps = await prisma.employeesAccessLkupDocumentTypeTemp.findMany()
    * ```
    */
  get employeesAccessLkupDocumentTypeTemp(): Prisma.EmployeesAccessLkupDocumentTypeTempDelegate<ExtArgs>;

  /**
   * `prisma.employeesAccessTemp`: Exposes CRUD operations for the **EmployeesAccessTemp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeesAccessTemps
    * const employeesAccessTemps = await prisma.employeesAccessTemp.findMany()
    * ```
    */
  get employeesAccessTemp(): Prisma.EmployeesAccessTempDelegate<ExtArgs>;

  /**
   * `prisma.errorsPhpLogs`: Exposes CRUD operations for the **ErrorsPhpLogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ErrorsPhpLogs
    * const errorsPhpLogs = await prisma.errorsPhpLogs.findMany()
    * ```
    */
  get errorsPhpLogs(): Prisma.ErrorsPhpLogsDelegate<ExtArgs>;

  /**
   * `prisma.lkup_ActionType`: Exposes CRUD operations for the **Lkup_ActionType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lkup_ActionTypes
    * const lkup_ActionTypes = await prisma.lkup_ActionType.findMany()
    * ```
    */
  get lkup_ActionType(): Prisma.Lkup_ActionTypeDelegate<ExtArgs>;

  /**
   * `prisma.logEnterEmployee`: Exposes CRUD operations for the **LogEnterEmployee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogEnterEmployees
    * const logEnterEmployees = await prisma.logEnterEmployee.findMany()
    * ```
    */
  get logEnterEmployee(): Prisma.LogEnterEmployeeDelegate<ExtArgs>;

  /**
   * `prisma.logSearchs`: Exposes CRUD operations for the **LogSearchs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogSearchs
    * const logSearchs = await prisma.logSearchs.findMany()
    * ```
    */
  get logSearchs(): Prisma.LogSearchsDelegate<ExtArgs>;

  /**
   * `prisma.logSignUp`: Exposes CRUD operations for the **LogSignUp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogSignUps
    * const logSignUps = await prisma.logSignUp.findMany()
    * ```
    */
  get logSignUp(): Prisma.LogSignUpDelegate<ExtArgs>;

  /**
   * `prisma.messagesEmployees`: Exposes CRUD operations for the **MessagesEmployees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessagesEmployees
    * const messagesEmployees = await prisma.messagesEmployees.findMany()
    * ```
    */
  get messagesEmployees(): Prisma.MessagesEmployeesDelegate<ExtArgs>;

  /**
   * `prisma.messagesStatus`: Exposes CRUD operations for the **MessagesStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessagesStatuses
    * const messagesStatuses = await prisma.messagesStatus.findMany()
    * ```
    */
  get messagesStatus(): Prisma.MessagesStatusDelegate<ExtArgs>;

  /**
   * `prisma.siteConfig`: Exposes CRUD operations for the **SiteConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteConfigs
    * const siteConfigs = await prisma.siteConfig.findMany()
    * ```
    */
  get siteConfig(): Prisma.SiteConfigDelegate<ExtArgs>;

  /**
   * `prisma.sysdiagrams`: Exposes CRUD operations for the **sysdiagrams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sysdiagrams
    * const sysdiagrams = await prisma.sysdiagrams.findMany()
    * ```
    */
  get sysdiagrams(): Prisma.sysdiagramsDelegate<ExtArgs>;

  /**
   * `prisma.usersLinkedViewRole`: Exposes CRUD operations for the **UsersLinkedViewRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersLinkedViewRoles
    * const usersLinkedViewRoles = await prisma.usersLinkedViewRole.findMany()
    * ```
    */
  get usersLinkedViewRole(): Prisma.UsersLinkedViewRoleDelegate<ExtArgs>;

  /**
   * `prisma.userViewRoles`: Exposes CRUD operations for the **UserViewRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserViewRoles
    * const userViewRoles = await prisma.userViewRoles.findMany()
    * ```
    */
  get userViewRoles(): Prisma.UserViewRolesDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.0.1
   * Query Engine version: 5dbef10bdbfb579e07d35cc85fb1518d357cb99e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CompaniesConfig: 'CompaniesConfig',
    CompanyAdmin: 'CompanyAdmin',
    EmployeeHours: 'EmployeeHours',
    EmployeeHoursByLocality: 'EmployeeHoursByLocality',
    EmployeeHoursByLocalityTotals: 'EmployeeHoursByLocalityTotals',
    EmployeeHoursByLocalityTotalsActionType: 'EmployeeHoursByLocalityTotalsActionType',
    EmployeeHoursCompaniesSmsAlert: 'EmployeeHoursCompaniesSmsAlert',
    EmployeeHoursContracts: 'EmployeeHoursContracts',
    EmployeeHoursForemansConfig: 'EmployeeHoursForemansConfig',
    EmployeeHoursLocalities: 'EmployeeHoursLocalities',
    EmployeeHoursUsers: 'EmployeeHoursUsers',
    EmployeesAccessDocumentsTemp: 'EmployeesAccessDocumentsTemp',
    EmployeesAccessHouseTemp: 'EmployeesAccessHouseTemp',
    EmployeesAccessLkupDocumentTypeTemp: 'EmployeesAccessLkupDocumentTypeTemp',
    EmployeesAccessTemp: 'EmployeesAccessTemp',
    ErrorsPhpLogs: 'ErrorsPhpLogs',
    Lkup_ActionType: 'Lkup_ActionType',
    LogEnterEmployee: 'LogEnterEmployee',
    LogSearchs: 'LogSearchs',
    LogSignUp: 'LogSignUp',
    MessagesEmployees: 'MessagesEmployees',
    MessagesStatus: 'MessagesStatus',
    SiteConfig: 'SiteConfig',
    sysdiagrams: 'sysdiagrams',
    UsersLinkedViewRole: 'UsersLinkedViewRole',
    UserViewRoles: 'UserViewRoles'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "companiesConfig" | "companyAdmin" | "employeeHours" | "employeeHoursByLocality" | "employeeHoursByLocalityTotals" | "employeeHoursByLocalityTotalsActionType" | "employeeHoursCompaniesSmsAlert" | "employeeHoursContracts" | "employeeHoursForemansConfig" | "employeeHoursLocalities" | "employeeHoursUsers" | "employeesAccessDocumentsTemp" | "employeesAccessHouseTemp" | "employeesAccessLkupDocumentTypeTemp" | "employeesAccessTemp" | "errorsPhpLogs" | "lkup_ActionType" | "logEnterEmployee" | "logSearchs" | "logSignUp" | "messagesEmployees" | "messagesStatus" | "siteConfig" | "sysdiagrams" | "usersLinkedViewRole" | "userViewRoles"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      CompaniesConfig: {
        payload: Prisma.$CompaniesConfigPayload<ExtArgs>
        fields: Prisma.CompaniesConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompaniesConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompaniesConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesConfigPayload>
          }
          findFirst: {
            args: Prisma.CompaniesConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompaniesConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesConfigPayload>
          }
          findMany: {
            args: Prisma.CompaniesConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesConfigPayload>[]
          }
          create: {
            args: Prisma.CompaniesConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesConfigPayload>
          }
          createMany: {
            args: Prisma.CompaniesConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompaniesConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesConfigPayload>
          }
          update: {
            args: Prisma.CompaniesConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesConfigPayload>
          }
          deleteMany: {
            args: Prisma.CompaniesConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompaniesConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompaniesConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesConfigPayload>
          }
          aggregate: {
            args: Prisma.CompaniesConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompaniesConfig>
          }
          groupBy: {
            args: Prisma.CompaniesConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompaniesConfigCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesConfigCountAggregateOutputType> | number
          }
        }
      }
      CompanyAdmin: {
        payload: Prisma.$CompanyAdminPayload<ExtArgs>
        fields: Prisma.CompanyAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyAdminPayload>
          }
          findFirst: {
            args: Prisma.CompanyAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyAdminPayload>
          }
          findMany: {
            args: Prisma.CompanyAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyAdminPayload>[]
          }
          create: {
            args: Prisma.CompanyAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyAdminPayload>
          }
          createMany: {
            args: Prisma.CompanyAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyAdminPayload>
          }
          update: {
            args: Prisma.CompanyAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyAdminPayload>
          }
          deleteMany: {
            args: Prisma.CompanyAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyAdminPayload>
          }
          aggregate: {
            args: Prisma.CompanyAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyAdmin>
          }
          groupBy: {
            args: Prisma.CompanyAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyAdminCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyAdminCountAggregateOutputType> | number
          }
        }
      }
      EmployeeHours: {
        payload: Prisma.$EmployeeHoursPayload<ExtArgs>
        fields: Prisma.EmployeeHoursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeHoursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeHoursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursPayload>
          }
          findFirst: {
            args: Prisma.EmployeeHoursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeHoursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursPayload>
          }
          findMany: {
            args: Prisma.EmployeeHoursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursPayload>[]
          }
          create: {
            args: Prisma.EmployeeHoursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursPayload>
          }
          createMany: {
            args: Prisma.EmployeeHoursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeHoursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursPayload>
          }
          update: {
            args: Prisma.EmployeeHoursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeHoursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeHoursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeHoursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursPayload>
          }
          aggregate: {
            args: Prisma.EmployeeHoursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeHours>
          }
          groupBy: {
            args: Prisma.EmployeeHoursGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeHoursCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursCountAggregateOutputType> | number
          }
        }
      }
      EmployeeHoursByLocality: {
        payload: Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>
        fields: Prisma.EmployeeHoursByLocalityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeHoursByLocalityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeHoursByLocalityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityPayload>
          }
          findFirst: {
            args: Prisma.EmployeeHoursByLocalityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeHoursByLocalityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityPayload>
          }
          findMany: {
            args: Prisma.EmployeeHoursByLocalityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityPayload>[]
          }
          create: {
            args: Prisma.EmployeeHoursByLocalityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityPayload>
          }
          createMany: {
            args: Prisma.EmployeeHoursByLocalityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeHoursByLocalityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityPayload>
          }
          update: {
            args: Prisma.EmployeeHoursByLocalityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeHoursByLocalityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeHoursByLocalityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeHoursByLocalityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityPayload>
          }
          aggregate: {
            args: Prisma.EmployeeHoursByLocalityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeHoursByLocality>
          }
          groupBy: {
            args: Prisma.EmployeeHoursByLocalityGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursByLocalityGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeHoursByLocalityCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursByLocalityCountAggregateOutputType> | number
          }
        }
      }
      EmployeeHoursByLocalityTotals: {
        payload: Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>
        fields: Prisma.EmployeeHoursByLocalityTotalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeHoursByLocalityTotalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeHoursByLocalityTotalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsPayload>
          }
          findFirst: {
            args: Prisma.EmployeeHoursByLocalityTotalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeHoursByLocalityTotalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsPayload>
          }
          findMany: {
            args: Prisma.EmployeeHoursByLocalityTotalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsPayload>[]
          }
          create: {
            args: Prisma.EmployeeHoursByLocalityTotalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsPayload>
          }
          createMany: {
            args: Prisma.EmployeeHoursByLocalityTotalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeHoursByLocalityTotalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsPayload>
          }
          update: {
            args: Prisma.EmployeeHoursByLocalityTotalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeHoursByLocalityTotalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeHoursByLocalityTotalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeHoursByLocalityTotalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsPayload>
          }
          aggregate: {
            args: Prisma.EmployeeHoursByLocalityTotalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeHoursByLocalityTotals>
          }
          groupBy: {
            args: Prisma.EmployeeHoursByLocalityTotalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursByLocalityTotalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeHoursByLocalityTotalsCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursByLocalityTotalsCountAggregateOutputType> | number
          }
        }
      }
      EmployeeHoursByLocalityTotalsActionType: {
        payload: Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>
        fields: Prisma.EmployeeHoursByLocalityTotalsActionTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload>
          }
          findFirst: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload>
          }
          findMany: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload>[]
          }
          create: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload>
          }
          createMany: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload>
          }
          update: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload>
          }
          aggregate: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeHoursByLocalityTotalsActionType>
          }
          groupBy: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursByLocalityTotalsActionTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeHoursByLocalityTotalsActionTypeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursByLocalityTotalsActionTypeCountAggregateOutputType> | number
          }
        }
      }
      EmployeeHoursCompaniesSmsAlert: {
        payload: Prisma.$EmployeeHoursCompaniesSmsAlertPayload<ExtArgs>
        fields: Prisma.EmployeeHoursCompaniesSmsAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload>
          }
          findFirst: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload>
          }
          findMany: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload>[]
          }
          create: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload>
          }
          createMany: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload>
          }
          update: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload>
          }
          aggregate: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeHoursCompaniesSmsAlert>
          }
          groupBy: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursCompaniesSmsAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeHoursCompaniesSmsAlertCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursCompaniesSmsAlertCountAggregateOutputType> | number
          }
        }
      }
      EmployeeHoursContracts: {
        payload: Prisma.$EmployeeHoursContractsPayload<ExtArgs>
        fields: Prisma.EmployeeHoursContractsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeHoursContractsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursContractsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeHoursContractsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursContractsPayload>
          }
          findFirst: {
            args: Prisma.EmployeeHoursContractsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursContractsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeHoursContractsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursContractsPayload>
          }
          findMany: {
            args: Prisma.EmployeeHoursContractsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursContractsPayload>[]
          }
          create: {
            args: Prisma.EmployeeHoursContractsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursContractsPayload>
          }
          createMany: {
            args: Prisma.EmployeeHoursContractsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeHoursContractsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursContractsPayload>
          }
          update: {
            args: Prisma.EmployeeHoursContractsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursContractsPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeHoursContractsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeHoursContractsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeHoursContractsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursContractsPayload>
          }
          aggregate: {
            args: Prisma.EmployeeHoursContractsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeHoursContracts>
          }
          groupBy: {
            args: Prisma.EmployeeHoursContractsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursContractsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeHoursContractsCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursContractsCountAggregateOutputType> | number
          }
        }
      }
      EmployeeHoursForemansConfig: {
        payload: Prisma.$EmployeeHoursForemansConfigPayload<ExtArgs>
        fields: Prisma.EmployeeHoursForemansConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeHoursForemansConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursForemansConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeHoursForemansConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursForemansConfigPayload>
          }
          findFirst: {
            args: Prisma.EmployeeHoursForemansConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursForemansConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeHoursForemansConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursForemansConfigPayload>
          }
          findMany: {
            args: Prisma.EmployeeHoursForemansConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursForemansConfigPayload>[]
          }
          create: {
            args: Prisma.EmployeeHoursForemansConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursForemansConfigPayload>
          }
          createMany: {
            args: Prisma.EmployeeHoursForemansConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeHoursForemansConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursForemansConfigPayload>
          }
          update: {
            args: Prisma.EmployeeHoursForemansConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursForemansConfigPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeHoursForemansConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeHoursForemansConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeHoursForemansConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursForemansConfigPayload>
          }
          aggregate: {
            args: Prisma.EmployeeHoursForemansConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeHoursForemansConfig>
          }
          groupBy: {
            args: Prisma.EmployeeHoursForemansConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursForemansConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeHoursForemansConfigCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursForemansConfigCountAggregateOutputType> | number
          }
        }
      }
      EmployeeHoursLocalities: {
        payload: Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>
        fields: Prisma.EmployeeHoursLocalitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeHoursLocalitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursLocalitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeHoursLocalitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursLocalitiesPayload>
          }
          findFirst: {
            args: Prisma.EmployeeHoursLocalitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursLocalitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeHoursLocalitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursLocalitiesPayload>
          }
          findMany: {
            args: Prisma.EmployeeHoursLocalitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursLocalitiesPayload>[]
          }
          create: {
            args: Prisma.EmployeeHoursLocalitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursLocalitiesPayload>
          }
          createMany: {
            args: Prisma.EmployeeHoursLocalitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeHoursLocalitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursLocalitiesPayload>
          }
          update: {
            args: Prisma.EmployeeHoursLocalitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursLocalitiesPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeHoursLocalitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeHoursLocalitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeHoursLocalitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursLocalitiesPayload>
          }
          aggregate: {
            args: Prisma.EmployeeHoursLocalitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeHoursLocalities>
          }
          groupBy: {
            args: Prisma.EmployeeHoursLocalitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursLocalitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeHoursLocalitiesCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursLocalitiesCountAggregateOutputType> | number
          }
        }
      }
      EmployeeHoursUsers: {
        payload: Prisma.$EmployeeHoursUsersPayload<ExtArgs>
        fields: Prisma.EmployeeHoursUsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeHoursUsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursUsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeHoursUsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursUsersPayload>
          }
          findFirst: {
            args: Prisma.EmployeeHoursUsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursUsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeHoursUsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursUsersPayload>
          }
          findMany: {
            args: Prisma.EmployeeHoursUsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursUsersPayload>[]
          }
          create: {
            args: Prisma.EmployeeHoursUsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursUsersPayload>
          }
          createMany: {
            args: Prisma.EmployeeHoursUsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeHoursUsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursUsersPayload>
          }
          update: {
            args: Prisma.EmployeeHoursUsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursUsersPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeHoursUsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeHoursUsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeHoursUsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeHoursUsersPayload>
          }
          aggregate: {
            args: Prisma.EmployeeHoursUsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeHoursUsers>
          }
          groupBy: {
            args: Prisma.EmployeeHoursUsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursUsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeHoursUsersCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeHoursUsersCountAggregateOutputType> | number
          }
        }
      }
      EmployeesAccessDocumentsTemp: {
        payload: Prisma.$EmployeesAccessDocumentsTempPayload<ExtArgs>
        fields: Prisma.EmployeesAccessDocumentsTempFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeesAccessDocumentsTempFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessDocumentsTempPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeesAccessDocumentsTempFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessDocumentsTempPayload>
          }
          findFirst: {
            args: Prisma.EmployeesAccessDocumentsTempFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessDocumentsTempPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeesAccessDocumentsTempFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessDocumentsTempPayload>
          }
          findMany: {
            args: Prisma.EmployeesAccessDocumentsTempFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessDocumentsTempPayload>[]
          }
          create: {
            args: Prisma.EmployeesAccessDocumentsTempCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessDocumentsTempPayload>
          }
          createMany: {
            args: Prisma.EmployeesAccessDocumentsTempCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeesAccessDocumentsTempDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessDocumentsTempPayload>
          }
          update: {
            args: Prisma.EmployeesAccessDocumentsTempUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessDocumentsTempPayload>
          }
          deleteMany: {
            args: Prisma.EmployeesAccessDocumentsTempDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeesAccessDocumentsTempUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeesAccessDocumentsTempUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessDocumentsTempPayload>
          }
          aggregate: {
            args: Prisma.EmployeesAccessDocumentsTempAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeesAccessDocumentsTemp>
          }
          groupBy: {
            args: Prisma.EmployeesAccessDocumentsTempGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeesAccessDocumentsTempGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeesAccessDocumentsTempCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeesAccessDocumentsTempCountAggregateOutputType> | number
          }
        }
      }
      EmployeesAccessHouseTemp: {
        payload: Prisma.$EmployeesAccessHouseTempPayload<ExtArgs>
        fields: Prisma.EmployeesAccessHouseTempFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeesAccessHouseTempFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessHouseTempPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeesAccessHouseTempFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessHouseTempPayload>
          }
          findFirst: {
            args: Prisma.EmployeesAccessHouseTempFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessHouseTempPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeesAccessHouseTempFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessHouseTempPayload>
          }
          findMany: {
            args: Prisma.EmployeesAccessHouseTempFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessHouseTempPayload>[]
          }
          create: {
            args: Prisma.EmployeesAccessHouseTempCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessHouseTempPayload>
          }
          createMany: {
            args: Prisma.EmployeesAccessHouseTempCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeesAccessHouseTempDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessHouseTempPayload>
          }
          update: {
            args: Prisma.EmployeesAccessHouseTempUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessHouseTempPayload>
          }
          deleteMany: {
            args: Prisma.EmployeesAccessHouseTempDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeesAccessHouseTempUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeesAccessHouseTempUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessHouseTempPayload>
          }
          aggregate: {
            args: Prisma.EmployeesAccessHouseTempAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeesAccessHouseTemp>
          }
          groupBy: {
            args: Prisma.EmployeesAccessHouseTempGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeesAccessHouseTempGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeesAccessHouseTempCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeesAccessHouseTempCountAggregateOutputType> | number
          }
        }
      }
      EmployeesAccessLkupDocumentTypeTemp: {
        payload: Prisma.$EmployeesAccessLkupDocumentTypeTempPayload<ExtArgs>
        fields: Prisma.EmployeesAccessLkupDocumentTypeTempFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload>
          }
          findFirst: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload>
          }
          findMany: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload>[]
          }
          create: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload>
          }
          createMany: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload>
          }
          update: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload>
          }
          deleteMany: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload>
          }
          aggregate: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeesAccessLkupDocumentTypeTemp>
          }
          groupBy: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeesAccessLkupDocumentTypeTempGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeesAccessLkupDocumentTypeTempCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeesAccessLkupDocumentTypeTempCountAggregateOutputType> | number
          }
        }
      }
      EmployeesAccessTemp: {
        payload: Prisma.$EmployeesAccessTempPayload<ExtArgs>
        fields: Prisma.EmployeesAccessTempFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeesAccessTempFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessTempPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeesAccessTempFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessTempPayload>
          }
          findFirst: {
            args: Prisma.EmployeesAccessTempFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessTempPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeesAccessTempFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessTempPayload>
          }
          findMany: {
            args: Prisma.EmployeesAccessTempFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessTempPayload>[]
          }
          create: {
            args: Prisma.EmployeesAccessTempCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessTempPayload>
          }
          createMany: {
            args: Prisma.EmployeesAccessTempCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeesAccessTempDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessTempPayload>
          }
          update: {
            args: Prisma.EmployeesAccessTempUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessTempPayload>
          }
          deleteMany: {
            args: Prisma.EmployeesAccessTempDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeesAccessTempUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeesAccessTempUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesAccessTempPayload>
          }
          aggregate: {
            args: Prisma.EmployeesAccessTempAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeesAccessTemp>
          }
          groupBy: {
            args: Prisma.EmployeesAccessTempGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeesAccessTempGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeesAccessTempCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeesAccessTempCountAggregateOutputType> | number
          }
        }
      }
      ErrorsPhpLogs: {
        payload: Prisma.$ErrorsPhpLogsPayload<ExtArgs>
        fields: Prisma.ErrorsPhpLogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ErrorsPhpLogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPhpLogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ErrorsPhpLogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPhpLogsPayload>
          }
          findFirst: {
            args: Prisma.ErrorsPhpLogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPhpLogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ErrorsPhpLogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPhpLogsPayload>
          }
          findMany: {
            args: Prisma.ErrorsPhpLogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPhpLogsPayload>[]
          }
          create: {
            args: Prisma.ErrorsPhpLogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPhpLogsPayload>
          }
          createMany: {
            args: Prisma.ErrorsPhpLogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ErrorsPhpLogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPhpLogsPayload>
          }
          update: {
            args: Prisma.ErrorsPhpLogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPhpLogsPayload>
          }
          deleteMany: {
            args: Prisma.ErrorsPhpLogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ErrorsPhpLogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ErrorsPhpLogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorsPhpLogsPayload>
          }
          aggregate: {
            args: Prisma.ErrorsPhpLogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateErrorsPhpLogs>
          }
          groupBy: {
            args: Prisma.ErrorsPhpLogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ErrorsPhpLogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ErrorsPhpLogsCountArgs<ExtArgs>
            result: $Utils.Optional<ErrorsPhpLogsCountAggregateOutputType> | number
          }
        }
      }
      Lkup_ActionType: {
        payload: Prisma.$Lkup_ActionTypePayload<ExtArgs>
        fields: Prisma.Lkup_ActionTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Lkup_ActionTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_ActionTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Lkup_ActionTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_ActionTypePayload>
          }
          findFirst: {
            args: Prisma.Lkup_ActionTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_ActionTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Lkup_ActionTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_ActionTypePayload>
          }
          findMany: {
            args: Prisma.Lkup_ActionTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_ActionTypePayload>[]
          }
          create: {
            args: Prisma.Lkup_ActionTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_ActionTypePayload>
          }
          createMany: {
            args: Prisma.Lkup_ActionTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Lkup_ActionTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_ActionTypePayload>
          }
          update: {
            args: Prisma.Lkup_ActionTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_ActionTypePayload>
          }
          deleteMany: {
            args: Prisma.Lkup_ActionTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Lkup_ActionTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Lkup_ActionTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Lkup_ActionTypePayload>
          }
          aggregate: {
            args: Prisma.Lkup_ActionTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLkup_ActionType>
          }
          groupBy: {
            args: Prisma.Lkup_ActionTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lkup_ActionTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.Lkup_ActionTypeCountArgs<ExtArgs>
            result: $Utils.Optional<Lkup_ActionTypeCountAggregateOutputType> | number
          }
        }
      }
      LogEnterEmployee: {
        payload: Prisma.$LogEnterEmployeePayload<ExtArgs>
        fields: Prisma.LogEnterEmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogEnterEmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEnterEmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogEnterEmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEnterEmployeePayload>
          }
          findFirst: {
            args: Prisma.LogEnterEmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEnterEmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogEnterEmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEnterEmployeePayload>
          }
          findMany: {
            args: Prisma.LogEnterEmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEnterEmployeePayload>[]
          }
          create: {
            args: Prisma.LogEnterEmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEnterEmployeePayload>
          }
          createMany: {
            args: Prisma.LogEnterEmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LogEnterEmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEnterEmployeePayload>
          }
          update: {
            args: Prisma.LogEnterEmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEnterEmployeePayload>
          }
          deleteMany: {
            args: Prisma.LogEnterEmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogEnterEmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogEnterEmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEnterEmployeePayload>
          }
          aggregate: {
            args: Prisma.LogEnterEmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogEnterEmployee>
          }
          groupBy: {
            args: Prisma.LogEnterEmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogEnterEmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogEnterEmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<LogEnterEmployeeCountAggregateOutputType> | number
          }
        }
      }
      LogSearchs: {
        payload: Prisma.$LogSearchsPayload<ExtArgs>
        fields: Prisma.LogSearchsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogSearchsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSearchsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogSearchsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSearchsPayload>
          }
          findFirst: {
            args: Prisma.LogSearchsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSearchsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogSearchsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSearchsPayload>
          }
          findMany: {
            args: Prisma.LogSearchsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSearchsPayload>[]
          }
          create: {
            args: Prisma.LogSearchsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSearchsPayload>
          }
          createMany: {
            args: Prisma.LogSearchsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LogSearchsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSearchsPayload>
          }
          update: {
            args: Prisma.LogSearchsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSearchsPayload>
          }
          deleteMany: {
            args: Prisma.LogSearchsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogSearchsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogSearchsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSearchsPayload>
          }
          aggregate: {
            args: Prisma.LogSearchsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogSearchs>
          }
          groupBy: {
            args: Prisma.LogSearchsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogSearchsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogSearchsCountArgs<ExtArgs>
            result: $Utils.Optional<LogSearchsCountAggregateOutputType> | number
          }
        }
      }
      LogSignUp: {
        payload: Prisma.$LogSignUpPayload<ExtArgs>
        fields: Prisma.LogSignUpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogSignUpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSignUpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogSignUpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSignUpPayload>
          }
          findFirst: {
            args: Prisma.LogSignUpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSignUpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogSignUpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSignUpPayload>
          }
          findMany: {
            args: Prisma.LogSignUpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSignUpPayload>[]
          }
          create: {
            args: Prisma.LogSignUpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSignUpPayload>
          }
          createMany: {
            args: Prisma.LogSignUpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LogSignUpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSignUpPayload>
          }
          update: {
            args: Prisma.LogSignUpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSignUpPayload>
          }
          deleteMany: {
            args: Prisma.LogSignUpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogSignUpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogSignUpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSignUpPayload>
          }
          aggregate: {
            args: Prisma.LogSignUpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogSignUp>
          }
          groupBy: {
            args: Prisma.LogSignUpGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogSignUpGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogSignUpCountArgs<ExtArgs>
            result: $Utils.Optional<LogSignUpCountAggregateOutputType> | number
          }
        }
      }
      MessagesEmployees: {
        payload: Prisma.$MessagesEmployeesPayload<ExtArgs>
        fields: Prisma.MessagesEmployeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessagesEmployeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesEmployeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessagesEmployeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesEmployeesPayload>
          }
          findFirst: {
            args: Prisma.MessagesEmployeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesEmployeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessagesEmployeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesEmployeesPayload>
          }
          findMany: {
            args: Prisma.MessagesEmployeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesEmployeesPayload>[]
          }
          create: {
            args: Prisma.MessagesEmployeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesEmployeesPayload>
          }
          createMany: {
            args: Prisma.MessagesEmployeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessagesEmployeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesEmployeesPayload>
          }
          update: {
            args: Prisma.MessagesEmployeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesEmployeesPayload>
          }
          deleteMany: {
            args: Prisma.MessagesEmployeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessagesEmployeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessagesEmployeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesEmployeesPayload>
          }
          aggregate: {
            args: Prisma.MessagesEmployeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessagesEmployees>
          }
          groupBy: {
            args: Prisma.MessagesEmployeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessagesEmployeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessagesEmployeesCountArgs<ExtArgs>
            result: $Utils.Optional<MessagesEmployeesCountAggregateOutputType> | number
          }
        }
      }
      MessagesStatus: {
        payload: Prisma.$MessagesStatusPayload<ExtArgs>
        fields: Prisma.MessagesStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessagesStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessagesStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesStatusPayload>
          }
          findFirst: {
            args: Prisma.MessagesStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessagesStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesStatusPayload>
          }
          findMany: {
            args: Prisma.MessagesStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesStatusPayload>[]
          }
          create: {
            args: Prisma.MessagesStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesStatusPayload>
          }
          createMany: {
            args: Prisma.MessagesStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessagesStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesStatusPayload>
          }
          update: {
            args: Prisma.MessagesStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesStatusPayload>
          }
          deleteMany: {
            args: Prisma.MessagesStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessagesStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessagesStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesStatusPayload>
          }
          aggregate: {
            args: Prisma.MessagesStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessagesStatus>
          }
          groupBy: {
            args: Prisma.MessagesStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessagesStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessagesStatusCountArgs<ExtArgs>
            result: $Utils.Optional<MessagesStatusCountAggregateOutputType> | number
          }
        }
      }
      SiteConfig: {
        payload: Prisma.$SiteConfigPayload<ExtArgs>
        fields: Prisma.SiteConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          findFirst: {
            args: Prisma.SiteConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          findMany: {
            args: Prisma.SiteConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>[]
          }
          create: {
            args: Prisma.SiteConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          createMany: {
            args: Prisma.SiteConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SiteConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          update: {
            args: Prisma.SiteConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          deleteMany: {
            args: Prisma.SiteConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SiteConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          aggregate: {
            args: Prisma.SiteConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteConfig>
          }
          groupBy: {
            args: Prisma.SiteConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SiteConfigCountAggregateOutputType> | number
          }
        }
      }
      sysdiagrams: {
        payload: Prisma.$sysdiagramsPayload<ExtArgs>
        fields: Prisma.sysdiagramsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sysdiagramsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sysdiagramsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findFirst: {
            args: Prisma.sysdiagramsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sysdiagramsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findMany: {
            args: Prisma.sysdiagramsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>[]
          }
          create: {
            args: Prisma.sysdiagramsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          createMany: {
            args: Prisma.sysdiagramsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sysdiagramsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          update: {
            args: Prisma.sysdiagramsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          deleteMany: {
            args: Prisma.sysdiagramsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sysdiagramsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sysdiagramsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          aggregate: {
            args: Prisma.SysdiagramsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSysdiagrams>
          }
          groupBy: {
            args: Prisma.sysdiagramsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sysdiagramsCountArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsCountAggregateOutputType> | number
          }
        }
      }
      UsersLinkedViewRole: {
        payload: Prisma.$UsersLinkedViewRolePayload<ExtArgs>
        fields: Prisma.UsersLinkedViewRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersLinkedViewRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLinkedViewRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersLinkedViewRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLinkedViewRolePayload>
          }
          findFirst: {
            args: Prisma.UsersLinkedViewRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLinkedViewRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersLinkedViewRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLinkedViewRolePayload>
          }
          findMany: {
            args: Prisma.UsersLinkedViewRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLinkedViewRolePayload>[]
          }
          create: {
            args: Prisma.UsersLinkedViewRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLinkedViewRolePayload>
          }
          createMany: {
            args: Prisma.UsersLinkedViewRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersLinkedViewRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLinkedViewRolePayload>
          }
          update: {
            args: Prisma.UsersLinkedViewRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLinkedViewRolePayload>
          }
          deleteMany: {
            args: Prisma.UsersLinkedViewRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersLinkedViewRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersLinkedViewRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLinkedViewRolePayload>
          }
          aggregate: {
            args: Prisma.UsersLinkedViewRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsersLinkedViewRole>
          }
          groupBy: {
            args: Prisma.UsersLinkedViewRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersLinkedViewRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersLinkedViewRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UsersLinkedViewRoleCountAggregateOutputType> | number
          }
        }
      }
      UserViewRoles: {
        payload: Prisma.$UserViewRolesPayload<ExtArgs>
        fields: Prisma.UserViewRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserViewRolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserViewRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserViewRolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserViewRolesPayload>
          }
          findFirst: {
            args: Prisma.UserViewRolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserViewRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserViewRolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserViewRolesPayload>
          }
          findMany: {
            args: Prisma.UserViewRolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserViewRolesPayload>[]
          }
          create: {
            args: Prisma.UserViewRolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserViewRolesPayload>
          }
          createMany: {
            args: Prisma.UserViewRolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserViewRolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserViewRolesPayload>
          }
          update: {
            args: Prisma.UserViewRolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserViewRolesPayload>
          }
          deleteMany: {
            args: Prisma.UserViewRolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserViewRolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserViewRolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserViewRolesPayload>
          }
          aggregate: {
            args: Prisma.UserViewRolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserViewRoles>
          }
          groupBy: {
            args: Prisma.UserViewRolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserViewRolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserViewRolesCountArgs<ExtArgs>
            result: $Utils.Optional<UserViewRolesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EmployeeHoursByLocalityCountOutputType
   */

  export type EmployeeHoursByLocalityCountOutputType = {
    EmployeeHours: number
  }

  export type EmployeeHoursByLocalityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeHours?: boolean | EmployeeHoursByLocalityCountOutputTypeCountEmployeeHoursArgs
  }

  // Custom InputTypes
  /**
   * EmployeeHoursByLocalityCountOutputType without action
   */
  export type EmployeeHoursByLocalityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityCountOutputType
     */
    select?: EmployeeHoursByLocalityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeHoursByLocalityCountOutputType without action
   */
  export type EmployeeHoursByLocalityCountOutputTypeCountEmployeeHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursWhereInput
  }


  /**
   * Count Type EmployeeHoursByLocalityTotalsCountOutputType
   */

  export type EmployeeHoursByLocalityTotalsCountOutputType = {
    EmployeeHoursByLocalityTotalsActionType: number
  }

  export type EmployeeHoursByLocalityTotalsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeHoursByLocalityTotalsActionType?: boolean | EmployeeHoursByLocalityTotalsCountOutputTypeCountEmployeeHoursByLocalityTotalsActionTypeArgs
  }

  // Custom InputTypes
  /**
   * EmployeeHoursByLocalityTotalsCountOutputType without action
   */
  export type EmployeeHoursByLocalityTotalsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsCountOutputType
     */
    select?: EmployeeHoursByLocalityTotalsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeHoursByLocalityTotalsCountOutputType without action
   */
  export type EmployeeHoursByLocalityTotalsCountOutputTypeCountEmployeeHoursByLocalityTotalsActionTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
  }


  /**
   * Count Type EmployeeHoursContractsCountOutputType
   */

  export type EmployeeHoursContractsCountOutputType = {
    EmployeeHoursByLocality: number
  }

  export type EmployeeHoursContractsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeHoursByLocality?: boolean | EmployeeHoursContractsCountOutputTypeCountEmployeeHoursByLocalityArgs
  }

  // Custom InputTypes
  /**
   * EmployeeHoursContractsCountOutputType without action
   */
  export type EmployeeHoursContractsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursContractsCountOutputType
     */
    select?: EmployeeHoursContractsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeHoursContractsCountOutputType without action
   */
  export type EmployeeHoursContractsCountOutputTypeCountEmployeeHoursByLocalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursByLocalityWhereInput
  }


  /**
   * Count Type EmployeeHoursLocalitiesCountOutputType
   */

  export type EmployeeHoursLocalitiesCountOutputType = {
    EmployeeHoursByLocality: number
    EmployeeHoursByLocalityTotals: number
  }

  export type EmployeeHoursLocalitiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeHoursByLocality?: boolean | EmployeeHoursLocalitiesCountOutputTypeCountEmployeeHoursByLocalityArgs
    EmployeeHoursByLocalityTotals?: boolean | EmployeeHoursLocalitiesCountOutputTypeCountEmployeeHoursByLocalityTotalsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeHoursLocalitiesCountOutputType without action
   */
  export type EmployeeHoursLocalitiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursLocalitiesCountOutputType
     */
    select?: EmployeeHoursLocalitiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeHoursLocalitiesCountOutputType without action
   */
  export type EmployeeHoursLocalitiesCountOutputTypeCountEmployeeHoursByLocalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursByLocalityWhereInput
  }

  /**
   * EmployeeHoursLocalitiesCountOutputType without action
   */
  export type EmployeeHoursLocalitiesCountOutputTypeCountEmployeeHoursByLocalityTotalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursByLocalityTotalsWhereInput
  }


  /**
   * Count Type EmployeeHoursUsersCountOutputType
   */

  export type EmployeeHoursUsersCountOutputType = {
    EmployeeHoursByLocality: number
  }

  export type EmployeeHoursUsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeHoursByLocality?: boolean | EmployeeHoursUsersCountOutputTypeCountEmployeeHoursByLocalityArgs
  }

  // Custom InputTypes
  /**
   * EmployeeHoursUsersCountOutputType without action
   */
  export type EmployeeHoursUsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursUsersCountOutputType
     */
    select?: EmployeeHoursUsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeHoursUsersCountOutputType without action
   */
  export type EmployeeHoursUsersCountOutputTypeCountEmployeeHoursByLocalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursByLocalityWhereInput
  }


  /**
   * Count Type Lkup_ActionTypeCountOutputType
   */

  export type Lkup_ActionTypeCountOutputType = {
    EmployeeHours: number
    EmployeeHoursByLocalityTotalsActionType: number
  }

  export type Lkup_ActionTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeHours?: boolean | Lkup_ActionTypeCountOutputTypeCountEmployeeHoursArgs
    EmployeeHoursByLocalityTotalsActionType?: boolean | Lkup_ActionTypeCountOutputTypeCountEmployeeHoursByLocalityTotalsActionTypeArgs
  }

  // Custom InputTypes
  /**
   * Lkup_ActionTypeCountOutputType without action
   */
  export type Lkup_ActionTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_ActionTypeCountOutputType
     */
    select?: Lkup_ActionTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Lkup_ActionTypeCountOutputType without action
   */
  export type Lkup_ActionTypeCountOutputTypeCountEmployeeHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursWhereInput
  }

  /**
   * Lkup_ActionTypeCountOutputType without action
   */
  export type Lkup_ActionTypeCountOutputTypeCountEmployeeHoursByLocalityTotalsActionTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
  }


  /**
   * Count Type MessagesEmployeesCountOutputType
   */

  export type MessagesEmployeesCountOutputType = {
    other_MessagesEmployees: number
  }

  export type MessagesEmployeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_MessagesEmployees?: boolean | MessagesEmployeesCountOutputTypeCountOther_MessagesEmployeesArgs
  }

  // Custom InputTypes
  /**
   * MessagesEmployeesCountOutputType without action
   */
  export type MessagesEmployeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployeesCountOutputType
     */
    select?: MessagesEmployeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessagesEmployeesCountOutputType without action
   */
  export type MessagesEmployeesCountOutputTypeCountOther_MessagesEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesEmployeesWhereInput
  }


  /**
   * Count Type MessagesStatusCountOutputType
   */

  export type MessagesStatusCountOutputType = {
    MessagesEmployees: number
  }

  export type MessagesStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessagesEmployees?: boolean | MessagesStatusCountOutputTypeCountMessagesEmployeesArgs
  }

  // Custom InputTypes
  /**
   * MessagesStatusCountOutputType without action
   */
  export type MessagesStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesStatusCountOutputType
     */
    select?: MessagesStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessagesStatusCountOutputType without action
   */
  export type MessagesStatusCountOutputTypeCountMessagesEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesEmployeesWhereInput
  }


  /**
   * Count Type UserViewRolesCountOutputType
   */

  export type UserViewRolesCountOutputType = {
    UsersLinkedViewRole: number
  }

  export type UserViewRolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UsersLinkedViewRole?: boolean | UserViewRolesCountOutputTypeCountUsersLinkedViewRoleArgs
  }

  // Custom InputTypes
  /**
   * UserViewRolesCountOutputType without action
   */
  export type UserViewRolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserViewRolesCountOutputType
     */
    select?: UserViewRolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserViewRolesCountOutputType without action
   */
  export type UserViewRolesCountOutputTypeCountUsersLinkedViewRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersLinkedViewRoleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model CompaniesConfig
   */

  export type AggregateCompaniesConfig = {
    _count: CompaniesConfigCountAggregateOutputType | null
    _avg: CompaniesConfigAvgAggregateOutputType | null
    _sum: CompaniesConfigSumAggregateOutputType | null
    _min: CompaniesConfigMinAggregateOutputType | null
    _max: CompaniesConfigMaxAggregateOutputType | null
  }

  export type CompaniesConfigAvgAggregateOutputType = {
    CompanyConfigId: number | null
    PropertyValue: number | null
  }

  export type CompaniesConfigSumAggregateOutputType = {
    CompanyConfigId: number | null
    PropertyValue: number | null
  }

  export type CompaniesConfigMinAggregateOutputType = {
    CompanyConfigId: number | null
    CompanyIdGeneralCRM: string | null
    CreatedAt: Date | null
    PropertyEngName: string | null
    PropertyValue: number | null
    PropertyTextJsonValue: string | null
    PropertyHebDescription: string | null
  }

  export type CompaniesConfigMaxAggregateOutputType = {
    CompanyConfigId: number | null
    CompanyIdGeneralCRM: string | null
    CreatedAt: Date | null
    PropertyEngName: string | null
    PropertyValue: number | null
    PropertyTextJsonValue: string | null
    PropertyHebDescription: string | null
  }

  export type CompaniesConfigCountAggregateOutputType = {
    CompanyConfigId: number
    CompanyIdGeneralCRM: number
    CreatedAt: number
    PropertyEngName: number
    PropertyValue: number
    PropertyTextJsonValue: number
    PropertyHebDescription: number
    _all: number
  }


  export type CompaniesConfigAvgAggregateInputType = {
    CompanyConfigId?: true
    PropertyValue?: true
  }

  export type CompaniesConfigSumAggregateInputType = {
    CompanyConfigId?: true
    PropertyValue?: true
  }

  export type CompaniesConfigMinAggregateInputType = {
    CompanyConfigId?: true
    CompanyIdGeneralCRM?: true
    CreatedAt?: true
    PropertyEngName?: true
    PropertyValue?: true
    PropertyTextJsonValue?: true
    PropertyHebDescription?: true
  }

  export type CompaniesConfigMaxAggregateInputType = {
    CompanyConfigId?: true
    CompanyIdGeneralCRM?: true
    CreatedAt?: true
    PropertyEngName?: true
    PropertyValue?: true
    PropertyTextJsonValue?: true
    PropertyHebDescription?: true
  }

  export type CompaniesConfigCountAggregateInputType = {
    CompanyConfigId?: true
    CompanyIdGeneralCRM?: true
    CreatedAt?: true
    PropertyEngName?: true
    PropertyValue?: true
    PropertyTextJsonValue?: true
    PropertyHebDescription?: true
    _all?: true
  }

  export type CompaniesConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesConfig to aggregate.
     */
    where?: CompaniesConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesConfigs to fetch.
     */
    orderBy?: CompaniesConfigOrderByWithRelationInput | CompaniesConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompaniesConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompaniesConfigs
    **/
    _count?: true | CompaniesConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniesConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniesConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesConfigMaxAggregateInputType
  }

  export type GetCompaniesConfigAggregateType<T extends CompaniesConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateCompaniesConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompaniesConfig[P]>
      : GetScalarType<T[P], AggregateCompaniesConfig[P]>
  }




  export type CompaniesConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesConfigWhereInput
    orderBy?: CompaniesConfigOrderByWithAggregationInput | CompaniesConfigOrderByWithAggregationInput[]
    by: CompaniesConfigScalarFieldEnum[] | CompaniesConfigScalarFieldEnum
    having?: CompaniesConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesConfigCountAggregateInputType | true
    _avg?: CompaniesConfigAvgAggregateInputType
    _sum?: CompaniesConfigSumAggregateInputType
    _min?: CompaniesConfigMinAggregateInputType
    _max?: CompaniesConfigMaxAggregateInputType
  }

  export type CompaniesConfigGroupByOutputType = {
    CompanyConfigId: number
    CompanyIdGeneralCRM: string
    CreatedAt: Date | null
    PropertyEngName: string
    PropertyValue: number | null
    PropertyTextJsonValue: string | null
    PropertyHebDescription: string
    _count: CompaniesConfigCountAggregateOutputType | null
    _avg: CompaniesConfigAvgAggregateOutputType | null
    _sum: CompaniesConfigSumAggregateOutputType | null
    _min: CompaniesConfigMinAggregateOutputType | null
    _max: CompaniesConfigMaxAggregateOutputType | null
  }

  type GetCompaniesConfigGroupByPayload<T extends CompaniesConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesConfigGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesConfigGroupByOutputType[P]>
        }
      >
    >


  export type CompaniesConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CompanyConfigId?: boolean
    CompanyIdGeneralCRM?: boolean
    CreatedAt?: boolean
    PropertyEngName?: boolean
    PropertyValue?: boolean
    PropertyTextJsonValue?: boolean
    PropertyHebDescription?: boolean
  }, ExtArgs["result"]["companiesConfig"]>


  export type CompaniesConfigSelectScalar = {
    CompanyConfigId?: boolean
    CompanyIdGeneralCRM?: boolean
    CreatedAt?: boolean
    PropertyEngName?: boolean
    PropertyValue?: boolean
    PropertyTextJsonValue?: boolean
    PropertyHebDescription?: boolean
  }


  export type $CompaniesConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompaniesConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CompanyConfigId: number
      CompanyIdGeneralCRM: string
      CreatedAt: Date | null
      PropertyEngName: string
      PropertyValue: number | null
      PropertyTextJsonValue: string | null
      PropertyHebDescription: string
    }, ExtArgs["result"]["companiesConfig"]>
    composites: {}
  }

  type CompaniesConfigGetPayload<S extends boolean | null | undefined | CompaniesConfigDefaultArgs> = $Result.GetResult<Prisma.$CompaniesConfigPayload, S>

  type CompaniesConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompaniesConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompaniesConfigCountAggregateInputType | true
    }

  export interface CompaniesConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompaniesConfig'], meta: { name: 'CompaniesConfig' } }
    /**
     * Find zero or one CompaniesConfig that matches the filter.
     * @param {CompaniesConfigFindUniqueArgs} args - Arguments to find a CompaniesConfig
     * @example
     * // Get one CompaniesConfig
     * const companiesConfig = await prisma.companiesConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompaniesConfigFindUniqueArgs>(args: SelectSubset<T, CompaniesConfigFindUniqueArgs<ExtArgs>>): Prisma__CompaniesConfigClient<$Result.GetResult<Prisma.$CompaniesConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompaniesConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompaniesConfigFindUniqueOrThrowArgs} args - Arguments to find a CompaniesConfig
     * @example
     * // Get one CompaniesConfig
     * const companiesConfig = await prisma.companiesConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompaniesConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, CompaniesConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompaniesConfigClient<$Result.GetResult<Prisma.$CompaniesConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompaniesConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesConfigFindFirstArgs} args - Arguments to find a CompaniesConfig
     * @example
     * // Get one CompaniesConfig
     * const companiesConfig = await prisma.companiesConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompaniesConfigFindFirstArgs>(args?: SelectSubset<T, CompaniesConfigFindFirstArgs<ExtArgs>>): Prisma__CompaniesConfigClient<$Result.GetResult<Prisma.$CompaniesConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompaniesConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesConfigFindFirstOrThrowArgs} args - Arguments to find a CompaniesConfig
     * @example
     * // Get one CompaniesConfig
     * const companiesConfig = await prisma.companiesConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompaniesConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, CompaniesConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompaniesConfigClient<$Result.GetResult<Prisma.$CompaniesConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompaniesConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompaniesConfigs
     * const companiesConfigs = await prisma.companiesConfig.findMany()
     * 
     * // Get first 10 CompaniesConfigs
     * const companiesConfigs = await prisma.companiesConfig.findMany({ take: 10 })
     * 
     * // Only select the `CompanyConfigId`
     * const companiesConfigWithCompanyConfigIdOnly = await prisma.companiesConfig.findMany({ select: { CompanyConfigId: true } })
     * 
     */
    findMany<T extends CompaniesConfigFindManyArgs>(args?: SelectSubset<T, CompaniesConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompaniesConfig.
     * @param {CompaniesConfigCreateArgs} args - Arguments to create a CompaniesConfig.
     * @example
     * // Create one CompaniesConfig
     * const CompaniesConfig = await prisma.companiesConfig.create({
     *   data: {
     *     // ... data to create a CompaniesConfig
     *   }
     * })
     * 
     */
    create<T extends CompaniesConfigCreateArgs>(args: SelectSubset<T, CompaniesConfigCreateArgs<ExtArgs>>): Prisma__CompaniesConfigClient<$Result.GetResult<Prisma.$CompaniesConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompaniesConfigs.
     * @param {CompaniesConfigCreateManyArgs} args - Arguments to create many CompaniesConfigs.
     * @example
     * // Create many CompaniesConfigs
     * const companiesConfig = await prisma.companiesConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompaniesConfigCreateManyArgs>(args?: SelectSubset<T, CompaniesConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompaniesConfig.
     * @param {CompaniesConfigDeleteArgs} args - Arguments to delete one CompaniesConfig.
     * @example
     * // Delete one CompaniesConfig
     * const CompaniesConfig = await prisma.companiesConfig.delete({
     *   where: {
     *     // ... filter to delete one CompaniesConfig
     *   }
     * })
     * 
     */
    delete<T extends CompaniesConfigDeleteArgs>(args: SelectSubset<T, CompaniesConfigDeleteArgs<ExtArgs>>): Prisma__CompaniesConfigClient<$Result.GetResult<Prisma.$CompaniesConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompaniesConfig.
     * @param {CompaniesConfigUpdateArgs} args - Arguments to update one CompaniesConfig.
     * @example
     * // Update one CompaniesConfig
     * const companiesConfig = await prisma.companiesConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompaniesConfigUpdateArgs>(args: SelectSubset<T, CompaniesConfigUpdateArgs<ExtArgs>>): Prisma__CompaniesConfigClient<$Result.GetResult<Prisma.$CompaniesConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompaniesConfigs.
     * @param {CompaniesConfigDeleteManyArgs} args - Arguments to filter CompaniesConfigs to delete.
     * @example
     * // Delete a few CompaniesConfigs
     * const { count } = await prisma.companiesConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompaniesConfigDeleteManyArgs>(args?: SelectSubset<T, CompaniesConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompaniesConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompaniesConfigs
     * const companiesConfig = await prisma.companiesConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompaniesConfigUpdateManyArgs>(args: SelectSubset<T, CompaniesConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompaniesConfig.
     * @param {CompaniesConfigUpsertArgs} args - Arguments to update or create a CompaniesConfig.
     * @example
     * // Update or create a CompaniesConfig
     * const companiesConfig = await prisma.companiesConfig.upsert({
     *   create: {
     *     // ... data to create a CompaniesConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompaniesConfig we want to update
     *   }
     * })
     */
    upsert<T extends CompaniesConfigUpsertArgs>(args: SelectSubset<T, CompaniesConfigUpsertArgs<ExtArgs>>): Prisma__CompaniesConfigClient<$Result.GetResult<Prisma.$CompaniesConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompaniesConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesConfigCountArgs} args - Arguments to filter CompaniesConfigs to count.
     * @example
     * // Count the number of CompaniesConfigs
     * const count = await prisma.companiesConfig.count({
     *   where: {
     *     // ... the filter for the CompaniesConfigs we want to count
     *   }
     * })
    **/
    count<T extends CompaniesConfigCountArgs>(
      args?: Subset<T, CompaniesConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompaniesConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesConfigAggregateArgs>(args: Subset<T, CompaniesConfigAggregateArgs>): Prisma.PrismaPromise<GetCompaniesConfigAggregateType<T>>

    /**
     * Group by CompaniesConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompaniesConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompaniesConfigGroupByArgs['orderBy'] }
        : { orderBy?: CompaniesConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompaniesConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompaniesConfig model
   */
  readonly fields: CompaniesConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompaniesConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompaniesConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompaniesConfig model
   */ 
  interface CompaniesConfigFieldRefs {
    readonly CompanyConfigId: FieldRef<"CompaniesConfig", 'Int'>
    readonly CompanyIdGeneralCRM: FieldRef<"CompaniesConfig", 'String'>
    readonly CreatedAt: FieldRef<"CompaniesConfig", 'DateTime'>
    readonly PropertyEngName: FieldRef<"CompaniesConfig", 'String'>
    readonly PropertyValue: FieldRef<"CompaniesConfig", 'Float'>
    readonly PropertyTextJsonValue: FieldRef<"CompaniesConfig", 'String'>
    readonly PropertyHebDescription: FieldRef<"CompaniesConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompaniesConfig findUnique
   */
  export type CompaniesConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesConfig
     */
    select?: CompaniesConfigSelect<ExtArgs> | null
    /**
     * Filter, which CompaniesConfig to fetch.
     */
    where: CompaniesConfigWhereUniqueInput
  }

  /**
   * CompaniesConfig findUniqueOrThrow
   */
  export type CompaniesConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesConfig
     */
    select?: CompaniesConfigSelect<ExtArgs> | null
    /**
     * Filter, which CompaniesConfig to fetch.
     */
    where: CompaniesConfigWhereUniqueInput
  }

  /**
   * CompaniesConfig findFirst
   */
  export type CompaniesConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesConfig
     */
    select?: CompaniesConfigSelect<ExtArgs> | null
    /**
     * Filter, which CompaniesConfig to fetch.
     */
    where?: CompaniesConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesConfigs to fetch.
     */
    orderBy?: CompaniesConfigOrderByWithRelationInput | CompaniesConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesConfigs.
     */
    cursor?: CompaniesConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesConfigs.
     */
    distinct?: CompaniesConfigScalarFieldEnum | CompaniesConfigScalarFieldEnum[]
  }

  /**
   * CompaniesConfig findFirstOrThrow
   */
  export type CompaniesConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesConfig
     */
    select?: CompaniesConfigSelect<ExtArgs> | null
    /**
     * Filter, which CompaniesConfig to fetch.
     */
    where?: CompaniesConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesConfigs to fetch.
     */
    orderBy?: CompaniesConfigOrderByWithRelationInput | CompaniesConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesConfigs.
     */
    cursor?: CompaniesConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesConfigs.
     */
    distinct?: CompaniesConfigScalarFieldEnum | CompaniesConfigScalarFieldEnum[]
  }

  /**
   * CompaniesConfig findMany
   */
  export type CompaniesConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesConfig
     */
    select?: CompaniesConfigSelect<ExtArgs> | null
    /**
     * Filter, which CompaniesConfigs to fetch.
     */
    where?: CompaniesConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesConfigs to fetch.
     */
    orderBy?: CompaniesConfigOrderByWithRelationInput | CompaniesConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompaniesConfigs.
     */
    cursor?: CompaniesConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesConfigs.
     */
    skip?: number
    distinct?: CompaniesConfigScalarFieldEnum | CompaniesConfigScalarFieldEnum[]
  }

  /**
   * CompaniesConfig create
   */
  export type CompaniesConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesConfig
     */
    select?: CompaniesConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a CompaniesConfig.
     */
    data: XOR<CompaniesConfigCreateInput, CompaniesConfigUncheckedCreateInput>
  }

  /**
   * CompaniesConfig createMany
   */
  export type CompaniesConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompaniesConfigs.
     */
    data: CompaniesConfigCreateManyInput | CompaniesConfigCreateManyInput[]
  }

  /**
   * CompaniesConfig update
   */
  export type CompaniesConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesConfig
     */
    select?: CompaniesConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a CompaniesConfig.
     */
    data: XOR<CompaniesConfigUpdateInput, CompaniesConfigUncheckedUpdateInput>
    /**
     * Choose, which CompaniesConfig to update.
     */
    where: CompaniesConfigWhereUniqueInput
  }

  /**
   * CompaniesConfig updateMany
   */
  export type CompaniesConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompaniesConfigs.
     */
    data: XOR<CompaniesConfigUpdateManyMutationInput, CompaniesConfigUncheckedUpdateManyInput>
    /**
     * Filter which CompaniesConfigs to update
     */
    where?: CompaniesConfigWhereInput
  }

  /**
   * CompaniesConfig upsert
   */
  export type CompaniesConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesConfig
     */
    select?: CompaniesConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the CompaniesConfig to update in case it exists.
     */
    where: CompaniesConfigWhereUniqueInput
    /**
     * In case the CompaniesConfig found by the `where` argument doesn't exist, create a new CompaniesConfig with this data.
     */
    create: XOR<CompaniesConfigCreateInput, CompaniesConfigUncheckedCreateInput>
    /**
     * In case the CompaniesConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompaniesConfigUpdateInput, CompaniesConfigUncheckedUpdateInput>
  }

  /**
   * CompaniesConfig delete
   */
  export type CompaniesConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesConfig
     */
    select?: CompaniesConfigSelect<ExtArgs> | null
    /**
     * Filter which CompaniesConfig to delete.
     */
    where: CompaniesConfigWhereUniqueInput
  }

  /**
   * CompaniesConfig deleteMany
   */
  export type CompaniesConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesConfigs to delete
     */
    where?: CompaniesConfigWhereInput
  }

  /**
   * CompaniesConfig without action
   */
  export type CompaniesConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesConfig
     */
    select?: CompaniesConfigSelect<ExtArgs> | null
  }


  /**
   * Model CompanyAdmin
   */

  export type AggregateCompanyAdmin = {
    _count: CompanyAdminCountAggregateOutputType | null
    _avg: CompanyAdminAvgAggregateOutputType | null
    _sum: CompanyAdminSumAggregateOutputType | null
    _min: CompanyAdminMinAggregateOutputType | null
    _max: CompanyAdminMaxAggregateOutputType | null
  }

  export type CompanyAdminAvgAggregateOutputType = {
    MaxSearchResults: number | null
  }

  export type CompanyAdminSumAggregateOutputType = {
    MaxSearchResults: number | null
  }

  export type CompanyAdminMinAggregateOutputType = {
    CompanyAdminId: string | null
    CompanyID: string | null
    CreatedAt: Date | null
    NotShowFields: string | null
    MaxSearchResults: number | null
    EditFields: string | null
  }

  export type CompanyAdminMaxAggregateOutputType = {
    CompanyAdminId: string | null
    CompanyID: string | null
    CreatedAt: Date | null
    NotShowFields: string | null
    MaxSearchResults: number | null
    EditFields: string | null
  }

  export type CompanyAdminCountAggregateOutputType = {
    CompanyAdminId: number
    CompanyID: number
    CreatedAt: number
    NotShowFields: number
    MaxSearchResults: number
    EditFields: number
    _all: number
  }


  export type CompanyAdminAvgAggregateInputType = {
    MaxSearchResults?: true
  }

  export type CompanyAdminSumAggregateInputType = {
    MaxSearchResults?: true
  }

  export type CompanyAdminMinAggregateInputType = {
    CompanyAdminId?: true
    CompanyID?: true
    CreatedAt?: true
    NotShowFields?: true
    MaxSearchResults?: true
    EditFields?: true
  }

  export type CompanyAdminMaxAggregateInputType = {
    CompanyAdminId?: true
    CompanyID?: true
    CreatedAt?: true
    NotShowFields?: true
    MaxSearchResults?: true
    EditFields?: true
  }

  export type CompanyAdminCountAggregateInputType = {
    CompanyAdminId?: true
    CompanyID?: true
    CreatedAt?: true
    NotShowFields?: true
    MaxSearchResults?: true
    EditFields?: true
    _all?: true
  }

  export type CompanyAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyAdmin to aggregate.
     */
    where?: CompanyAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyAdmins to fetch.
     */
    orderBy?: CompanyAdminOrderByWithRelationInput | CompanyAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyAdmins
    **/
    _count?: true | CompanyAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyAdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyAdminMaxAggregateInputType
  }

  export type GetCompanyAdminAggregateType<T extends CompanyAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyAdmin[P]>
      : GetScalarType<T[P], AggregateCompanyAdmin[P]>
  }




  export type CompanyAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyAdminWhereInput
    orderBy?: CompanyAdminOrderByWithAggregationInput | CompanyAdminOrderByWithAggregationInput[]
    by: CompanyAdminScalarFieldEnum[] | CompanyAdminScalarFieldEnum
    having?: CompanyAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyAdminCountAggregateInputType | true
    _avg?: CompanyAdminAvgAggregateInputType
    _sum?: CompanyAdminSumAggregateInputType
    _min?: CompanyAdminMinAggregateInputType
    _max?: CompanyAdminMaxAggregateInputType
  }

  export type CompanyAdminGroupByOutputType = {
    CompanyAdminId: string
    CompanyID: string
    CreatedAt: Date | null
    NotShowFields: string | null
    MaxSearchResults: number | null
    EditFields: string | null
    _count: CompanyAdminCountAggregateOutputType | null
    _avg: CompanyAdminAvgAggregateOutputType | null
    _sum: CompanyAdminSumAggregateOutputType | null
    _min: CompanyAdminMinAggregateOutputType | null
    _max: CompanyAdminMaxAggregateOutputType | null
  }

  type GetCompanyAdminGroupByPayload<T extends CompanyAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyAdminGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyAdminGroupByOutputType[P]>
        }
      >
    >


  export type CompanyAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CompanyAdminId?: boolean
    CompanyID?: boolean
    CreatedAt?: boolean
    NotShowFields?: boolean
    MaxSearchResults?: boolean
    EditFields?: boolean
  }, ExtArgs["result"]["companyAdmin"]>


  export type CompanyAdminSelectScalar = {
    CompanyAdminId?: boolean
    CompanyID?: boolean
    CreatedAt?: boolean
    NotShowFields?: boolean
    MaxSearchResults?: boolean
    EditFields?: boolean
  }


  export type $CompanyAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyAdmin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CompanyAdminId: string
      CompanyID: string
      CreatedAt: Date | null
      NotShowFields: string | null
      MaxSearchResults: number | null
      EditFields: string | null
    }, ExtArgs["result"]["companyAdmin"]>
    composites: {}
  }

  type CompanyAdminGetPayload<S extends boolean | null | undefined | CompanyAdminDefaultArgs> = $Result.GetResult<Prisma.$CompanyAdminPayload, S>

  type CompanyAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyAdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyAdminCountAggregateInputType | true
    }

  export interface CompanyAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyAdmin'], meta: { name: 'CompanyAdmin' } }
    /**
     * Find zero or one CompanyAdmin that matches the filter.
     * @param {CompanyAdminFindUniqueArgs} args - Arguments to find a CompanyAdmin
     * @example
     * // Get one CompanyAdmin
     * const companyAdmin = await prisma.companyAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyAdminFindUniqueArgs>(args: SelectSubset<T, CompanyAdminFindUniqueArgs<ExtArgs>>): Prisma__CompanyAdminClient<$Result.GetResult<Prisma.$CompanyAdminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyAdmin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyAdminFindUniqueOrThrowArgs} args - Arguments to find a CompanyAdmin
     * @example
     * // Get one CompanyAdmin
     * const companyAdmin = await prisma.companyAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyAdminClient<$Result.GetResult<Prisma.$CompanyAdminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAdminFindFirstArgs} args - Arguments to find a CompanyAdmin
     * @example
     * // Get one CompanyAdmin
     * const companyAdmin = await prisma.companyAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyAdminFindFirstArgs>(args?: SelectSubset<T, CompanyAdminFindFirstArgs<ExtArgs>>): Prisma__CompanyAdminClient<$Result.GetResult<Prisma.$CompanyAdminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAdminFindFirstOrThrowArgs} args - Arguments to find a CompanyAdmin
     * @example
     * // Get one CompanyAdmin
     * const companyAdmin = await prisma.companyAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyAdminClient<$Result.GetResult<Prisma.$CompanyAdminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyAdmins
     * const companyAdmins = await prisma.companyAdmin.findMany()
     * 
     * // Get first 10 CompanyAdmins
     * const companyAdmins = await prisma.companyAdmin.findMany({ take: 10 })
     * 
     * // Only select the `CompanyAdminId`
     * const companyAdminWithCompanyAdminIdOnly = await prisma.companyAdmin.findMany({ select: { CompanyAdminId: true } })
     * 
     */
    findMany<T extends CompanyAdminFindManyArgs>(args?: SelectSubset<T, CompanyAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyAdminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyAdmin.
     * @param {CompanyAdminCreateArgs} args - Arguments to create a CompanyAdmin.
     * @example
     * // Create one CompanyAdmin
     * const CompanyAdmin = await prisma.companyAdmin.create({
     *   data: {
     *     // ... data to create a CompanyAdmin
     *   }
     * })
     * 
     */
    create<T extends CompanyAdminCreateArgs>(args: SelectSubset<T, CompanyAdminCreateArgs<ExtArgs>>): Prisma__CompanyAdminClient<$Result.GetResult<Prisma.$CompanyAdminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyAdmins.
     * @param {CompanyAdminCreateManyArgs} args - Arguments to create many CompanyAdmins.
     * @example
     * // Create many CompanyAdmins
     * const companyAdmin = await prisma.companyAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyAdminCreateManyArgs>(args?: SelectSubset<T, CompanyAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyAdmin.
     * @param {CompanyAdminDeleteArgs} args - Arguments to delete one CompanyAdmin.
     * @example
     * // Delete one CompanyAdmin
     * const CompanyAdmin = await prisma.companyAdmin.delete({
     *   where: {
     *     // ... filter to delete one CompanyAdmin
     *   }
     * })
     * 
     */
    delete<T extends CompanyAdminDeleteArgs>(args: SelectSubset<T, CompanyAdminDeleteArgs<ExtArgs>>): Prisma__CompanyAdminClient<$Result.GetResult<Prisma.$CompanyAdminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyAdmin.
     * @param {CompanyAdminUpdateArgs} args - Arguments to update one CompanyAdmin.
     * @example
     * // Update one CompanyAdmin
     * const companyAdmin = await prisma.companyAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyAdminUpdateArgs>(args: SelectSubset<T, CompanyAdminUpdateArgs<ExtArgs>>): Prisma__CompanyAdminClient<$Result.GetResult<Prisma.$CompanyAdminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyAdmins.
     * @param {CompanyAdminDeleteManyArgs} args - Arguments to filter CompanyAdmins to delete.
     * @example
     * // Delete a few CompanyAdmins
     * const { count } = await prisma.companyAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyAdminDeleteManyArgs>(args?: SelectSubset<T, CompanyAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyAdmins
     * const companyAdmin = await prisma.companyAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyAdminUpdateManyArgs>(args: SelectSubset<T, CompanyAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyAdmin.
     * @param {CompanyAdminUpsertArgs} args - Arguments to update or create a CompanyAdmin.
     * @example
     * // Update or create a CompanyAdmin
     * const companyAdmin = await prisma.companyAdmin.upsert({
     *   create: {
     *     // ... data to create a CompanyAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyAdmin we want to update
     *   }
     * })
     */
    upsert<T extends CompanyAdminUpsertArgs>(args: SelectSubset<T, CompanyAdminUpsertArgs<ExtArgs>>): Prisma__CompanyAdminClient<$Result.GetResult<Prisma.$CompanyAdminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAdminCountArgs} args - Arguments to filter CompanyAdmins to count.
     * @example
     * // Count the number of CompanyAdmins
     * const count = await prisma.companyAdmin.count({
     *   where: {
     *     // ... the filter for the CompanyAdmins we want to count
     *   }
     * })
    **/
    count<T extends CompanyAdminCountArgs>(
      args?: Subset<T, CompanyAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAdminAggregateArgs>(args: Subset<T, CompanyAdminAggregateArgs>): Prisma.PrismaPromise<GetCompanyAdminAggregateType<T>>

    /**
     * Group by CompanyAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyAdminGroupByArgs['orderBy'] }
        : { orderBy?: CompanyAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyAdmin model
   */
  readonly fields: CompanyAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyAdmin model
   */ 
  interface CompanyAdminFieldRefs {
    readonly CompanyAdminId: FieldRef<"CompanyAdmin", 'String'>
    readonly CompanyID: FieldRef<"CompanyAdmin", 'String'>
    readonly CreatedAt: FieldRef<"CompanyAdmin", 'DateTime'>
    readonly NotShowFields: FieldRef<"CompanyAdmin", 'String'>
    readonly MaxSearchResults: FieldRef<"CompanyAdmin", 'Int'>
    readonly EditFields: FieldRef<"CompanyAdmin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompanyAdmin findUnique
   */
  export type CompanyAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyAdmin
     */
    select?: CompanyAdminSelect<ExtArgs> | null
    /**
     * Filter, which CompanyAdmin to fetch.
     */
    where: CompanyAdminWhereUniqueInput
  }

  /**
   * CompanyAdmin findUniqueOrThrow
   */
  export type CompanyAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyAdmin
     */
    select?: CompanyAdminSelect<ExtArgs> | null
    /**
     * Filter, which CompanyAdmin to fetch.
     */
    where: CompanyAdminWhereUniqueInput
  }

  /**
   * CompanyAdmin findFirst
   */
  export type CompanyAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyAdmin
     */
    select?: CompanyAdminSelect<ExtArgs> | null
    /**
     * Filter, which CompanyAdmin to fetch.
     */
    where?: CompanyAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyAdmins to fetch.
     */
    orderBy?: CompanyAdminOrderByWithRelationInput | CompanyAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyAdmins.
     */
    cursor?: CompanyAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyAdmins.
     */
    distinct?: CompanyAdminScalarFieldEnum | CompanyAdminScalarFieldEnum[]
  }

  /**
   * CompanyAdmin findFirstOrThrow
   */
  export type CompanyAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyAdmin
     */
    select?: CompanyAdminSelect<ExtArgs> | null
    /**
     * Filter, which CompanyAdmin to fetch.
     */
    where?: CompanyAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyAdmins to fetch.
     */
    orderBy?: CompanyAdminOrderByWithRelationInput | CompanyAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyAdmins.
     */
    cursor?: CompanyAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyAdmins.
     */
    distinct?: CompanyAdminScalarFieldEnum | CompanyAdminScalarFieldEnum[]
  }

  /**
   * CompanyAdmin findMany
   */
  export type CompanyAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyAdmin
     */
    select?: CompanyAdminSelect<ExtArgs> | null
    /**
     * Filter, which CompanyAdmins to fetch.
     */
    where?: CompanyAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyAdmins to fetch.
     */
    orderBy?: CompanyAdminOrderByWithRelationInput | CompanyAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyAdmins.
     */
    cursor?: CompanyAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyAdmins.
     */
    skip?: number
    distinct?: CompanyAdminScalarFieldEnum | CompanyAdminScalarFieldEnum[]
  }

  /**
   * CompanyAdmin create
   */
  export type CompanyAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyAdmin
     */
    select?: CompanyAdminSelect<ExtArgs> | null
    /**
     * The data needed to create a CompanyAdmin.
     */
    data: XOR<CompanyAdminCreateInput, CompanyAdminUncheckedCreateInput>
  }

  /**
   * CompanyAdmin createMany
   */
  export type CompanyAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyAdmins.
     */
    data: CompanyAdminCreateManyInput | CompanyAdminCreateManyInput[]
  }

  /**
   * CompanyAdmin update
   */
  export type CompanyAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyAdmin
     */
    select?: CompanyAdminSelect<ExtArgs> | null
    /**
     * The data needed to update a CompanyAdmin.
     */
    data: XOR<CompanyAdminUpdateInput, CompanyAdminUncheckedUpdateInput>
    /**
     * Choose, which CompanyAdmin to update.
     */
    where: CompanyAdminWhereUniqueInput
  }

  /**
   * CompanyAdmin updateMany
   */
  export type CompanyAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyAdmins.
     */
    data: XOR<CompanyAdminUpdateManyMutationInput, CompanyAdminUncheckedUpdateManyInput>
    /**
     * Filter which CompanyAdmins to update
     */
    where?: CompanyAdminWhereInput
  }

  /**
   * CompanyAdmin upsert
   */
  export type CompanyAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyAdmin
     */
    select?: CompanyAdminSelect<ExtArgs> | null
    /**
     * The filter to search for the CompanyAdmin to update in case it exists.
     */
    where: CompanyAdminWhereUniqueInput
    /**
     * In case the CompanyAdmin found by the `where` argument doesn't exist, create a new CompanyAdmin with this data.
     */
    create: XOR<CompanyAdminCreateInput, CompanyAdminUncheckedCreateInput>
    /**
     * In case the CompanyAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyAdminUpdateInput, CompanyAdminUncheckedUpdateInput>
  }

  /**
   * CompanyAdmin delete
   */
  export type CompanyAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyAdmin
     */
    select?: CompanyAdminSelect<ExtArgs> | null
    /**
     * Filter which CompanyAdmin to delete.
     */
    where: CompanyAdminWhereUniqueInput
  }

  /**
   * CompanyAdmin deleteMany
   */
  export type CompanyAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyAdmins to delete
     */
    where?: CompanyAdminWhereInput
  }

  /**
   * CompanyAdmin without action
   */
  export type CompanyAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyAdmin
     */
    select?: CompanyAdminSelect<ExtArgs> | null
  }


  /**
   * Model EmployeeHours
   */

  export type AggregateEmployeeHours = {
    _count: EmployeeHoursCountAggregateOutputType | null
    _avg: EmployeeHoursAvgAggregateOutputType | null
    _sum: EmployeeHoursSumAggregateOutputType | null
    _min: EmployeeHoursMinAggregateOutputType | null
    _max: EmployeeHoursMaxAggregateOutputType | null
  }

  export type EmployeeHoursAvgAggregateOutputType = {
    EmployeeId: number | null
    EmployeeNumber: number | null
    MonthManaged: number | null
    YearManaged: number | null
    RealHours: number | null
    QtyHour: number | null
    QtyHour125: number | null
    QtyHour150: number | null
    QtyHour175: number | null
    QtyHour200: number | null
    BreakMinutes: number | null
    IsManualInsert: number | null
    IsRowDeleted: number | null
    ActionTypeID: number | null
    DayTypeID: number | null
    IsComplementRow: number | null
  }

  export type EmployeeHoursSumAggregateOutputType = {
    EmployeeId: number | null
    EmployeeNumber: number | null
    MonthManaged: number | null
    YearManaged: number | null
    RealHours: number | null
    QtyHour: number | null
    QtyHour125: number | null
    QtyHour150: number | null
    QtyHour175: number | null
    QtyHour200: number | null
    BreakMinutes: number | null
    IsManualInsert: number | null
    IsRowDeleted: number | null
    ActionTypeID: number | null
    DayTypeID: number | null
    IsComplementRow: number | null
  }

  export type EmployeeHoursMinAggregateOutputType = {
    EmployeeHoursId: string | null
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string | null
    EmployeeId: number | null
    EmployeeNumber: number | null
    MonthManaged: number | null
    YearManaged: number | null
    LeadingDate: Date | null
    HourStart: Date | null
    HourEnd: Date | null
    HourStartSource: Date | null
    HourEndSource: Date | null
    RealHours: number | null
    QtyHour: number | null
    QtyHour125: number | null
    QtyHour150: number | null
    QtyHour175: number | null
    QtyHour200: number | null
    BreakMinutes: number | null
    GpsStart: string | null
    GpsEnd: string | null
    EmployeeHoursByLocalityId: string | null
    IsManualInsert: number | null
    ManualInsertUserId: string | null
    IsRowDeleted: number | null
    ActionTypeID: number | null
    DayTypeID: number | null
    HolidayName: string | null
    StartEndTimeSabat: Date | null
    IsForemanHourApproved: Date | null
    IsForemanApproval: Date | null
    ForemanApprovalGeneralCRMUserId: string | null
    IsComplementRow: number | null
  }

  export type EmployeeHoursMaxAggregateOutputType = {
    EmployeeHoursId: string | null
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string | null
    EmployeeId: number | null
    EmployeeNumber: number | null
    MonthManaged: number | null
    YearManaged: number | null
    LeadingDate: Date | null
    HourStart: Date | null
    HourEnd: Date | null
    HourStartSource: Date | null
    HourEndSource: Date | null
    RealHours: number | null
    QtyHour: number | null
    QtyHour125: number | null
    QtyHour150: number | null
    QtyHour175: number | null
    QtyHour200: number | null
    BreakMinutes: number | null
    GpsStart: string | null
    GpsEnd: string | null
    EmployeeHoursByLocalityId: string | null
    IsManualInsert: number | null
    ManualInsertUserId: string | null
    IsRowDeleted: number | null
    ActionTypeID: number | null
    DayTypeID: number | null
    HolidayName: string | null
    StartEndTimeSabat: Date | null
    IsForemanHourApproved: Date | null
    IsForemanApproval: Date | null
    ForemanApprovalGeneralCRMUserId: string | null
    IsComplementRow: number | null
  }

  export type EmployeeHoursCountAggregateOutputType = {
    EmployeeHoursId: number
    CreatedAt: number
    CompanyIdGeneralCRM: number
    EmployeeId: number
    EmployeeNumber: number
    MonthManaged: number
    YearManaged: number
    LeadingDate: number
    HourStart: number
    HourEnd: number
    HourStartSource: number
    HourEndSource: number
    RealHours: number
    QtyHour: number
    QtyHour125: number
    QtyHour150: number
    QtyHour175: number
    QtyHour200: number
    BreakMinutes: number
    GpsStart: number
    GpsEnd: number
    EmployeeHoursByLocalityId: number
    IsManualInsert: number
    ManualInsertUserId: number
    IsRowDeleted: number
    ActionTypeID: number
    DayTypeID: number
    HolidayName: number
    StartEndTimeSabat: number
    IsForemanHourApproved: number
    IsForemanApproval: number
    ForemanApprovalGeneralCRMUserId: number
    IsComplementRow: number
    _all: number
  }


  export type EmployeeHoursAvgAggregateInputType = {
    EmployeeId?: true
    EmployeeNumber?: true
    MonthManaged?: true
    YearManaged?: true
    RealHours?: true
    QtyHour?: true
    QtyHour125?: true
    QtyHour150?: true
    QtyHour175?: true
    QtyHour200?: true
    BreakMinutes?: true
    IsManualInsert?: true
    IsRowDeleted?: true
    ActionTypeID?: true
    DayTypeID?: true
    IsComplementRow?: true
  }

  export type EmployeeHoursSumAggregateInputType = {
    EmployeeId?: true
    EmployeeNumber?: true
    MonthManaged?: true
    YearManaged?: true
    RealHours?: true
    QtyHour?: true
    QtyHour125?: true
    QtyHour150?: true
    QtyHour175?: true
    QtyHour200?: true
    BreakMinutes?: true
    IsManualInsert?: true
    IsRowDeleted?: true
    ActionTypeID?: true
    DayTypeID?: true
    IsComplementRow?: true
  }

  export type EmployeeHoursMinAggregateInputType = {
    EmployeeHoursId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    EmployeeId?: true
    EmployeeNumber?: true
    MonthManaged?: true
    YearManaged?: true
    LeadingDate?: true
    HourStart?: true
    HourEnd?: true
    HourStartSource?: true
    HourEndSource?: true
    RealHours?: true
    QtyHour?: true
    QtyHour125?: true
    QtyHour150?: true
    QtyHour175?: true
    QtyHour200?: true
    BreakMinutes?: true
    GpsStart?: true
    GpsEnd?: true
    EmployeeHoursByLocalityId?: true
    IsManualInsert?: true
    ManualInsertUserId?: true
    IsRowDeleted?: true
    ActionTypeID?: true
    DayTypeID?: true
    HolidayName?: true
    StartEndTimeSabat?: true
    IsForemanHourApproved?: true
    IsForemanApproval?: true
    ForemanApprovalGeneralCRMUserId?: true
    IsComplementRow?: true
  }

  export type EmployeeHoursMaxAggregateInputType = {
    EmployeeHoursId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    EmployeeId?: true
    EmployeeNumber?: true
    MonthManaged?: true
    YearManaged?: true
    LeadingDate?: true
    HourStart?: true
    HourEnd?: true
    HourStartSource?: true
    HourEndSource?: true
    RealHours?: true
    QtyHour?: true
    QtyHour125?: true
    QtyHour150?: true
    QtyHour175?: true
    QtyHour200?: true
    BreakMinutes?: true
    GpsStart?: true
    GpsEnd?: true
    EmployeeHoursByLocalityId?: true
    IsManualInsert?: true
    ManualInsertUserId?: true
    IsRowDeleted?: true
    ActionTypeID?: true
    DayTypeID?: true
    HolidayName?: true
    StartEndTimeSabat?: true
    IsForemanHourApproved?: true
    IsForemanApproval?: true
    ForemanApprovalGeneralCRMUserId?: true
    IsComplementRow?: true
  }

  export type EmployeeHoursCountAggregateInputType = {
    EmployeeHoursId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    EmployeeId?: true
    EmployeeNumber?: true
    MonthManaged?: true
    YearManaged?: true
    LeadingDate?: true
    HourStart?: true
    HourEnd?: true
    HourStartSource?: true
    HourEndSource?: true
    RealHours?: true
    QtyHour?: true
    QtyHour125?: true
    QtyHour150?: true
    QtyHour175?: true
    QtyHour200?: true
    BreakMinutes?: true
    GpsStart?: true
    GpsEnd?: true
    EmployeeHoursByLocalityId?: true
    IsManualInsert?: true
    ManualInsertUserId?: true
    IsRowDeleted?: true
    ActionTypeID?: true
    DayTypeID?: true
    HolidayName?: true
    StartEndTimeSabat?: true
    IsForemanHourApproved?: true
    IsForemanApproval?: true
    ForemanApprovalGeneralCRMUserId?: true
    IsComplementRow?: true
    _all?: true
  }

  export type EmployeeHoursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHours to aggregate.
     */
    where?: EmployeeHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHours to fetch.
     */
    orderBy?: EmployeeHoursOrderByWithRelationInput | EmployeeHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeHours
    **/
    _count?: true | EmployeeHoursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeHoursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeHoursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeHoursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeHoursMaxAggregateInputType
  }

  export type GetEmployeeHoursAggregateType<T extends EmployeeHoursAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeHours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeHours[P]>
      : GetScalarType<T[P], AggregateEmployeeHours[P]>
  }




  export type EmployeeHoursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursWhereInput
    orderBy?: EmployeeHoursOrderByWithAggregationInput | EmployeeHoursOrderByWithAggregationInput[]
    by: EmployeeHoursScalarFieldEnum[] | EmployeeHoursScalarFieldEnum
    having?: EmployeeHoursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeHoursCountAggregateInputType | true
    _avg?: EmployeeHoursAvgAggregateInputType
    _sum?: EmployeeHoursSumAggregateInputType
    _min?: EmployeeHoursMinAggregateInputType
    _max?: EmployeeHoursMaxAggregateInputType
  }

  export type EmployeeHoursGroupByOutputType = {
    EmployeeHoursId: string
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    EmployeeNumber: number
    MonthManaged: number
    YearManaged: number
    LeadingDate: Date
    HourStart: Date | null
    HourEnd: Date | null
    HourStartSource: Date | null
    HourEndSource: Date | null
    RealHours: number | null
    QtyHour: number | null
    QtyHour125: number | null
    QtyHour150: number | null
    QtyHour175: number | null
    QtyHour200: number | null
    BreakMinutes: number | null
    GpsStart: string | null
    GpsEnd: string | null
    EmployeeHoursByLocalityId: string
    IsManualInsert: number | null
    ManualInsertUserId: string | null
    IsRowDeleted: number | null
    ActionTypeID: number | null
    DayTypeID: number | null
    HolidayName: string | null
    StartEndTimeSabat: Date | null
    IsForemanHourApproved: Date | null
    IsForemanApproval: Date | null
    ForemanApprovalGeneralCRMUserId: string | null
    IsComplementRow: number | null
    _count: EmployeeHoursCountAggregateOutputType | null
    _avg: EmployeeHoursAvgAggregateOutputType | null
    _sum: EmployeeHoursSumAggregateOutputType | null
    _min: EmployeeHoursMinAggregateOutputType | null
    _max: EmployeeHoursMaxAggregateOutputType | null
  }

  type GetEmployeeHoursGroupByPayload<T extends EmployeeHoursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeHoursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeHoursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeHoursGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeHoursGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeHoursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmployeeHoursId?: boolean
    CreatedAt?: boolean
    CompanyIdGeneralCRM?: boolean
    EmployeeId?: boolean
    EmployeeNumber?: boolean
    MonthManaged?: boolean
    YearManaged?: boolean
    LeadingDate?: boolean
    HourStart?: boolean
    HourEnd?: boolean
    HourStartSource?: boolean
    HourEndSource?: boolean
    RealHours?: boolean
    QtyHour?: boolean
    QtyHour125?: boolean
    QtyHour150?: boolean
    QtyHour175?: boolean
    QtyHour200?: boolean
    BreakMinutes?: boolean
    GpsStart?: boolean
    GpsEnd?: boolean
    EmployeeHoursByLocalityId?: boolean
    IsManualInsert?: boolean
    ManualInsertUserId?: boolean
    IsRowDeleted?: boolean
    ActionTypeID?: boolean
    DayTypeID?: boolean
    HolidayName?: boolean
    StartEndTimeSabat?: boolean
    IsForemanHourApproved?: boolean
    IsForemanApproval?: boolean
    ForemanApprovalGeneralCRMUserId?: boolean
    IsComplementRow?: boolean
    Lkup_ActionType?: boolean | EmployeeHours$Lkup_ActionTypeArgs<ExtArgs>
    EmployeeHoursByLocality?: boolean | EmployeeHoursByLocalityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeHours"]>


  export type EmployeeHoursSelectScalar = {
    EmployeeHoursId?: boolean
    CreatedAt?: boolean
    CompanyIdGeneralCRM?: boolean
    EmployeeId?: boolean
    EmployeeNumber?: boolean
    MonthManaged?: boolean
    YearManaged?: boolean
    LeadingDate?: boolean
    HourStart?: boolean
    HourEnd?: boolean
    HourStartSource?: boolean
    HourEndSource?: boolean
    RealHours?: boolean
    QtyHour?: boolean
    QtyHour125?: boolean
    QtyHour150?: boolean
    QtyHour175?: boolean
    QtyHour200?: boolean
    BreakMinutes?: boolean
    GpsStart?: boolean
    GpsEnd?: boolean
    EmployeeHoursByLocalityId?: boolean
    IsManualInsert?: boolean
    ManualInsertUserId?: boolean
    IsRowDeleted?: boolean
    ActionTypeID?: boolean
    DayTypeID?: boolean
    HolidayName?: boolean
    StartEndTimeSabat?: boolean
    IsForemanHourApproved?: boolean
    IsForemanApproval?: boolean
    ForemanApprovalGeneralCRMUserId?: boolean
    IsComplementRow?: boolean
  }

  export type EmployeeHoursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lkup_ActionType?: boolean | EmployeeHours$Lkup_ActionTypeArgs<ExtArgs>
    EmployeeHoursByLocality?: boolean | EmployeeHoursByLocalityDefaultArgs<ExtArgs>
  }

  export type $EmployeeHoursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeHours"
    objects: {
      Lkup_ActionType: Prisma.$Lkup_ActionTypePayload<ExtArgs> | null
      EmployeeHoursByLocality: Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      EmployeeHoursId: string
      CreatedAt: Date | null
      CompanyIdGeneralCRM: string
      EmployeeId: number
      EmployeeNumber: number
      MonthManaged: number
      YearManaged: number
      LeadingDate: Date
      HourStart: Date | null
      HourEnd: Date | null
      HourStartSource: Date | null
      HourEndSource: Date | null
      RealHours: number | null
      QtyHour: number | null
      QtyHour125: number | null
      QtyHour150: number | null
      QtyHour175: number | null
      QtyHour200: number | null
      BreakMinutes: number | null
      GpsStart: string | null
      GpsEnd: string | null
      EmployeeHoursByLocalityId: string
      IsManualInsert: number | null
      ManualInsertUserId: string | null
      IsRowDeleted: number | null
      ActionTypeID: number | null
      DayTypeID: number | null
      HolidayName: string | null
      StartEndTimeSabat: Date | null
      IsForemanHourApproved: Date | null
      IsForemanApproval: Date | null
      ForemanApprovalGeneralCRMUserId: string | null
      IsComplementRow: number | null
    }, ExtArgs["result"]["employeeHours"]>
    composites: {}
  }

  type EmployeeHoursGetPayload<S extends boolean | null | undefined | EmployeeHoursDefaultArgs> = $Result.GetResult<Prisma.$EmployeeHoursPayload, S>

  type EmployeeHoursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeHoursFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeHoursCountAggregateInputType | true
    }

  export interface EmployeeHoursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeHours'], meta: { name: 'EmployeeHours' } }
    /**
     * Find zero or one EmployeeHours that matches the filter.
     * @param {EmployeeHoursFindUniqueArgs} args - Arguments to find a EmployeeHours
     * @example
     * // Get one EmployeeHours
     * const employeeHours = await prisma.employeeHours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeHoursFindUniqueArgs>(args: SelectSubset<T, EmployeeHoursFindUniqueArgs<ExtArgs>>): Prisma__EmployeeHoursClient<$Result.GetResult<Prisma.$EmployeeHoursPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeHours that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeHoursFindUniqueOrThrowArgs} args - Arguments to find a EmployeeHours
     * @example
     * // Get one EmployeeHours
     * const employeeHours = await prisma.employeeHours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeHoursFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeHoursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursClient<$Result.GetResult<Prisma.$EmployeeHoursPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursFindFirstArgs} args - Arguments to find a EmployeeHours
     * @example
     * // Get one EmployeeHours
     * const employeeHours = await prisma.employeeHours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeHoursFindFirstArgs>(args?: SelectSubset<T, EmployeeHoursFindFirstArgs<ExtArgs>>): Prisma__EmployeeHoursClient<$Result.GetResult<Prisma.$EmployeeHoursPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeHours that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursFindFirstOrThrowArgs} args - Arguments to find a EmployeeHours
     * @example
     * // Get one EmployeeHours
     * const employeeHours = await prisma.employeeHours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeHoursFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeHoursFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursClient<$Result.GetResult<Prisma.$EmployeeHoursPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeHours
     * const employeeHours = await prisma.employeeHours.findMany()
     * 
     * // Get first 10 EmployeeHours
     * const employeeHours = await prisma.employeeHours.findMany({ take: 10 })
     * 
     * // Only select the `EmployeeHoursId`
     * const employeeHoursWithEmployeeHoursIdOnly = await prisma.employeeHours.findMany({ select: { EmployeeHoursId: true } })
     * 
     */
    findMany<T extends EmployeeHoursFindManyArgs>(args?: SelectSubset<T, EmployeeHoursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeHours.
     * @param {EmployeeHoursCreateArgs} args - Arguments to create a EmployeeHours.
     * @example
     * // Create one EmployeeHours
     * const EmployeeHours = await prisma.employeeHours.create({
     *   data: {
     *     // ... data to create a EmployeeHours
     *   }
     * })
     * 
     */
    create<T extends EmployeeHoursCreateArgs>(args: SelectSubset<T, EmployeeHoursCreateArgs<ExtArgs>>): Prisma__EmployeeHoursClient<$Result.GetResult<Prisma.$EmployeeHoursPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeHours.
     * @param {EmployeeHoursCreateManyArgs} args - Arguments to create many EmployeeHours.
     * @example
     * // Create many EmployeeHours
     * const employeeHours = await prisma.employeeHours.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeHoursCreateManyArgs>(args?: SelectSubset<T, EmployeeHoursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeHours.
     * @param {EmployeeHoursDeleteArgs} args - Arguments to delete one EmployeeHours.
     * @example
     * // Delete one EmployeeHours
     * const EmployeeHours = await prisma.employeeHours.delete({
     *   where: {
     *     // ... filter to delete one EmployeeHours
     *   }
     * })
     * 
     */
    delete<T extends EmployeeHoursDeleteArgs>(args: SelectSubset<T, EmployeeHoursDeleteArgs<ExtArgs>>): Prisma__EmployeeHoursClient<$Result.GetResult<Prisma.$EmployeeHoursPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeHours.
     * @param {EmployeeHoursUpdateArgs} args - Arguments to update one EmployeeHours.
     * @example
     * // Update one EmployeeHours
     * const employeeHours = await prisma.employeeHours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeHoursUpdateArgs>(args: SelectSubset<T, EmployeeHoursUpdateArgs<ExtArgs>>): Prisma__EmployeeHoursClient<$Result.GetResult<Prisma.$EmployeeHoursPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeHours.
     * @param {EmployeeHoursDeleteManyArgs} args - Arguments to filter EmployeeHours to delete.
     * @example
     * // Delete a few EmployeeHours
     * const { count } = await prisma.employeeHours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeHoursDeleteManyArgs>(args?: SelectSubset<T, EmployeeHoursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeHours
     * const employeeHours = await prisma.employeeHours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeHoursUpdateManyArgs>(args: SelectSubset<T, EmployeeHoursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeHours.
     * @param {EmployeeHoursUpsertArgs} args - Arguments to update or create a EmployeeHours.
     * @example
     * // Update or create a EmployeeHours
     * const employeeHours = await prisma.employeeHours.upsert({
     *   create: {
     *     // ... data to create a EmployeeHours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeHours we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeHoursUpsertArgs>(args: SelectSubset<T, EmployeeHoursUpsertArgs<ExtArgs>>): Prisma__EmployeeHoursClient<$Result.GetResult<Prisma.$EmployeeHoursPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursCountArgs} args - Arguments to filter EmployeeHours to count.
     * @example
     * // Count the number of EmployeeHours
     * const count = await prisma.employeeHours.count({
     *   where: {
     *     // ... the filter for the EmployeeHours we want to count
     *   }
     * })
    **/
    count<T extends EmployeeHoursCountArgs>(
      args?: Subset<T, EmployeeHoursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeHoursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeHoursAggregateArgs>(args: Subset<T, EmployeeHoursAggregateArgs>): Prisma.PrismaPromise<GetEmployeeHoursAggregateType<T>>

    /**
     * Group by EmployeeHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeHoursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeHoursGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeHoursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeHoursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeHoursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeHours model
   */
  readonly fields: EmployeeHoursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeHours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeHoursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lkup_ActionType<T extends EmployeeHours$Lkup_ActionTypeArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHours$Lkup_ActionTypeArgs<ExtArgs>>): Prisma__Lkup_ActionTypeClient<$Result.GetResult<Prisma.$Lkup_ActionTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    EmployeeHoursByLocality<T extends EmployeeHoursByLocalityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHoursByLocalityDefaultArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeHours model
   */ 
  interface EmployeeHoursFieldRefs {
    readonly EmployeeHoursId: FieldRef<"EmployeeHours", 'String'>
    readonly CreatedAt: FieldRef<"EmployeeHours", 'DateTime'>
    readonly CompanyIdGeneralCRM: FieldRef<"EmployeeHours", 'String'>
    readonly EmployeeId: FieldRef<"EmployeeHours", 'Int'>
    readonly EmployeeNumber: FieldRef<"EmployeeHours", 'Int'>
    readonly MonthManaged: FieldRef<"EmployeeHours", 'Int'>
    readonly YearManaged: FieldRef<"EmployeeHours", 'Int'>
    readonly LeadingDate: FieldRef<"EmployeeHours", 'DateTime'>
    readonly HourStart: FieldRef<"EmployeeHours", 'DateTime'>
    readonly HourEnd: FieldRef<"EmployeeHours", 'DateTime'>
    readonly HourStartSource: FieldRef<"EmployeeHours", 'DateTime'>
    readonly HourEndSource: FieldRef<"EmployeeHours", 'DateTime'>
    readonly RealHours: FieldRef<"EmployeeHours", 'Float'>
    readonly QtyHour: FieldRef<"EmployeeHours", 'Float'>
    readonly QtyHour125: FieldRef<"EmployeeHours", 'Float'>
    readonly QtyHour150: FieldRef<"EmployeeHours", 'Float'>
    readonly QtyHour175: FieldRef<"EmployeeHours", 'Float'>
    readonly QtyHour200: FieldRef<"EmployeeHours", 'Float'>
    readonly BreakMinutes: FieldRef<"EmployeeHours", 'Float'>
    readonly GpsStart: FieldRef<"EmployeeHours", 'String'>
    readonly GpsEnd: FieldRef<"EmployeeHours", 'String'>
    readonly EmployeeHoursByLocalityId: FieldRef<"EmployeeHours", 'String'>
    readonly IsManualInsert: FieldRef<"EmployeeHours", 'Int'>
    readonly ManualInsertUserId: FieldRef<"EmployeeHours", 'String'>
    readonly IsRowDeleted: FieldRef<"EmployeeHours", 'Int'>
    readonly ActionTypeID: FieldRef<"EmployeeHours", 'Int'>
    readonly DayTypeID: FieldRef<"EmployeeHours", 'Int'>
    readonly HolidayName: FieldRef<"EmployeeHours", 'String'>
    readonly StartEndTimeSabat: FieldRef<"EmployeeHours", 'DateTime'>
    readonly IsForemanHourApproved: FieldRef<"EmployeeHours", 'DateTime'>
    readonly IsForemanApproval: FieldRef<"EmployeeHours", 'DateTime'>
    readonly ForemanApprovalGeneralCRMUserId: FieldRef<"EmployeeHours", 'String'>
    readonly IsComplementRow: FieldRef<"EmployeeHours", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeHours findUnique
   */
  export type EmployeeHoursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHours
     */
    select?: EmployeeHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHours to fetch.
     */
    where: EmployeeHoursWhereUniqueInput
  }

  /**
   * EmployeeHours findUniqueOrThrow
   */
  export type EmployeeHoursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHours
     */
    select?: EmployeeHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHours to fetch.
     */
    where: EmployeeHoursWhereUniqueInput
  }

  /**
   * EmployeeHours findFirst
   */
  export type EmployeeHoursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHours
     */
    select?: EmployeeHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHours to fetch.
     */
    where?: EmployeeHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHours to fetch.
     */
    orderBy?: EmployeeHoursOrderByWithRelationInput | EmployeeHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHours.
     */
    cursor?: EmployeeHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHours.
     */
    distinct?: EmployeeHoursScalarFieldEnum | EmployeeHoursScalarFieldEnum[]
  }

  /**
   * EmployeeHours findFirstOrThrow
   */
  export type EmployeeHoursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHours
     */
    select?: EmployeeHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHours to fetch.
     */
    where?: EmployeeHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHours to fetch.
     */
    orderBy?: EmployeeHoursOrderByWithRelationInput | EmployeeHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHours.
     */
    cursor?: EmployeeHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHours.
     */
    distinct?: EmployeeHoursScalarFieldEnum | EmployeeHoursScalarFieldEnum[]
  }

  /**
   * EmployeeHours findMany
   */
  export type EmployeeHoursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHours
     */
    select?: EmployeeHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHours to fetch.
     */
    where?: EmployeeHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHours to fetch.
     */
    orderBy?: EmployeeHoursOrderByWithRelationInput | EmployeeHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeHours.
     */
    cursor?: EmployeeHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHours.
     */
    skip?: number
    distinct?: EmployeeHoursScalarFieldEnum | EmployeeHoursScalarFieldEnum[]
  }

  /**
   * EmployeeHours create
   */
  export type EmployeeHoursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHours
     */
    select?: EmployeeHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeHours.
     */
    data: XOR<EmployeeHoursCreateInput, EmployeeHoursUncheckedCreateInput>
  }

  /**
   * EmployeeHours createMany
   */
  export type EmployeeHoursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeHours.
     */
    data: EmployeeHoursCreateManyInput | EmployeeHoursCreateManyInput[]
  }

  /**
   * EmployeeHours update
   */
  export type EmployeeHoursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHours
     */
    select?: EmployeeHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeHours.
     */
    data: XOR<EmployeeHoursUpdateInput, EmployeeHoursUncheckedUpdateInput>
    /**
     * Choose, which EmployeeHours to update.
     */
    where: EmployeeHoursWhereUniqueInput
  }

  /**
   * EmployeeHours updateMany
   */
  export type EmployeeHoursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeHours.
     */
    data: XOR<EmployeeHoursUpdateManyMutationInput, EmployeeHoursUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeHours to update
     */
    where?: EmployeeHoursWhereInput
  }

  /**
   * EmployeeHours upsert
   */
  export type EmployeeHoursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHours
     */
    select?: EmployeeHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeHours to update in case it exists.
     */
    where: EmployeeHoursWhereUniqueInput
    /**
     * In case the EmployeeHours found by the `where` argument doesn't exist, create a new EmployeeHours with this data.
     */
    create: XOR<EmployeeHoursCreateInput, EmployeeHoursUncheckedCreateInput>
    /**
     * In case the EmployeeHours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeHoursUpdateInput, EmployeeHoursUncheckedUpdateInput>
  }

  /**
   * EmployeeHours delete
   */
  export type EmployeeHoursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHours
     */
    select?: EmployeeHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursInclude<ExtArgs> | null
    /**
     * Filter which EmployeeHours to delete.
     */
    where: EmployeeHoursWhereUniqueInput
  }

  /**
   * EmployeeHours deleteMany
   */
  export type EmployeeHoursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHours to delete
     */
    where?: EmployeeHoursWhereInput
  }

  /**
   * EmployeeHours.Lkup_ActionType
   */
  export type EmployeeHours$Lkup_ActionTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_ActionType
     */
    select?: Lkup_ActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Lkup_ActionTypeInclude<ExtArgs> | null
    where?: Lkup_ActionTypeWhereInput
  }

  /**
   * EmployeeHours without action
   */
  export type EmployeeHoursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHours
     */
    select?: EmployeeHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeHoursByLocality
   */

  export type AggregateEmployeeHoursByLocality = {
    _count: EmployeeHoursByLocalityCountAggregateOutputType | null
    _avg: EmployeeHoursByLocalityAvgAggregateOutputType | null
    _sum: EmployeeHoursByLocalitySumAggregateOutputType | null
    _min: EmployeeHoursByLocalityMinAggregateOutputType | null
    _max: EmployeeHoursByLocalityMaxAggregateOutputType | null
  }

  export type EmployeeHoursByLocalityAvgAggregateOutputType = {
    EmployeeId: number | null
    NotShowEmployeeHours: number | null
    MinimumHours2BreakTime: number | null
    BreakTime: number | null
    AlertForMaxMonthHours: number | null
  }

  export type EmployeeHoursByLocalitySumAggregateOutputType = {
    EmployeeId: number | null
    NotShowEmployeeHours: number | null
    MinimumHours2BreakTime: number | null
    BreakTime: number | null
    AlertForMaxMonthHours: number | null
  }

  export type EmployeeHoursByLocalityMinAggregateOutputType = {
    EmployeeHoursByLocalityId: string | null
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string | null
    EmployeeId: number | null
    NotShowEmployeeHours: number | null
    EmployeeHoursLocalityId: string | null
    HourMinStart: Date | null
    HourMaxStop: Date | null
    RoundTime: string | null
    EmployeeHoursUserId: string | null
    MinimumHours2BreakTime: number | null
    BreakTime: number | null
    AlertForMaxMonthHours: number | null
    EmployeeHoursContractId: string | null
  }

  export type EmployeeHoursByLocalityMaxAggregateOutputType = {
    EmployeeHoursByLocalityId: string | null
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string | null
    EmployeeId: number | null
    NotShowEmployeeHours: number | null
    EmployeeHoursLocalityId: string | null
    HourMinStart: Date | null
    HourMaxStop: Date | null
    RoundTime: string | null
    EmployeeHoursUserId: string | null
    MinimumHours2BreakTime: number | null
    BreakTime: number | null
    AlertForMaxMonthHours: number | null
    EmployeeHoursContractId: string | null
  }

  export type EmployeeHoursByLocalityCountAggregateOutputType = {
    EmployeeHoursByLocalityId: number
    CreatedAt: number
    CompanyIdGeneralCRM: number
    EmployeeId: number
    NotShowEmployeeHours: number
    EmployeeHoursLocalityId: number
    HourMinStart: number
    HourMaxStop: number
    RoundTime: number
    EmployeeHoursUserId: number
    MinimumHours2BreakTime: number
    BreakTime: number
    AlertForMaxMonthHours: number
    EmployeeHoursContractId: number
    _all: number
  }


  export type EmployeeHoursByLocalityAvgAggregateInputType = {
    EmployeeId?: true
    NotShowEmployeeHours?: true
    MinimumHours2BreakTime?: true
    BreakTime?: true
    AlertForMaxMonthHours?: true
  }

  export type EmployeeHoursByLocalitySumAggregateInputType = {
    EmployeeId?: true
    NotShowEmployeeHours?: true
    MinimumHours2BreakTime?: true
    BreakTime?: true
    AlertForMaxMonthHours?: true
  }

  export type EmployeeHoursByLocalityMinAggregateInputType = {
    EmployeeHoursByLocalityId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    EmployeeId?: true
    NotShowEmployeeHours?: true
    EmployeeHoursLocalityId?: true
    HourMinStart?: true
    HourMaxStop?: true
    RoundTime?: true
    EmployeeHoursUserId?: true
    MinimumHours2BreakTime?: true
    BreakTime?: true
    AlertForMaxMonthHours?: true
    EmployeeHoursContractId?: true
  }

  export type EmployeeHoursByLocalityMaxAggregateInputType = {
    EmployeeHoursByLocalityId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    EmployeeId?: true
    NotShowEmployeeHours?: true
    EmployeeHoursLocalityId?: true
    HourMinStart?: true
    HourMaxStop?: true
    RoundTime?: true
    EmployeeHoursUserId?: true
    MinimumHours2BreakTime?: true
    BreakTime?: true
    AlertForMaxMonthHours?: true
    EmployeeHoursContractId?: true
  }

  export type EmployeeHoursByLocalityCountAggregateInputType = {
    EmployeeHoursByLocalityId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    EmployeeId?: true
    NotShowEmployeeHours?: true
    EmployeeHoursLocalityId?: true
    HourMinStart?: true
    HourMaxStop?: true
    RoundTime?: true
    EmployeeHoursUserId?: true
    MinimumHours2BreakTime?: true
    BreakTime?: true
    AlertForMaxMonthHours?: true
    EmployeeHoursContractId?: true
    _all?: true
  }

  export type EmployeeHoursByLocalityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursByLocality to aggregate.
     */
    where?: EmployeeHoursByLocalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursByLocalities to fetch.
     */
    orderBy?: EmployeeHoursByLocalityOrderByWithRelationInput | EmployeeHoursByLocalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeHoursByLocalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursByLocalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursByLocalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeHoursByLocalities
    **/
    _count?: true | EmployeeHoursByLocalityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeHoursByLocalityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeHoursByLocalitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeHoursByLocalityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeHoursByLocalityMaxAggregateInputType
  }

  export type GetEmployeeHoursByLocalityAggregateType<T extends EmployeeHoursByLocalityAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeHoursByLocality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeHoursByLocality[P]>
      : GetScalarType<T[P], AggregateEmployeeHoursByLocality[P]>
  }




  export type EmployeeHoursByLocalityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursByLocalityWhereInput
    orderBy?: EmployeeHoursByLocalityOrderByWithAggregationInput | EmployeeHoursByLocalityOrderByWithAggregationInput[]
    by: EmployeeHoursByLocalityScalarFieldEnum[] | EmployeeHoursByLocalityScalarFieldEnum
    having?: EmployeeHoursByLocalityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeHoursByLocalityCountAggregateInputType | true
    _avg?: EmployeeHoursByLocalityAvgAggregateInputType
    _sum?: EmployeeHoursByLocalitySumAggregateInputType
    _min?: EmployeeHoursByLocalityMinAggregateInputType
    _max?: EmployeeHoursByLocalityMaxAggregateInputType
  }

  export type EmployeeHoursByLocalityGroupByOutputType = {
    EmployeeHoursByLocalityId: string
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours: number | null
    EmployeeHoursLocalityId: string
    HourMinStart: Date | null
    HourMaxStop: Date | null
    RoundTime: string | null
    EmployeeHoursUserId: string
    MinimumHours2BreakTime: number
    BreakTime: number | null
    AlertForMaxMonthHours: number | null
    EmployeeHoursContractId: string
    _count: EmployeeHoursByLocalityCountAggregateOutputType | null
    _avg: EmployeeHoursByLocalityAvgAggregateOutputType | null
    _sum: EmployeeHoursByLocalitySumAggregateOutputType | null
    _min: EmployeeHoursByLocalityMinAggregateOutputType | null
    _max: EmployeeHoursByLocalityMaxAggregateOutputType | null
  }

  type GetEmployeeHoursByLocalityGroupByPayload<T extends EmployeeHoursByLocalityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeHoursByLocalityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeHoursByLocalityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeHoursByLocalityGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeHoursByLocalityGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeHoursByLocalitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmployeeHoursByLocalityId?: boolean
    CreatedAt?: boolean
    CompanyIdGeneralCRM?: boolean
    EmployeeId?: boolean
    NotShowEmployeeHours?: boolean
    EmployeeHoursLocalityId?: boolean
    HourMinStart?: boolean
    HourMaxStop?: boolean
    RoundTime?: boolean
    EmployeeHoursUserId?: boolean
    MinimumHours2BreakTime?: boolean
    BreakTime?: boolean
    AlertForMaxMonthHours?: boolean
    EmployeeHoursContractId?: boolean
    EmployeeHours?: boolean | EmployeeHoursByLocality$EmployeeHoursArgs<ExtArgs>
    EmployeeHoursUsers?: boolean | EmployeeHoursUsersDefaultArgs<ExtArgs>
    EmployeeHoursContracts?: boolean | EmployeeHoursContractsDefaultArgs<ExtArgs>
    EmployeeHoursLocalities?: boolean | EmployeeHoursLocalitiesDefaultArgs<ExtArgs>
    _count?: boolean | EmployeeHoursByLocalityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeHoursByLocality"]>


  export type EmployeeHoursByLocalitySelectScalar = {
    EmployeeHoursByLocalityId?: boolean
    CreatedAt?: boolean
    CompanyIdGeneralCRM?: boolean
    EmployeeId?: boolean
    NotShowEmployeeHours?: boolean
    EmployeeHoursLocalityId?: boolean
    HourMinStart?: boolean
    HourMaxStop?: boolean
    RoundTime?: boolean
    EmployeeHoursUserId?: boolean
    MinimumHours2BreakTime?: boolean
    BreakTime?: boolean
    AlertForMaxMonthHours?: boolean
    EmployeeHoursContractId?: boolean
  }

  export type EmployeeHoursByLocalityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeHours?: boolean | EmployeeHoursByLocality$EmployeeHoursArgs<ExtArgs>
    EmployeeHoursUsers?: boolean | EmployeeHoursUsersDefaultArgs<ExtArgs>
    EmployeeHoursContracts?: boolean | EmployeeHoursContractsDefaultArgs<ExtArgs>
    EmployeeHoursLocalities?: boolean | EmployeeHoursLocalitiesDefaultArgs<ExtArgs>
    _count?: boolean | EmployeeHoursByLocalityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmployeeHoursByLocalityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeHoursByLocality"
    objects: {
      EmployeeHours: Prisma.$EmployeeHoursPayload<ExtArgs>[]
      EmployeeHoursUsers: Prisma.$EmployeeHoursUsersPayload<ExtArgs>
      EmployeeHoursContracts: Prisma.$EmployeeHoursContractsPayload<ExtArgs>
      EmployeeHoursLocalities: Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      EmployeeHoursByLocalityId: string
      CreatedAt: Date | null
      CompanyIdGeneralCRM: string
      EmployeeId: number
      NotShowEmployeeHours: number | null
      EmployeeHoursLocalityId: string
      HourMinStart: Date | null
      HourMaxStop: Date | null
      RoundTime: string | null
      EmployeeHoursUserId: string
      MinimumHours2BreakTime: number
      BreakTime: number | null
      AlertForMaxMonthHours: number | null
      EmployeeHoursContractId: string
    }, ExtArgs["result"]["employeeHoursByLocality"]>
    composites: {}
  }

  type EmployeeHoursByLocalityGetPayload<S extends boolean | null | undefined | EmployeeHoursByLocalityDefaultArgs> = $Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload, S>

  type EmployeeHoursByLocalityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeHoursByLocalityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeHoursByLocalityCountAggregateInputType | true
    }

  export interface EmployeeHoursByLocalityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeHoursByLocality'], meta: { name: 'EmployeeHoursByLocality' } }
    /**
     * Find zero or one EmployeeHoursByLocality that matches the filter.
     * @param {EmployeeHoursByLocalityFindUniqueArgs} args - Arguments to find a EmployeeHoursByLocality
     * @example
     * // Get one EmployeeHoursByLocality
     * const employeeHoursByLocality = await prisma.employeeHoursByLocality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeHoursByLocalityFindUniqueArgs>(args: SelectSubset<T, EmployeeHoursByLocalityFindUniqueArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeHoursByLocality that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeHoursByLocalityFindUniqueOrThrowArgs} args - Arguments to find a EmployeeHoursByLocality
     * @example
     * // Get one EmployeeHoursByLocality
     * const employeeHoursByLocality = await prisma.employeeHoursByLocality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeHoursByLocalityFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeHoursByLocalityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeHoursByLocality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityFindFirstArgs} args - Arguments to find a EmployeeHoursByLocality
     * @example
     * // Get one EmployeeHoursByLocality
     * const employeeHoursByLocality = await prisma.employeeHoursByLocality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeHoursByLocalityFindFirstArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityFindFirstArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeHoursByLocality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityFindFirstOrThrowArgs} args - Arguments to find a EmployeeHoursByLocality
     * @example
     * // Get one EmployeeHoursByLocality
     * const employeeHoursByLocality = await prisma.employeeHoursByLocality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeHoursByLocalityFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeHoursByLocalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeHoursByLocalities
     * const employeeHoursByLocalities = await prisma.employeeHoursByLocality.findMany()
     * 
     * // Get first 10 EmployeeHoursByLocalities
     * const employeeHoursByLocalities = await prisma.employeeHoursByLocality.findMany({ take: 10 })
     * 
     * // Only select the `EmployeeHoursByLocalityId`
     * const employeeHoursByLocalityWithEmployeeHoursByLocalityIdOnly = await prisma.employeeHoursByLocality.findMany({ select: { EmployeeHoursByLocalityId: true } })
     * 
     */
    findMany<T extends EmployeeHoursByLocalityFindManyArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeHoursByLocality.
     * @param {EmployeeHoursByLocalityCreateArgs} args - Arguments to create a EmployeeHoursByLocality.
     * @example
     * // Create one EmployeeHoursByLocality
     * const EmployeeHoursByLocality = await prisma.employeeHoursByLocality.create({
     *   data: {
     *     // ... data to create a EmployeeHoursByLocality
     *   }
     * })
     * 
     */
    create<T extends EmployeeHoursByLocalityCreateArgs>(args: SelectSubset<T, EmployeeHoursByLocalityCreateArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeHoursByLocalities.
     * @param {EmployeeHoursByLocalityCreateManyArgs} args - Arguments to create many EmployeeHoursByLocalities.
     * @example
     * // Create many EmployeeHoursByLocalities
     * const employeeHoursByLocality = await prisma.employeeHoursByLocality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeHoursByLocalityCreateManyArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeHoursByLocality.
     * @param {EmployeeHoursByLocalityDeleteArgs} args - Arguments to delete one EmployeeHoursByLocality.
     * @example
     * // Delete one EmployeeHoursByLocality
     * const EmployeeHoursByLocality = await prisma.employeeHoursByLocality.delete({
     *   where: {
     *     // ... filter to delete one EmployeeHoursByLocality
     *   }
     * })
     * 
     */
    delete<T extends EmployeeHoursByLocalityDeleteArgs>(args: SelectSubset<T, EmployeeHoursByLocalityDeleteArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeHoursByLocality.
     * @param {EmployeeHoursByLocalityUpdateArgs} args - Arguments to update one EmployeeHoursByLocality.
     * @example
     * // Update one EmployeeHoursByLocality
     * const employeeHoursByLocality = await prisma.employeeHoursByLocality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeHoursByLocalityUpdateArgs>(args: SelectSubset<T, EmployeeHoursByLocalityUpdateArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeHoursByLocalities.
     * @param {EmployeeHoursByLocalityDeleteManyArgs} args - Arguments to filter EmployeeHoursByLocalities to delete.
     * @example
     * // Delete a few EmployeeHoursByLocalities
     * const { count } = await prisma.employeeHoursByLocality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeHoursByLocalityDeleteManyArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeHoursByLocalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeHoursByLocalities
     * const employeeHoursByLocality = await prisma.employeeHoursByLocality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeHoursByLocalityUpdateManyArgs>(args: SelectSubset<T, EmployeeHoursByLocalityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeHoursByLocality.
     * @param {EmployeeHoursByLocalityUpsertArgs} args - Arguments to update or create a EmployeeHoursByLocality.
     * @example
     * // Update or create a EmployeeHoursByLocality
     * const employeeHoursByLocality = await prisma.employeeHoursByLocality.upsert({
     *   create: {
     *     // ... data to create a EmployeeHoursByLocality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeHoursByLocality we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeHoursByLocalityUpsertArgs>(args: SelectSubset<T, EmployeeHoursByLocalityUpsertArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeHoursByLocalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityCountArgs} args - Arguments to filter EmployeeHoursByLocalities to count.
     * @example
     * // Count the number of EmployeeHoursByLocalities
     * const count = await prisma.employeeHoursByLocality.count({
     *   where: {
     *     // ... the filter for the EmployeeHoursByLocalities we want to count
     *   }
     * })
    **/
    count<T extends EmployeeHoursByLocalityCountArgs>(
      args?: Subset<T, EmployeeHoursByLocalityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeHoursByLocalityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeHoursByLocality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeHoursByLocalityAggregateArgs>(args: Subset<T, EmployeeHoursByLocalityAggregateArgs>): Prisma.PrismaPromise<GetEmployeeHoursByLocalityAggregateType<T>>

    /**
     * Group by EmployeeHoursByLocality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeHoursByLocalityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeHoursByLocalityGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeHoursByLocalityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeHoursByLocalityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeHoursByLocalityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeHoursByLocality model
   */
  readonly fields: EmployeeHoursByLocalityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeHoursByLocality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeHoursByLocalityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EmployeeHours<T extends EmployeeHoursByLocality$EmployeeHoursArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHoursByLocality$EmployeeHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursPayload<ExtArgs>, T, "findMany"> | Null>
    EmployeeHoursUsers<T extends EmployeeHoursUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHoursUsersDefaultArgs<ExtArgs>>): Prisma__EmployeeHoursUsersClient<$Result.GetResult<Prisma.$EmployeeHoursUsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    EmployeeHoursContracts<T extends EmployeeHoursContractsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHoursContractsDefaultArgs<ExtArgs>>): Prisma__EmployeeHoursContractsClient<$Result.GetResult<Prisma.$EmployeeHoursContractsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    EmployeeHoursLocalities<T extends EmployeeHoursLocalitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHoursLocalitiesDefaultArgs<ExtArgs>>): Prisma__EmployeeHoursLocalitiesClient<$Result.GetResult<Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeHoursByLocality model
   */ 
  interface EmployeeHoursByLocalityFieldRefs {
    readonly EmployeeHoursByLocalityId: FieldRef<"EmployeeHoursByLocality", 'String'>
    readonly CreatedAt: FieldRef<"EmployeeHoursByLocality", 'DateTime'>
    readonly CompanyIdGeneralCRM: FieldRef<"EmployeeHoursByLocality", 'String'>
    readonly EmployeeId: FieldRef<"EmployeeHoursByLocality", 'Int'>
    readonly NotShowEmployeeHours: FieldRef<"EmployeeHoursByLocality", 'Int'>
    readonly EmployeeHoursLocalityId: FieldRef<"EmployeeHoursByLocality", 'String'>
    readonly HourMinStart: FieldRef<"EmployeeHoursByLocality", 'DateTime'>
    readonly HourMaxStop: FieldRef<"EmployeeHoursByLocality", 'DateTime'>
    readonly RoundTime: FieldRef<"EmployeeHoursByLocality", 'String'>
    readonly EmployeeHoursUserId: FieldRef<"EmployeeHoursByLocality", 'String'>
    readonly MinimumHours2BreakTime: FieldRef<"EmployeeHoursByLocality", 'Float'>
    readonly BreakTime: FieldRef<"EmployeeHoursByLocality", 'Int'>
    readonly AlertForMaxMonthHours: FieldRef<"EmployeeHoursByLocality", 'Float'>
    readonly EmployeeHoursContractId: FieldRef<"EmployeeHoursByLocality", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeHoursByLocality findUnique
   */
  export type EmployeeHoursByLocalityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocality to fetch.
     */
    where: EmployeeHoursByLocalityWhereUniqueInput
  }

  /**
   * EmployeeHoursByLocality findUniqueOrThrow
   */
  export type EmployeeHoursByLocalityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocality to fetch.
     */
    where: EmployeeHoursByLocalityWhereUniqueInput
  }

  /**
   * EmployeeHoursByLocality findFirst
   */
  export type EmployeeHoursByLocalityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocality to fetch.
     */
    where?: EmployeeHoursByLocalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursByLocalities to fetch.
     */
    orderBy?: EmployeeHoursByLocalityOrderByWithRelationInput | EmployeeHoursByLocalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursByLocalities.
     */
    cursor?: EmployeeHoursByLocalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursByLocalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursByLocalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursByLocalities.
     */
    distinct?: EmployeeHoursByLocalityScalarFieldEnum | EmployeeHoursByLocalityScalarFieldEnum[]
  }

  /**
   * EmployeeHoursByLocality findFirstOrThrow
   */
  export type EmployeeHoursByLocalityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocality to fetch.
     */
    where?: EmployeeHoursByLocalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursByLocalities to fetch.
     */
    orderBy?: EmployeeHoursByLocalityOrderByWithRelationInput | EmployeeHoursByLocalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursByLocalities.
     */
    cursor?: EmployeeHoursByLocalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursByLocalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursByLocalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursByLocalities.
     */
    distinct?: EmployeeHoursByLocalityScalarFieldEnum | EmployeeHoursByLocalityScalarFieldEnum[]
  }

  /**
   * EmployeeHoursByLocality findMany
   */
  export type EmployeeHoursByLocalityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocalities to fetch.
     */
    where?: EmployeeHoursByLocalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursByLocalities to fetch.
     */
    orderBy?: EmployeeHoursByLocalityOrderByWithRelationInput | EmployeeHoursByLocalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeHoursByLocalities.
     */
    cursor?: EmployeeHoursByLocalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursByLocalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursByLocalities.
     */
    skip?: number
    distinct?: EmployeeHoursByLocalityScalarFieldEnum | EmployeeHoursByLocalityScalarFieldEnum[]
  }

  /**
   * EmployeeHoursByLocality create
   */
  export type EmployeeHoursByLocalityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeHoursByLocality.
     */
    data: XOR<EmployeeHoursByLocalityCreateInput, EmployeeHoursByLocalityUncheckedCreateInput>
  }

  /**
   * EmployeeHoursByLocality createMany
   */
  export type EmployeeHoursByLocalityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeHoursByLocalities.
     */
    data: EmployeeHoursByLocalityCreateManyInput | EmployeeHoursByLocalityCreateManyInput[]
  }

  /**
   * EmployeeHoursByLocality update
   */
  export type EmployeeHoursByLocalityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeHoursByLocality.
     */
    data: XOR<EmployeeHoursByLocalityUpdateInput, EmployeeHoursByLocalityUncheckedUpdateInput>
    /**
     * Choose, which EmployeeHoursByLocality to update.
     */
    where: EmployeeHoursByLocalityWhereUniqueInput
  }

  /**
   * EmployeeHoursByLocality updateMany
   */
  export type EmployeeHoursByLocalityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeHoursByLocalities.
     */
    data: XOR<EmployeeHoursByLocalityUpdateManyMutationInput, EmployeeHoursByLocalityUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeHoursByLocalities to update
     */
    where?: EmployeeHoursByLocalityWhereInput
  }

  /**
   * EmployeeHoursByLocality upsert
   */
  export type EmployeeHoursByLocalityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeHoursByLocality to update in case it exists.
     */
    where: EmployeeHoursByLocalityWhereUniqueInput
    /**
     * In case the EmployeeHoursByLocality found by the `where` argument doesn't exist, create a new EmployeeHoursByLocality with this data.
     */
    create: XOR<EmployeeHoursByLocalityCreateInput, EmployeeHoursByLocalityUncheckedCreateInput>
    /**
     * In case the EmployeeHoursByLocality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeHoursByLocalityUpdateInput, EmployeeHoursByLocalityUncheckedUpdateInput>
  }

  /**
   * EmployeeHoursByLocality delete
   */
  export type EmployeeHoursByLocalityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
    /**
     * Filter which EmployeeHoursByLocality to delete.
     */
    where: EmployeeHoursByLocalityWhereUniqueInput
  }

  /**
   * EmployeeHoursByLocality deleteMany
   */
  export type EmployeeHoursByLocalityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursByLocalities to delete
     */
    where?: EmployeeHoursByLocalityWhereInput
  }

  /**
   * EmployeeHoursByLocality.EmployeeHours
   */
  export type EmployeeHoursByLocality$EmployeeHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHours
     */
    select?: EmployeeHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursInclude<ExtArgs> | null
    where?: EmployeeHoursWhereInput
    orderBy?: EmployeeHoursOrderByWithRelationInput | EmployeeHoursOrderByWithRelationInput[]
    cursor?: EmployeeHoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeHoursScalarFieldEnum | EmployeeHoursScalarFieldEnum[]
  }

  /**
   * EmployeeHoursByLocality without action
   */
  export type EmployeeHoursByLocalityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeHoursByLocalityTotals
   */

  export type AggregateEmployeeHoursByLocalityTotals = {
    _count: EmployeeHoursByLocalityTotalsCountAggregateOutputType | null
    _avg: EmployeeHoursByLocalityTotalsAvgAggregateOutputType | null
    _sum: EmployeeHoursByLocalityTotalsSumAggregateOutputType | null
    _min: EmployeeHoursByLocalityTotalsMinAggregateOutputType | null
    _max: EmployeeHoursByLocalityTotalsMaxAggregateOutputType | null
  }

  export type EmployeeHoursByLocalityTotalsAvgAggregateOutputType = {
    MonthManaged: number | null
    YearManaged: number | null
    EmployeeId: number | null
    QtyHour: number | null
    QtyHour125: number | null
    QtyHour150: number | null
    QtyHour175: number | null
    QtyHour200: number | null
    RealHours: number | null
    BreakMinutes: number | null
    WorkedDays: number | null
    IsCloseSalary: number | null
  }

  export type EmployeeHoursByLocalityTotalsSumAggregateOutputType = {
    MonthManaged: number | null
    YearManaged: number | null
    EmployeeId: number | null
    QtyHour: number | null
    QtyHour125: number | null
    QtyHour150: number | null
    QtyHour175: number | null
    QtyHour200: number | null
    RealHours: number | null
    BreakMinutes: number | null
    WorkedDays: number | null
    IsCloseSalary: number | null
  }

  export type EmployeeHoursByLocalityTotalsMinAggregateOutputType = {
    EmployeeHoursByLocalityTotalsId: string | null
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string | null
    MonthManaged: number | null
    YearManaged: number | null
    EmployeeId: number | null
    EmployeeHoursLocalityId: string | null
    QtyHour: number | null
    QtyHour125: number | null
    QtyHour150: number | null
    QtyHour175: number | null
    QtyHour200: number | null
    RealHours: number | null
    BreakMinutes: number | null
    WorkedDays: number | null
    IsCloseSalary: number | null
  }

  export type EmployeeHoursByLocalityTotalsMaxAggregateOutputType = {
    EmployeeHoursByLocalityTotalsId: string | null
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string | null
    MonthManaged: number | null
    YearManaged: number | null
    EmployeeId: number | null
    EmployeeHoursLocalityId: string | null
    QtyHour: number | null
    QtyHour125: number | null
    QtyHour150: number | null
    QtyHour175: number | null
    QtyHour200: number | null
    RealHours: number | null
    BreakMinutes: number | null
    WorkedDays: number | null
    IsCloseSalary: number | null
  }

  export type EmployeeHoursByLocalityTotalsCountAggregateOutputType = {
    EmployeeHoursByLocalityTotalsId: number
    CreatedAt: number
    CompanyIdGeneralCRM: number
    MonthManaged: number
    YearManaged: number
    EmployeeId: number
    EmployeeHoursLocalityId: number
    QtyHour: number
    QtyHour125: number
    QtyHour150: number
    QtyHour175: number
    QtyHour200: number
    RealHours: number
    BreakMinutes: number
    WorkedDays: number
    IsCloseSalary: number
    _all: number
  }


  export type EmployeeHoursByLocalityTotalsAvgAggregateInputType = {
    MonthManaged?: true
    YearManaged?: true
    EmployeeId?: true
    QtyHour?: true
    QtyHour125?: true
    QtyHour150?: true
    QtyHour175?: true
    QtyHour200?: true
    RealHours?: true
    BreakMinutes?: true
    WorkedDays?: true
    IsCloseSalary?: true
  }

  export type EmployeeHoursByLocalityTotalsSumAggregateInputType = {
    MonthManaged?: true
    YearManaged?: true
    EmployeeId?: true
    QtyHour?: true
    QtyHour125?: true
    QtyHour150?: true
    QtyHour175?: true
    QtyHour200?: true
    RealHours?: true
    BreakMinutes?: true
    WorkedDays?: true
    IsCloseSalary?: true
  }

  export type EmployeeHoursByLocalityTotalsMinAggregateInputType = {
    EmployeeHoursByLocalityTotalsId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    MonthManaged?: true
    YearManaged?: true
    EmployeeId?: true
    EmployeeHoursLocalityId?: true
    QtyHour?: true
    QtyHour125?: true
    QtyHour150?: true
    QtyHour175?: true
    QtyHour200?: true
    RealHours?: true
    BreakMinutes?: true
    WorkedDays?: true
    IsCloseSalary?: true
  }

  export type EmployeeHoursByLocalityTotalsMaxAggregateInputType = {
    EmployeeHoursByLocalityTotalsId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    MonthManaged?: true
    YearManaged?: true
    EmployeeId?: true
    EmployeeHoursLocalityId?: true
    QtyHour?: true
    QtyHour125?: true
    QtyHour150?: true
    QtyHour175?: true
    QtyHour200?: true
    RealHours?: true
    BreakMinutes?: true
    WorkedDays?: true
    IsCloseSalary?: true
  }

  export type EmployeeHoursByLocalityTotalsCountAggregateInputType = {
    EmployeeHoursByLocalityTotalsId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    MonthManaged?: true
    YearManaged?: true
    EmployeeId?: true
    EmployeeHoursLocalityId?: true
    QtyHour?: true
    QtyHour125?: true
    QtyHour150?: true
    QtyHour175?: true
    QtyHour200?: true
    RealHours?: true
    BreakMinutes?: true
    WorkedDays?: true
    IsCloseSalary?: true
    _all?: true
  }

  export type EmployeeHoursByLocalityTotalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursByLocalityTotals to aggregate.
     */
    where?: EmployeeHoursByLocalityTotalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursByLocalityTotals to fetch.
     */
    orderBy?: EmployeeHoursByLocalityTotalsOrderByWithRelationInput | EmployeeHoursByLocalityTotalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeHoursByLocalityTotalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursByLocalityTotals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursByLocalityTotals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeHoursByLocalityTotals
    **/
    _count?: true | EmployeeHoursByLocalityTotalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeHoursByLocalityTotalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeHoursByLocalityTotalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeHoursByLocalityTotalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeHoursByLocalityTotalsMaxAggregateInputType
  }

  export type GetEmployeeHoursByLocalityTotalsAggregateType<T extends EmployeeHoursByLocalityTotalsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeHoursByLocalityTotals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeHoursByLocalityTotals[P]>
      : GetScalarType<T[P], AggregateEmployeeHoursByLocalityTotals[P]>
  }




  export type EmployeeHoursByLocalityTotalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursByLocalityTotalsWhereInput
    orderBy?: EmployeeHoursByLocalityTotalsOrderByWithAggregationInput | EmployeeHoursByLocalityTotalsOrderByWithAggregationInput[]
    by: EmployeeHoursByLocalityTotalsScalarFieldEnum[] | EmployeeHoursByLocalityTotalsScalarFieldEnum
    having?: EmployeeHoursByLocalityTotalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeHoursByLocalityTotalsCountAggregateInputType | true
    _avg?: EmployeeHoursByLocalityTotalsAvgAggregateInputType
    _sum?: EmployeeHoursByLocalityTotalsSumAggregateInputType
    _min?: EmployeeHoursByLocalityTotalsMinAggregateInputType
    _max?: EmployeeHoursByLocalityTotalsMaxAggregateInputType
  }

  export type EmployeeHoursByLocalityTotalsGroupByOutputType = {
    EmployeeHoursByLocalityTotalsId: string
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string
    MonthManaged: number
    YearManaged: number
    EmployeeId: number
    EmployeeHoursLocalityId: string
    QtyHour: number | null
    QtyHour125: number | null
    QtyHour150: number | null
    QtyHour175: number | null
    QtyHour200: number | null
    RealHours: number | null
    BreakMinutes: number | null
    WorkedDays: number | null
    IsCloseSalary: number
    _count: EmployeeHoursByLocalityTotalsCountAggregateOutputType | null
    _avg: EmployeeHoursByLocalityTotalsAvgAggregateOutputType | null
    _sum: EmployeeHoursByLocalityTotalsSumAggregateOutputType | null
    _min: EmployeeHoursByLocalityTotalsMinAggregateOutputType | null
    _max: EmployeeHoursByLocalityTotalsMaxAggregateOutputType | null
  }

  type GetEmployeeHoursByLocalityTotalsGroupByPayload<T extends EmployeeHoursByLocalityTotalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeHoursByLocalityTotalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeHoursByLocalityTotalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeHoursByLocalityTotalsGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeHoursByLocalityTotalsGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeHoursByLocalityTotalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmployeeHoursByLocalityTotalsId?: boolean
    CreatedAt?: boolean
    CompanyIdGeneralCRM?: boolean
    MonthManaged?: boolean
    YearManaged?: boolean
    EmployeeId?: boolean
    EmployeeHoursLocalityId?: boolean
    QtyHour?: boolean
    QtyHour125?: boolean
    QtyHour150?: boolean
    QtyHour175?: boolean
    QtyHour200?: boolean
    RealHours?: boolean
    BreakMinutes?: boolean
    WorkedDays?: boolean
    IsCloseSalary?: boolean
    EmployeeHoursLocalities?: boolean | EmployeeHoursLocalitiesDefaultArgs<ExtArgs>
    EmployeeHoursByLocalityTotalsActionType?: boolean | EmployeeHoursByLocalityTotals$EmployeeHoursByLocalityTotalsActionTypeArgs<ExtArgs>
    _count?: boolean | EmployeeHoursByLocalityTotalsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeHoursByLocalityTotals"]>


  export type EmployeeHoursByLocalityTotalsSelectScalar = {
    EmployeeHoursByLocalityTotalsId?: boolean
    CreatedAt?: boolean
    CompanyIdGeneralCRM?: boolean
    MonthManaged?: boolean
    YearManaged?: boolean
    EmployeeId?: boolean
    EmployeeHoursLocalityId?: boolean
    QtyHour?: boolean
    QtyHour125?: boolean
    QtyHour150?: boolean
    QtyHour175?: boolean
    QtyHour200?: boolean
    RealHours?: boolean
    BreakMinutes?: boolean
    WorkedDays?: boolean
    IsCloseSalary?: boolean
  }

  export type EmployeeHoursByLocalityTotalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeHoursLocalities?: boolean | EmployeeHoursLocalitiesDefaultArgs<ExtArgs>
    EmployeeHoursByLocalityTotalsActionType?: boolean | EmployeeHoursByLocalityTotals$EmployeeHoursByLocalityTotalsActionTypeArgs<ExtArgs>
    _count?: boolean | EmployeeHoursByLocalityTotalsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmployeeHoursByLocalityTotalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeHoursByLocalityTotals"
    objects: {
      EmployeeHoursLocalities: Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>
      EmployeeHoursByLocalityTotalsActionType: Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      EmployeeHoursByLocalityTotalsId: string
      CreatedAt: Date | null
      CompanyIdGeneralCRM: string
      MonthManaged: number
      YearManaged: number
      EmployeeId: number
      EmployeeHoursLocalityId: string
      QtyHour: number | null
      QtyHour125: number | null
      QtyHour150: number | null
      QtyHour175: number | null
      QtyHour200: number | null
      RealHours: number | null
      BreakMinutes: number | null
      WorkedDays: number | null
      IsCloseSalary: number
    }, ExtArgs["result"]["employeeHoursByLocalityTotals"]>
    composites: {}
  }

  type EmployeeHoursByLocalityTotalsGetPayload<S extends boolean | null | undefined | EmployeeHoursByLocalityTotalsDefaultArgs> = $Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsPayload, S>

  type EmployeeHoursByLocalityTotalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeHoursByLocalityTotalsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeHoursByLocalityTotalsCountAggregateInputType | true
    }

  export interface EmployeeHoursByLocalityTotalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeHoursByLocalityTotals'], meta: { name: 'EmployeeHoursByLocalityTotals' } }
    /**
     * Find zero or one EmployeeHoursByLocalityTotals that matches the filter.
     * @param {EmployeeHoursByLocalityTotalsFindUniqueArgs} args - Arguments to find a EmployeeHoursByLocalityTotals
     * @example
     * // Get one EmployeeHoursByLocalityTotals
     * const employeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeHoursByLocalityTotalsFindUniqueArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsFindUniqueArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeHoursByLocalityTotals that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeHoursByLocalityTotalsFindUniqueOrThrowArgs} args - Arguments to find a EmployeeHoursByLocalityTotals
     * @example
     * // Get one EmployeeHoursByLocalityTotals
     * const employeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeHoursByLocalityTotalsFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeHoursByLocalityTotals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsFindFirstArgs} args - Arguments to find a EmployeeHoursByLocalityTotals
     * @example
     * // Get one EmployeeHoursByLocalityTotals
     * const employeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeHoursByLocalityTotalsFindFirstArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityTotalsFindFirstArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeHoursByLocalityTotals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsFindFirstOrThrowArgs} args - Arguments to find a EmployeeHoursByLocalityTotals
     * @example
     * // Get one EmployeeHoursByLocalityTotals
     * const employeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeHoursByLocalityTotalsFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityTotalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeHoursByLocalityTotals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeHoursByLocalityTotals
     * const employeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.findMany()
     * 
     * // Get first 10 EmployeeHoursByLocalityTotals
     * const employeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.findMany({ take: 10 })
     * 
     * // Only select the `EmployeeHoursByLocalityTotalsId`
     * const employeeHoursByLocalityTotalsWithEmployeeHoursByLocalityTotalsIdOnly = await prisma.employeeHoursByLocalityTotals.findMany({ select: { EmployeeHoursByLocalityTotalsId: true } })
     * 
     */
    findMany<T extends EmployeeHoursByLocalityTotalsFindManyArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityTotalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeHoursByLocalityTotals.
     * @param {EmployeeHoursByLocalityTotalsCreateArgs} args - Arguments to create a EmployeeHoursByLocalityTotals.
     * @example
     * // Create one EmployeeHoursByLocalityTotals
     * const EmployeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.create({
     *   data: {
     *     // ... data to create a EmployeeHoursByLocalityTotals
     *   }
     * })
     * 
     */
    create<T extends EmployeeHoursByLocalityTotalsCreateArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsCreateArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeHoursByLocalityTotals.
     * @param {EmployeeHoursByLocalityTotalsCreateManyArgs} args - Arguments to create many EmployeeHoursByLocalityTotals.
     * @example
     * // Create many EmployeeHoursByLocalityTotals
     * const employeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeHoursByLocalityTotalsCreateManyArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityTotalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeHoursByLocalityTotals.
     * @param {EmployeeHoursByLocalityTotalsDeleteArgs} args - Arguments to delete one EmployeeHoursByLocalityTotals.
     * @example
     * // Delete one EmployeeHoursByLocalityTotals
     * const EmployeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.delete({
     *   where: {
     *     // ... filter to delete one EmployeeHoursByLocalityTotals
     *   }
     * })
     * 
     */
    delete<T extends EmployeeHoursByLocalityTotalsDeleteArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsDeleteArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeHoursByLocalityTotals.
     * @param {EmployeeHoursByLocalityTotalsUpdateArgs} args - Arguments to update one EmployeeHoursByLocalityTotals.
     * @example
     * // Update one EmployeeHoursByLocalityTotals
     * const employeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeHoursByLocalityTotalsUpdateArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsUpdateArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeHoursByLocalityTotals.
     * @param {EmployeeHoursByLocalityTotalsDeleteManyArgs} args - Arguments to filter EmployeeHoursByLocalityTotals to delete.
     * @example
     * // Delete a few EmployeeHoursByLocalityTotals
     * const { count } = await prisma.employeeHoursByLocalityTotals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeHoursByLocalityTotalsDeleteManyArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityTotalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeHoursByLocalityTotals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeHoursByLocalityTotals
     * const employeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeHoursByLocalityTotalsUpdateManyArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeHoursByLocalityTotals.
     * @param {EmployeeHoursByLocalityTotalsUpsertArgs} args - Arguments to update or create a EmployeeHoursByLocalityTotals.
     * @example
     * // Update or create a EmployeeHoursByLocalityTotals
     * const employeeHoursByLocalityTotals = await prisma.employeeHoursByLocalityTotals.upsert({
     *   create: {
     *     // ... data to create a EmployeeHoursByLocalityTotals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeHoursByLocalityTotals we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeHoursByLocalityTotalsUpsertArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsUpsertArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeHoursByLocalityTotals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsCountArgs} args - Arguments to filter EmployeeHoursByLocalityTotals to count.
     * @example
     * // Count the number of EmployeeHoursByLocalityTotals
     * const count = await prisma.employeeHoursByLocalityTotals.count({
     *   where: {
     *     // ... the filter for the EmployeeHoursByLocalityTotals we want to count
     *   }
     * })
    **/
    count<T extends EmployeeHoursByLocalityTotalsCountArgs>(
      args?: Subset<T, EmployeeHoursByLocalityTotalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeHoursByLocalityTotalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeHoursByLocalityTotals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeHoursByLocalityTotalsAggregateArgs>(args: Subset<T, EmployeeHoursByLocalityTotalsAggregateArgs>): Prisma.PrismaPromise<GetEmployeeHoursByLocalityTotalsAggregateType<T>>

    /**
     * Group by EmployeeHoursByLocalityTotals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeHoursByLocalityTotalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeHoursByLocalityTotalsGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeHoursByLocalityTotalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeHoursByLocalityTotalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeHoursByLocalityTotalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeHoursByLocalityTotals model
   */
  readonly fields: EmployeeHoursByLocalityTotalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeHoursByLocalityTotals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeHoursByLocalityTotalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EmployeeHoursLocalities<T extends EmployeeHoursLocalitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHoursLocalitiesDefaultArgs<ExtArgs>>): Prisma__EmployeeHoursLocalitiesClient<$Result.GetResult<Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    EmployeeHoursByLocalityTotalsActionType<T extends EmployeeHoursByLocalityTotals$EmployeeHoursByLocalityTotalsActionTypeArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHoursByLocalityTotals$EmployeeHoursByLocalityTotalsActionTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeHoursByLocalityTotals model
   */ 
  interface EmployeeHoursByLocalityTotalsFieldRefs {
    readonly EmployeeHoursByLocalityTotalsId: FieldRef<"EmployeeHoursByLocalityTotals", 'String'>
    readonly CreatedAt: FieldRef<"EmployeeHoursByLocalityTotals", 'DateTime'>
    readonly CompanyIdGeneralCRM: FieldRef<"EmployeeHoursByLocalityTotals", 'String'>
    readonly MonthManaged: FieldRef<"EmployeeHoursByLocalityTotals", 'Int'>
    readonly YearManaged: FieldRef<"EmployeeHoursByLocalityTotals", 'Int'>
    readonly EmployeeId: FieldRef<"EmployeeHoursByLocalityTotals", 'Int'>
    readonly EmployeeHoursLocalityId: FieldRef<"EmployeeHoursByLocalityTotals", 'String'>
    readonly QtyHour: FieldRef<"EmployeeHoursByLocalityTotals", 'Float'>
    readonly QtyHour125: FieldRef<"EmployeeHoursByLocalityTotals", 'Float'>
    readonly QtyHour150: FieldRef<"EmployeeHoursByLocalityTotals", 'Float'>
    readonly QtyHour175: FieldRef<"EmployeeHoursByLocalityTotals", 'Float'>
    readonly QtyHour200: FieldRef<"EmployeeHoursByLocalityTotals", 'Float'>
    readonly RealHours: FieldRef<"EmployeeHoursByLocalityTotals", 'Float'>
    readonly BreakMinutes: FieldRef<"EmployeeHoursByLocalityTotals", 'Float'>
    readonly WorkedDays: FieldRef<"EmployeeHoursByLocalityTotals", 'Int'>
    readonly IsCloseSalary: FieldRef<"EmployeeHoursByLocalityTotals", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeHoursByLocalityTotals findUnique
   */
  export type EmployeeHoursByLocalityTotalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotals
     */
    select?: EmployeeHoursByLocalityTotalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocalityTotals to fetch.
     */
    where: EmployeeHoursByLocalityTotalsWhereUniqueInput
  }

  /**
   * EmployeeHoursByLocalityTotals findUniqueOrThrow
   */
  export type EmployeeHoursByLocalityTotalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotals
     */
    select?: EmployeeHoursByLocalityTotalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocalityTotals to fetch.
     */
    where: EmployeeHoursByLocalityTotalsWhereUniqueInput
  }

  /**
   * EmployeeHoursByLocalityTotals findFirst
   */
  export type EmployeeHoursByLocalityTotalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotals
     */
    select?: EmployeeHoursByLocalityTotalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocalityTotals to fetch.
     */
    where?: EmployeeHoursByLocalityTotalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursByLocalityTotals to fetch.
     */
    orderBy?: EmployeeHoursByLocalityTotalsOrderByWithRelationInput | EmployeeHoursByLocalityTotalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursByLocalityTotals.
     */
    cursor?: EmployeeHoursByLocalityTotalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursByLocalityTotals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursByLocalityTotals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursByLocalityTotals.
     */
    distinct?: EmployeeHoursByLocalityTotalsScalarFieldEnum | EmployeeHoursByLocalityTotalsScalarFieldEnum[]
  }

  /**
   * EmployeeHoursByLocalityTotals findFirstOrThrow
   */
  export type EmployeeHoursByLocalityTotalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotals
     */
    select?: EmployeeHoursByLocalityTotalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocalityTotals to fetch.
     */
    where?: EmployeeHoursByLocalityTotalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursByLocalityTotals to fetch.
     */
    orderBy?: EmployeeHoursByLocalityTotalsOrderByWithRelationInput | EmployeeHoursByLocalityTotalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursByLocalityTotals.
     */
    cursor?: EmployeeHoursByLocalityTotalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursByLocalityTotals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursByLocalityTotals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursByLocalityTotals.
     */
    distinct?: EmployeeHoursByLocalityTotalsScalarFieldEnum | EmployeeHoursByLocalityTotalsScalarFieldEnum[]
  }

  /**
   * EmployeeHoursByLocalityTotals findMany
   */
  export type EmployeeHoursByLocalityTotalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotals
     */
    select?: EmployeeHoursByLocalityTotalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocalityTotals to fetch.
     */
    where?: EmployeeHoursByLocalityTotalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursByLocalityTotals to fetch.
     */
    orderBy?: EmployeeHoursByLocalityTotalsOrderByWithRelationInput | EmployeeHoursByLocalityTotalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeHoursByLocalityTotals.
     */
    cursor?: EmployeeHoursByLocalityTotalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursByLocalityTotals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursByLocalityTotals.
     */
    skip?: number
    distinct?: EmployeeHoursByLocalityTotalsScalarFieldEnum | EmployeeHoursByLocalityTotalsScalarFieldEnum[]
  }

  /**
   * EmployeeHoursByLocalityTotals create
   */
  export type EmployeeHoursByLocalityTotalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotals
     */
    select?: EmployeeHoursByLocalityTotalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeHoursByLocalityTotals.
     */
    data: XOR<EmployeeHoursByLocalityTotalsCreateInput, EmployeeHoursByLocalityTotalsUncheckedCreateInput>
  }

  /**
   * EmployeeHoursByLocalityTotals createMany
   */
  export type EmployeeHoursByLocalityTotalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeHoursByLocalityTotals.
     */
    data: EmployeeHoursByLocalityTotalsCreateManyInput | EmployeeHoursByLocalityTotalsCreateManyInput[]
  }

  /**
   * EmployeeHoursByLocalityTotals update
   */
  export type EmployeeHoursByLocalityTotalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotals
     */
    select?: EmployeeHoursByLocalityTotalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeHoursByLocalityTotals.
     */
    data: XOR<EmployeeHoursByLocalityTotalsUpdateInput, EmployeeHoursByLocalityTotalsUncheckedUpdateInput>
    /**
     * Choose, which EmployeeHoursByLocalityTotals to update.
     */
    where: EmployeeHoursByLocalityTotalsWhereUniqueInput
  }

  /**
   * EmployeeHoursByLocalityTotals updateMany
   */
  export type EmployeeHoursByLocalityTotalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeHoursByLocalityTotals.
     */
    data: XOR<EmployeeHoursByLocalityTotalsUpdateManyMutationInput, EmployeeHoursByLocalityTotalsUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeHoursByLocalityTotals to update
     */
    where?: EmployeeHoursByLocalityTotalsWhereInput
  }

  /**
   * EmployeeHoursByLocalityTotals upsert
   */
  export type EmployeeHoursByLocalityTotalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotals
     */
    select?: EmployeeHoursByLocalityTotalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeHoursByLocalityTotals to update in case it exists.
     */
    where: EmployeeHoursByLocalityTotalsWhereUniqueInput
    /**
     * In case the EmployeeHoursByLocalityTotals found by the `where` argument doesn't exist, create a new EmployeeHoursByLocalityTotals with this data.
     */
    create: XOR<EmployeeHoursByLocalityTotalsCreateInput, EmployeeHoursByLocalityTotalsUncheckedCreateInput>
    /**
     * In case the EmployeeHoursByLocalityTotals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeHoursByLocalityTotalsUpdateInput, EmployeeHoursByLocalityTotalsUncheckedUpdateInput>
  }

  /**
   * EmployeeHoursByLocalityTotals delete
   */
  export type EmployeeHoursByLocalityTotalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotals
     */
    select?: EmployeeHoursByLocalityTotalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsInclude<ExtArgs> | null
    /**
     * Filter which EmployeeHoursByLocalityTotals to delete.
     */
    where: EmployeeHoursByLocalityTotalsWhereUniqueInput
  }

  /**
   * EmployeeHoursByLocalityTotals deleteMany
   */
  export type EmployeeHoursByLocalityTotalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursByLocalityTotals to delete
     */
    where?: EmployeeHoursByLocalityTotalsWhereInput
  }

  /**
   * EmployeeHoursByLocalityTotals.EmployeeHoursByLocalityTotalsActionType
   */
  export type EmployeeHoursByLocalityTotals$EmployeeHoursByLocalityTotalsActionTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsActionType
     */
    select?: EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs> | null
    where?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
    orderBy?: EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput | EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput[]
    cursor?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum | EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum[]
  }

  /**
   * EmployeeHoursByLocalityTotals without action
   */
  export type EmployeeHoursByLocalityTotalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotals
     */
    select?: EmployeeHoursByLocalityTotalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeHoursByLocalityTotalsActionType
   */

  export type AggregateEmployeeHoursByLocalityTotalsActionType = {
    _count: EmployeeHoursByLocalityTotalsActionTypeCountAggregateOutputType | null
    _avg: EmployeeHoursByLocalityTotalsActionTypeAvgAggregateOutputType | null
    _sum: EmployeeHoursByLocalityTotalsActionTypeSumAggregateOutputType | null
    _min: EmployeeHoursByLocalityTotalsActionTypeMinAggregateOutputType | null
    _max: EmployeeHoursByLocalityTotalsActionTypeMaxAggregateOutputType | null
  }

  export type EmployeeHoursByLocalityTotalsActionTypeAvgAggregateOutputType = {
    ActionTypeId: number | null
    TotalActionType: number | null
  }

  export type EmployeeHoursByLocalityTotalsActionTypeSumAggregateOutputType = {
    ActionTypeId: number | null
    TotalActionType: number | null
  }

  export type EmployeeHoursByLocalityTotalsActionTypeMinAggregateOutputType = {
    EmployeeHoursByLocalityTotalsActionTypeId: string | null
    CreatedAt: Date | null
    EmployeeHoursByLocalityTotalsId: string | null
    ActionTypeId: number | null
    TotalActionType: number | null
  }

  export type EmployeeHoursByLocalityTotalsActionTypeMaxAggregateOutputType = {
    EmployeeHoursByLocalityTotalsActionTypeId: string | null
    CreatedAt: Date | null
    EmployeeHoursByLocalityTotalsId: string | null
    ActionTypeId: number | null
    TotalActionType: number | null
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCountAggregateOutputType = {
    EmployeeHoursByLocalityTotalsActionTypeId: number
    CreatedAt: number
    EmployeeHoursByLocalityTotalsId: number
    ActionTypeId: number
    TotalActionType: number
    _all: number
  }


  export type EmployeeHoursByLocalityTotalsActionTypeAvgAggregateInputType = {
    ActionTypeId?: true
    TotalActionType?: true
  }

  export type EmployeeHoursByLocalityTotalsActionTypeSumAggregateInputType = {
    ActionTypeId?: true
    TotalActionType?: true
  }

  export type EmployeeHoursByLocalityTotalsActionTypeMinAggregateInputType = {
    EmployeeHoursByLocalityTotalsActionTypeId?: true
    CreatedAt?: true
    EmployeeHoursByLocalityTotalsId?: true
    ActionTypeId?: true
    TotalActionType?: true
  }

  export type EmployeeHoursByLocalityTotalsActionTypeMaxAggregateInputType = {
    EmployeeHoursByLocalityTotalsActionTypeId?: true
    CreatedAt?: true
    EmployeeHoursByLocalityTotalsId?: true
    ActionTypeId?: true
    TotalActionType?: true
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCountAggregateInputType = {
    EmployeeHoursByLocalityTotalsActionTypeId?: true
    CreatedAt?: true
    EmployeeHoursByLocalityTotalsId?: true
    ActionTypeId?: true
    TotalActionType?: true
    _all?: true
  }

  export type EmployeeHoursByLocalityTotalsActionTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursByLocalityTotalsActionType to aggregate.
     */
    where?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursByLocalityTotalsActionTypes to fetch.
     */
    orderBy?: EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput | EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursByLocalityTotalsActionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursByLocalityTotalsActionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeHoursByLocalityTotalsActionTypes
    **/
    _count?: true | EmployeeHoursByLocalityTotalsActionTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeHoursByLocalityTotalsActionTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeHoursByLocalityTotalsActionTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeHoursByLocalityTotalsActionTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeHoursByLocalityTotalsActionTypeMaxAggregateInputType
  }

  export type GetEmployeeHoursByLocalityTotalsActionTypeAggregateType<T extends EmployeeHoursByLocalityTotalsActionTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeHoursByLocalityTotalsActionType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeHoursByLocalityTotalsActionType[P]>
      : GetScalarType<T[P], AggregateEmployeeHoursByLocalityTotalsActionType[P]>
  }




  export type EmployeeHoursByLocalityTotalsActionTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
    orderBy?: EmployeeHoursByLocalityTotalsActionTypeOrderByWithAggregationInput | EmployeeHoursByLocalityTotalsActionTypeOrderByWithAggregationInput[]
    by: EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum[] | EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum
    having?: EmployeeHoursByLocalityTotalsActionTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeHoursByLocalityTotalsActionTypeCountAggregateInputType | true
    _avg?: EmployeeHoursByLocalityTotalsActionTypeAvgAggregateInputType
    _sum?: EmployeeHoursByLocalityTotalsActionTypeSumAggregateInputType
    _min?: EmployeeHoursByLocalityTotalsActionTypeMinAggregateInputType
    _max?: EmployeeHoursByLocalityTotalsActionTypeMaxAggregateInputType
  }

  export type EmployeeHoursByLocalityTotalsActionTypeGroupByOutputType = {
    EmployeeHoursByLocalityTotalsActionTypeId: string
    CreatedAt: Date | null
    EmployeeHoursByLocalityTotalsId: string
    ActionTypeId: number
    TotalActionType: number
    _count: EmployeeHoursByLocalityTotalsActionTypeCountAggregateOutputType | null
    _avg: EmployeeHoursByLocalityTotalsActionTypeAvgAggregateOutputType | null
    _sum: EmployeeHoursByLocalityTotalsActionTypeSumAggregateOutputType | null
    _min: EmployeeHoursByLocalityTotalsActionTypeMinAggregateOutputType | null
    _max: EmployeeHoursByLocalityTotalsActionTypeMaxAggregateOutputType | null
  }

  type GetEmployeeHoursByLocalityTotalsActionTypeGroupByPayload<T extends EmployeeHoursByLocalityTotalsActionTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeHoursByLocalityTotalsActionTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeHoursByLocalityTotalsActionTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeHoursByLocalityTotalsActionTypeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeHoursByLocalityTotalsActionTypeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmployeeHoursByLocalityTotalsActionTypeId?: boolean
    CreatedAt?: boolean
    EmployeeHoursByLocalityTotalsId?: boolean
    ActionTypeId?: boolean
    TotalActionType?: boolean
    Lkup_ActionType?: boolean | Lkup_ActionTypeDefaultArgs<ExtArgs>
    EmployeeHoursByLocalityTotals?: boolean | EmployeeHoursByLocalityTotalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeHoursByLocalityTotalsActionType"]>


  export type EmployeeHoursByLocalityTotalsActionTypeSelectScalar = {
    EmployeeHoursByLocalityTotalsActionTypeId?: boolean
    CreatedAt?: boolean
    EmployeeHoursByLocalityTotalsId?: boolean
    ActionTypeId?: boolean
    TotalActionType?: boolean
  }

  export type EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lkup_ActionType?: boolean | Lkup_ActionTypeDefaultArgs<ExtArgs>
    EmployeeHoursByLocalityTotals?: boolean | EmployeeHoursByLocalityTotalsDefaultArgs<ExtArgs>
  }

  export type $EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeHoursByLocalityTotalsActionType"
    objects: {
      Lkup_ActionType: Prisma.$Lkup_ActionTypePayload<ExtArgs>
      EmployeeHoursByLocalityTotals: Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      EmployeeHoursByLocalityTotalsActionTypeId: string
      CreatedAt: Date | null
      EmployeeHoursByLocalityTotalsId: string
      ActionTypeId: number
      TotalActionType: number
    }, ExtArgs["result"]["employeeHoursByLocalityTotalsActionType"]>
    composites: {}
  }

  type EmployeeHoursByLocalityTotalsActionTypeGetPayload<S extends boolean | null | undefined | EmployeeHoursByLocalityTotalsActionTypeDefaultArgs> = $Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload, S>

  type EmployeeHoursByLocalityTotalsActionTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeHoursByLocalityTotalsActionTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeHoursByLocalityTotalsActionTypeCountAggregateInputType | true
    }

  export interface EmployeeHoursByLocalityTotalsActionTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeHoursByLocalityTotalsActionType'], meta: { name: 'EmployeeHoursByLocalityTotalsActionType' } }
    /**
     * Find zero or one EmployeeHoursByLocalityTotalsActionType that matches the filter.
     * @param {EmployeeHoursByLocalityTotalsActionTypeFindUniqueArgs} args - Arguments to find a EmployeeHoursByLocalityTotalsActionType
     * @example
     * // Get one EmployeeHoursByLocalityTotalsActionType
     * const employeeHoursByLocalityTotalsActionType = await prisma.employeeHoursByLocalityTotalsActionType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeHoursByLocalityTotalsActionTypeFindUniqueArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsActionTypeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsActionTypeClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeHoursByLocalityTotalsActionType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeHoursByLocalityTotalsActionTypeFindUniqueOrThrowArgs} args - Arguments to find a EmployeeHoursByLocalityTotalsActionType
     * @example
     * // Get one EmployeeHoursByLocalityTotalsActionType
     * const employeeHoursByLocalityTotalsActionType = await prisma.employeeHoursByLocalityTotalsActionType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeHoursByLocalityTotalsActionTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsActionTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsActionTypeClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeHoursByLocalityTotalsActionType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsActionTypeFindFirstArgs} args - Arguments to find a EmployeeHoursByLocalityTotalsActionType
     * @example
     * // Get one EmployeeHoursByLocalityTotalsActionType
     * const employeeHoursByLocalityTotalsActionType = await prisma.employeeHoursByLocalityTotalsActionType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeHoursByLocalityTotalsActionTypeFindFirstArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityTotalsActionTypeFindFirstArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsActionTypeClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeHoursByLocalityTotalsActionType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsActionTypeFindFirstOrThrowArgs} args - Arguments to find a EmployeeHoursByLocalityTotalsActionType
     * @example
     * // Get one EmployeeHoursByLocalityTotalsActionType
     * const employeeHoursByLocalityTotalsActionType = await prisma.employeeHoursByLocalityTotalsActionType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeHoursByLocalityTotalsActionTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityTotalsActionTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsActionTypeClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeHoursByLocalityTotalsActionTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsActionTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeHoursByLocalityTotalsActionTypes
     * const employeeHoursByLocalityTotalsActionTypes = await prisma.employeeHoursByLocalityTotalsActionType.findMany()
     * 
     * // Get first 10 EmployeeHoursByLocalityTotalsActionTypes
     * const employeeHoursByLocalityTotalsActionTypes = await prisma.employeeHoursByLocalityTotalsActionType.findMany({ take: 10 })
     * 
     * // Only select the `EmployeeHoursByLocalityTotalsActionTypeId`
     * const employeeHoursByLocalityTotalsActionTypeWithEmployeeHoursByLocalityTotalsActionTypeIdOnly = await prisma.employeeHoursByLocalityTotalsActionType.findMany({ select: { EmployeeHoursByLocalityTotalsActionTypeId: true } })
     * 
     */
    findMany<T extends EmployeeHoursByLocalityTotalsActionTypeFindManyArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityTotalsActionTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeHoursByLocalityTotalsActionType.
     * @param {EmployeeHoursByLocalityTotalsActionTypeCreateArgs} args - Arguments to create a EmployeeHoursByLocalityTotalsActionType.
     * @example
     * // Create one EmployeeHoursByLocalityTotalsActionType
     * const EmployeeHoursByLocalityTotalsActionType = await prisma.employeeHoursByLocalityTotalsActionType.create({
     *   data: {
     *     // ... data to create a EmployeeHoursByLocalityTotalsActionType
     *   }
     * })
     * 
     */
    create<T extends EmployeeHoursByLocalityTotalsActionTypeCreateArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsActionTypeCreateArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsActionTypeClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeHoursByLocalityTotalsActionTypes.
     * @param {EmployeeHoursByLocalityTotalsActionTypeCreateManyArgs} args - Arguments to create many EmployeeHoursByLocalityTotalsActionTypes.
     * @example
     * // Create many EmployeeHoursByLocalityTotalsActionTypes
     * const employeeHoursByLocalityTotalsActionType = await prisma.employeeHoursByLocalityTotalsActionType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeHoursByLocalityTotalsActionTypeCreateManyArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityTotalsActionTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeHoursByLocalityTotalsActionType.
     * @param {EmployeeHoursByLocalityTotalsActionTypeDeleteArgs} args - Arguments to delete one EmployeeHoursByLocalityTotalsActionType.
     * @example
     * // Delete one EmployeeHoursByLocalityTotalsActionType
     * const EmployeeHoursByLocalityTotalsActionType = await prisma.employeeHoursByLocalityTotalsActionType.delete({
     *   where: {
     *     // ... filter to delete one EmployeeHoursByLocalityTotalsActionType
     *   }
     * })
     * 
     */
    delete<T extends EmployeeHoursByLocalityTotalsActionTypeDeleteArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsActionTypeDeleteArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsActionTypeClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeHoursByLocalityTotalsActionType.
     * @param {EmployeeHoursByLocalityTotalsActionTypeUpdateArgs} args - Arguments to update one EmployeeHoursByLocalityTotalsActionType.
     * @example
     * // Update one EmployeeHoursByLocalityTotalsActionType
     * const employeeHoursByLocalityTotalsActionType = await prisma.employeeHoursByLocalityTotalsActionType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeHoursByLocalityTotalsActionTypeUpdateArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsActionTypeUpdateArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsActionTypeClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeHoursByLocalityTotalsActionTypes.
     * @param {EmployeeHoursByLocalityTotalsActionTypeDeleteManyArgs} args - Arguments to filter EmployeeHoursByLocalityTotalsActionTypes to delete.
     * @example
     * // Delete a few EmployeeHoursByLocalityTotalsActionTypes
     * const { count } = await prisma.employeeHoursByLocalityTotalsActionType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeHoursByLocalityTotalsActionTypeDeleteManyArgs>(args?: SelectSubset<T, EmployeeHoursByLocalityTotalsActionTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeHoursByLocalityTotalsActionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsActionTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeHoursByLocalityTotalsActionTypes
     * const employeeHoursByLocalityTotalsActionType = await prisma.employeeHoursByLocalityTotalsActionType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeHoursByLocalityTotalsActionTypeUpdateManyArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsActionTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeHoursByLocalityTotalsActionType.
     * @param {EmployeeHoursByLocalityTotalsActionTypeUpsertArgs} args - Arguments to update or create a EmployeeHoursByLocalityTotalsActionType.
     * @example
     * // Update or create a EmployeeHoursByLocalityTotalsActionType
     * const employeeHoursByLocalityTotalsActionType = await prisma.employeeHoursByLocalityTotalsActionType.upsert({
     *   create: {
     *     // ... data to create a EmployeeHoursByLocalityTotalsActionType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeHoursByLocalityTotalsActionType we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeHoursByLocalityTotalsActionTypeUpsertArgs>(args: SelectSubset<T, EmployeeHoursByLocalityTotalsActionTypeUpsertArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsActionTypeClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeHoursByLocalityTotalsActionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsActionTypeCountArgs} args - Arguments to filter EmployeeHoursByLocalityTotalsActionTypes to count.
     * @example
     * // Count the number of EmployeeHoursByLocalityTotalsActionTypes
     * const count = await prisma.employeeHoursByLocalityTotalsActionType.count({
     *   where: {
     *     // ... the filter for the EmployeeHoursByLocalityTotalsActionTypes we want to count
     *   }
     * })
    **/
    count<T extends EmployeeHoursByLocalityTotalsActionTypeCountArgs>(
      args?: Subset<T, EmployeeHoursByLocalityTotalsActionTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeHoursByLocalityTotalsActionTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeHoursByLocalityTotalsActionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsActionTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeHoursByLocalityTotalsActionTypeAggregateArgs>(args: Subset<T, EmployeeHoursByLocalityTotalsActionTypeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeHoursByLocalityTotalsActionTypeAggregateType<T>>

    /**
     * Group by EmployeeHoursByLocalityTotalsActionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursByLocalityTotalsActionTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeHoursByLocalityTotalsActionTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeHoursByLocalityTotalsActionTypeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeHoursByLocalityTotalsActionTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeHoursByLocalityTotalsActionTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeHoursByLocalityTotalsActionTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeHoursByLocalityTotalsActionType model
   */
  readonly fields: EmployeeHoursByLocalityTotalsActionTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeHoursByLocalityTotalsActionType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeHoursByLocalityTotalsActionTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lkup_ActionType<T extends Lkup_ActionTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Lkup_ActionTypeDefaultArgs<ExtArgs>>): Prisma__Lkup_ActionTypeClient<$Result.GetResult<Prisma.$Lkup_ActionTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    EmployeeHoursByLocalityTotals<T extends EmployeeHoursByLocalityTotalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHoursByLocalityTotalsDefaultArgs<ExtArgs>>): Prisma__EmployeeHoursByLocalityTotalsClient<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeHoursByLocalityTotalsActionType model
   */ 
  interface EmployeeHoursByLocalityTotalsActionTypeFieldRefs {
    readonly EmployeeHoursByLocalityTotalsActionTypeId: FieldRef<"EmployeeHoursByLocalityTotalsActionType", 'String'>
    readonly CreatedAt: FieldRef<"EmployeeHoursByLocalityTotalsActionType", 'DateTime'>
    readonly EmployeeHoursByLocalityTotalsId: FieldRef<"EmployeeHoursByLocalityTotalsActionType", 'String'>
    readonly ActionTypeId: FieldRef<"EmployeeHoursByLocalityTotalsActionType", 'Int'>
    readonly TotalActionType: FieldRef<"EmployeeHoursByLocalityTotalsActionType", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeHoursByLocalityTotalsActionType findUnique
   */
  export type EmployeeHoursByLocalityTotalsActionTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsActionType
     */
    select?: EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocalityTotalsActionType to fetch.
     */
    where: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
  }

  /**
   * EmployeeHoursByLocalityTotalsActionType findUniqueOrThrow
   */
  export type EmployeeHoursByLocalityTotalsActionTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsActionType
     */
    select?: EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocalityTotalsActionType to fetch.
     */
    where: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
  }

  /**
   * EmployeeHoursByLocalityTotalsActionType findFirst
   */
  export type EmployeeHoursByLocalityTotalsActionTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsActionType
     */
    select?: EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocalityTotalsActionType to fetch.
     */
    where?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursByLocalityTotalsActionTypes to fetch.
     */
    orderBy?: EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput | EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursByLocalityTotalsActionTypes.
     */
    cursor?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursByLocalityTotalsActionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursByLocalityTotalsActionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursByLocalityTotalsActionTypes.
     */
    distinct?: EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum | EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum[]
  }

  /**
   * EmployeeHoursByLocalityTotalsActionType findFirstOrThrow
   */
  export type EmployeeHoursByLocalityTotalsActionTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsActionType
     */
    select?: EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocalityTotalsActionType to fetch.
     */
    where?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursByLocalityTotalsActionTypes to fetch.
     */
    orderBy?: EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput | EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursByLocalityTotalsActionTypes.
     */
    cursor?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursByLocalityTotalsActionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursByLocalityTotalsActionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursByLocalityTotalsActionTypes.
     */
    distinct?: EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum | EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum[]
  }

  /**
   * EmployeeHoursByLocalityTotalsActionType findMany
   */
  export type EmployeeHoursByLocalityTotalsActionTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsActionType
     */
    select?: EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursByLocalityTotalsActionTypes to fetch.
     */
    where?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursByLocalityTotalsActionTypes to fetch.
     */
    orderBy?: EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput | EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeHoursByLocalityTotalsActionTypes.
     */
    cursor?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursByLocalityTotalsActionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursByLocalityTotalsActionTypes.
     */
    skip?: number
    distinct?: EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum | EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum[]
  }

  /**
   * EmployeeHoursByLocalityTotalsActionType create
   */
  export type EmployeeHoursByLocalityTotalsActionTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsActionType
     */
    select?: EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeHoursByLocalityTotalsActionType.
     */
    data: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateInput>
  }

  /**
   * EmployeeHoursByLocalityTotalsActionType createMany
   */
  export type EmployeeHoursByLocalityTotalsActionTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeHoursByLocalityTotalsActionTypes.
     */
    data: EmployeeHoursByLocalityTotalsActionTypeCreateManyInput | EmployeeHoursByLocalityTotalsActionTypeCreateManyInput[]
  }

  /**
   * EmployeeHoursByLocalityTotalsActionType update
   */
  export type EmployeeHoursByLocalityTotalsActionTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsActionType
     */
    select?: EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeHoursByLocalityTotalsActionType.
     */
    data: XOR<EmployeeHoursByLocalityTotalsActionTypeUpdateInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateInput>
    /**
     * Choose, which EmployeeHoursByLocalityTotalsActionType to update.
     */
    where: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
  }

  /**
   * EmployeeHoursByLocalityTotalsActionType updateMany
   */
  export type EmployeeHoursByLocalityTotalsActionTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeHoursByLocalityTotalsActionTypes.
     */
    data: XOR<EmployeeHoursByLocalityTotalsActionTypeUpdateManyMutationInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeHoursByLocalityTotalsActionTypes to update
     */
    where?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
  }

  /**
   * EmployeeHoursByLocalityTotalsActionType upsert
   */
  export type EmployeeHoursByLocalityTotalsActionTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsActionType
     */
    select?: EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeHoursByLocalityTotalsActionType to update in case it exists.
     */
    where: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    /**
     * In case the EmployeeHoursByLocalityTotalsActionType found by the `where` argument doesn't exist, create a new EmployeeHoursByLocalityTotalsActionType with this data.
     */
    create: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateInput>
    /**
     * In case the EmployeeHoursByLocalityTotalsActionType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeHoursByLocalityTotalsActionTypeUpdateInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateInput>
  }

  /**
   * EmployeeHoursByLocalityTotalsActionType delete
   */
  export type EmployeeHoursByLocalityTotalsActionTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsActionType
     */
    select?: EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs> | null
    /**
     * Filter which EmployeeHoursByLocalityTotalsActionType to delete.
     */
    where: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
  }

  /**
   * EmployeeHoursByLocalityTotalsActionType deleteMany
   */
  export type EmployeeHoursByLocalityTotalsActionTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursByLocalityTotalsActionTypes to delete
     */
    where?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
  }

  /**
   * EmployeeHoursByLocalityTotalsActionType without action
   */
  export type EmployeeHoursByLocalityTotalsActionTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsActionType
     */
    select?: EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeHoursCompaniesSmsAlert
   */

  export type AggregateEmployeeHoursCompaniesSmsAlert = {
    _count: EmployeeHoursCompaniesSmsAlertCountAggregateOutputType | null
    _avg: EmployeeHoursCompaniesSmsAlertAvgAggregateOutputType | null
    _sum: EmployeeHoursCompaniesSmsAlertSumAggregateOutputType | null
    _min: EmployeeHoursCompaniesSmsAlertMinAggregateOutputType | null
    _max: EmployeeHoursCompaniesSmsAlertMaxAggregateOutputType | null
  }

  export type EmployeeHoursCompaniesSmsAlertAvgAggregateOutputType = {
    CompaniesSmsAlertId: number | null
    EmployeeID: number | null
  }

  export type EmployeeHoursCompaniesSmsAlertSumAggregateOutputType = {
    CompaniesSmsAlertId: number | null
    EmployeeID: number | null
  }

  export type EmployeeHoursCompaniesSmsAlertMinAggregateOutputType = {
    CompaniesSmsAlertId: number | null
    CompanyIdGeneralCRM: string | null
    CreatedAt: Date | null
    EmployeeID: number | null
    SmsNumber: string | null
    SmsResponse: string | null
    UserSend: string | null
  }

  export type EmployeeHoursCompaniesSmsAlertMaxAggregateOutputType = {
    CompaniesSmsAlertId: number | null
    CompanyIdGeneralCRM: string | null
    CreatedAt: Date | null
    EmployeeID: number | null
    SmsNumber: string | null
    SmsResponse: string | null
    UserSend: string | null
  }

  export type EmployeeHoursCompaniesSmsAlertCountAggregateOutputType = {
    CompaniesSmsAlertId: number
    CompanyIdGeneralCRM: number
    CreatedAt: number
    EmployeeID: number
    SmsNumber: number
    SmsResponse: number
    UserSend: number
    _all: number
  }


  export type EmployeeHoursCompaniesSmsAlertAvgAggregateInputType = {
    CompaniesSmsAlertId?: true
    EmployeeID?: true
  }

  export type EmployeeHoursCompaniesSmsAlertSumAggregateInputType = {
    CompaniesSmsAlertId?: true
    EmployeeID?: true
  }

  export type EmployeeHoursCompaniesSmsAlertMinAggregateInputType = {
    CompaniesSmsAlertId?: true
    CompanyIdGeneralCRM?: true
    CreatedAt?: true
    EmployeeID?: true
    SmsNumber?: true
    SmsResponse?: true
    UserSend?: true
  }

  export type EmployeeHoursCompaniesSmsAlertMaxAggregateInputType = {
    CompaniesSmsAlertId?: true
    CompanyIdGeneralCRM?: true
    CreatedAt?: true
    EmployeeID?: true
    SmsNumber?: true
    SmsResponse?: true
    UserSend?: true
  }

  export type EmployeeHoursCompaniesSmsAlertCountAggregateInputType = {
    CompaniesSmsAlertId?: true
    CompanyIdGeneralCRM?: true
    CreatedAt?: true
    EmployeeID?: true
    SmsNumber?: true
    SmsResponse?: true
    UserSend?: true
    _all?: true
  }

  export type EmployeeHoursCompaniesSmsAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursCompaniesSmsAlert to aggregate.
     */
    where?: EmployeeHoursCompaniesSmsAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursCompaniesSmsAlerts to fetch.
     */
    orderBy?: EmployeeHoursCompaniesSmsAlertOrderByWithRelationInput | EmployeeHoursCompaniesSmsAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeHoursCompaniesSmsAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursCompaniesSmsAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursCompaniesSmsAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeHoursCompaniesSmsAlerts
    **/
    _count?: true | EmployeeHoursCompaniesSmsAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeHoursCompaniesSmsAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeHoursCompaniesSmsAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeHoursCompaniesSmsAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeHoursCompaniesSmsAlertMaxAggregateInputType
  }

  export type GetEmployeeHoursCompaniesSmsAlertAggregateType<T extends EmployeeHoursCompaniesSmsAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeHoursCompaniesSmsAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeHoursCompaniesSmsAlert[P]>
      : GetScalarType<T[P], AggregateEmployeeHoursCompaniesSmsAlert[P]>
  }




  export type EmployeeHoursCompaniesSmsAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursCompaniesSmsAlertWhereInput
    orderBy?: EmployeeHoursCompaniesSmsAlertOrderByWithAggregationInput | EmployeeHoursCompaniesSmsAlertOrderByWithAggregationInput[]
    by: EmployeeHoursCompaniesSmsAlertScalarFieldEnum[] | EmployeeHoursCompaniesSmsAlertScalarFieldEnum
    having?: EmployeeHoursCompaniesSmsAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeHoursCompaniesSmsAlertCountAggregateInputType | true
    _avg?: EmployeeHoursCompaniesSmsAlertAvgAggregateInputType
    _sum?: EmployeeHoursCompaniesSmsAlertSumAggregateInputType
    _min?: EmployeeHoursCompaniesSmsAlertMinAggregateInputType
    _max?: EmployeeHoursCompaniesSmsAlertMaxAggregateInputType
  }

  export type EmployeeHoursCompaniesSmsAlertGroupByOutputType = {
    CompaniesSmsAlertId: number
    CompanyIdGeneralCRM: string
    CreatedAt: Date | null
    EmployeeID: number | null
    SmsNumber: string
    SmsResponse: string | null
    UserSend: string
    _count: EmployeeHoursCompaniesSmsAlertCountAggregateOutputType | null
    _avg: EmployeeHoursCompaniesSmsAlertAvgAggregateOutputType | null
    _sum: EmployeeHoursCompaniesSmsAlertSumAggregateOutputType | null
    _min: EmployeeHoursCompaniesSmsAlertMinAggregateOutputType | null
    _max: EmployeeHoursCompaniesSmsAlertMaxAggregateOutputType | null
  }

  type GetEmployeeHoursCompaniesSmsAlertGroupByPayload<T extends EmployeeHoursCompaniesSmsAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeHoursCompaniesSmsAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeHoursCompaniesSmsAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeHoursCompaniesSmsAlertGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeHoursCompaniesSmsAlertGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeHoursCompaniesSmsAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CompaniesSmsAlertId?: boolean
    CompanyIdGeneralCRM?: boolean
    CreatedAt?: boolean
    EmployeeID?: boolean
    SmsNumber?: boolean
    SmsResponse?: boolean
    UserSend?: boolean
  }, ExtArgs["result"]["employeeHoursCompaniesSmsAlert"]>


  export type EmployeeHoursCompaniesSmsAlertSelectScalar = {
    CompaniesSmsAlertId?: boolean
    CompanyIdGeneralCRM?: boolean
    CreatedAt?: boolean
    EmployeeID?: boolean
    SmsNumber?: boolean
    SmsResponse?: boolean
    UserSend?: boolean
  }


  export type $EmployeeHoursCompaniesSmsAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeHoursCompaniesSmsAlert"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CompaniesSmsAlertId: number
      CompanyIdGeneralCRM: string
      CreatedAt: Date | null
      EmployeeID: number | null
      SmsNumber: string
      SmsResponse: string | null
      UserSend: string
    }, ExtArgs["result"]["employeeHoursCompaniesSmsAlert"]>
    composites: {}
  }

  type EmployeeHoursCompaniesSmsAlertGetPayload<S extends boolean | null | undefined | EmployeeHoursCompaniesSmsAlertDefaultArgs> = $Result.GetResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload, S>

  type EmployeeHoursCompaniesSmsAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeHoursCompaniesSmsAlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeHoursCompaniesSmsAlertCountAggregateInputType | true
    }

  export interface EmployeeHoursCompaniesSmsAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeHoursCompaniesSmsAlert'], meta: { name: 'EmployeeHoursCompaniesSmsAlert' } }
    /**
     * Find zero or one EmployeeHoursCompaniesSmsAlert that matches the filter.
     * @param {EmployeeHoursCompaniesSmsAlertFindUniqueArgs} args - Arguments to find a EmployeeHoursCompaniesSmsAlert
     * @example
     * // Get one EmployeeHoursCompaniesSmsAlert
     * const employeeHoursCompaniesSmsAlert = await prisma.employeeHoursCompaniesSmsAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeHoursCompaniesSmsAlertFindUniqueArgs>(args: SelectSubset<T, EmployeeHoursCompaniesSmsAlertFindUniqueArgs<ExtArgs>>): Prisma__EmployeeHoursCompaniesSmsAlertClient<$Result.GetResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeHoursCompaniesSmsAlert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeHoursCompaniesSmsAlertFindUniqueOrThrowArgs} args - Arguments to find a EmployeeHoursCompaniesSmsAlert
     * @example
     * // Get one EmployeeHoursCompaniesSmsAlert
     * const employeeHoursCompaniesSmsAlert = await prisma.employeeHoursCompaniesSmsAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeHoursCompaniesSmsAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeHoursCompaniesSmsAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursCompaniesSmsAlertClient<$Result.GetResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeHoursCompaniesSmsAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursCompaniesSmsAlertFindFirstArgs} args - Arguments to find a EmployeeHoursCompaniesSmsAlert
     * @example
     * // Get one EmployeeHoursCompaniesSmsAlert
     * const employeeHoursCompaniesSmsAlert = await prisma.employeeHoursCompaniesSmsAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeHoursCompaniesSmsAlertFindFirstArgs>(args?: SelectSubset<T, EmployeeHoursCompaniesSmsAlertFindFirstArgs<ExtArgs>>): Prisma__EmployeeHoursCompaniesSmsAlertClient<$Result.GetResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeHoursCompaniesSmsAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursCompaniesSmsAlertFindFirstOrThrowArgs} args - Arguments to find a EmployeeHoursCompaniesSmsAlert
     * @example
     * // Get one EmployeeHoursCompaniesSmsAlert
     * const employeeHoursCompaniesSmsAlert = await prisma.employeeHoursCompaniesSmsAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeHoursCompaniesSmsAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeHoursCompaniesSmsAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursCompaniesSmsAlertClient<$Result.GetResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeHoursCompaniesSmsAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursCompaniesSmsAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeHoursCompaniesSmsAlerts
     * const employeeHoursCompaniesSmsAlerts = await prisma.employeeHoursCompaniesSmsAlert.findMany()
     * 
     * // Get first 10 EmployeeHoursCompaniesSmsAlerts
     * const employeeHoursCompaniesSmsAlerts = await prisma.employeeHoursCompaniesSmsAlert.findMany({ take: 10 })
     * 
     * // Only select the `CompaniesSmsAlertId`
     * const employeeHoursCompaniesSmsAlertWithCompaniesSmsAlertIdOnly = await prisma.employeeHoursCompaniesSmsAlert.findMany({ select: { CompaniesSmsAlertId: true } })
     * 
     */
    findMany<T extends EmployeeHoursCompaniesSmsAlertFindManyArgs>(args?: SelectSubset<T, EmployeeHoursCompaniesSmsAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeHoursCompaniesSmsAlert.
     * @param {EmployeeHoursCompaniesSmsAlertCreateArgs} args - Arguments to create a EmployeeHoursCompaniesSmsAlert.
     * @example
     * // Create one EmployeeHoursCompaniesSmsAlert
     * const EmployeeHoursCompaniesSmsAlert = await prisma.employeeHoursCompaniesSmsAlert.create({
     *   data: {
     *     // ... data to create a EmployeeHoursCompaniesSmsAlert
     *   }
     * })
     * 
     */
    create<T extends EmployeeHoursCompaniesSmsAlertCreateArgs>(args: SelectSubset<T, EmployeeHoursCompaniesSmsAlertCreateArgs<ExtArgs>>): Prisma__EmployeeHoursCompaniesSmsAlertClient<$Result.GetResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeHoursCompaniesSmsAlerts.
     * @param {EmployeeHoursCompaniesSmsAlertCreateManyArgs} args - Arguments to create many EmployeeHoursCompaniesSmsAlerts.
     * @example
     * // Create many EmployeeHoursCompaniesSmsAlerts
     * const employeeHoursCompaniesSmsAlert = await prisma.employeeHoursCompaniesSmsAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeHoursCompaniesSmsAlertCreateManyArgs>(args?: SelectSubset<T, EmployeeHoursCompaniesSmsAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeHoursCompaniesSmsAlert.
     * @param {EmployeeHoursCompaniesSmsAlertDeleteArgs} args - Arguments to delete one EmployeeHoursCompaniesSmsAlert.
     * @example
     * // Delete one EmployeeHoursCompaniesSmsAlert
     * const EmployeeHoursCompaniesSmsAlert = await prisma.employeeHoursCompaniesSmsAlert.delete({
     *   where: {
     *     // ... filter to delete one EmployeeHoursCompaniesSmsAlert
     *   }
     * })
     * 
     */
    delete<T extends EmployeeHoursCompaniesSmsAlertDeleteArgs>(args: SelectSubset<T, EmployeeHoursCompaniesSmsAlertDeleteArgs<ExtArgs>>): Prisma__EmployeeHoursCompaniesSmsAlertClient<$Result.GetResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeHoursCompaniesSmsAlert.
     * @param {EmployeeHoursCompaniesSmsAlertUpdateArgs} args - Arguments to update one EmployeeHoursCompaniesSmsAlert.
     * @example
     * // Update one EmployeeHoursCompaniesSmsAlert
     * const employeeHoursCompaniesSmsAlert = await prisma.employeeHoursCompaniesSmsAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeHoursCompaniesSmsAlertUpdateArgs>(args: SelectSubset<T, EmployeeHoursCompaniesSmsAlertUpdateArgs<ExtArgs>>): Prisma__EmployeeHoursCompaniesSmsAlertClient<$Result.GetResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeHoursCompaniesSmsAlerts.
     * @param {EmployeeHoursCompaniesSmsAlertDeleteManyArgs} args - Arguments to filter EmployeeHoursCompaniesSmsAlerts to delete.
     * @example
     * // Delete a few EmployeeHoursCompaniesSmsAlerts
     * const { count } = await prisma.employeeHoursCompaniesSmsAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeHoursCompaniesSmsAlertDeleteManyArgs>(args?: SelectSubset<T, EmployeeHoursCompaniesSmsAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeHoursCompaniesSmsAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursCompaniesSmsAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeHoursCompaniesSmsAlerts
     * const employeeHoursCompaniesSmsAlert = await prisma.employeeHoursCompaniesSmsAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeHoursCompaniesSmsAlertUpdateManyArgs>(args: SelectSubset<T, EmployeeHoursCompaniesSmsAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeHoursCompaniesSmsAlert.
     * @param {EmployeeHoursCompaniesSmsAlertUpsertArgs} args - Arguments to update or create a EmployeeHoursCompaniesSmsAlert.
     * @example
     * // Update or create a EmployeeHoursCompaniesSmsAlert
     * const employeeHoursCompaniesSmsAlert = await prisma.employeeHoursCompaniesSmsAlert.upsert({
     *   create: {
     *     // ... data to create a EmployeeHoursCompaniesSmsAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeHoursCompaniesSmsAlert we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeHoursCompaniesSmsAlertUpsertArgs>(args: SelectSubset<T, EmployeeHoursCompaniesSmsAlertUpsertArgs<ExtArgs>>): Prisma__EmployeeHoursCompaniesSmsAlertClient<$Result.GetResult<Prisma.$EmployeeHoursCompaniesSmsAlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeHoursCompaniesSmsAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursCompaniesSmsAlertCountArgs} args - Arguments to filter EmployeeHoursCompaniesSmsAlerts to count.
     * @example
     * // Count the number of EmployeeHoursCompaniesSmsAlerts
     * const count = await prisma.employeeHoursCompaniesSmsAlert.count({
     *   where: {
     *     // ... the filter for the EmployeeHoursCompaniesSmsAlerts we want to count
     *   }
     * })
    **/
    count<T extends EmployeeHoursCompaniesSmsAlertCountArgs>(
      args?: Subset<T, EmployeeHoursCompaniesSmsAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeHoursCompaniesSmsAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeHoursCompaniesSmsAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursCompaniesSmsAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeHoursCompaniesSmsAlertAggregateArgs>(args: Subset<T, EmployeeHoursCompaniesSmsAlertAggregateArgs>): Prisma.PrismaPromise<GetEmployeeHoursCompaniesSmsAlertAggregateType<T>>

    /**
     * Group by EmployeeHoursCompaniesSmsAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursCompaniesSmsAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeHoursCompaniesSmsAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeHoursCompaniesSmsAlertGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeHoursCompaniesSmsAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeHoursCompaniesSmsAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeHoursCompaniesSmsAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeHoursCompaniesSmsAlert model
   */
  readonly fields: EmployeeHoursCompaniesSmsAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeHoursCompaniesSmsAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeHoursCompaniesSmsAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeHoursCompaniesSmsAlert model
   */ 
  interface EmployeeHoursCompaniesSmsAlertFieldRefs {
    readonly CompaniesSmsAlertId: FieldRef<"EmployeeHoursCompaniesSmsAlert", 'Int'>
    readonly CompanyIdGeneralCRM: FieldRef<"EmployeeHoursCompaniesSmsAlert", 'String'>
    readonly CreatedAt: FieldRef<"EmployeeHoursCompaniesSmsAlert", 'DateTime'>
    readonly EmployeeID: FieldRef<"EmployeeHoursCompaniesSmsAlert", 'Int'>
    readonly SmsNumber: FieldRef<"EmployeeHoursCompaniesSmsAlert", 'String'>
    readonly SmsResponse: FieldRef<"EmployeeHoursCompaniesSmsAlert", 'String'>
    readonly UserSend: FieldRef<"EmployeeHoursCompaniesSmsAlert", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeHoursCompaniesSmsAlert findUnique
   */
  export type EmployeeHoursCompaniesSmsAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursCompaniesSmsAlert
     */
    select?: EmployeeHoursCompaniesSmsAlertSelect<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursCompaniesSmsAlert to fetch.
     */
    where: EmployeeHoursCompaniesSmsAlertWhereUniqueInput
  }

  /**
   * EmployeeHoursCompaniesSmsAlert findUniqueOrThrow
   */
  export type EmployeeHoursCompaniesSmsAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursCompaniesSmsAlert
     */
    select?: EmployeeHoursCompaniesSmsAlertSelect<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursCompaniesSmsAlert to fetch.
     */
    where: EmployeeHoursCompaniesSmsAlertWhereUniqueInput
  }

  /**
   * EmployeeHoursCompaniesSmsAlert findFirst
   */
  export type EmployeeHoursCompaniesSmsAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursCompaniesSmsAlert
     */
    select?: EmployeeHoursCompaniesSmsAlertSelect<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursCompaniesSmsAlert to fetch.
     */
    where?: EmployeeHoursCompaniesSmsAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursCompaniesSmsAlerts to fetch.
     */
    orderBy?: EmployeeHoursCompaniesSmsAlertOrderByWithRelationInput | EmployeeHoursCompaniesSmsAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursCompaniesSmsAlerts.
     */
    cursor?: EmployeeHoursCompaniesSmsAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursCompaniesSmsAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursCompaniesSmsAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursCompaniesSmsAlerts.
     */
    distinct?: EmployeeHoursCompaniesSmsAlertScalarFieldEnum | EmployeeHoursCompaniesSmsAlertScalarFieldEnum[]
  }

  /**
   * EmployeeHoursCompaniesSmsAlert findFirstOrThrow
   */
  export type EmployeeHoursCompaniesSmsAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursCompaniesSmsAlert
     */
    select?: EmployeeHoursCompaniesSmsAlertSelect<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursCompaniesSmsAlert to fetch.
     */
    where?: EmployeeHoursCompaniesSmsAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursCompaniesSmsAlerts to fetch.
     */
    orderBy?: EmployeeHoursCompaniesSmsAlertOrderByWithRelationInput | EmployeeHoursCompaniesSmsAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursCompaniesSmsAlerts.
     */
    cursor?: EmployeeHoursCompaniesSmsAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursCompaniesSmsAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursCompaniesSmsAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursCompaniesSmsAlerts.
     */
    distinct?: EmployeeHoursCompaniesSmsAlertScalarFieldEnum | EmployeeHoursCompaniesSmsAlertScalarFieldEnum[]
  }

  /**
   * EmployeeHoursCompaniesSmsAlert findMany
   */
  export type EmployeeHoursCompaniesSmsAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursCompaniesSmsAlert
     */
    select?: EmployeeHoursCompaniesSmsAlertSelect<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursCompaniesSmsAlerts to fetch.
     */
    where?: EmployeeHoursCompaniesSmsAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursCompaniesSmsAlerts to fetch.
     */
    orderBy?: EmployeeHoursCompaniesSmsAlertOrderByWithRelationInput | EmployeeHoursCompaniesSmsAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeHoursCompaniesSmsAlerts.
     */
    cursor?: EmployeeHoursCompaniesSmsAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursCompaniesSmsAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursCompaniesSmsAlerts.
     */
    skip?: number
    distinct?: EmployeeHoursCompaniesSmsAlertScalarFieldEnum | EmployeeHoursCompaniesSmsAlertScalarFieldEnum[]
  }

  /**
   * EmployeeHoursCompaniesSmsAlert create
   */
  export type EmployeeHoursCompaniesSmsAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursCompaniesSmsAlert
     */
    select?: EmployeeHoursCompaniesSmsAlertSelect<ExtArgs> | null
    /**
     * The data needed to create a EmployeeHoursCompaniesSmsAlert.
     */
    data: XOR<EmployeeHoursCompaniesSmsAlertCreateInput, EmployeeHoursCompaniesSmsAlertUncheckedCreateInput>
  }

  /**
   * EmployeeHoursCompaniesSmsAlert createMany
   */
  export type EmployeeHoursCompaniesSmsAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeHoursCompaniesSmsAlerts.
     */
    data: EmployeeHoursCompaniesSmsAlertCreateManyInput | EmployeeHoursCompaniesSmsAlertCreateManyInput[]
  }

  /**
   * EmployeeHoursCompaniesSmsAlert update
   */
  export type EmployeeHoursCompaniesSmsAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursCompaniesSmsAlert
     */
    select?: EmployeeHoursCompaniesSmsAlertSelect<ExtArgs> | null
    /**
     * The data needed to update a EmployeeHoursCompaniesSmsAlert.
     */
    data: XOR<EmployeeHoursCompaniesSmsAlertUpdateInput, EmployeeHoursCompaniesSmsAlertUncheckedUpdateInput>
    /**
     * Choose, which EmployeeHoursCompaniesSmsAlert to update.
     */
    where: EmployeeHoursCompaniesSmsAlertWhereUniqueInput
  }

  /**
   * EmployeeHoursCompaniesSmsAlert updateMany
   */
  export type EmployeeHoursCompaniesSmsAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeHoursCompaniesSmsAlerts.
     */
    data: XOR<EmployeeHoursCompaniesSmsAlertUpdateManyMutationInput, EmployeeHoursCompaniesSmsAlertUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeHoursCompaniesSmsAlerts to update
     */
    where?: EmployeeHoursCompaniesSmsAlertWhereInput
  }

  /**
   * EmployeeHoursCompaniesSmsAlert upsert
   */
  export type EmployeeHoursCompaniesSmsAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursCompaniesSmsAlert
     */
    select?: EmployeeHoursCompaniesSmsAlertSelect<ExtArgs> | null
    /**
     * The filter to search for the EmployeeHoursCompaniesSmsAlert to update in case it exists.
     */
    where: EmployeeHoursCompaniesSmsAlertWhereUniqueInput
    /**
     * In case the EmployeeHoursCompaniesSmsAlert found by the `where` argument doesn't exist, create a new EmployeeHoursCompaniesSmsAlert with this data.
     */
    create: XOR<EmployeeHoursCompaniesSmsAlertCreateInput, EmployeeHoursCompaniesSmsAlertUncheckedCreateInput>
    /**
     * In case the EmployeeHoursCompaniesSmsAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeHoursCompaniesSmsAlertUpdateInput, EmployeeHoursCompaniesSmsAlertUncheckedUpdateInput>
  }

  /**
   * EmployeeHoursCompaniesSmsAlert delete
   */
  export type EmployeeHoursCompaniesSmsAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursCompaniesSmsAlert
     */
    select?: EmployeeHoursCompaniesSmsAlertSelect<ExtArgs> | null
    /**
     * Filter which EmployeeHoursCompaniesSmsAlert to delete.
     */
    where: EmployeeHoursCompaniesSmsAlertWhereUniqueInput
  }

  /**
   * EmployeeHoursCompaniesSmsAlert deleteMany
   */
  export type EmployeeHoursCompaniesSmsAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursCompaniesSmsAlerts to delete
     */
    where?: EmployeeHoursCompaniesSmsAlertWhereInput
  }

  /**
   * EmployeeHoursCompaniesSmsAlert without action
   */
  export type EmployeeHoursCompaniesSmsAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursCompaniesSmsAlert
     */
    select?: EmployeeHoursCompaniesSmsAlertSelect<ExtArgs> | null
  }


  /**
   * Model EmployeeHoursContracts
   */

  export type AggregateEmployeeHoursContracts = {
    _count: EmployeeHoursContractsCountAggregateOutputType | null
    _avg: EmployeeHoursContractsAvgAggregateOutputType | null
    _sum: EmployeeHoursContractsSumAggregateOutputType | null
    _min: EmployeeHoursContractsMinAggregateOutputType | null
    _max: EmployeeHoursContractsMaxAggregateOutputType | null
  }

  export type EmployeeHoursContractsAvgAggregateOutputType = {
    Active: number | null
    HoursWeek: number | null
    NumberDayInWeek: number | null
    IsExtraHoursWeekCalc: number | null
    IsNightShiftCalc: number | null
  }

  export type EmployeeHoursContractsSumAggregateOutputType = {
    Active: number | null
    HoursWeek: number | null
    NumberDayInWeek: number | null
    IsExtraHoursWeekCalc: number | null
    IsNightShiftCalc: number | null
  }

  export type EmployeeHoursContractsMinAggregateOutputType = {
    EmployeeHoursContractsId: string | null
    CreatedAt: Date | null
    Active: number | null
    HebrewName: string | null
    Comments: string | null
    JsonData: string | null
    CompanyIdGeneralCRM: string | null
    HoursWeek: number | null
    NumberDayInWeek: number | null
    IsExtraHoursWeekCalc: number | null
    IsNightShiftCalc: number | null
  }

  export type EmployeeHoursContractsMaxAggregateOutputType = {
    EmployeeHoursContractsId: string | null
    CreatedAt: Date | null
    Active: number | null
    HebrewName: string | null
    Comments: string | null
    JsonData: string | null
    CompanyIdGeneralCRM: string | null
    HoursWeek: number | null
    NumberDayInWeek: number | null
    IsExtraHoursWeekCalc: number | null
    IsNightShiftCalc: number | null
  }

  export type EmployeeHoursContractsCountAggregateOutputType = {
    EmployeeHoursContractsId: number
    CreatedAt: number
    Active: number
    HebrewName: number
    Comments: number
    JsonData: number
    CompanyIdGeneralCRM: number
    HoursWeek: number
    NumberDayInWeek: number
    IsExtraHoursWeekCalc: number
    IsNightShiftCalc: number
    _all: number
  }


  export type EmployeeHoursContractsAvgAggregateInputType = {
    Active?: true
    HoursWeek?: true
    NumberDayInWeek?: true
    IsExtraHoursWeekCalc?: true
    IsNightShiftCalc?: true
  }

  export type EmployeeHoursContractsSumAggregateInputType = {
    Active?: true
    HoursWeek?: true
    NumberDayInWeek?: true
    IsExtraHoursWeekCalc?: true
    IsNightShiftCalc?: true
  }

  export type EmployeeHoursContractsMinAggregateInputType = {
    EmployeeHoursContractsId?: true
    CreatedAt?: true
    Active?: true
    HebrewName?: true
    Comments?: true
    JsonData?: true
    CompanyIdGeneralCRM?: true
    HoursWeek?: true
    NumberDayInWeek?: true
    IsExtraHoursWeekCalc?: true
    IsNightShiftCalc?: true
  }

  export type EmployeeHoursContractsMaxAggregateInputType = {
    EmployeeHoursContractsId?: true
    CreatedAt?: true
    Active?: true
    HebrewName?: true
    Comments?: true
    JsonData?: true
    CompanyIdGeneralCRM?: true
    HoursWeek?: true
    NumberDayInWeek?: true
    IsExtraHoursWeekCalc?: true
    IsNightShiftCalc?: true
  }

  export type EmployeeHoursContractsCountAggregateInputType = {
    EmployeeHoursContractsId?: true
    CreatedAt?: true
    Active?: true
    HebrewName?: true
    Comments?: true
    JsonData?: true
    CompanyIdGeneralCRM?: true
    HoursWeek?: true
    NumberDayInWeek?: true
    IsExtraHoursWeekCalc?: true
    IsNightShiftCalc?: true
    _all?: true
  }

  export type EmployeeHoursContractsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursContracts to aggregate.
     */
    where?: EmployeeHoursContractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursContracts to fetch.
     */
    orderBy?: EmployeeHoursContractsOrderByWithRelationInput | EmployeeHoursContractsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeHoursContractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeHoursContracts
    **/
    _count?: true | EmployeeHoursContractsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeHoursContractsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeHoursContractsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeHoursContractsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeHoursContractsMaxAggregateInputType
  }

  export type GetEmployeeHoursContractsAggregateType<T extends EmployeeHoursContractsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeHoursContracts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeHoursContracts[P]>
      : GetScalarType<T[P], AggregateEmployeeHoursContracts[P]>
  }




  export type EmployeeHoursContractsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursContractsWhereInput
    orderBy?: EmployeeHoursContractsOrderByWithAggregationInput | EmployeeHoursContractsOrderByWithAggregationInput[]
    by: EmployeeHoursContractsScalarFieldEnum[] | EmployeeHoursContractsScalarFieldEnum
    having?: EmployeeHoursContractsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeHoursContractsCountAggregateInputType | true
    _avg?: EmployeeHoursContractsAvgAggregateInputType
    _sum?: EmployeeHoursContractsSumAggregateInputType
    _min?: EmployeeHoursContractsMinAggregateInputType
    _max?: EmployeeHoursContractsMaxAggregateInputType
  }

  export type EmployeeHoursContractsGroupByOutputType = {
    EmployeeHoursContractsId: string
    CreatedAt: Date | null
    Active: number
    HebrewName: string
    Comments: string | null
    JsonData: string
    CompanyIdGeneralCRM: string | null
    HoursWeek: number
    NumberDayInWeek: number
    IsExtraHoursWeekCalc: number | null
    IsNightShiftCalc: number | null
    _count: EmployeeHoursContractsCountAggregateOutputType | null
    _avg: EmployeeHoursContractsAvgAggregateOutputType | null
    _sum: EmployeeHoursContractsSumAggregateOutputType | null
    _min: EmployeeHoursContractsMinAggregateOutputType | null
    _max: EmployeeHoursContractsMaxAggregateOutputType | null
  }

  type GetEmployeeHoursContractsGroupByPayload<T extends EmployeeHoursContractsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeHoursContractsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeHoursContractsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeHoursContractsGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeHoursContractsGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeHoursContractsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmployeeHoursContractsId?: boolean
    CreatedAt?: boolean
    Active?: boolean
    HebrewName?: boolean
    Comments?: boolean
    JsonData?: boolean
    CompanyIdGeneralCRM?: boolean
    HoursWeek?: boolean
    NumberDayInWeek?: boolean
    IsExtraHoursWeekCalc?: boolean
    IsNightShiftCalc?: boolean
    EmployeeHoursByLocality?: boolean | EmployeeHoursContracts$EmployeeHoursByLocalityArgs<ExtArgs>
    _count?: boolean | EmployeeHoursContractsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeHoursContracts"]>


  export type EmployeeHoursContractsSelectScalar = {
    EmployeeHoursContractsId?: boolean
    CreatedAt?: boolean
    Active?: boolean
    HebrewName?: boolean
    Comments?: boolean
    JsonData?: boolean
    CompanyIdGeneralCRM?: boolean
    HoursWeek?: boolean
    NumberDayInWeek?: boolean
    IsExtraHoursWeekCalc?: boolean
    IsNightShiftCalc?: boolean
  }

  export type EmployeeHoursContractsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeHoursByLocality?: boolean | EmployeeHoursContracts$EmployeeHoursByLocalityArgs<ExtArgs>
    _count?: boolean | EmployeeHoursContractsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmployeeHoursContractsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeHoursContracts"
    objects: {
      EmployeeHoursByLocality: Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      EmployeeHoursContractsId: string
      CreatedAt: Date | null
      Active: number
      HebrewName: string
      Comments: string | null
      JsonData: string
      CompanyIdGeneralCRM: string | null
      HoursWeek: number
      NumberDayInWeek: number
      IsExtraHoursWeekCalc: number | null
      IsNightShiftCalc: number | null
    }, ExtArgs["result"]["employeeHoursContracts"]>
    composites: {}
  }

  type EmployeeHoursContractsGetPayload<S extends boolean | null | undefined | EmployeeHoursContractsDefaultArgs> = $Result.GetResult<Prisma.$EmployeeHoursContractsPayload, S>

  type EmployeeHoursContractsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeHoursContractsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeHoursContractsCountAggregateInputType | true
    }

  export interface EmployeeHoursContractsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeHoursContracts'], meta: { name: 'EmployeeHoursContracts' } }
    /**
     * Find zero or one EmployeeHoursContracts that matches the filter.
     * @param {EmployeeHoursContractsFindUniqueArgs} args - Arguments to find a EmployeeHoursContracts
     * @example
     * // Get one EmployeeHoursContracts
     * const employeeHoursContracts = await prisma.employeeHoursContracts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeHoursContractsFindUniqueArgs>(args: SelectSubset<T, EmployeeHoursContractsFindUniqueArgs<ExtArgs>>): Prisma__EmployeeHoursContractsClient<$Result.GetResult<Prisma.$EmployeeHoursContractsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeHoursContracts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeHoursContractsFindUniqueOrThrowArgs} args - Arguments to find a EmployeeHoursContracts
     * @example
     * // Get one EmployeeHoursContracts
     * const employeeHoursContracts = await prisma.employeeHoursContracts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeHoursContractsFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeHoursContractsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursContractsClient<$Result.GetResult<Prisma.$EmployeeHoursContractsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeHoursContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursContractsFindFirstArgs} args - Arguments to find a EmployeeHoursContracts
     * @example
     * // Get one EmployeeHoursContracts
     * const employeeHoursContracts = await prisma.employeeHoursContracts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeHoursContractsFindFirstArgs>(args?: SelectSubset<T, EmployeeHoursContractsFindFirstArgs<ExtArgs>>): Prisma__EmployeeHoursContractsClient<$Result.GetResult<Prisma.$EmployeeHoursContractsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeHoursContracts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursContractsFindFirstOrThrowArgs} args - Arguments to find a EmployeeHoursContracts
     * @example
     * // Get one EmployeeHoursContracts
     * const employeeHoursContracts = await prisma.employeeHoursContracts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeHoursContractsFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeHoursContractsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursContractsClient<$Result.GetResult<Prisma.$EmployeeHoursContractsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeHoursContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursContractsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeHoursContracts
     * const employeeHoursContracts = await prisma.employeeHoursContracts.findMany()
     * 
     * // Get first 10 EmployeeHoursContracts
     * const employeeHoursContracts = await prisma.employeeHoursContracts.findMany({ take: 10 })
     * 
     * // Only select the `EmployeeHoursContractsId`
     * const employeeHoursContractsWithEmployeeHoursContractsIdOnly = await prisma.employeeHoursContracts.findMany({ select: { EmployeeHoursContractsId: true } })
     * 
     */
    findMany<T extends EmployeeHoursContractsFindManyArgs>(args?: SelectSubset<T, EmployeeHoursContractsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursContractsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeHoursContracts.
     * @param {EmployeeHoursContractsCreateArgs} args - Arguments to create a EmployeeHoursContracts.
     * @example
     * // Create one EmployeeHoursContracts
     * const EmployeeHoursContracts = await prisma.employeeHoursContracts.create({
     *   data: {
     *     // ... data to create a EmployeeHoursContracts
     *   }
     * })
     * 
     */
    create<T extends EmployeeHoursContractsCreateArgs>(args: SelectSubset<T, EmployeeHoursContractsCreateArgs<ExtArgs>>): Prisma__EmployeeHoursContractsClient<$Result.GetResult<Prisma.$EmployeeHoursContractsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeHoursContracts.
     * @param {EmployeeHoursContractsCreateManyArgs} args - Arguments to create many EmployeeHoursContracts.
     * @example
     * // Create many EmployeeHoursContracts
     * const employeeHoursContracts = await prisma.employeeHoursContracts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeHoursContractsCreateManyArgs>(args?: SelectSubset<T, EmployeeHoursContractsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeHoursContracts.
     * @param {EmployeeHoursContractsDeleteArgs} args - Arguments to delete one EmployeeHoursContracts.
     * @example
     * // Delete one EmployeeHoursContracts
     * const EmployeeHoursContracts = await prisma.employeeHoursContracts.delete({
     *   where: {
     *     // ... filter to delete one EmployeeHoursContracts
     *   }
     * })
     * 
     */
    delete<T extends EmployeeHoursContractsDeleteArgs>(args: SelectSubset<T, EmployeeHoursContractsDeleteArgs<ExtArgs>>): Prisma__EmployeeHoursContractsClient<$Result.GetResult<Prisma.$EmployeeHoursContractsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeHoursContracts.
     * @param {EmployeeHoursContractsUpdateArgs} args - Arguments to update one EmployeeHoursContracts.
     * @example
     * // Update one EmployeeHoursContracts
     * const employeeHoursContracts = await prisma.employeeHoursContracts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeHoursContractsUpdateArgs>(args: SelectSubset<T, EmployeeHoursContractsUpdateArgs<ExtArgs>>): Prisma__EmployeeHoursContractsClient<$Result.GetResult<Prisma.$EmployeeHoursContractsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeHoursContracts.
     * @param {EmployeeHoursContractsDeleteManyArgs} args - Arguments to filter EmployeeHoursContracts to delete.
     * @example
     * // Delete a few EmployeeHoursContracts
     * const { count } = await prisma.employeeHoursContracts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeHoursContractsDeleteManyArgs>(args?: SelectSubset<T, EmployeeHoursContractsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeHoursContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursContractsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeHoursContracts
     * const employeeHoursContracts = await prisma.employeeHoursContracts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeHoursContractsUpdateManyArgs>(args: SelectSubset<T, EmployeeHoursContractsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeHoursContracts.
     * @param {EmployeeHoursContractsUpsertArgs} args - Arguments to update or create a EmployeeHoursContracts.
     * @example
     * // Update or create a EmployeeHoursContracts
     * const employeeHoursContracts = await prisma.employeeHoursContracts.upsert({
     *   create: {
     *     // ... data to create a EmployeeHoursContracts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeHoursContracts we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeHoursContractsUpsertArgs>(args: SelectSubset<T, EmployeeHoursContractsUpsertArgs<ExtArgs>>): Prisma__EmployeeHoursContractsClient<$Result.GetResult<Prisma.$EmployeeHoursContractsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeHoursContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursContractsCountArgs} args - Arguments to filter EmployeeHoursContracts to count.
     * @example
     * // Count the number of EmployeeHoursContracts
     * const count = await prisma.employeeHoursContracts.count({
     *   where: {
     *     // ... the filter for the EmployeeHoursContracts we want to count
     *   }
     * })
    **/
    count<T extends EmployeeHoursContractsCountArgs>(
      args?: Subset<T, EmployeeHoursContractsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeHoursContractsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeHoursContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursContractsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeHoursContractsAggregateArgs>(args: Subset<T, EmployeeHoursContractsAggregateArgs>): Prisma.PrismaPromise<GetEmployeeHoursContractsAggregateType<T>>

    /**
     * Group by EmployeeHoursContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursContractsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeHoursContractsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeHoursContractsGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeHoursContractsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeHoursContractsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeHoursContractsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeHoursContracts model
   */
  readonly fields: EmployeeHoursContractsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeHoursContracts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeHoursContractsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EmployeeHoursByLocality<T extends EmployeeHoursContracts$EmployeeHoursByLocalityArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHoursContracts$EmployeeHoursByLocalityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeHoursContracts model
   */ 
  interface EmployeeHoursContractsFieldRefs {
    readonly EmployeeHoursContractsId: FieldRef<"EmployeeHoursContracts", 'String'>
    readonly CreatedAt: FieldRef<"EmployeeHoursContracts", 'DateTime'>
    readonly Active: FieldRef<"EmployeeHoursContracts", 'Int'>
    readonly HebrewName: FieldRef<"EmployeeHoursContracts", 'String'>
    readonly Comments: FieldRef<"EmployeeHoursContracts", 'String'>
    readonly JsonData: FieldRef<"EmployeeHoursContracts", 'String'>
    readonly CompanyIdGeneralCRM: FieldRef<"EmployeeHoursContracts", 'String'>
    readonly HoursWeek: FieldRef<"EmployeeHoursContracts", 'Float'>
    readonly NumberDayInWeek: FieldRef<"EmployeeHoursContracts", 'Int'>
    readonly IsExtraHoursWeekCalc: FieldRef<"EmployeeHoursContracts", 'Int'>
    readonly IsNightShiftCalc: FieldRef<"EmployeeHoursContracts", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeHoursContracts findUnique
   */
  export type EmployeeHoursContractsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursContracts
     */
    select?: EmployeeHoursContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursContractsInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursContracts to fetch.
     */
    where: EmployeeHoursContractsWhereUniqueInput
  }

  /**
   * EmployeeHoursContracts findUniqueOrThrow
   */
  export type EmployeeHoursContractsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursContracts
     */
    select?: EmployeeHoursContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursContractsInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursContracts to fetch.
     */
    where: EmployeeHoursContractsWhereUniqueInput
  }

  /**
   * EmployeeHoursContracts findFirst
   */
  export type EmployeeHoursContractsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursContracts
     */
    select?: EmployeeHoursContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursContractsInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursContracts to fetch.
     */
    where?: EmployeeHoursContractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursContracts to fetch.
     */
    orderBy?: EmployeeHoursContractsOrderByWithRelationInput | EmployeeHoursContractsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursContracts.
     */
    cursor?: EmployeeHoursContractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursContracts.
     */
    distinct?: EmployeeHoursContractsScalarFieldEnum | EmployeeHoursContractsScalarFieldEnum[]
  }

  /**
   * EmployeeHoursContracts findFirstOrThrow
   */
  export type EmployeeHoursContractsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursContracts
     */
    select?: EmployeeHoursContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursContractsInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursContracts to fetch.
     */
    where?: EmployeeHoursContractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursContracts to fetch.
     */
    orderBy?: EmployeeHoursContractsOrderByWithRelationInput | EmployeeHoursContractsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursContracts.
     */
    cursor?: EmployeeHoursContractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursContracts.
     */
    distinct?: EmployeeHoursContractsScalarFieldEnum | EmployeeHoursContractsScalarFieldEnum[]
  }

  /**
   * EmployeeHoursContracts findMany
   */
  export type EmployeeHoursContractsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursContracts
     */
    select?: EmployeeHoursContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursContractsInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursContracts to fetch.
     */
    where?: EmployeeHoursContractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursContracts to fetch.
     */
    orderBy?: EmployeeHoursContractsOrderByWithRelationInput | EmployeeHoursContractsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeHoursContracts.
     */
    cursor?: EmployeeHoursContractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursContracts.
     */
    skip?: number
    distinct?: EmployeeHoursContractsScalarFieldEnum | EmployeeHoursContractsScalarFieldEnum[]
  }

  /**
   * EmployeeHoursContracts create
   */
  export type EmployeeHoursContractsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursContracts
     */
    select?: EmployeeHoursContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursContractsInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeHoursContracts.
     */
    data: XOR<EmployeeHoursContractsCreateInput, EmployeeHoursContractsUncheckedCreateInput>
  }

  /**
   * EmployeeHoursContracts createMany
   */
  export type EmployeeHoursContractsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeHoursContracts.
     */
    data: EmployeeHoursContractsCreateManyInput | EmployeeHoursContractsCreateManyInput[]
  }

  /**
   * EmployeeHoursContracts update
   */
  export type EmployeeHoursContractsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursContracts
     */
    select?: EmployeeHoursContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursContractsInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeHoursContracts.
     */
    data: XOR<EmployeeHoursContractsUpdateInput, EmployeeHoursContractsUncheckedUpdateInput>
    /**
     * Choose, which EmployeeHoursContracts to update.
     */
    where: EmployeeHoursContractsWhereUniqueInput
  }

  /**
   * EmployeeHoursContracts updateMany
   */
  export type EmployeeHoursContractsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeHoursContracts.
     */
    data: XOR<EmployeeHoursContractsUpdateManyMutationInput, EmployeeHoursContractsUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeHoursContracts to update
     */
    where?: EmployeeHoursContractsWhereInput
  }

  /**
   * EmployeeHoursContracts upsert
   */
  export type EmployeeHoursContractsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursContracts
     */
    select?: EmployeeHoursContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursContractsInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeHoursContracts to update in case it exists.
     */
    where: EmployeeHoursContractsWhereUniqueInput
    /**
     * In case the EmployeeHoursContracts found by the `where` argument doesn't exist, create a new EmployeeHoursContracts with this data.
     */
    create: XOR<EmployeeHoursContractsCreateInput, EmployeeHoursContractsUncheckedCreateInput>
    /**
     * In case the EmployeeHoursContracts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeHoursContractsUpdateInput, EmployeeHoursContractsUncheckedUpdateInput>
  }

  /**
   * EmployeeHoursContracts delete
   */
  export type EmployeeHoursContractsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursContracts
     */
    select?: EmployeeHoursContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursContractsInclude<ExtArgs> | null
    /**
     * Filter which EmployeeHoursContracts to delete.
     */
    where: EmployeeHoursContractsWhereUniqueInput
  }

  /**
   * EmployeeHoursContracts deleteMany
   */
  export type EmployeeHoursContractsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursContracts to delete
     */
    where?: EmployeeHoursContractsWhereInput
  }

  /**
   * EmployeeHoursContracts.EmployeeHoursByLocality
   */
  export type EmployeeHoursContracts$EmployeeHoursByLocalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
    where?: EmployeeHoursByLocalityWhereInput
    orderBy?: EmployeeHoursByLocalityOrderByWithRelationInput | EmployeeHoursByLocalityOrderByWithRelationInput[]
    cursor?: EmployeeHoursByLocalityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeHoursByLocalityScalarFieldEnum | EmployeeHoursByLocalityScalarFieldEnum[]
  }

  /**
   * EmployeeHoursContracts without action
   */
  export type EmployeeHoursContractsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursContracts
     */
    select?: EmployeeHoursContractsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursContractsInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeHoursForemansConfig
   */

  export type AggregateEmployeeHoursForemansConfig = {
    _count: EmployeeHoursForemansConfigCountAggregateOutputType | null
    _avg: EmployeeHoursForemansConfigAvgAggregateOutputType | null
    _sum: EmployeeHoursForemansConfigSumAggregateOutputType | null
    _min: EmployeeHoursForemansConfigMinAggregateOutputType | null
    _max: EmployeeHoursForemansConfigMaxAggregateOutputType | null
  }

  export type EmployeeHoursForemansConfigAvgAggregateOutputType = {
    CanEdit: number | null
    NotShowSourceHours: number | null
  }

  export type EmployeeHoursForemansConfigSumAggregateOutputType = {
    CanEdit: number | null
    NotShowSourceHours: number | null
  }

  export type EmployeeHoursForemansConfigMinAggregateOutputType = {
    EmployeeHoursForemanConfigId: string | null
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string | null
    ForemanUserGeneralCRM: string | null
    CanEdit: number | null
    NotShowSourceHours: number | null
  }

  export type EmployeeHoursForemansConfigMaxAggregateOutputType = {
    EmployeeHoursForemanConfigId: string | null
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string | null
    ForemanUserGeneralCRM: string | null
    CanEdit: number | null
    NotShowSourceHours: number | null
  }

  export type EmployeeHoursForemansConfigCountAggregateOutputType = {
    EmployeeHoursForemanConfigId: number
    CreatedAt: number
    CompanyIdGeneralCRM: number
    ForemanUserGeneralCRM: number
    CanEdit: number
    NotShowSourceHours: number
    _all: number
  }


  export type EmployeeHoursForemansConfigAvgAggregateInputType = {
    CanEdit?: true
    NotShowSourceHours?: true
  }

  export type EmployeeHoursForemansConfigSumAggregateInputType = {
    CanEdit?: true
    NotShowSourceHours?: true
  }

  export type EmployeeHoursForemansConfigMinAggregateInputType = {
    EmployeeHoursForemanConfigId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    ForemanUserGeneralCRM?: true
    CanEdit?: true
    NotShowSourceHours?: true
  }

  export type EmployeeHoursForemansConfigMaxAggregateInputType = {
    EmployeeHoursForemanConfigId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    ForemanUserGeneralCRM?: true
    CanEdit?: true
    NotShowSourceHours?: true
  }

  export type EmployeeHoursForemansConfigCountAggregateInputType = {
    EmployeeHoursForemanConfigId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    ForemanUserGeneralCRM?: true
    CanEdit?: true
    NotShowSourceHours?: true
    _all?: true
  }

  export type EmployeeHoursForemansConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursForemansConfig to aggregate.
     */
    where?: EmployeeHoursForemansConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursForemansConfigs to fetch.
     */
    orderBy?: EmployeeHoursForemansConfigOrderByWithRelationInput | EmployeeHoursForemansConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeHoursForemansConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursForemansConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursForemansConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeHoursForemansConfigs
    **/
    _count?: true | EmployeeHoursForemansConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeHoursForemansConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeHoursForemansConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeHoursForemansConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeHoursForemansConfigMaxAggregateInputType
  }

  export type GetEmployeeHoursForemansConfigAggregateType<T extends EmployeeHoursForemansConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeHoursForemansConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeHoursForemansConfig[P]>
      : GetScalarType<T[P], AggregateEmployeeHoursForemansConfig[P]>
  }




  export type EmployeeHoursForemansConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursForemansConfigWhereInput
    orderBy?: EmployeeHoursForemansConfigOrderByWithAggregationInput | EmployeeHoursForemansConfigOrderByWithAggregationInput[]
    by: EmployeeHoursForemansConfigScalarFieldEnum[] | EmployeeHoursForemansConfigScalarFieldEnum
    having?: EmployeeHoursForemansConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeHoursForemansConfigCountAggregateInputType | true
    _avg?: EmployeeHoursForemansConfigAvgAggregateInputType
    _sum?: EmployeeHoursForemansConfigSumAggregateInputType
    _min?: EmployeeHoursForemansConfigMinAggregateInputType
    _max?: EmployeeHoursForemansConfigMaxAggregateInputType
  }

  export type EmployeeHoursForemansConfigGroupByOutputType = {
    EmployeeHoursForemanConfigId: string
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string
    ForemanUserGeneralCRM: string
    CanEdit: number | null
    NotShowSourceHours: number | null
    _count: EmployeeHoursForemansConfigCountAggregateOutputType | null
    _avg: EmployeeHoursForemansConfigAvgAggregateOutputType | null
    _sum: EmployeeHoursForemansConfigSumAggregateOutputType | null
    _min: EmployeeHoursForemansConfigMinAggregateOutputType | null
    _max: EmployeeHoursForemansConfigMaxAggregateOutputType | null
  }

  type GetEmployeeHoursForemansConfigGroupByPayload<T extends EmployeeHoursForemansConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeHoursForemansConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeHoursForemansConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeHoursForemansConfigGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeHoursForemansConfigGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeHoursForemansConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmployeeHoursForemanConfigId?: boolean
    CreatedAt?: boolean
    CompanyIdGeneralCRM?: boolean
    ForemanUserGeneralCRM?: boolean
    CanEdit?: boolean
    NotShowSourceHours?: boolean
  }, ExtArgs["result"]["employeeHoursForemansConfig"]>


  export type EmployeeHoursForemansConfigSelectScalar = {
    EmployeeHoursForemanConfigId?: boolean
    CreatedAt?: boolean
    CompanyIdGeneralCRM?: boolean
    ForemanUserGeneralCRM?: boolean
    CanEdit?: boolean
    NotShowSourceHours?: boolean
  }


  export type $EmployeeHoursForemansConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeHoursForemansConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      EmployeeHoursForemanConfigId: string
      CreatedAt: Date | null
      CompanyIdGeneralCRM: string
      ForemanUserGeneralCRM: string
      CanEdit: number | null
      NotShowSourceHours: number | null
    }, ExtArgs["result"]["employeeHoursForemansConfig"]>
    composites: {}
  }

  type EmployeeHoursForemansConfigGetPayload<S extends boolean | null | undefined | EmployeeHoursForemansConfigDefaultArgs> = $Result.GetResult<Prisma.$EmployeeHoursForemansConfigPayload, S>

  type EmployeeHoursForemansConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeHoursForemansConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeHoursForemansConfigCountAggregateInputType | true
    }

  export interface EmployeeHoursForemansConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeHoursForemansConfig'], meta: { name: 'EmployeeHoursForemansConfig' } }
    /**
     * Find zero or one EmployeeHoursForemansConfig that matches the filter.
     * @param {EmployeeHoursForemansConfigFindUniqueArgs} args - Arguments to find a EmployeeHoursForemansConfig
     * @example
     * // Get one EmployeeHoursForemansConfig
     * const employeeHoursForemansConfig = await prisma.employeeHoursForemansConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeHoursForemansConfigFindUniqueArgs>(args: SelectSubset<T, EmployeeHoursForemansConfigFindUniqueArgs<ExtArgs>>): Prisma__EmployeeHoursForemansConfigClient<$Result.GetResult<Prisma.$EmployeeHoursForemansConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeHoursForemansConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeHoursForemansConfigFindUniqueOrThrowArgs} args - Arguments to find a EmployeeHoursForemansConfig
     * @example
     * // Get one EmployeeHoursForemansConfig
     * const employeeHoursForemansConfig = await prisma.employeeHoursForemansConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeHoursForemansConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeHoursForemansConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursForemansConfigClient<$Result.GetResult<Prisma.$EmployeeHoursForemansConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeHoursForemansConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursForemansConfigFindFirstArgs} args - Arguments to find a EmployeeHoursForemansConfig
     * @example
     * // Get one EmployeeHoursForemansConfig
     * const employeeHoursForemansConfig = await prisma.employeeHoursForemansConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeHoursForemansConfigFindFirstArgs>(args?: SelectSubset<T, EmployeeHoursForemansConfigFindFirstArgs<ExtArgs>>): Prisma__EmployeeHoursForemansConfigClient<$Result.GetResult<Prisma.$EmployeeHoursForemansConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeHoursForemansConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursForemansConfigFindFirstOrThrowArgs} args - Arguments to find a EmployeeHoursForemansConfig
     * @example
     * // Get one EmployeeHoursForemansConfig
     * const employeeHoursForemansConfig = await prisma.employeeHoursForemansConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeHoursForemansConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeHoursForemansConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursForemansConfigClient<$Result.GetResult<Prisma.$EmployeeHoursForemansConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeHoursForemansConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursForemansConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeHoursForemansConfigs
     * const employeeHoursForemansConfigs = await prisma.employeeHoursForemansConfig.findMany()
     * 
     * // Get first 10 EmployeeHoursForemansConfigs
     * const employeeHoursForemansConfigs = await prisma.employeeHoursForemansConfig.findMany({ take: 10 })
     * 
     * // Only select the `EmployeeHoursForemanConfigId`
     * const employeeHoursForemansConfigWithEmployeeHoursForemanConfigIdOnly = await prisma.employeeHoursForemansConfig.findMany({ select: { EmployeeHoursForemanConfigId: true } })
     * 
     */
    findMany<T extends EmployeeHoursForemansConfigFindManyArgs>(args?: SelectSubset<T, EmployeeHoursForemansConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursForemansConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeHoursForemansConfig.
     * @param {EmployeeHoursForemansConfigCreateArgs} args - Arguments to create a EmployeeHoursForemansConfig.
     * @example
     * // Create one EmployeeHoursForemansConfig
     * const EmployeeHoursForemansConfig = await prisma.employeeHoursForemansConfig.create({
     *   data: {
     *     // ... data to create a EmployeeHoursForemansConfig
     *   }
     * })
     * 
     */
    create<T extends EmployeeHoursForemansConfigCreateArgs>(args: SelectSubset<T, EmployeeHoursForemansConfigCreateArgs<ExtArgs>>): Prisma__EmployeeHoursForemansConfigClient<$Result.GetResult<Prisma.$EmployeeHoursForemansConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeHoursForemansConfigs.
     * @param {EmployeeHoursForemansConfigCreateManyArgs} args - Arguments to create many EmployeeHoursForemansConfigs.
     * @example
     * // Create many EmployeeHoursForemansConfigs
     * const employeeHoursForemansConfig = await prisma.employeeHoursForemansConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeHoursForemansConfigCreateManyArgs>(args?: SelectSubset<T, EmployeeHoursForemansConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeHoursForemansConfig.
     * @param {EmployeeHoursForemansConfigDeleteArgs} args - Arguments to delete one EmployeeHoursForemansConfig.
     * @example
     * // Delete one EmployeeHoursForemansConfig
     * const EmployeeHoursForemansConfig = await prisma.employeeHoursForemansConfig.delete({
     *   where: {
     *     // ... filter to delete one EmployeeHoursForemansConfig
     *   }
     * })
     * 
     */
    delete<T extends EmployeeHoursForemansConfigDeleteArgs>(args: SelectSubset<T, EmployeeHoursForemansConfigDeleteArgs<ExtArgs>>): Prisma__EmployeeHoursForemansConfigClient<$Result.GetResult<Prisma.$EmployeeHoursForemansConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeHoursForemansConfig.
     * @param {EmployeeHoursForemansConfigUpdateArgs} args - Arguments to update one EmployeeHoursForemansConfig.
     * @example
     * // Update one EmployeeHoursForemansConfig
     * const employeeHoursForemansConfig = await prisma.employeeHoursForemansConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeHoursForemansConfigUpdateArgs>(args: SelectSubset<T, EmployeeHoursForemansConfigUpdateArgs<ExtArgs>>): Prisma__EmployeeHoursForemansConfigClient<$Result.GetResult<Prisma.$EmployeeHoursForemansConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeHoursForemansConfigs.
     * @param {EmployeeHoursForemansConfigDeleteManyArgs} args - Arguments to filter EmployeeHoursForemansConfigs to delete.
     * @example
     * // Delete a few EmployeeHoursForemansConfigs
     * const { count } = await prisma.employeeHoursForemansConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeHoursForemansConfigDeleteManyArgs>(args?: SelectSubset<T, EmployeeHoursForemansConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeHoursForemansConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursForemansConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeHoursForemansConfigs
     * const employeeHoursForemansConfig = await prisma.employeeHoursForemansConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeHoursForemansConfigUpdateManyArgs>(args: SelectSubset<T, EmployeeHoursForemansConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeHoursForemansConfig.
     * @param {EmployeeHoursForemansConfigUpsertArgs} args - Arguments to update or create a EmployeeHoursForemansConfig.
     * @example
     * // Update or create a EmployeeHoursForemansConfig
     * const employeeHoursForemansConfig = await prisma.employeeHoursForemansConfig.upsert({
     *   create: {
     *     // ... data to create a EmployeeHoursForemansConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeHoursForemansConfig we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeHoursForemansConfigUpsertArgs>(args: SelectSubset<T, EmployeeHoursForemansConfigUpsertArgs<ExtArgs>>): Prisma__EmployeeHoursForemansConfigClient<$Result.GetResult<Prisma.$EmployeeHoursForemansConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeHoursForemansConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursForemansConfigCountArgs} args - Arguments to filter EmployeeHoursForemansConfigs to count.
     * @example
     * // Count the number of EmployeeHoursForemansConfigs
     * const count = await prisma.employeeHoursForemansConfig.count({
     *   where: {
     *     // ... the filter for the EmployeeHoursForemansConfigs we want to count
     *   }
     * })
    **/
    count<T extends EmployeeHoursForemansConfigCountArgs>(
      args?: Subset<T, EmployeeHoursForemansConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeHoursForemansConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeHoursForemansConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursForemansConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeHoursForemansConfigAggregateArgs>(args: Subset<T, EmployeeHoursForemansConfigAggregateArgs>): Prisma.PrismaPromise<GetEmployeeHoursForemansConfigAggregateType<T>>

    /**
     * Group by EmployeeHoursForemansConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursForemansConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeHoursForemansConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeHoursForemansConfigGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeHoursForemansConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeHoursForemansConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeHoursForemansConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeHoursForemansConfig model
   */
  readonly fields: EmployeeHoursForemansConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeHoursForemansConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeHoursForemansConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeHoursForemansConfig model
   */ 
  interface EmployeeHoursForemansConfigFieldRefs {
    readonly EmployeeHoursForemanConfigId: FieldRef<"EmployeeHoursForemansConfig", 'String'>
    readonly CreatedAt: FieldRef<"EmployeeHoursForemansConfig", 'DateTime'>
    readonly CompanyIdGeneralCRM: FieldRef<"EmployeeHoursForemansConfig", 'String'>
    readonly ForemanUserGeneralCRM: FieldRef<"EmployeeHoursForemansConfig", 'String'>
    readonly CanEdit: FieldRef<"EmployeeHoursForemansConfig", 'Int'>
    readonly NotShowSourceHours: FieldRef<"EmployeeHoursForemansConfig", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeHoursForemansConfig findUnique
   */
  export type EmployeeHoursForemansConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursForemansConfig
     */
    select?: EmployeeHoursForemansConfigSelect<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursForemansConfig to fetch.
     */
    where: EmployeeHoursForemansConfigWhereUniqueInput
  }

  /**
   * EmployeeHoursForemansConfig findUniqueOrThrow
   */
  export type EmployeeHoursForemansConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursForemansConfig
     */
    select?: EmployeeHoursForemansConfigSelect<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursForemansConfig to fetch.
     */
    where: EmployeeHoursForemansConfigWhereUniqueInput
  }

  /**
   * EmployeeHoursForemansConfig findFirst
   */
  export type EmployeeHoursForemansConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursForemansConfig
     */
    select?: EmployeeHoursForemansConfigSelect<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursForemansConfig to fetch.
     */
    where?: EmployeeHoursForemansConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursForemansConfigs to fetch.
     */
    orderBy?: EmployeeHoursForemansConfigOrderByWithRelationInput | EmployeeHoursForemansConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursForemansConfigs.
     */
    cursor?: EmployeeHoursForemansConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursForemansConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursForemansConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursForemansConfigs.
     */
    distinct?: EmployeeHoursForemansConfigScalarFieldEnum | EmployeeHoursForemansConfigScalarFieldEnum[]
  }

  /**
   * EmployeeHoursForemansConfig findFirstOrThrow
   */
  export type EmployeeHoursForemansConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursForemansConfig
     */
    select?: EmployeeHoursForemansConfigSelect<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursForemansConfig to fetch.
     */
    where?: EmployeeHoursForemansConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursForemansConfigs to fetch.
     */
    orderBy?: EmployeeHoursForemansConfigOrderByWithRelationInput | EmployeeHoursForemansConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursForemansConfigs.
     */
    cursor?: EmployeeHoursForemansConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursForemansConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursForemansConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursForemansConfigs.
     */
    distinct?: EmployeeHoursForemansConfigScalarFieldEnum | EmployeeHoursForemansConfigScalarFieldEnum[]
  }

  /**
   * EmployeeHoursForemansConfig findMany
   */
  export type EmployeeHoursForemansConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursForemansConfig
     */
    select?: EmployeeHoursForemansConfigSelect<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursForemansConfigs to fetch.
     */
    where?: EmployeeHoursForemansConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursForemansConfigs to fetch.
     */
    orderBy?: EmployeeHoursForemansConfigOrderByWithRelationInput | EmployeeHoursForemansConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeHoursForemansConfigs.
     */
    cursor?: EmployeeHoursForemansConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursForemansConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursForemansConfigs.
     */
    skip?: number
    distinct?: EmployeeHoursForemansConfigScalarFieldEnum | EmployeeHoursForemansConfigScalarFieldEnum[]
  }

  /**
   * EmployeeHoursForemansConfig create
   */
  export type EmployeeHoursForemansConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursForemansConfig
     */
    select?: EmployeeHoursForemansConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a EmployeeHoursForemansConfig.
     */
    data: XOR<EmployeeHoursForemansConfigCreateInput, EmployeeHoursForemansConfigUncheckedCreateInput>
  }

  /**
   * EmployeeHoursForemansConfig createMany
   */
  export type EmployeeHoursForemansConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeHoursForemansConfigs.
     */
    data: EmployeeHoursForemansConfigCreateManyInput | EmployeeHoursForemansConfigCreateManyInput[]
  }

  /**
   * EmployeeHoursForemansConfig update
   */
  export type EmployeeHoursForemansConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursForemansConfig
     */
    select?: EmployeeHoursForemansConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a EmployeeHoursForemansConfig.
     */
    data: XOR<EmployeeHoursForemansConfigUpdateInput, EmployeeHoursForemansConfigUncheckedUpdateInput>
    /**
     * Choose, which EmployeeHoursForemansConfig to update.
     */
    where: EmployeeHoursForemansConfigWhereUniqueInput
  }

  /**
   * EmployeeHoursForemansConfig updateMany
   */
  export type EmployeeHoursForemansConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeHoursForemansConfigs.
     */
    data: XOR<EmployeeHoursForemansConfigUpdateManyMutationInput, EmployeeHoursForemansConfigUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeHoursForemansConfigs to update
     */
    where?: EmployeeHoursForemansConfigWhereInput
  }

  /**
   * EmployeeHoursForemansConfig upsert
   */
  export type EmployeeHoursForemansConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursForemansConfig
     */
    select?: EmployeeHoursForemansConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the EmployeeHoursForemansConfig to update in case it exists.
     */
    where: EmployeeHoursForemansConfigWhereUniqueInput
    /**
     * In case the EmployeeHoursForemansConfig found by the `where` argument doesn't exist, create a new EmployeeHoursForemansConfig with this data.
     */
    create: XOR<EmployeeHoursForemansConfigCreateInput, EmployeeHoursForemansConfigUncheckedCreateInput>
    /**
     * In case the EmployeeHoursForemansConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeHoursForemansConfigUpdateInput, EmployeeHoursForemansConfigUncheckedUpdateInput>
  }

  /**
   * EmployeeHoursForemansConfig delete
   */
  export type EmployeeHoursForemansConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursForemansConfig
     */
    select?: EmployeeHoursForemansConfigSelect<ExtArgs> | null
    /**
     * Filter which EmployeeHoursForemansConfig to delete.
     */
    where: EmployeeHoursForemansConfigWhereUniqueInput
  }

  /**
   * EmployeeHoursForemansConfig deleteMany
   */
  export type EmployeeHoursForemansConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursForemansConfigs to delete
     */
    where?: EmployeeHoursForemansConfigWhereInput
  }

  /**
   * EmployeeHoursForemansConfig without action
   */
  export type EmployeeHoursForemansConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursForemansConfig
     */
    select?: EmployeeHoursForemansConfigSelect<ExtArgs> | null
  }


  /**
   * Model EmployeeHoursLocalities
   */

  export type AggregateEmployeeHoursLocalities = {
    _count: EmployeeHoursLocalitiesCountAggregateOutputType | null
    _avg: EmployeeHoursLocalitiesAvgAggregateOutputType | null
    _sum: EmployeeHoursLocalitiesSumAggregateOutputType | null
    _min: EmployeeHoursLocalitiesMinAggregateOutputType | null
    _max: EmployeeHoursLocalitiesMaxAggregateOutputType | null
  }

  export type EmployeeHoursLocalitiesAvgAggregateOutputType = {
    NotShowLocality: number | null
    GpsRadius: number | null
    LocalityIDAccess: number | null
    LocalityCodeAccess: number | null
    CustomerIDAccess: number | null
    MinimumHours2BreakTime: number | null
    BreakTime: number | null
    AlertForMaxMonthHours: number | null
    RestrictDayHoursAbove12: number | null
    RestrictWeekExtraHoursAbove16: number | null
    RestrictGpsActive: number | null
  }

  export type EmployeeHoursLocalitiesSumAggregateOutputType = {
    NotShowLocality: number | null
    GpsRadius: number | null
    LocalityIDAccess: number | null
    LocalityCodeAccess: number | null
    CustomerIDAccess: number | null
    MinimumHours2BreakTime: number | null
    BreakTime: number | null
    AlertForMaxMonthHours: number | null
    RestrictDayHoursAbove12: number | null
    RestrictWeekExtraHoursAbove16: number | null
    RestrictGpsActive: number | null
  }

  export type EmployeeHoursLocalitiesMinAggregateOutputType = {
    EmployeeHoursLocalityId: string | null
    CreatedAt: Date | null
    NotShowLocality: number | null
    LocalityName: string | null
    LocalityNameEng: string | null
    CompanyIdGeneralCRM: string | null
    Address: string | null
    Gps: string | null
    GpsRadius: number | null
    AddressAccess: string | null
    LocalityIDAccess: number | null
    LocalityCodeAccess: number | null
    CustomerIDAccess: number | null
    CustomerNameAccess: string | null
    ForemanGeneralCRMUserId: string | null
    HourMinStart: Date | null
    HourMaxStop: Date | null
    RoundTime: string | null
    MinimumHours2BreakTime: number | null
    BreakTime: number | null
    AlertForMaxMonthHours: number | null
    RestrictDayHoursAbove12: number | null
    RestrictWeekExtraHoursAbove16: number | null
    RestrictGpsActive: number | null
  }

  export type EmployeeHoursLocalitiesMaxAggregateOutputType = {
    EmployeeHoursLocalityId: string | null
    CreatedAt: Date | null
    NotShowLocality: number | null
    LocalityName: string | null
    LocalityNameEng: string | null
    CompanyIdGeneralCRM: string | null
    Address: string | null
    Gps: string | null
    GpsRadius: number | null
    AddressAccess: string | null
    LocalityIDAccess: number | null
    LocalityCodeAccess: number | null
    CustomerIDAccess: number | null
    CustomerNameAccess: string | null
    ForemanGeneralCRMUserId: string | null
    HourMinStart: Date | null
    HourMaxStop: Date | null
    RoundTime: string | null
    MinimumHours2BreakTime: number | null
    BreakTime: number | null
    AlertForMaxMonthHours: number | null
    RestrictDayHoursAbove12: number | null
    RestrictWeekExtraHoursAbove16: number | null
    RestrictGpsActive: number | null
  }

  export type EmployeeHoursLocalitiesCountAggregateOutputType = {
    EmployeeHoursLocalityId: number
    CreatedAt: number
    NotShowLocality: number
    LocalityName: number
    LocalityNameEng: number
    CompanyIdGeneralCRM: number
    Address: number
    Gps: number
    GpsRadius: number
    AddressAccess: number
    LocalityIDAccess: number
    LocalityCodeAccess: number
    CustomerIDAccess: number
    CustomerNameAccess: number
    ForemanGeneralCRMUserId: number
    HourMinStart: number
    HourMaxStop: number
    RoundTime: number
    MinimumHours2BreakTime: number
    BreakTime: number
    AlertForMaxMonthHours: number
    RestrictDayHoursAbove12: number
    RestrictWeekExtraHoursAbove16: number
    RestrictGpsActive: number
    _all: number
  }


  export type EmployeeHoursLocalitiesAvgAggregateInputType = {
    NotShowLocality?: true
    GpsRadius?: true
    LocalityIDAccess?: true
    LocalityCodeAccess?: true
    CustomerIDAccess?: true
    MinimumHours2BreakTime?: true
    BreakTime?: true
    AlertForMaxMonthHours?: true
    RestrictDayHoursAbove12?: true
    RestrictWeekExtraHoursAbove16?: true
    RestrictGpsActive?: true
  }

  export type EmployeeHoursLocalitiesSumAggregateInputType = {
    NotShowLocality?: true
    GpsRadius?: true
    LocalityIDAccess?: true
    LocalityCodeAccess?: true
    CustomerIDAccess?: true
    MinimumHours2BreakTime?: true
    BreakTime?: true
    AlertForMaxMonthHours?: true
    RestrictDayHoursAbove12?: true
    RestrictWeekExtraHoursAbove16?: true
    RestrictGpsActive?: true
  }

  export type EmployeeHoursLocalitiesMinAggregateInputType = {
    EmployeeHoursLocalityId?: true
    CreatedAt?: true
    NotShowLocality?: true
    LocalityName?: true
    LocalityNameEng?: true
    CompanyIdGeneralCRM?: true
    Address?: true
    Gps?: true
    GpsRadius?: true
    AddressAccess?: true
    LocalityIDAccess?: true
    LocalityCodeAccess?: true
    CustomerIDAccess?: true
    CustomerNameAccess?: true
    ForemanGeneralCRMUserId?: true
    HourMinStart?: true
    HourMaxStop?: true
    RoundTime?: true
    MinimumHours2BreakTime?: true
    BreakTime?: true
    AlertForMaxMonthHours?: true
    RestrictDayHoursAbove12?: true
    RestrictWeekExtraHoursAbove16?: true
    RestrictGpsActive?: true
  }

  export type EmployeeHoursLocalitiesMaxAggregateInputType = {
    EmployeeHoursLocalityId?: true
    CreatedAt?: true
    NotShowLocality?: true
    LocalityName?: true
    LocalityNameEng?: true
    CompanyIdGeneralCRM?: true
    Address?: true
    Gps?: true
    GpsRadius?: true
    AddressAccess?: true
    LocalityIDAccess?: true
    LocalityCodeAccess?: true
    CustomerIDAccess?: true
    CustomerNameAccess?: true
    ForemanGeneralCRMUserId?: true
    HourMinStart?: true
    HourMaxStop?: true
    RoundTime?: true
    MinimumHours2BreakTime?: true
    BreakTime?: true
    AlertForMaxMonthHours?: true
    RestrictDayHoursAbove12?: true
    RestrictWeekExtraHoursAbove16?: true
    RestrictGpsActive?: true
  }

  export type EmployeeHoursLocalitiesCountAggregateInputType = {
    EmployeeHoursLocalityId?: true
    CreatedAt?: true
    NotShowLocality?: true
    LocalityName?: true
    LocalityNameEng?: true
    CompanyIdGeneralCRM?: true
    Address?: true
    Gps?: true
    GpsRadius?: true
    AddressAccess?: true
    LocalityIDAccess?: true
    LocalityCodeAccess?: true
    CustomerIDAccess?: true
    CustomerNameAccess?: true
    ForemanGeneralCRMUserId?: true
    HourMinStart?: true
    HourMaxStop?: true
    RoundTime?: true
    MinimumHours2BreakTime?: true
    BreakTime?: true
    AlertForMaxMonthHours?: true
    RestrictDayHoursAbove12?: true
    RestrictWeekExtraHoursAbove16?: true
    RestrictGpsActive?: true
    _all?: true
  }

  export type EmployeeHoursLocalitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursLocalities to aggregate.
     */
    where?: EmployeeHoursLocalitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursLocalities to fetch.
     */
    orderBy?: EmployeeHoursLocalitiesOrderByWithRelationInput | EmployeeHoursLocalitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeHoursLocalitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursLocalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursLocalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeHoursLocalities
    **/
    _count?: true | EmployeeHoursLocalitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeHoursLocalitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeHoursLocalitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeHoursLocalitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeHoursLocalitiesMaxAggregateInputType
  }

  export type GetEmployeeHoursLocalitiesAggregateType<T extends EmployeeHoursLocalitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeHoursLocalities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeHoursLocalities[P]>
      : GetScalarType<T[P], AggregateEmployeeHoursLocalities[P]>
  }




  export type EmployeeHoursLocalitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursLocalitiesWhereInput
    orderBy?: EmployeeHoursLocalitiesOrderByWithAggregationInput | EmployeeHoursLocalitiesOrderByWithAggregationInput[]
    by: EmployeeHoursLocalitiesScalarFieldEnum[] | EmployeeHoursLocalitiesScalarFieldEnum
    having?: EmployeeHoursLocalitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeHoursLocalitiesCountAggregateInputType | true
    _avg?: EmployeeHoursLocalitiesAvgAggregateInputType
    _sum?: EmployeeHoursLocalitiesSumAggregateInputType
    _min?: EmployeeHoursLocalitiesMinAggregateInputType
    _max?: EmployeeHoursLocalitiesMaxAggregateInputType
  }

  export type EmployeeHoursLocalitiesGroupByOutputType = {
    EmployeeHoursLocalityId: string
    CreatedAt: Date | null
    NotShowLocality: number | null
    LocalityName: string
    LocalityNameEng: string | null
    CompanyIdGeneralCRM: string
    Address: string | null
    Gps: string | null
    GpsRadius: number
    AddressAccess: string | null
    LocalityIDAccess: number
    LocalityCodeAccess: number | null
    CustomerIDAccess: number | null
    CustomerNameAccess: string | null
    ForemanGeneralCRMUserId: string | null
    HourMinStart: Date | null
    HourMaxStop: Date | null
    RoundTime: string | null
    MinimumHours2BreakTime: number | null
    BreakTime: number | null
    AlertForMaxMonthHours: number | null
    RestrictDayHoursAbove12: number | null
    RestrictWeekExtraHoursAbove16: number | null
    RestrictGpsActive: number | null
    _count: EmployeeHoursLocalitiesCountAggregateOutputType | null
    _avg: EmployeeHoursLocalitiesAvgAggregateOutputType | null
    _sum: EmployeeHoursLocalitiesSumAggregateOutputType | null
    _min: EmployeeHoursLocalitiesMinAggregateOutputType | null
    _max: EmployeeHoursLocalitiesMaxAggregateOutputType | null
  }

  type GetEmployeeHoursLocalitiesGroupByPayload<T extends EmployeeHoursLocalitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeHoursLocalitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeHoursLocalitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeHoursLocalitiesGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeHoursLocalitiesGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeHoursLocalitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmployeeHoursLocalityId?: boolean
    CreatedAt?: boolean
    NotShowLocality?: boolean
    LocalityName?: boolean
    LocalityNameEng?: boolean
    CompanyIdGeneralCRM?: boolean
    Address?: boolean
    Gps?: boolean
    GpsRadius?: boolean
    AddressAccess?: boolean
    LocalityIDAccess?: boolean
    LocalityCodeAccess?: boolean
    CustomerIDAccess?: boolean
    CustomerNameAccess?: boolean
    ForemanGeneralCRMUserId?: boolean
    HourMinStart?: boolean
    HourMaxStop?: boolean
    RoundTime?: boolean
    MinimumHours2BreakTime?: boolean
    BreakTime?: boolean
    AlertForMaxMonthHours?: boolean
    RestrictDayHoursAbove12?: boolean
    RestrictWeekExtraHoursAbove16?: boolean
    RestrictGpsActive?: boolean
    EmployeeHoursByLocality?: boolean | EmployeeHoursLocalities$EmployeeHoursByLocalityArgs<ExtArgs>
    EmployeeHoursByLocalityTotals?: boolean | EmployeeHoursLocalities$EmployeeHoursByLocalityTotalsArgs<ExtArgs>
    _count?: boolean | EmployeeHoursLocalitiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeHoursLocalities"]>


  export type EmployeeHoursLocalitiesSelectScalar = {
    EmployeeHoursLocalityId?: boolean
    CreatedAt?: boolean
    NotShowLocality?: boolean
    LocalityName?: boolean
    LocalityNameEng?: boolean
    CompanyIdGeneralCRM?: boolean
    Address?: boolean
    Gps?: boolean
    GpsRadius?: boolean
    AddressAccess?: boolean
    LocalityIDAccess?: boolean
    LocalityCodeAccess?: boolean
    CustomerIDAccess?: boolean
    CustomerNameAccess?: boolean
    ForemanGeneralCRMUserId?: boolean
    HourMinStart?: boolean
    HourMaxStop?: boolean
    RoundTime?: boolean
    MinimumHours2BreakTime?: boolean
    BreakTime?: boolean
    AlertForMaxMonthHours?: boolean
    RestrictDayHoursAbove12?: boolean
    RestrictWeekExtraHoursAbove16?: boolean
    RestrictGpsActive?: boolean
  }

  export type EmployeeHoursLocalitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeHoursByLocality?: boolean | EmployeeHoursLocalities$EmployeeHoursByLocalityArgs<ExtArgs>
    EmployeeHoursByLocalityTotals?: boolean | EmployeeHoursLocalities$EmployeeHoursByLocalityTotalsArgs<ExtArgs>
    _count?: boolean | EmployeeHoursLocalitiesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmployeeHoursLocalitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeHoursLocalities"
    objects: {
      EmployeeHoursByLocality: Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>[]
      EmployeeHoursByLocalityTotals: Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      EmployeeHoursLocalityId: string
      CreatedAt: Date | null
      NotShowLocality: number | null
      LocalityName: string
      LocalityNameEng: string | null
      CompanyIdGeneralCRM: string
      Address: string | null
      Gps: string | null
      GpsRadius: number
      AddressAccess: string | null
      LocalityIDAccess: number
      LocalityCodeAccess: number | null
      CustomerIDAccess: number | null
      CustomerNameAccess: string | null
      ForemanGeneralCRMUserId: string | null
      HourMinStart: Date | null
      HourMaxStop: Date | null
      RoundTime: string | null
      MinimumHours2BreakTime: number | null
      BreakTime: number | null
      AlertForMaxMonthHours: number | null
      RestrictDayHoursAbove12: number | null
      RestrictWeekExtraHoursAbove16: number | null
      RestrictGpsActive: number | null
    }, ExtArgs["result"]["employeeHoursLocalities"]>
    composites: {}
  }

  type EmployeeHoursLocalitiesGetPayload<S extends boolean | null | undefined | EmployeeHoursLocalitiesDefaultArgs> = $Result.GetResult<Prisma.$EmployeeHoursLocalitiesPayload, S>

  type EmployeeHoursLocalitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeHoursLocalitiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeHoursLocalitiesCountAggregateInputType | true
    }

  export interface EmployeeHoursLocalitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeHoursLocalities'], meta: { name: 'EmployeeHoursLocalities' } }
    /**
     * Find zero or one EmployeeHoursLocalities that matches the filter.
     * @param {EmployeeHoursLocalitiesFindUniqueArgs} args - Arguments to find a EmployeeHoursLocalities
     * @example
     * // Get one EmployeeHoursLocalities
     * const employeeHoursLocalities = await prisma.employeeHoursLocalities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeHoursLocalitiesFindUniqueArgs>(args: SelectSubset<T, EmployeeHoursLocalitiesFindUniqueArgs<ExtArgs>>): Prisma__EmployeeHoursLocalitiesClient<$Result.GetResult<Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeHoursLocalities that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeHoursLocalitiesFindUniqueOrThrowArgs} args - Arguments to find a EmployeeHoursLocalities
     * @example
     * // Get one EmployeeHoursLocalities
     * const employeeHoursLocalities = await prisma.employeeHoursLocalities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeHoursLocalitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeHoursLocalitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursLocalitiesClient<$Result.GetResult<Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeHoursLocalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursLocalitiesFindFirstArgs} args - Arguments to find a EmployeeHoursLocalities
     * @example
     * // Get one EmployeeHoursLocalities
     * const employeeHoursLocalities = await prisma.employeeHoursLocalities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeHoursLocalitiesFindFirstArgs>(args?: SelectSubset<T, EmployeeHoursLocalitiesFindFirstArgs<ExtArgs>>): Prisma__EmployeeHoursLocalitiesClient<$Result.GetResult<Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeHoursLocalities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursLocalitiesFindFirstOrThrowArgs} args - Arguments to find a EmployeeHoursLocalities
     * @example
     * // Get one EmployeeHoursLocalities
     * const employeeHoursLocalities = await prisma.employeeHoursLocalities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeHoursLocalitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeHoursLocalitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursLocalitiesClient<$Result.GetResult<Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeHoursLocalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursLocalitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeHoursLocalities
     * const employeeHoursLocalities = await prisma.employeeHoursLocalities.findMany()
     * 
     * // Get first 10 EmployeeHoursLocalities
     * const employeeHoursLocalities = await prisma.employeeHoursLocalities.findMany({ take: 10 })
     * 
     * // Only select the `EmployeeHoursLocalityId`
     * const employeeHoursLocalitiesWithEmployeeHoursLocalityIdOnly = await prisma.employeeHoursLocalities.findMany({ select: { EmployeeHoursLocalityId: true } })
     * 
     */
    findMany<T extends EmployeeHoursLocalitiesFindManyArgs>(args?: SelectSubset<T, EmployeeHoursLocalitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeHoursLocalities.
     * @param {EmployeeHoursLocalitiesCreateArgs} args - Arguments to create a EmployeeHoursLocalities.
     * @example
     * // Create one EmployeeHoursLocalities
     * const EmployeeHoursLocalities = await prisma.employeeHoursLocalities.create({
     *   data: {
     *     // ... data to create a EmployeeHoursLocalities
     *   }
     * })
     * 
     */
    create<T extends EmployeeHoursLocalitiesCreateArgs>(args: SelectSubset<T, EmployeeHoursLocalitiesCreateArgs<ExtArgs>>): Prisma__EmployeeHoursLocalitiesClient<$Result.GetResult<Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeHoursLocalities.
     * @param {EmployeeHoursLocalitiesCreateManyArgs} args - Arguments to create many EmployeeHoursLocalities.
     * @example
     * // Create many EmployeeHoursLocalities
     * const employeeHoursLocalities = await prisma.employeeHoursLocalities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeHoursLocalitiesCreateManyArgs>(args?: SelectSubset<T, EmployeeHoursLocalitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeHoursLocalities.
     * @param {EmployeeHoursLocalitiesDeleteArgs} args - Arguments to delete one EmployeeHoursLocalities.
     * @example
     * // Delete one EmployeeHoursLocalities
     * const EmployeeHoursLocalities = await prisma.employeeHoursLocalities.delete({
     *   where: {
     *     // ... filter to delete one EmployeeHoursLocalities
     *   }
     * })
     * 
     */
    delete<T extends EmployeeHoursLocalitiesDeleteArgs>(args: SelectSubset<T, EmployeeHoursLocalitiesDeleteArgs<ExtArgs>>): Prisma__EmployeeHoursLocalitiesClient<$Result.GetResult<Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeHoursLocalities.
     * @param {EmployeeHoursLocalitiesUpdateArgs} args - Arguments to update one EmployeeHoursLocalities.
     * @example
     * // Update one EmployeeHoursLocalities
     * const employeeHoursLocalities = await prisma.employeeHoursLocalities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeHoursLocalitiesUpdateArgs>(args: SelectSubset<T, EmployeeHoursLocalitiesUpdateArgs<ExtArgs>>): Prisma__EmployeeHoursLocalitiesClient<$Result.GetResult<Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeHoursLocalities.
     * @param {EmployeeHoursLocalitiesDeleteManyArgs} args - Arguments to filter EmployeeHoursLocalities to delete.
     * @example
     * // Delete a few EmployeeHoursLocalities
     * const { count } = await prisma.employeeHoursLocalities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeHoursLocalitiesDeleteManyArgs>(args?: SelectSubset<T, EmployeeHoursLocalitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeHoursLocalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursLocalitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeHoursLocalities
     * const employeeHoursLocalities = await prisma.employeeHoursLocalities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeHoursLocalitiesUpdateManyArgs>(args: SelectSubset<T, EmployeeHoursLocalitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeHoursLocalities.
     * @param {EmployeeHoursLocalitiesUpsertArgs} args - Arguments to update or create a EmployeeHoursLocalities.
     * @example
     * // Update or create a EmployeeHoursLocalities
     * const employeeHoursLocalities = await prisma.employeeHoursLocalities.upsert({
     *   create: {
     *     // ... data to create a EmployeeHoursLocalities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeHoursLocalities we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeHoursLocalitiesUpsertArgs>(args: SelectSubset<T, EmployeeHoursLocalitiesUpsertArgs<ExtArgs>>): Prisma__EmployeeHoursLocalitiesClient<$Result.GetResult<Prisma.$EmployeeHoursLocalitiesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeHoursLocalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursLocalitiesCountArgs} args - Arguments to filter EmployeeHoursLocalities to count.
     * @example
     * // Count the number of EmployeeHoursLocalities
     * const count = await prisma.employeeHoursLocalities.count({
     *   where: {
     *     // ... the filter for the EmployeeHoursLocalities we want to count
     *   }
     * })
    **/
    count<T extends EmployeeHoursLocalitiesCountArgs>(
      args?: Subset<T, EmployeeHoursLocalitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeHoursLocalitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeHoursLocalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursLocalitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeHoursLocalitiesAggregateArgs>(args: Subset<T, EmployeeHoursLocalitiesAggregateArgs>): Prisma.PrismaPromise<GetEmployeeHoursLocalitiesAggregateType<T>>

    /**
     * Group by EmployeeHoursLocalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursLocalitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeHoursLocalitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeHoursLocalitiesGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeHoursLocalitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeHoursLocalitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeHoursLocalitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeHoursLocalities model
   */
  readonly fields: EmployeeHoursLocalitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeHoursLocalities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeHoursLocalitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EmployeeHoursByLocality<T extends EmployeeHoursLocalities$EmployeeHoursByLocalityArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHoursLocalities$EmployeeHoursByLocalityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "findMany"> | Null>
    EmployeeHoursByLocalityTotals<T extends EmployeeHoursLocalities$EmployeeHoursByLocalityTotalsArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHoursLocalities$EmployeeHoursByLocalityTotalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeHoursLocalities model
   */ 
  interface EmployeeHoursLocalitiesFieldRefs {
    readonly EmployeeHoursLocalityId: FieldRef<"EmployeeHoursLocalities", 'String'>
    readonly CreatedAt: FieldRef<"EmployeeHoursLocalities", 'DateTime'>
    readonly NotShowLocality: FieldRef<"EmployeeHoursLocalities", 'Int'>
    readonly LocalityName: FieldRef<"EmployeeHoursLocalities", 'String'>
    readonly LocalityNameEng: FieldRef<"EmployeeHoursLocalities", 'String'>
    readonly CompanyIdGeneralCRM: FieldRef<"EmployeeHoursLocalities", 'String'>
    readonly Address: FieldRef<"EmployeeHoursLocalities", 'String'>
    readonly Gps: FieldRef<"EmployeeHoursLocalities", 'String'>
    readonly GpsRadius: FieldRef<"EmployeeHoursLocalities", 'Int'>
    readonly AddressAccess: FieldRef<"EmployeeHoursLocalities", 'String'>
    readonly LocalityIDAccess: FieldRef<"EmployeeHoursLocalities", 'Int'>
    readonly LocalityCodeAccess: FieldRef<"EmployeeHoursLocalities", 'Int'>
    readonly CustomerIDAccess: FieldRef<"EmployeeHoursLocalities", 'Int'>
    readonly CustomerNameAccess: FieldRef<"EmployeeHoursLocalities", 'String'>
    readonly ForemanGeneralCRMUserId: FieldRef<"EmployeeHoursLocalities", 'String'>
    readonly HourMinStart: FieldRef<"EmployeeHoursLocalities", 'DateTime'>
    readonly HourMaxStop: FieldRef<"EmployeeHoursLocalities", 'DateTime'>
    readonly RoundTime: FieldRef<"EmployeeHoursLocalities", 'String'>
    readonly MinimumHours2BreakTime: FieldRef<"EmployeeHoursLocalities", 'Float'>
    readonly BreakTime: FieldRef<"EmployeeHoursLocalities", 'Int'>
    readonly AlertForMaxMonthHours: FieldRef<"EmployeeHoursLocalities", 'Float'>
    readonly RestrictDayHoursAbove12: FieldRef<"EmployeeHoursLocalities", 'Int'>
    readonly RestrictWeekExtraHoursAbove16: FieldRef<"EmployeeHoursLocalities", 'Int'>
    readonly RestrictGpsActive: FieldRef<"EmployeeHoursLocalities", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeHoursLocalities findUnique
   */
  export type EmployeeHoursLocalitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursLocalities
     */
    select?: EmployeeHoursLocalitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursLocalitiesInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursLocalities to fetch.
     */
    where: EmployeeHoursLocalitiesWhereUniqueInput
  }

  /**
   * EmployeeHoursLocalities findUniqueOrThrow
   */
  export type EmployeeHoursLocalitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursLocalities
     */
    select?: EmployeeHoursLocalitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursLocalitiesInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursLocalities to fetch.
     */
    where: EmployeeHoursLocalitiesWhereUniqueInput
  }

  /**
   * EmployeeHoursLocalities findFirst
   */
  export type EmployeeHoursLocalitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursLocalities
     */
    select?: EmployeeHoursLocalitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursLocalitiesInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursLocalities to fetch.
     */
    where?: EmployeeHoursLocalitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursLocalities to fetch.
     */
    orderBy?: EmployeeHoursLocalitiesOrderByWithRelationInput | EmployeeHoursLocalitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursLocalities.
     */
    cursor?: EmployeeHoursLocalitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursLocalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursLocalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursLocalities.
     */
    distinct?: EmployeeHoursLocalitiesScalarFieldEnum | EmployeeHoursLocalitiesScalarFieldEnum[]
  }

  /**
   * EmployeeHoursLocalities findFirstOrThrow
   */
  export type EmployeeHoursLocalitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursLocalities
     */
    select?: EmployeeHoursLocalitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursLocalitiesInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursLocalities to fetch.
     */
    where?: EmployeeHoursLocalitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursLocalities to fetch.
     */
    orderBy?: EmployeeHoursLocalitiesOrderByWithRelationInput | EmployeeHoursLocalitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursLocalities.
     */
    cursor?: EmployeeHoursLocalitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursLocalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursLocalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursLocalities.
     */
    distinct?: EmployeeHoursLocalitiesScalarFieldEnum | EmployeeHoursLocalitiesScalarFieldEnum[]
  }

  /**
   * EmployeeHoursLocalities findMany
   */
  export type EmployeeHoursLocalitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursLocalities
     */
    select?: EmployeeHoursLocalitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursLocalitiesInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursLocalities to fetch.
     */
    where?: EmployeeHoursLocalitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursLocalities to fetch.
     */
    orderBy?: EmployeeHoursLocalitiesOrderByWithRelationInput | EmployeeHoursLocalitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeHoursLocalities.
     */
    cursor?: EmployeeHoursLocalitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursLocalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursLocalities.
     */
    skip?: number
    distinct?: EmployeeHoursLocalitiesScalarFieldEnum | EmployeeHoursLocalitiesScalarFieldEnum[]
  }

  /**
   * EmployeeHoursLocalities create
   */
  export type EmployeeHoursLocalitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursLocalities
     */
    select?: EmployeeHoursLocalitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursLocalitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeHoursLocalities.
     */
    data: XOR<EmployeeHoursLocalitiesCreateInput, EmployeeHoursLocalitiesUncheckedCreateInput>
  }

  /**
   * EmployeeHoursLocalities createMany
   */
  export type EmployeeHoursLocalitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeHoursLocalities.
     */
    data: EmployeeHoursLocalitiesCreateManyInput | EmployeeHoursLocalitiesCreateManyInput[]
  }

  /**
   * EmployeeHoursLocalities update
   */
  export type EmployeeHoursLocalitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursLocalities
     */
    select?: EmployeeHoursLocalitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursLocalitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeHoursLocalities.
     */
    data: XOR<EmployeeHoursLocalitiesUpdateInput, EmployeeHoursLocalitiesUncheckedUpdateInput>
    /**
     * Choose, which EmployeeHoursLocalities to update.
     */
    where: EmployeeHoursLocalitiesWhereUniqueInput
  }

  /**
   * EmployeeHoursLocalities updateMany
   */
  export type EmployeeHoursLocalitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeHoursLocalities.
     */
    data: XOR<EmployeeHoursLocalitiesUpdateManyMutationInput, EmployeeHoursLocalitiesUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeHoursLocalities to update
     */
    where?: EmployeeHoursLocalitiesWhereInput
  }

  /**
   * EmployeeHoursLocalities upsert
   */
  export type EmployeeHoursLocalitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursLocalities
     */
    select?: EmployeeHoursLocalitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursLocalitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeHoursLocalities to update in case it exists.
     */
    where: EmployeeHoursLocalitiesWhereUniqueInput
    /**
     * In case the EmployeeHoursLocalities found by the `where` argument doesn't exist, create a new EmployeeHoursLocalities with this data.
     */
    create: XOR<EmployeeHoursLocalitiesCreateInput, EmployeeHoursLocalitiesUncheckedCreateInput>
    /**
     * In case the EmployeeHoursLocalities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeHoursLocalitiesUpdateInput, EmployeeHoursLocalitiesUncheckedUpdateInput>
  }

  /**
   * EmployeeHoursLocalities delete
   */
  export type EmployeeHoursLocalitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursLocalities
     */
    select?: EmployeeHoursLocalitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursLocalitiesInclude<ExtArgs> | null
    /**
     * Filter which EmployeeHoursLocalities to delete.
     */
    where: EmployeeHoursLocalitiesWhereUniqueInput
  }

  /**
   * EmployeeHoursLocalities deleteMany
   */
  export type EmployeeHoursLocalitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursLocalities to delete
     */
    where?: EmployeeHoursLocalitiesWhereInput
  }

  /**
   * EmployeeHoursLocalities.EmployeeHoursByLocality
   */
  export type EmployeeHoursLocalities$EmployeeHoursByLocalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
    where?: EmployeeHoursByLocalityWhereInput
    orderBy?: EmployeeHoursByLocalityOrderByWithRelationInput | EmployeeHoursByLocalityOrderByWithRelationInput[]
    cursor?: EmployeeHoursByLocalityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeHoursByLocalityScalarFieldEnum | EmployeeHoursByLocalityScalarFieldEnum[]
  }

  /**
   * EmployeeHoursLocalities.EmployeeHoursByLocalityTotals
   */
  export type EmployeeHoursLocalities$EmployeeHoursByLocalityTotalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotals
     */
    select?: EmployeeHoursByLocalityTotalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsInclude<ExtArgs> | null
    where?: EmployeeHoursByLocalityTotalsWhereInput
    orderBy?: EmployeeHoursByLocalityTotalsOrderByWithRelationInput | EmployeeHoursByLocalityTotalsOrderByWithRelationInput[]
    cursor?: EmployeeHoursByLocalityTotalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeHoursByLocalityTotalsScalarFieldEnum | EmployeeHoursByLocalityTotalsScalarFieldEnum[]
  }

  /**
   * EmployeeHoursLocalities without action
   */
  export type EmployeeHoursLocalitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursLocalities
     */
    select?: EmployeeHoursLocalitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursLocalitiesInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeHoursUsers
   */

  export type AggregateEmployeeHoursUsers = {
    _count: EmployeeHoursUsersCountAggregateOutputType | null
    _avg: EmployeeHoursUsersAvgAggregateOutputType | null
    _sum: EmployeeHoursUsersSumAggregateOutputType | null
    _min: EmployeeHoursUsersMinAggregateOutputType | null
    _max: EmployeeHoursUsersMaxAggregateOutputType | null
  }

  export type EmployeeHoursUsersAvgAggregateOutputType = {
    EmployeeId: number | null
    IsAdmin: number | null
    IsAllowAccess2WebSite: number | null
  }

  export type EmployeeHoursUsersSumAggregateOutputType = {
    EmployeeId: number | null
    IsAdmin: number | null
    IsAllowAccess2WebSite: number | null
  }

  export type EmployeeHoursUsersMinAggregateOutputType = {
    EmployeeHoursUsersId: string | null
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string | null
    EmployeeId: number | null
    MobileNumber: string | null
    UserName: string | null
    Password: string | null
    IsAdmin: number | null
    LastEntry: Date | null
    IsAllowAccess2WebSite: number | null
    PhoneData: string | null
    CookieError: Date | null
  }

  export type EmployeeHoursUsersMaxAggregateOutputType = {
    EmployeeHoursUsersId: string | null
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string | null
    EmployeeId: number | null
    MobileNumber: string | null
    UserName: string | null
    Password: string | null
    IsAdmin: number | null
    LastEntry: Date | null
    IsAllowAccess2WebSite: number | null
    PhoneData: string | null
    CookieError: Date | null
  }

  export type EmployeeHoursUsersCountAggregateOutputType = {
    EmployeeHoursUsersId: number
    CreatedAt: number
    CompanyIdGeneralCRM: number
    EmployeeId: number
    MobileNumber: number
    UserName: number
    Password: number
    IsAdmin: number
    LastEntry: number
    IsAllowAccess2WebSite: number
    PhoneData: number
    CookieError: number
    _all: number
  }


  export type EmployeeHoursUsersAvgAggregateInputType = {
    EmployeeId?: true
    IsAdmin?: true
    IsAllowAccess2WebSite?: true
  }

  export type EmployeeHoursUsersSumAggregateInputType = {
    EmployeeId?: true
    IsAdmin?: true
    IsAllowAccess2WebSite?: true
  }

  export type EmployeeHoursUsersMinAggregateInputType = {
    EmployeeHoursUsersId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    EmployeeId?: true
    MobileNumber?: true
    UserName?: true
    Password?: true
    IsAdmin?: true
    LastEntry?: true
    IsAllowAccess2WebSite?: true
    PhoneData?: true
    CookieError?: true
  }

  export type EmployeeHoursUsersMaxAggregateInputType = {
    EmployeeHoursUsersId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    EmployeeId?: true
    MobileNumber?: true
    UserName?: true
    Password?: true
    IsAdmin?: true
    LastEntry?: true
    IsAllowAccess2WebSite?: true
    PhoneData?: true
    CookieError?: true
  }

  export type EmployeeHoursUsersCountAggregateInputType = {
    EmployeeHoursUsersId?: true
    CreatedAt?: true
    CompanyIdGeneralCRM?: true
    EmployeeId?: true
    MobileNumber?: true
    UserName?: true
    Password?: true
    IsAdmin?: true
    LastEntry?: true
    IsAllowAccess2WebSite?: true
    PhoneData?: true
    CookieError?: true
    _all?: true
  }

  export type EmployeeHoursUsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursUsers to aggregate.
     */
    where?: EmployeeHoursUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursUsers to fetch.
     */
    orderBy?: EmployeeHoursUsersOrderByWithRelationInput | EmployeeHoursUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeHoursUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeHoursUsers
    **/
    _count?: true | EmployeeHoursUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeHoursUsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeHoursUsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeHoursUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeHoursUsersMaxAggregateInputType
  }

  export type GetEmployeeHoursUsersAggregateType<T extends EmployeeHoursUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeHoursUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeHoursUsers[P]>
      : GetScalarType<T[P], AggregateEmployeeHoursUsers[P]>
  }




  export type EmployeeHoursUsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeHoursUsersWhereInput
    orderBy?: EmployeeHoursUsersOrderByWithAggregationInput | EmployeeHoursUsersOrderByWithAggregationInput[]
    by: EmployeeHoursUsersScalarFieldEnum[] | EmployeeHoursUsersScalarFieldEnum
    having?: EmployeeHoursUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeHoursUsersCountAggregateInputType | true
    _avg?: EmployeeHoursUsersAvgAggregateInputType
    _sum?: EmployeeHoursUsersSumAggregateInputType
    _min?: EmployeeHoursUsersMinAggregateInputType
    _max?: EmployeeHoursUsersMaxAggregateInputType
  }

  export type EmployeeHoursUsersGroupByOutputType = {
    EmployeeHoursUsersId: string
    CreatedAt: Date | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    MobileNumber: string | null
    UserName: string
    Password: string
    IsAdmin: number
    LastEntry: Date | null
    IsAllowAccess2WebSite: number
    PhoneData: string | null
    CookieError: Date | null
    _count: EmployeeHoursUsersCountAggregateOutputType | null
    _avg: EmployeeHoursUsersAvgAggregateOutputType | null
    _sum: EmployeeHoursUsersSumAggregateOutputType | null
    _min: EmployeeHoursUsersMinAggregateOutputType | null
    _max: EmployeeHoursUsersMaxAggregateOutputType | null
  }

  type GetEmployeeHoursUsersGroupByPayload<T extends EmployeeHoursUsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeHoursUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeHoursUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeHoursUsersGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeHoursUsersGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeHoursUsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmployeeHoursUsersId?: boolean
    CreatedAt?: boolean
    CompanyIdGeneralCRM?: boolean
    EmployeeId?: boolean
    MobileNumber?: boolean
    UserName?: boolean
    Password?: boolean
    IsAdmin?: boolean
    LastEntry?: boolean
    IsAllowAccess2WebSite?: boolean
    PhoneData?: boolean
    CookieError?: boolean
    EmployeeHoursByLocality?: boolean | EmployeeHoursUsers$EmployeeHoursByLocalityArgs<ExtArgs>
    _count?: boolean | EmployeeHoursUsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeHoursUsers"]>


  export type EmployeeHoursUsersSelectScalar = {
    EmployeeHoursUsersId?: boolean
    CreatedAt?: boolean
    CompanyIdGeneralCRM?: boolean
    EmployeeId?: boolean
    MobileNumber?: boolean
    UserName?: boolean
    Password?: boolean
    IsAdmin?: boolean
    LastEntry?: boolean
    IsAllowAccess2WebSite?: boolean
    PhoneData?: boolean
    CookieError?: boolean
  }

  export type EmployeeHoursUsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeHoursByLocality?: boolean | EmployeeHoursUsers$EmployeeHoursByLocalityArgs<ExtArgs>
    _count?: boolean | EmployeeHoursUsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmployeeHoursUsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeHoursUsers"
    objects: {
      EmployeeHoursByLocality: Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      EmployeeHoursUsersId: string
      CreatedAt: Date | null
      CompanyIdGeneralCRM: string
      EmployeeId: number
      MobileNumber: string | null
      UserName: string
      Password: string
      IsAdmin: number
      LastEntry: Date | null
      IsAllowAccess2WebSite: number
      PhoneData: string | null
      CookieError: Date | null
    }, ExtArgs["result"]["employeeHoursUsers"]>
    composites: {}
  }

  type EmployeeHoursUsersGetPayload<S extends boolean | null | undefined | EmployeeHoursUsersDefaultArgs> = $Result.GetResult<Prisma.$EmployeeHoursUsersPayload, S>

  type EmployeeHoursUsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeHoursUsersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeHoursUsersCountAggregateInputType | true
    }

  export interface EmployeeHoursUsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeHoursUsers'], meta: { name: 'EmployeeHoursUsers' } }
    /**
     * Find zero or one EmployeeHoursUsers that matches the filter.
     * @param {EmployeeHoursUsersFindUniqueArgs} args - Arguments to find a EmployeeHoursUsers
     * @example
     * // Get one EmployeeHoursUsers
     * const employeeHoursUsers = await prisma.employeeHoursUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeHoursUsersFindUniqueArgs>(args: SelectSubset<T, EmployeeHoursUsersFindUniqueArgs<ExtArgs>>): Prisma__EmployeeHoursUsersClient<$Result.GetResult<Prisma.$EmployeeHoursUsersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeHoursUsers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeHoursUsersFindUniqueOrThrowArgs} args - Arguments to find a EmployeeHoursUsers
     * @example
     * // Get one EmployeeHoursUsers
     * const employeeHoursUsers = await prisma.employeeHoursUsers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeHoursUsersFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeHoursUsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursUsersClient<$Result.GetResult<Prisma.$EmployeeHoursUsersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeHoursUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursUsersFindFirstArgs} args - Arguments to find a EmployeeHoursUsers
     * @example
     * // Get one EmployeeHoursUsers
     * const employeeHoursUsers = await prisma.employeeHoursUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeHoursUsersFindFirstArgs>(args?: SelectSubset<T, EmployeeHoursUsersFindFirstArgs<ExtArgs>>): Prisma__EmployeeHoursUsersClient<$Result.GetResult<Prisma.$EmployeeHoursUsersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeHoursUsers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursUsersFindFirstOrThrowArgs} args - Arguments to find a EmployeeHoursUsers
     * @example
     * // Get one EmployeeHoursUsers
     * const employeeHoursUsers = await prisma.employeeHoursUsers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeHoursUsersFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeHoursUsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeHoursUsersClient<$Result.GetResult<Prisma.$EmployeeHoursUsersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeHoursUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursUsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeHoursUsers
     * const employeeHoursUsers = await prisma.employeeHoursUsers.findMany()
     * 
     * // Get first 10 EmployeeHoursUsers
     * const employeeHoursUsers = await prisma.employeeHoursUsers.findMany({ take: 10 })
     * 
     * // Only select the `EmployeeHoursUsersId`
     * const employeeHoursUsersWithEmployeeHoursUsersIdOnly = await prisma.employeeHoursUsers.findMany({ select: { EmployeeHoursUsersId: true } })
     * 
     */
    findMany<T extends EmployeeHoursUsersFindManyArgs>(args?: SelectSubset<T, EmployeeHoursUsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursUsersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeHoursUsers.
     * @param {EmployeeHoursUsersCreateArgs} args - Arguments to create a EmployeeHoursUsers.
     * @example
     * // Create one EmployeeHoursUsers
     * const EmployeeHoursUsers = await prisma.employeeHoursUsers.create({
     *   data: {
     *     // ... data to create a EmployeeHoursUsers
     *   }
     * })
     * 
     */
    create<T extends EmployeeHoursUsersCreateArgs>(args: SelectSubset<T, EmployeeHoursUsersCreateArgs<ExtArgs>>): Prisma__EmployeeHoursUsersClient<$Result.GetResult<Prisma.$EmployeeHoursUsersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeHoursUsers.
     * @param {EmployeeHoursUsersCreateManyArgs} args - Arguments to create many EmployeeHoursUsers.
     * @example
     * // Create many EmployeeHoursUsers
     * const employeeHoursUsers = await prisma.employeeHoursUsers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeHoursUsersCreateManyArgs>(args?: SelectSubset<T, EmployeeHoursUsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeHoursUsers.
     * @param {EmployeeHoursUsersDeleteArgs} args - Arguments to delete one EmployeeHoursUsers.
     * @example
     * // Delete one EmployeeHoursUsers
     * const EmployeeHoursUsers = await prisma.employeeHoursUsers.delete({
     *   where: {
     *     // ... filter to delete one EmployeeHoursUsers
     *   }
     * })
     * 
     */
    delete<T extends EmployeeHoursUsersDeleteArgs>(args: SelectSubset<T, EmployeeHoursUsersDeleteArgs<ExtArgs>>): Prisma__EmployeeHoursUsersClient<$Result.GetResult<Prisma.$EmployeeHoursUsersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeHoursUsers.
     * @param {EmployeeHoursUsersUpdateArgs} args - Arguments to update one EmployeeHoursUsers.
     * @example
     * // Update one EmployeeHoursUsers
     * const employeeHoursUsers = await prisma.employeeHoursUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeHoursUsersUpdateArgs>(args: SelectSubset<T, EmployeeHoursUsersUpdateArgs<ExtArgs>>): Prisma__EmployeeHoursUsersClient<$Result.GetResult<Prisma.$EmployeeHoursUsersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeHoursUsers.
     * @param {EmployeeHoursUsersDeleteManyArgs} args - Arguments to filter EmployeeHoursUsers to delete.
     * @example
     * // Delete a few EmployeeHoursUsers
     * const { count } = await prisma.employeeHoursUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeHoursUsersDeleteManyArgs>(args?: SelectSubset<T, EmployeeHoursUsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeHoursUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeHoursUsers
     * const employeeHoursUsers = await prisma.employeeHoursUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeHoursUsersUpdateManyArgs>(args: SelectSubset<T, EmployeeHoursUsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeHoursUsers.
     * @param {EmployeeHoursUsersUpsertArgs} args - Arguments to update or create a EmployeeHoursUsers.
     * @example
     * // Update or create a EmployeeHoursUsers
     * const employeeHoursUsers = await prisma.employeeHoursUsers.upsert({
     *   create: {
     *     // ... data to create a EmployeeHoursUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeHoursUsers we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeHoursUsersUpsertArgs>(args: SelectSubset<T, EmployeeHoursUsersUpsertArgs<ExtArgs>>): Prisma__EmployeeHoursUsersClient<$Result.GetResult<Prisma.$EmployeeHoursUsersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeHoursUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursUsersCountArgs} args - Arguments to filter EmployeeHoursUsers to count.
     * @example
     * // Count the number of EmployeeHoursUsers
     * const count = await prisma.employeeHoursUsers.count({
     *   where: {
     *     // ... the filter for the EmployeeHoursUsers we want to count
     *   }
     * })
    **/
    count<T extends EmployeeHoursUsersCountArgs>(
      args?: Subset<T, EmployeeHoursUsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeHoursUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeHoursUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeHoursUsersAggregateArgs>(args: Subset<T, EmployeeHoursUsersAggregateArgs>): Prisma.PrismaPromise<GetEmployeeHoursUsersAggregateType<T>>

    /**
     * Group by EmployeeHoursUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeHoursUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeHoursUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeHoursUsersGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeHoursUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeHoursUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeHoursUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeHoursUsers model
   */
  readonly fields: EmployeeHoursUsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeHoursUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeHoursUsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EmployeeHoursByLocality<T extends EmployeeHoursUsers$EmployeeHoursByLocalityArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeHoursUsers$EmployeeHoursByLocalityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursByLocalityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeHoursUsers model
   */ 
  interface EmployeeHoursUsersFieldRefs {
    readonly EmployeeHoursUsersId: FieldRef<"EmployeeHoursUsers", 'String'>
    readonly CreatedAt: FieldRef<"EmployeeHoursUsers", 'DateTime'>
    readonly CompanyIdGeneralCRM: FieldRef<"EmployeeHoursUsers", 'String'>
    readonly EmployeeId: FieldRef<"EmployeeHoursUsers", 'Int'>
    readonly MobileNumber: FieldRef<"EmployeeHoursUsers", 'String'>
    readonly UserName: FieldRef<"EmployeeHoursUsers", 'String'>
    readonly Password: FieldRef<"EmployeeHoursUsers", 'String'>
    readonly IsAdmin: FieldRef<"EmployeeHoursUsers", 'Int'>
    readonly LastEntry: FieldRef<"EmployeeHoursUsers", 'DateTime'>
    readonly IsAllowAccess2WebSite: FieldRef<"EmployeeHoursUsers", 'Int'>
    readonly PhoneData: FieldRef<"EmployeeHoursUsers", 'String'>
    readonly CookieError: FieldRef<"EmployeeHoursUsers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeHoursUsers findUnique
   */
  export type EmployeeHoursUsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursUsers
     */
    select?: EmployeeHoursUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursUsersInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursUsers to fetch.
     */
    where: EmployeeHoursUsersWhereUniqueInput
  }

  /**
   * EmployeeHoursUsers findUniqueOrThrow
   */
  export type EmployeeHoursUsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursUsers
     */
    select?: EmployeeHoursUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursUsersInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursUsers to fetch.
     */
    where: EmployeeHoursUsersWhereUniqueInput
  }

  /**
   * EmployeeHoursUsers findFirst
   */
  export type EmployeeHoursUsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursUsers
     */
    select?: EmployeeHoursUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursUsersInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursUsers to fetch.
     */
    where?: EmployeeHoursUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursUsers to fetch.
     */
    orderBy?: EmployeeHoursUsersOrderByWithRelationInput | EmployeeHoursUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursUsers.
     */
    cursor?: EmployeeHoursUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursUsers.
     */
    distinct?: EmployeeHoursUsersScalarFieldEnum | EmployeeHoursUsersScalarFieldEnum[]
  }

  /**
   * EmployeeHoursUsers findFirstOrThrow
   */
  export type EmployeeHoursUsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursUsers
     */
    select?: EmployeeHoursUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursUsersInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursUsers to fetch.
     */
    where?: EmployeeHoursUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursUsers to fetch.
     */
    orderBy?: EmployeeHoursUsersOrderByWithRelationInput | EmployeeHoursUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeHoursUsers.
     */
    cursor?: EmployeeHoursUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeHoursUsers.
     */
    distinct?: EmployeeHoursUsersScalarFieldEnum | EmployeeHoursUsersScalarFieldEnum[]
  }

  /**
   * EmployeeHoursUsers findMany
   */
  export type EmployeeHoursUsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursUsers
     */
    select?: EmployeeHoursUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursUsersInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeHoursUsers to fetch.
     */
    where?: EmployeeHoursUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeHoursUsers to fetch.
     */
    orderBy?: EmployeeHoursUsersOrderByWithRelationInput | EmployeeHoursUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeHoursUsers.
     */
    cursor?: EmployeeHoursUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeHoursUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeHoursUsers.
     */
    skip?: number
    distinct?: EmployeeHoursUsersScalarFieldEnum | EmployeeHoursUsersScalarFieldEnum[]
  }

  /**
   * EmployeeHoursUsers create
   */
  export type EmployeeHoursUsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursUsers
     */
    select?: EmployeeHoursUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursUsersInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeHoursUsers.
     */
    data: XOR<EmployeeHoursUsersCreateInput, EmployeeHoursUsersUncheckedCreateInput>
  }

  /**
   * EmployeeHoursUsers createMany
   */
  export type EmployeeHoursUsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeHoursUsers.
     */
    data: EmployeeHoursUsersCreateManyInput | EmployeeHoursUsersCreateManyInput[]
  }

  /**
   * EmployeeHoursUsers update
   */
  export type EmployeeHoursUsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursUsers
     */
    select?: EmployeeHoursUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursUsersInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeHoursUsers.
     */
    data: XOR<EmployeeHoursUsersUpdateInput, EmployeeHoursUsersUncheckedUpdateInput>
    /**
     * Choose, which EmployeeHoursUsers to update.
     */
    where: EmployeeHoursUsersWhereUniqueInput
  }

  /**
   * EmployeeHoursUsers updateMany
   */
  export type EmployeeHoursUsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeHoursUsers.
     */
    data: XOR<EmployeeHoursUsersUpdateManyMutationInput, EmployeeHoursUsersUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeHoursUsers to update
     */
    where?: EmployeeHoursUsersWhereInput
  }

  /**
   * EmployeeHoursUsers upsert
   */
  export type EmployeeHoursUsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursUsers
     */
    select?: EmployeeHoursUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursUsersInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeHoursUsers to update in case it exists.
     */
    where: EmployeeHoursUsersWhereUniqueInput
    /**
     * In case the EmployeeHoursUsers found by the `where` argument doesn't exist, create a new EmployeeHoursUsers with this data.
     */
    create: XOR<EmployeeHoursUsersCreateInput, EmployeeHoursUsersUncheckedCreateInput>
    /**
     * In case the EmployeeHoursUsers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeHoursUsersUpdateInput, EmployeeHoursUsersUncheckedUpdateInput>
  }

  /**
   * EmployeeHoursUsers delete
   */
  export type EmployeeHoursUsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursUsers
     */
    select?: EmployeeHoursUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursUsersInclude<ExtArgs> | null
    /**
     * Filter which EmployeeHoursUsers to delete.
     */
    where: EmployeeHoursUsersWhereUniqueInput
  }

  /**
   * EmployeeHoursUsers deleteMany
   */
  export type EmployeeHoursUsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeHoursUsers to delete
     */
    where?: EmployeeHoursUsersWhereInput
  }

  /**
   * EmployeeHoursUsers.EmployeeHoursByLocality
   */
  export type EmployeeHoursUsers$EmployeeHoursByLocalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocality
     */
    select?: EmployeeHoursByLocalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityInclude<ExtArgs> | null
    where?: EmployeeHoursByLocalityWhereInput
    orderBy?: EmployeeHoursByLocalityOrderByWithRelationInput | EmployeeHoursByLocalityOrderByWithRelationInput[]
    cursor?: EmployeeHoursByLocalityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeHoursByLocalityScalarFieldEnum | EmployeeHoursByLocalityScalarFieldEnum[]
  }

  /**
   * EmployeeHoursUsers without action
   */
  export type EmployeeHoursUsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursUsers
     */
    select?: EmployeeHoursUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursUsersInclude<ExtArgs> | null
  }


  /**
   * Model EmployeesAccessDocumentsTemp
   */

  export type AggregateEmployeesAccessDocumentsTemp = {
    _count: EmployeesAccessDocumentsTempCountAggregateOutputType | null
    _min: EmployeesAccessDocumentsTempMinAggregateOutputType | null
    _max: EmployeesAccessDocumentsTempMaxAggregateOutputType | null
  }

  export type EmployeesAccessDocumentsTempMinAggregateOutputType = {
    EmployeesAccessDocumentTempId: string | null
    CompanyGeneralCrmId: string | null
    CreatedAt: Date | null
    EmployeeID: string | null
    DocumemtID: string | null
    Date: string | null
    DocumemtType: string | null
    Comment: string | null
    DocumentName: string | null
  }

  export type EmployeesAccessDocumentsTempMaxAggregateOutputType = {
    EmployeesAccessDocumentTempId: string | null
    CompanyGeneralCrmId: string | null
    CreatedAt: Date | null
    EmployeeID: string | null
    DocumemtID: string | null
    Date: string | null
    DocumemtType: string | null
    Comment: string | null
    DocumentName: string | null
  }

  export type EmployeesAccessDocumentsTempCountAggregateOutputType = {
    EmployeesAccessDocumentTempId: number
    CompanyGeneralCrmId: number
    CreatedAt: number
    EmployeeID: number
    DocumemtID: number
    Date: number
    DocumemtType: number
    Comment: number
    DocumentName: number
    _all: number
  }


  export type EmployeesAccessDocumentsTempMinAggregateInputType = {
    EmployeesAccessDocumentTempId?: true
    CompanyGeneralCrmId?: true
    CreatedAt?: true
    EmployeeID?: true
    DocumemtID?: true
    Date?: true
    DocumemtType?: true
    Comment?: true
    DocumentName?: true
  }

  export type EmployeesAccessDocumentsTempMaxAggregateInputType = {
    EmployeesAccessDocumentTempId?: true
    CompanyGeneralCrmId?: true
    CreatedAt?: true
    EmployeeID?: true
    DocumemtID?: true
    Date?: true
    DocumemtType?: true
    Comment?: true
    DocumentName?: true
  }

  export type EmployeesAccessDocumentsTempCountAggregateInputType = {
    EmployeesAccessDocumentTempId?: true
    CompanyGeneralCrmId?: true
    CreatedAt?: true
    EmployeeID?: true
    DocumemtID?: true
    Date?: true
    DocumemtType?: true
    Comment?: true
    DocumentName?: true
    _all?: true
  }

  export type EmployeesAccessDocumentsTempAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeesAccessDocumentsTemp to aggregate.
     */
    where?: EmployeesAccessDocumentsTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessDocumentsTemps to fetch.
     */
    orderBy?: EmployeesAccessDocumentsTempOrderByWithRelationInput | EmployeesAccessDocumentsTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeesAccessDocumentsTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessDocumentsTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessDocumentsTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeesAccessDocumentsTemps
    **/
    _count?: true | EmployeesAccessDocumentsTempCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeesAccessDocumentsTempMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeesAccessDocumentsTempMaxAggregateInputType
  }

  export type GetEmployeesAccessDocumentsTempAggregateType<T extends EmployeesAccessDocumentsTempAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeesAccessDocumentsTemp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeesAccessDocumentsTemp[P]>
      : GetScalarType<T[P], AggregateEmployeesAccessDocumentsTemp[P]>
  }




  export type EmployeesAccessDocumentsTempGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeesAccessDocumentsTempWhereInput
    orderBy?: EmployeesAccessDocumentsTempOrderByWithAggregationInput | EmployeesAccessDocumentsTempOrderByWithAggregationInput[]
    by: EmployeesAccessDocumentsTempScalarFieldEnum[] | EmployeesAccessDocumentsTempScalarFieldEnum
    having?: EmployeesAccessDocumentsTempScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeesAccessDocumentsTempCountAggregateInputType | true
    _min?: EmployeesAccessDocumentsTempMinAggregateInputType
    _max?: EmployeesAccessDocumentsTempMaxAggregateInputType
  }

  export type EmployeesAccessDocumentsTempGroupByOutputType = {
    EmployeesAccessDocumentTempId: string
    CompanyGeneralCrmId: string
    CreatedAt: Date
    EmployeeID: string | null
    DocumemtID: string | null
    Date: string | null
    DocumemtType: string | null
    Comment: string | null
    DocumentName: string | null
    _count: EmployeesAccessDocumentsTempCountAggregateOutputType | null
    _min: EmployeesAccessDocumentsTempMinAggregateOutputType | null
    _max: EmployeesAccessDocumentsTempMaxAggregateOutputType | null
  }

  type GetEmployeesAccessDocumentsTempGroupByPayload<T extends EmployeesAccessDocumentsTempGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeesAccessDocumentsTempGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeesAccessDocumentsTempGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeesAccessDocumentsTempGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeesAccessDocumentsTempGroupByOutputType[P]>
        }
      >
    >


  export type EmployeesAccessDocumentsTempSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmployeesAccessDocumentTempId?: boolean
    CompanyGeneralCrmId?: boolean
    CreatedAt?: boolean
    EmployeeID?: boolean
    DocumemtID?: boolean
    Date?: boolean
    DocumemtType?: boolean
    Comment?: boolean
    DocumentName?: boolean
  }, ExtArgs["result"]["employeesAccessDocumentsTemp"]>


  export type EmployeesAccessDocumentsTempSelectScalar = {
    EmployeesAccessDocumentTempId?: boolean
    CompanyGeneralCrmId?: boolean
    CreatedAt?: boolean
    EmployeeID?: boolean
    DocumemtID?: boolean
    Date?: boolean
    DocumemtType?: boolean
    Comment?: boolean
    DocumentName?: boolean
  }


  export type $EmployeesAccessDocumentsTempPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeesAccessDocumentsTemp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      EmployeesAccessDocumentTempId: string
      CompanyGeneralCrmId: string
      CreatedAt: Date
      EmployeeID: string | null
      DocumemtID: string | null
      Date: string | null
      DocumemtType: string | null
      Comment: string | null
      DocumentName: string | null
    }, ExtArgs["result"]["employeesAccessDocumentsTemp"]>
    composites: {}
  }

  type EmployeesAccessDocumentsTempGetPayload<S extends boolean | null | undefined | EmployeesAccessDocumentsTempDefaultArgs> = $Result.GetResult<Prisma.$EmployeesAccessDocumentsTempPayload, S>

  type EmployeesAccessDocumentsTempCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeesAccessDocumentsTempFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeesAccessDocumentsTempCountAggregateInputType | true
    }

  export interface EmployeesAccessDocumentsTempDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeesAccessDocumentsTemp'], meta: { name: 'EmployeesAccessDocumentsTemp' } }
    /**
     * Find zero or one EmployeesAccessDocumentsTemp that matches the filter.
     * @param {EmployeesAccessDocumentsTempFindUniqueArgs} args - Arguments to find a EmployeesAccessDocumentsTemp
     * @example
     * // Get one EmployeesAccessDocumentsTemp
     * const employeesAccessDocumentsTemp = await prisma.employeesAccessDocumentsTemp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeesAccessDocumentsTempFindUniqueArgs>(args: SelectSubset<T, EmployeesAccessDocumentsTempFindUniqueArgs<ExtArgs>>): Prisma__EmployeesAccessDocumentsTempClient<$Result.GetResult<Prisma.$EmployeesAccessDocumentsTempPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeesAccessDocumentsTemp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeesAccessDocumentsTempFindUniqueOrThrowArgs} args - Arguments to find a EmployeesAccessDocumentsTemp
     * @example
     * // Get one EmployeesAccessDocumentsTemp
     * const employeesAccessDocumentsTemp = await prisma.employeesAccessDocumentsTemp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeesAccessDocumentsTempFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeesAccessDocumentsTempFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeesAccessDocumentsTempClient<$Result.GetResult<Prisma.$EmployeesAccessDocumentsTempPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeesAccessDocumentsTemp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessDocumentsTempFindFirstArgs} args - Arguments to find a EmployeesAccessDocumentsTemp
     * @example
     * // Get one EmployeesAccessDocumentsTemp
     * const employeesAccessDocumentsTemp = await prisma.employeesAccessDocumentsTemp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeesAccessDocumentsTempFindFirstArgs>(args?: SelectSubset<T, EmployeesAccessDocumentsTempFindFirstArgs<ExtArgs>>): Prisma__EmployeesAccessDocumentsTempClient<$Result.GetResult<Prisma.$EmployeesAccessDocumentsTempPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeesAccessDocumentsTemp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessDocumentsTempFindFirstOrThrowArgs} args - Arguments to find a EmployeesAccessDocumentsTemp
     * @example
     * // Get one EmployeesAccessDocumentsTemp
     * const employeesAccessDocumentsTemp = await prisma.employeesAccessDocumentsTemp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeesAccessDocumentsTempFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeesAccessDocumentsTempFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeesAccessDocumentsTempClient<$Result.GetResult<Prisma.$EmployeesAccessDocumentsTempPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeesAccessDocumentsTemps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessDocumentsTempFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeesAccessDocumentsTemps
     * const employeesAccessDocumentsTemps = await prisma.employeesAccessDocumentsTemp.findMany()
     * 
     * // Get first 10 EmployeesAccessDocumentsTemps
     * const employeesAccessDocumentsTemps = await prisma.employeesAccessDocumentsTemp.findMany({ take: 10 })
     * 
     * // Only select the `EmployeesAccessDocumentTempId`
     * const employeesAccessDocumentsTempWithEmployeesAccessDocumentTempIdOnly = await prisma.employeesAccessDocumentsTemp.findMany({ select: { EmployeesAccessDocumentTempId: true } })
     * 
     */
    findMany<T extends EmployeesAccessDocumentsTempFindManyArgs>(args?: SelectSubset<T, EmployeesAccessDocumentsTempFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesAccessDocumentsTempPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeesAccessDocumentsTemp.
     * @param {EmployeesAccessDocumentsTempCreateArgs} args - Arguments to create a EmployeesAccessDocumentsTemp.
     * @example
     * // Create one EmployeesAccessDocumentsTemp
     * const EmployeesAccessDocumentsTemp = await prisma.employeesAccessDocumentsTemp.create({
     *   data: {
     *     // ... data to create a EmployeesAccessDocumentsTemp
     *   }
     * })
     * 
     */
    create<T extends EmployeesAccessDocumentsTempCreateArgs>(args: SelectSubset<T, EmployeesAccessDocumentsTempCreateArgs<ExtArgs>>): Prisma__EmployeesAccessDocumentsTempClient<$Result.GetResult<Prisma.$EmployeesAccessDocumentsTempPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeesAccessDocumentsTemps.
     * @param {EmployeesAccessDocumentsTempCreateManyArgs} args - Arguments to create many EmployeesAccessDocumentsTemps.
     * @example
     * // Create many EmployeesAccessDocumentsTemps
     * const employeesAccessDocumentsTemp = await prisma.employeesAccessDocumentsTemp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeesAccessDocumentsTempCreateManyArgs>(args?: SelectSubset<T, EmployeesAccessDocumentsTempCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeesAccessDocumentsTemp.
     * @param {EmployeesAccessDocumentsTempDeleteArgs} args - Arguments to delete one EmployeesAccessDocumentsTemp.
     * @example
     * // Delete one EmployeesAccessDocumentsTemp
     * const EmployeesAccessDocumentsTemp = await prisma.employeesAccessDocumentsTemp.delete({
     *   where: {
     *     // ... filter to delete one EmployeesAccessDocumentsTemp
     *   }
     * })
     * 
     */
    delete<T extends EmployeesAccessDocumentsTempDeleteArgs>(args: SelectSubset<T, EmployeesAccessDocumentsTempDeleteArgs<ExtArgs>>): Prisma__EmployeesAccessDocumentsTempClient<$Result.GetResult<Prisma.$EmployeesAccessDocumentsTempPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeesAccessDocumentsTemp.
     * @param {EmployeesAccessDocumentsTempUpdateArgs} args - Arguments to update one EmployeesAccessDocumentsTemp.
     * @example
     * // Update one EmployeesAccessDocumentsTemp
     * const employeesAccessDocumentsTemp = await prisma.employeesAccessDocumentsTemp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeesAccessDocumentsTempUpdateArgs>(args: SelectSubset<T, EmployeesAccessDocumentsTempUpdateArgs<ExtArgs>>): Prisma__EmployeesAccessDocumentsTempClient<$Result.GetResult<Prisma.$EmployeesAccessDocumentsTempPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeesAccessDocumentsTemps.
     * @param {EmployeesAccessDocumentsTempDeleteManyArgs} args - Arguments to filter EmployeesAccessDocumentsTemps to delete.
     * @example
     * // Delete a few EmployeesAccessDocumentsTemps
     * const { count } = await prisma.employeesAccessDocumentsTemp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeesAccessDocumentsTempDeleteManyArgs>(args?: SelectSubset<T, EmployeesAccessDocumentsTempDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeesAccessDocumentsTemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessDocumentsTempUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeesAccessDocumentsTemps
     * const employeesAccessDocumentsTemp = await prisma.employeesAccessDocumentsTemp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeesAccessDocumentsTempUpdateManyArgs>(args: SelectSubset<T, EmployeesAccessDocumentsTempUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeesAccessDocumentsTemp.
     * @param {EmployeesAccessDocumentsTempUpsertArgs} args - Arguments to update or create a EmployeesAccessDocumentsTemp.
     * @example
     * // Update or create a EmployeesAccessDocumentsTemp
     * const employeesAccessDocumentsTemp = await prisma.employeesAccessDocumentsTemp.upsert({
     *   create: {
     *     // ... data to create a EmployeesAccessDocumentsTemp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeesAccessDocumentsTemp we want to update
     *   }
     * })
     */
    upsert<T extends EmployeesAccessDocumentsTempUpsertArgs>(args: SelectSubset<T, EmployeesAccessDocumentsTempUpsertArgs<ExtArgs>>): Prisma__EmployeesAccessDocumentsTempClient<$Result.GetResult<Prisma.$EmployeesAccessDocumentsTempPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeesAccessDocumentsTemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessDocumentsTempCountArgs} args - Arguments to filter EmployeesAccessDocumentsTemps to count.
     * @example
     * // Count the number of EmployeesAccessDocumentsTemps
     * const count = await prisma.employeesAccessDocumentsTemp.count({
     *   where: {
     *     // ... the filter for the EmployeesAccessDocumentsTemps we want to count
     *   }
     * })
    **/
    count<T extends EmployeesAccessDocumentsTempCountArgs>(
      args?: Subset<T, EmployeesAccessDocumentsTempCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeesAccessDocumentsTempCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeesAccessDocumentsTemp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessDocumentsTempAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeesAccessDocumentsTempAggregateArgs>(args: Subset<T, EmployeesAccessDocumentsTempAggregateArgs>): Prisma.PrismaPromise<GetEmployeesAccessDocumentsTempAggregateType<T>>

    /**
     * Group by EmployeesAccessDocumentsTemp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessDocumentsTempGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeesAccessDocumentsTempGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeesAccessDocumentsTempGroupByArgs['orderBy'] }
        : { orderBy?: EmployeesAccessDocumentsTempGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeesAccessDocumentsTempGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeesAccessDocumentsTempGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeesAccessDocumentsTemp model
   */
  readonly fields: EmployeesAccessDocumentsTempFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeesAccessDocumentsTemp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeesAccessDocumentsTempClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeesAccessDocumentsTemp model
   */ 
  interface EmployeesAccessDocumentsTempFieldRefs {
    readonly EmployeesAccessDocumentTempId: FieldRef<"EmployeesAccessDocumentsTemp", 'String'>
    readonly CompanyGeneralCrmId: FieldRef<"EmployeesAccessDocumentsTemp", 'String'>
    readonly CreatedAt: FieldRef<"EmployeesAccessDocumentsTemp", 'DateTime'>
    readonly EmployeeID: FieldRef<"EmployeesAccessDocumentsTemp", 'String'>
    readonly DocumemtID: FieldRef<"EmployeesAccessDocumentsTemp", 'String'>
    readonly Date: FieldRef<"EmployeesAccessDocumentsTemp", 'String'>
    readonly DocumemtType: FieldRef<"EmployeesAccessDocumentsTemp", 'String'>
    readonly Comment: FieldRef<"EmployeesAccessDocumentsTemp", 'String'>
    readonly DocumentName: FieldRef<"EmployeesAccessDocumentsTemp", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeesAccessDocumentsTemp findUnique
   */
  export type EmployeesAccessDocumentsTempFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessDocumentsTemp
     */
    select?: EmployeesAccessDocumentsTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessDocumentsTemp to fetch.
     */
    where: EmployeesAccessDocumentsTempWhereUniqueInput
  }

  /**
   * EmployeesAccessDocumentsTemp findUniqueOrThrow
   */
  export type EmployeesAccessDocumentsTempFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessDocumentsTemp
     */
    select?: EmployeesAccessDocumentsTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessDocumentsTemp to fetch.
     */
    where: EmployeesAccessDocumentsTempWhereUniqueInput
  }

  /**
   * EmployeesAccessDocumentsTemp findFirst
   */
  export type EmployeesAccessDocumentsTempFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessDocumentsTemp
     */
    select?: EmployeesAccessDocumentsTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessDocumentsTemp to fetch.
     */
    where?: EmployeesAccessDocumentsTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessDocumentsTemps to fetch.
     */
    orderBy?: EmployeesAccessDocumentsTempOrderByWithRelationInput | EmployeesAccessDocumentsTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeesAccessDocumentsTemps.
     */
    cursor?: EmployeesAccessDocumentsTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessDocumentsTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessDocumentsTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeesAccessDocumentsTemps.
     */
    distinct?: EmployeesAccessDocumentsTempScalarFieldEnum | EmployeesAccessDocumentsTempScalarFieldEnum[]
  }

  /**
   * EmployeesAccessDocumentsTemp findFirstOrThrow
   */
  export type EmployeesAccessDocumentsTempFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessDocumentsTemp
     */
    select?: EmployeesAccessDocumentsTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessDocumentsTemp to fetch.
     */
    where?: EmployeesAccessDocumentsTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessDocumentsTemps to fetch.
     */
    orderBy?: EmployeesAccessDocumentsTempOrderByWithRelationInput | EmployeesAccessDocumentsTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeesAccessDocumentsTemps.
     */
    cursor?: EmployeesAccessDocumentsTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessDocumentsTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessDocumentsTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeesAccessDocumentsTemps.
     */
    distinct?: EmployeesAccessDocumentsTempScalarFieldEnum | EmployeesAccessDocumentsTempScalarFieldEnum[]
  }

  /**
   * EmployeesAccessDocumentsTemp findMany
   */
  export type EmployeesAccessDocumentsTempFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessDocumentsTemp
     */
    select?: EmployeesAccessDocumentsTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessDocumentsTemps to fetch.
     */
    where?: EmployeesAccessDocumentsTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessDocumentsTemps to fetch.
     */
    orderBy?: EmployeesAccessDocumentsTempOrderByWithRelationInput | EmployeesAccessDocumentsTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeesAccessDocumentsTemps.
     */
    cursor?: EmployeesAccessDocumentsTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessDocumentsTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessDocumentsTemps.
     */
    skip?: number
    distinct?: EmployeesAccessDocumentsTempScalarFieldEnum | EmployeesAccessDocumentsTempScalarFieldEnum[]
  }

  /**
   * EmployeesAccessDocumentsTemp create
   */
  export type EmployeesAccessDocumentsTempCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessDocumentsTemp
     */
    select?: EmployeesAccessDocumentsTempSelect<ExtArgs> | null
    /**
     * The data needed to create a EmployeesAccessDocumentsTemp.
     */
    data: XOR<EmployeesAccessDocumentsTempCreateInput, EmployeesAccessDocumentsTempUncheckedCreateInput>
  }

  /**
   * EmployeesAccessDocumentsTemp createMany
   */
  export type EmployeesAccessDocumentsTempCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeesAccessDocumentsTemps.
     */
    data: EmployeesAccessDocumentsTempCreateManyInput | EmployeesAccessDocumentsTempCreateManyInput[]
  }

  /**
   * EmployeesAccessDocumentsTemp update
   */
  export type EmployeesAccessDocumentsTempUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessDocumentsTemp
     */
    select?: EmployeesAccessDocumentsTempSelect<ExtArgs> | null
    /**
     * The data needed to update a EmployeesAccessDocumentsTemp.
     */
    data: XOR<EmployeesAccessDocumentsTempUpdateInput, EmployeesAccessDocumentsTempUncheckedUpdateInput>
    /**
     * Choose, which EmployeesAccessDocumentsTemp to update.
     */
    where: EmployeesAccessDocumentsTempWhereUniqueInput
  }

  /**
   * EmployeesAccessDocumentsTemp updateMany
   */
  export type EmployeesAccessDocumentsTempUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeesAccessDocumentsTemps.
     */
    data: XOR<EmployeesAccessDocumentsTempUpdateManyMutationInput, EmployeesAccessDocumentsTempUncheckedUpdateManyInput>
    /**
     * Filter which EmployeesAccessDocumentsTemps to update
     */
    where?: EmployeesAccessDocumentsTempWhereInput
  }

  /**
   * EmployeesAccessDocumentsTemp upsert
   */
  export type EmployeesAccessDocumentsTempUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessDocumentsTemp
     */
    select?: EmployeesAccessDocumentsTempSelect<ExtArgs> | null
    /**
     * The filter to search for the EmployeesAccessDocumentsTemp to update in case it exists.
     */
    where: EmployeesAccessDocumentsTempWhereUniqueInput
    /**
     * In case the EmployeesAccessDocumentsTemp found by the `where` argument doesn't exist, create a new EmployeesAccessDocumentsTemp with this data.
     */
    create: XOR<EmployeesAccessDocumentsTempCreateInput, EmployeesAccessDocumentsTempUncheckedCreateInput>
    /**
     * In case the EmployeesAccessDocumentsTemp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeesAccessDocumentsTempUpdateInput, EmployeesAccessDocumentsTempUncheckedUpdateInput>
  }

  /**
   * EmployeesAccessDocumentsTemp delete
   */
  export type EmployeesAccessDocumentsTempDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessDocumentsTemp
     */
    select?: EmployeesAccessDocumentsTempSelect<ExtArgs> | null
    /**
     * Filter which EmployeesAccessDocumentsTemp to delete.
     */
    where: EmployeesAccessDocumentsTempWhereUniqueInput
  }

  /**
   * EmployeesAccessDocumentsTemp deleteMany
   */
  export type EmployeesAccessDocumentsTempDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeesAccessDocumentsTemps to delete
     */
    where?: EmployeesAccessDocumentsTempWhereInput
  }

  /**
   * EmployeesAccessDocumentsTemp without action
   */
  export type EmployeesAccessDocumentsTempDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessDocumentsTemp
     */
    select?: EmployeesAccessDocumentsTempSelect<ExtArgs> | null
  }


  /**
   * Model EmployeesAccessHouseTemp
   */

  export type AggregateEmployeesAccessHouseTemp = {
    _count: EmployeesAccessHouseTempCountAggregateOutputType | null
    _min: EmployeesAccessHouseTempMinAggregateOutputType | null
    _max: EmployeesAccessHouseTempMaxAggregateOutputType | null
  }

  export type EmployeesAccessHouseTempMinAggregateOutputType = {
    EmployeesAccessHouseTempId: string | null
    CompanyGeneralCrmId: string | null
    CreatedAt: Date | null
    HouseID: string | null
    HouseCode: string | null
    CityName: string | null
    Street: string | null
    HouseNumber: string | null
    ZipCode: string | null
    EmployeesQtyMax: string | null
    ElectricityCounter_Start: string | null
    ElectricityCounter_End: string | null
    GasCounter_Start: string | null
    GasCounter_End: string | null
    WaterCounter_Start: string | null
    WaterCounter_End: string | null
    ElectricityNumber: string | null
    GasNumber: string | null
    WaterNumber: string | null
    HouseField: string | null
    ArnonaNumber: string | null
    EvacuationDate: string | null
    AreaMan: string | null
    GasContainer: string | null
    GasCompanyID: string | null
    SleepingRooms: string | null
    Salon: string | null
    Toilet: string | null
    Baths: string | null
    HouseCommittee: string | null
    HouseCommitteePhone: string | null
    Status: string | null
    Name: string | null
    Street_: string | null
    CityName_: string | null
    ZipCode_: string | null
    Phone_1: string | null
    Phone_2: string | null
    FaxNumber: string | null
    StartDateContract: string | null
    EndDateContract: string | null
    Security: string | null
    SecurityAmount: string | null
    PaymentFrequency: string | null
    Rant: string | null
    Comment: string | null
    IsInsured: string | null
    InsureEndDate: string | null
    IsUpdate: string | null
    LivingArea: string | null
    HouseRelation: string | null
    CableTypeID: string | null
    CableInstallationdate: string | null
    AccountNumber: string | null
    PathNumber: string | null
    AppartmentNum: string | null
    IsBroker: string | null
    BrokerName: string | null
    BrokerPhone: string | null
    ElectricityCode: string | null
    GasNumberCode: string | null
    WaterNumberCode: string | null
    ElectricityComment: string | null
    GasCounteComment: string | null
    WaterCounterComment: string | null
    AgencyFee: string | null
    IdNumber: string | null
    ArrivalInstructions: string | null
    OwnerEmail: string | null
    OwnerBankAcount: string | null
    CustomerID: string | null
    LocalityName: string | null
    Contractor_billing: string | null
    Floor: string | null
    Entrance: string | null
    OwnerBranchCode: string | null
    OwnerBankID: string | null
  }

  export type EmployeesAccessHouseTempMaxAggregateOutputType = {
    EmployeesAccessHouseTempId: string | null
    CompanyGeneralCrmId: string | null
    CreatedAt: Date | null
    HouseID: string | null
    HouseCode: string | null
    CityName: string | null
    Street: string | null
    HouseNumber: string | null
    ZipCode: string | null
    EmployeesQtyMax: string | null
    ElectricityCounter_Start: string | null
    ElectricityCounter_End: string | null
    GasCounter_Start: string | null
    GasCounter_End: string | null
    WaterCounter_Start: string | null
    WaterCounter_End: string | null
    ElectricityNumber: string | null
    GasNumber: string | null
    WaterNumber: string | null
    HouseField: string | null
    ArnonaNumber: string | null
    EvacuationDate: string | null
    AreaMan: string | null
    GasContainer: string | null
    GasCompanyID: string | null
    SleepingRooms: string | null
    Salon: string | null
    Toilet: string | null
    Baths: string | null
    HouseCommittee: string | null
    HouseCommitteePhone: string | null
    Status: string | null
    Name: string | null
    Street_: string | null
    CityName_: string | null
    ZipCode_: string | null
    Phone_1: string | null
    Phone_2: string | null
    FaxNumber: string | null
    StartDateContract: string | null
    EndDateContract: string | null
    Security: string | null
    SecurityAmount: string | null
    PaymentFrequency: string | null
    Rant: string | null
    Comment: string | null
    IsInsured: string | null
    InsureEndDate: string | null
    IsUpdate: string | null
    LivingArea: string | null
    HouseRelation: string | null
    CableTypeID: string | null
    CableInstallationdate: string | null
    AccountNumber: string | null
    PathNumber: string | null
    AppartmentNum: string | null
    IsBroker: string | null
    BrokerName: string | null
    BrokerPhone: string | null
    ElectricityCode: string | null
    GasNumberCode: string | null
    WaterNumberCode: string | null
    ElectricityComment: string | null
    GasCounteComment: string | null
    WaterCounterComment: string | null
    AgencyFee: string | null
    IdNumber: string | null
    ArrivalInstructions: string | null
    OwnerEmail: string | null
    OwnerBankAcount: string | null
    CustomerID: string | null
    LocalityName: string | null
    Contractor_billing: string | null
    Floor: string | null
    Entrance: string | null
    OwnerBranchCode: string | null
    OwnerBankID: string | null
  }

  export type EmployeesAccessHouseTempCountAggregateOutputType = {
    EmployeesAccessHouseTempId: number
    CompanyGeneralCrmId: number
    CreatedAt: number
    HouseID: number
    HouseCode: number
    CityName: number
    Street: number
    HouseNumber: number
    ZipCode: number
    EmployeesQtyMax: number
    ElectricityCounter_Start: number
    ElectricityCounter_End: number
    GasCounter_Start: number
    GasCounter_End: number
    WaterCounter_Start: number
    WaterCounter_End: number
    ElectricityNumber: number
    GasNumber: number
    WaterNumber: number
    HouseField: number
    ArnonaNumber: number
    EvacuationDate: number
    AreaMan: number
    GasContainer: number
    GasCompanyID: number
    SleepingRooms: number
    Salon: number
    Toilet: number
    Baths: number
    HouseCommittee: number
    HouseCommitteePhone: number
    Status: number
    Name: number
    Street_: number
    CityName_: number
    ZipCode_: number
    Phone_1: number
    Phone_2: number
    FaxNumber: number
    StartDateContract: number
    EndDateContract: number
    Security: number
    SecurityAmount: number
    PaymentFrequency: number
    Rant: number
    Comment: number
    IsInsured: number
    InsureEndDate: number
    IsUpdate: number
    LivingArea: number
    HouseRelation: number
    CableTypeID: number
    CableInstallationdate: number
    AccountNumber: number
    PathNumber: number
    AppartmentNum: number
    IsBroker: number
    BrokerName: number
    BrokerPhone: number
    ElectricityCode: number
    GasNumberCode: number
    WaterNumberCode: number
    ElectricityComment: number
    GasCounteComment: number
    WaterCounterComment: number
    AgencyFee: number
    IdNumber: number
    ArrivalInstructions: number
    OwnerEmail: number
    OwnerBankAcount: number
    CustomerID: number
    LocalityName: number
    Contractor_billing: number
    Floor: number
    Entrance: number
    OwnerBranchCode: number
    OwnerBankID: number
    _all: number
  }


  export type EmployeesAccessHouseTempMinAggregateInputType = {
    EmployeesAccessHouseTempId?: true
    CompanyGeneralCrmId?: true
    CreatedAt?: true
    HouseID?: true
    HouseCode?: true
    CityName?: true
    Street?: true
    HouseNumber?: true
    ZipCode?: true
    EmployeesQtyMax?: true
    ElectricityCounter_Start?: true
    ElectricityCounter_End?: true
    GasCounter_Start?: true
    GasCounter_End?: true
    WaterCounter_Start?: true
    WaterCounter_End?: true
    ElectricityNumber?: true
    GasNumber?: true
    WaterNumber?: true
    HouseField?: true
    ArnonaNumber?: true
    EvacuationDate?: true
    AreaMan?: true
    GasContainer?: true
    GasCompanyID?: true
    SleepingRooms?: true
    Salon?: true
    Toilet?: true
    Baths?: true
    HouseCommittee?: true
    HouseCommitteePhone?: true
    Status?: true
    Name?: true
    Street_?: true
    CityName_?: true
    ZipCode_?: true
    Phone_1?: true
    Phone_2?: true
    FaxNumber?: true
    StartDateContract?: true
    EndDateContract?: true
    Security?: true
    SecurityAmount?: true
    PaymentFrequency?: true
    Rant?: true
    Comment?: true
    IsInsured?: true
    InsureEndDate?: true
    IsUpdate?: true
    LivingArea?: true
    HouseRelation?: true
    CableTypeID?: true
    CableInstallationdate?: true
    AccountNumber?: true
    PathNumber?: true
    AppartmentNum?: true
    IsBroker?: true
    BrokerName?: true
    BrokerPhone?: true
    ElectricityCode?: true
    GasNumberCode?: true
    WaterNumberCode?: true
    ElectricityComment?: true
    GasCounteComment?: true
    WaterCounterComment?: true
    AgencyFee?: true
    IdNumber?: true
    ArrivalInstructions?: true
    OwnerEmail?: true
    OwnerBankAcount?: true
    CustomerID?: true
    LocalityName?: true
    Contractor_billing?: true
    Floor?: true
    Entrance?: true
    OwnerBranchCode?: true
    OwnerBankID?: true
  }

  export type EmployeesAccessHouseTempMaxAggregateInputType = {
    EmployeesAccessHouseTempId?: true
    CompanyGeneralCrmId?: true
    CreatedAt?: true
    HouseID?: true
    HouseCode?: true
    CityName?: true
    Street?: true
    HouseNumber?: true
    ZipCode?: true
    EmployeesQtyMax?: true
    ElectricityCounter_Start?: true
    ElectricityCounter_End?: true
    GasCounter_Start?: true
    GasCounter_End?: true
    WaterCounter_Start?: true
    WaterCounter_End?: true
    ElectricityNumber?: true
    GasNumber?: true
    WaterNumber?: true
    HouseField?: true
    ArnonaNumber?: true
    EvacuationDate?: true
    AreaMan?: true
    GasContainer?: true
    GasCompanyID?: true
    SleepingRooms?: true
    Salon?: true
    Toilet?: true
    Baths?: true
    HouseCommittee?: true
    HouseCommitteePhone?: true
    Status?: true
    Name?: true
    Street_?: true
    CityName_?: true
    ZipCode_?: true
    Phone_1?: true
    Phone_2?: true
    FaxNumber?: true
    StartDateContract?: true
    EndDateContract?: true
    Security?: true
    SecurityAmount?: true
    PaymentFrequency?: true
    Rant?: true
    Comment?: true
    IsInsured?: true
    InsureEndDate?: true
    IsUpdate?: true
    LivingArea?: true
    HouseRelation?: true
    CableTypeID?: true
    CableInstallationdate?: true
    AccountNumber?: true
    PathNumber?: true
    AppartmentNum?: true
    IsBroker?: true
    BrokerName?: true
    BrokerPhone?: true
    ElectricityCode?: true
    GasNumberCode?: true
    WaterNumberCode?: true
    ElectricityComment?: true
    GasCounteComment?: true
    WaterCounterComment?: true
    AgencyFee?: true
    IdNumber?: true
    ArrivalInstructions?: true
    OwnerEmail?: true
    OwnerBankAcount?: true
    CustomerID?: true
    LocalityName?: true
    Contractor_billing?: true
    Floor?: true
    Entrance?: true
    OwnerBranchCode?: true
    OwnerBankID?: true
  }

  export type EmployeesAccessHouseTempCountAggregateInputType = {
    EmployeesAccessHouseTempId?: true
    CompanyGeneralCrmId?: true
    CreatedAt?: true
    HouseID?: true
    HouseCode?: true
    CityName?: true
    Street?: true
    HouseNumber?: true
    ZipCode?: true
    EmployeesQtyMax?: true
    ElectricityCounter_Start?: true
    ElectricityCounter_End?: true
    GasCounter_Start?: true
    GasCounter_End?: true
    WaterCounter_Start?: true
    WaterCounter_End?: true
    ElectricityNumber?: true
    GasNumber?: true
    WaterNumber?: true
    HouseField?: true
    ArnonaNumber?: true
    EvacuationDate?: true
    AreaMan?: true
    GasContainer?: true
    GasCompanyID?: true
    SleepingRooms?: true
    Salon?: true
    Toilet?: true
    Baths?: true
    HouseCommittee?: true
    HouseCommitteePhone?: true
    Status?: true
    Name?: true
    Street_?: true
    CityName_?: true
    ZipCode_?: true
    Phone_1?: true
    Phone_2?: true
    FaxNumber?: true
    StartDateContract?: true
    EndDateContract?: true
    Security?: true
    SecurityAmount?: true
    PaymentFrequency?: true
    Rant?: true
    Comment?: true
    IsInsured?: true
    InsureEndDate?: true
    IsUpdate?: true
    LivingArea?: true
    HouseRelation?: true
    CableTypeID?: true
    CableInstallationdate?: true
    AccountNumber?: true
    PathNumber?: true
    AppartmentNum?: true
    IsBroker?: true
    BrokerName?: true
    BrokerPhone?: true
    ElectricityCode?: true
    GasNumberCode?: true
    WaterNumberCode?: true
    ElectricityComment?: true
    GasCounteComment?: true
    WaterCounterComment?: true
    AgencyFee?: true
    IdNumber?: true
    ArrivalInstructions?: true
    OwnerEmail?: true
    OwnerBankAcount?: true
    CustomerID?: true
    LocalityName?: true
    Contractor_billing?: true
    Floor?: true
    Entrance?: true
    OwnerBranchCode?: true
    OwnerBankID?: true
    _all?: true
  }

  export type EmployeesAccessHouseTempAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeesAccessHouseTemp to aggregate.
     */
    where?: EmployeesAccessHouseTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessHouseTemps to fetch.
     */
    orderBy?: EmployeesAccessHouseTempOrderByWithRelationInput | EmployeesAccessHouseTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeesAccessHouseTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessHouseTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessHouseTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeesAccessHouseTemps
    **/
    _count?: true | EmployeesAccessHouseTempCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeesAccessHouseTempMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeesAccessHouseTempMaxAggregateInputType
  }

  export type GetEmployeesAccessHouseTempAggregateType<T extends EmployeesAccessHouseTempAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeesAccessHouseTemp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeesAccessHouseTemp[P]>
      : GetScalarType<T[P], AggregateEmployeesAccessHouseTemp[P]>
  }




  export type EmployeesAccessHouseTempGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeesAccessHouseTempWhereInput
    orderBy?: EmployeesAccessHouseTempOrderByWithAggregationInput | EmployeesAccessHouseTempOrderByWithAggregationInput[]
    by: EmployeesAccessHouseTempScalarFieldEnum[] | EmployeesAccessHouseTempScalarFieldEnum
    having?: EmployeesAccessHouseTempScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeesAccessHouseTempCountAggregateInputType | true
    _min?: EmployeesAccessHouseTempMinAggregateInputType
    _max?: EmployeesAccessHouseTempMaxAggregateInputType
  }

  export type EmployeesAccessHouseTempGroupByOutputType = {
    EmployeesAccessHouseTempId: string
    CompanyGeneralCrmId: string
    CreatedAt: Date
    HouseID: string | null
    HouseCode: string | null
    CityName: string | null
    Street: string | null
    HouseNumber: string | null
    ZipCode: string | null
    EmployeesQtyMax: string | null
    ElectricityCounter_Start: string | null
    ElectricityCounter_End: string | null
    GasCounter_Start: string | null
    GasCounter_End: string | null
    WaterCounter_Start: string | null
    WaterCounter_End: string | null
    ElectricityNumber: string | null
    GasNumber: string | null
    WaterNumber: string | null
    HouseField: string | null
    ArnonaNumber: string | null
    EvacuationDate: string | null
    AreaMan: string | null
    GasContainer: string | null
    GasCompanyID: string | null
    SleepingRooms: string | null
    Salon: string | null
    Toilet: string | null
    Baths: string | null
    HouseCommittee: string | null
    HouseCommitteePhone: string | null
    Status: string | null
    Name: string | null
    Street_: string | null
    CityName_: string | null
    ZipCode_: string | null
    Phone_1: string | null
    Phone_2: string | null
    FaxNumber: string | null
    StartDateContract: string | null
    EndDateContract: string | null
    Security: string | null
    SecurityAmount: string | null
    PaymentFrequency: string | null
    Rant: string | null
    Comment: string | null
    IsInsured: string | null
    InsureEndDate: string | null
    IsUpdate: string | null
    LivingArea: string | null
    HouseRelation: string | null
    CableTypeID: string | null
    CableInstallationdate: string | null
    AccountNumber: string | null
    PathNumber: string | null
    AppartmentNum: string | null
    IsBroker: string | null
    BrokerName: string | null
    BrokerPhone: string | null
    ElectricityCode: string | null
    GasNumberCode: string | null
    WaterNumberCode: string | null
    ElectricityComment: string | null
    GasCounteComment: string | null
    WaterCounterComment: string | null
    AgencyFee: string | null
    IdNumber: string | null
    ArrivalInstructions: string | null
    OwnerEmail: string | null
    OwnerBankAcount: string | null
    CustomerID: string | null
    LocalityName: string | null
    Contractor_billing: string | null
    Floor: string | null
    Entrance: string | null
    OwnerBranchCode: string | null
    OwnerBankID: string | null
    _count: EmployeesAccessHouseTempCountAggregateOutputType | null
    _min: EmployeesAccessHouseTempMinAggregateOutputType | null
    _max: EmployeesAccessHouseTempMaxAggregateOutputType | null
  }

  type GetEmployeesAccessHouseTempGroupByPayload<T extends EmployeesAccessHouseTempGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeesAccessHouseTempGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeesAccessHouseTempGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeesAccessHouseTempGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeesAccessHouseTempGroupByOutputType[P]>
        }
      >
    >


  export type EmployeesAccessHouseTempSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmployeesAccessHouseTempId?: boolean
    CompanyGeneralCrmId?: boolean
    CreatedAt?: boolean
    HouseID?: boolean
    HouseCode?: boolean
    CityName?: boolean
    Street?: boolean
    HouseNumber?: boolean
    ZipCode?: boolean
    EmployeesQtyMax?: boolean
    ElectricityCounter_Start?: boolean
    ElectricityCounter_End?: boolean
    GasCounter_Start?: boolean
    GasCounter_End?: boolean
    WaterCounter_Start?: boolean
    WaterCounter_End?: boolean
    ElectricityNumber?: boolean
    GasNumber?: boolean
    WaterNumber?: boolean
    HouseField?: boolean
    ArnonaNumber?: boolean
    EvacuationDate?: boolean
    AreaMan?: boolean
    GasContainer?: boolean
    GasCompanyID?: boolean
    SleepingRooms?: boolean
    Salon?: boolean
    Toilet?: boolean
    Baths?: boolean
    HouseCommittee?: boolean
    HouseCommitteePhone?: boolean
    Status?: boolean
    Name?: boolean
    Street_?: boolean
    CityName_?: boolean
    ZipCode_?: boolean
    Phone_1?: boolean
    Phone_2?: boolean
    FaxNumber?: boolean
    StartDateContract?: boolean
    EndDateContract?: boolean
    Security?: boolean
    SecurityAmount?: boolean
    PaymentFrequency?: boolean
    Rant?: boolean
    Comment?: boolean
    IsInsured?: boolean
    InsureEndDate?: boolean
    IsUpdate?: boolean
    LivingArea?: boolean
    HouseRelation?: boolean
    CableTypeID?: boolean
    CableInstallationdate?: boolean
    AccountNumber?: boolean
    PathNumber?: boolean
    AppartmentNum?: boolean
    IsBroker?: boolean
    BrokerName?: boolean
    BrokerPhone?: boolean
    ElectricityCode?: boolean
    GasNumberCode?: boolean
    WaterNumberCode?: boolean
    ElectricityComment?: boolean
    GasCounteComment?: boolean
    WaterCounterComment?: boolean
    AgencyFee?: boolean
    IdNumber?: boolean
    ArrivalInstructions?: boolean
    OwnerEmail?: boolean
    OwnerBankAcount?: boolean
    CustomerID?: boolean
    LocalityName?: boolean
    Contractor_billing?: boolean
    Floor?: boolean
    Entrance?: boolean
    OwnerBranchCode?: boolean
    OwnerBankID?: boolean
  }, ExtArgs["result"]["employeesAccessHouseTemp"]>


  export type EmployeesAccessHouseTempSelectScalar = {
    EmployeesAccessHouseTempId?: boolean
    CompanyGeneralCrmId?: boolean
    CreatedAt?: boolean
    HouseID?: boolean
    HouseCode?: boolean
    CityName?: boolean
    Street?: boolean
    HouseNumber?: boolean
    ZipCode?: boolean
    EmployeesQtyMax?: boolean
    ElectricityCounter_Start?: boolean
    ElectricityCounter_End?: boolean
    GasCounter_Start?: boolean
    GasCounter_End?: boolean
    WaterCounter_Start?: boolean
    WaterCounter_End?: boolean
    ElectricityNumber?: boolean
    GasNumber?: boolean
    WaterNumber?: boolean
    HouseField?: boolean
    ArnonaNumber?: boolean
    EvacuationDate?: boolean
    AreaMan?: boolean
    GasContainer?: boolean
    GasCompanyID?: boolean
    SleepingRooms?: boolean
    Salon?: boolean
    Toilet?: boolean
    Baths?: boolean
    HouseCommittee?: boolean
    HouseCommitteePhone?: boolean
    Status?: boolean
    Name?: boolean
    Street_?: boolean
    CityName_?: boolean
    ZipCode_?: boolean
    Phone_1?: boolean
    Phone_2?: boolean
    FaxNumber?: boolean
    StartDateContract?: boolean
    EndDateContract?: boolean
    Security?: boolean
    SecurityAmount?: boolean
    PaymentFrequency?: boolean
    Rant?: boolean
    Comment?: boolean
    IsInsured?: boolean
    InsureEndDate?: boolean
    IsUpdate?: boolean
    LivingArea?: boolean
    HouseRelation?: boolean
    CableTypeID?: boolean
    CableInstallationdate?: boolean
    AccountNumber?: boolean
    PathNumber?: boolean
    AppartmentNum?: boolean
    IsBroker?: boolean
    BrokerName?: boolean
    BrokerPhone?: boolean
    ElectricityCode?: boolean
    GasNumberCode?: boolean
    WaterNumberCode?: boolean
    ElectricityComment?: boolean
    GasCounteComment?: boolean
    WaterCounterComment?: boolean
    AgencyFee?: boolean
    IdNumber?: boolean
    ArrivalInstructions?: boolean
    OwnerEmail?: boolean
    OwnerBankAcount?: boolean
    CustomerID?: boolean
    LocalityName?: boolean
    Contractor_billing?: boolean
    Floor?: boolean
    Entrance?: boolean
    OwnerBranchCode?: boolean
    OwnerBankID?: boolean
  }


  export type $EmployeesAccessHouseTempPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeesAccessHouseTemp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      EmployeesAccessHouseTempId: string
      CompanyGeneralCrmId: string
      CreatedAt: Date
      HouseID: string | null
      HouseCode: string | null
      CityName: string | null
      Street: string | null
      HouseNumber: string | null
      ZipCode: string | null
      EmployeesQtyMax: string | null
      ElectricityCounter_Start: string | null
      ElectricityCounter_End: string | null
      GasCounter_Start: string | null
      GasCounter_End: string | null
      WaterCounter_Start: string | null
      WaterCounter_End: string | null
      ElectricityNumber: string | null
      GasNumber: string | null
      WaterNumber: string | null
      HouseField: string | null
      ArnonaNumber: string | null
      EvacuationDate: string | null
      AreaMan: string | null
      GasContainer: string | null
      GasCompanyID: string | null
      SleepingRooms: string | null
      Salon: string | null
      Toilet: string | null
      Baths: string | null
      HouseCommittee: string | null
      HouseCommitteePhone: string | null
      Status: string | null
      Name: string | null
      Street_: string | null
      CityName_: string | null
      ZipCode_: string | null
      Phone_1: string | null
      Phone_2: string | null
      FaxNumber: string | null
      StartDateContract: string | null
      EndDateContract: string | null
      Security: string | null
      SecurityAmount: string | null
      PaymentFrequency: string | null
      Rant: string | null
      Comment: string | null
      IsInsured: string | null
      InsureEndDate: string | null
      IsUpdate: string | null
      LivingArea: string | null
      HouseRelation: string | null
      CableTypeID: string | null
      CableInstallationdate: string | null
      AccountNumber: string | null
      PathNumber: string | null
      AppartmentNum: string | null
      IsBroker: string | null
      BrokerName: string | null
      BrokerPhone: string | null
      ElectricityCode: string | null
      GasNumberCode: string | null
      WaterNumberCode: string | null
      ElectricityComment: string | null
      GasCounteComment: string | null
      WaterCounterComment: string | null
      AgencyFee: string | null
      IdNumber: string | null
      ArrivalInstructions: string | null
      OwnerEmail: string | null
      OwnerBankAcount: string | null
      CustomerID: string | null
      LocalityName: string | null
      Contractor_billing: string | null
      Floor: string | null
      Entrance: string | null
      OwnerBranchCode: string | null
      OwnerBankID: string | null
    }, ExtArgs["result"]["employeesAccessHouseTemp"]>
    composites: {}
  }

  type EmployeesAccessHouseTempGetPayload<S extends boolean | null | undefined | EmployeesAccessHouseTempDefaultArgs> = $Result.GetResult<Prisma.$EmployeesAccessHouseTempPayload, S>

  type EmployeesAccessHouseTempCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeesAccessHouseTempFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeesAccessHouseTempCountAggregateInputType | true
    }

  export interface EmployeesAccessHouseTempDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeesAccessHouseTemp'], meta: { name: 'EmployeesAccessHouseTemp' } }
    /**
     * Find zero or one EmployeesAccessHouseTemp that matches the filter.
     * @param {EmployeesAccessHouseTempFindUniqueArgs} args - Arguments to find a EmployeesAccessHouseTemp
     * @example
     * // Get one EmployeesAccessHouseTemp
     * const employeesAccessHouseTemp = await prisma.employeesAccessHouseTemp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeesAccessHouseTempFindUniqueArgs>(args: SelectSubset<T, EmployeesAccessHouseTempFindUniqueArgs<ExtArgs>>): Prisma__EmployeesAccessHouseTempClient<$Result.GetResult<Prisma.$EmployeesAccessHouseTempPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeesAccessHouseTemp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeesAccessHouseTempFindUniqueOrThrowArgs} args - Arguments to find a EmployeesAccessHouseTemp
     * @example
     * // Get one EmployeesAccessHouseTemp
     * const employeesAccessHouseTemp = await prisma.employeesAccessHouseTemp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeesAccessHouseTempFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeesAccessHouseTempFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeesAccessHouseTempClient<$Result.GetResult<Prisma.$EmployeesAccessHouseTempPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeesAccessHouseTemp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessHouseTempFindFirstArgs} args - Arguments to find a EmployeesAccessHouseTemp
     * @example
     * // Get one EmployeesAccessHouseTemp
     * const employeesAccessHouseTemp = await prisma.employeesAccessHouseTemp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeesAccessHouseTempFindFirstArgs>(args?: SelectSubset<T, EmployeesAccessHouseTempFindFirstArgs<ExtArgs>>): Prisma__EmployeesAccessHouseTempClient<$Result.GetResult<Prisma.$EmployeesAccessHouseTempPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeesAccessHouseTemp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessHouseTempFindFirstOrThrowArgs} args - Arguments to find a EmployeesAccessHouseTemp
     * @example
     * // Get one EmployeesAccessHouseTemp
     * const employeesAccessHouseTemp = await prisma.employeesAccessHouseTemp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeesAccessHouseTempFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeesAccessHouseTempFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeesAccessHouseTempClient<$Result.GetResult<Prisma.$EmployeesAccessHouseTempPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeesAccessHouseTemps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessHouseTempFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeesAccessHouseTemps
     * const employeesAccessHouseTemps = await prisma.employeesAccessHouseTemp.findMany()
     * 
     * // Get first 10 EmployeesAccessHouseTemps
     * const employeesAccessHouseTemps = await prisma.employeesAccessHouseTemp.findMany({ take: 10 })
     * 
     * // Only select the `EmployeesAccessHouseTempId`
     * const employeesAccessHouseTempWithEmployeesAccessHouseTempIdOnly = await prisma.employeesAccessHouseTemp.findMany({ select: { EmployeesAccessHouseTempId: true } })
     * 
     */
    findMany<T extends EmployeesAccessHouseTempFindManyArgs>(args?: SelectSubset<T, EmployeesAccessHouseTempFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesAccessHouseTempPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeesAccessHouseTemp.
     * @param {EmployeesAccessHouseTempCreateArgs} args - Arguments to create a EmployeesAccessHouseTemp.
     * @example
     * // Create one EmployeesAccessHouseTemp
     * const EmployeesAccessHouseTemp = await prisma.employeesAccessHouseTemp.create({
     *   data: {
     *     // ... data to create a EmployeesAccessHouseTemp
     *   }
     * })
     * 
     */
    create<T extends EmployeesAccessHouseTempCreateArgs>(args: SelectSubset<T, EmployeesAccessHouseTempCreateArgs<ExtArgs>>): Prisma__EmployeesAccessHouseTempClient<$Result.GetResult<Prisma.$EmployeesAccessHouseTempPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeesAccessHouseTemps.
     * @param {EmployeesAccessHouseTempCreateManyArgs} args - Arguments to create many EmployeesAccessHouseTemps.
     * @example
     * // Create many EmployeesAccessHouseTemps
     * const employeesAccessHouseTemp = await prisma.employeesAccessHouseTemp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeesAccessHouseTempCreateManyArgs>(args?: SelectSubset<T, EmployeesAccessHouseTempCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeesAccessHouseTemp.
     * @param {EmployeesAccessHouseTempDeleteArgs} args - Arguments to delete one EmployeesAccessHouseTemp.
     * @example
     * // Delete one EmployeesAccessHouseTemp
     * const EmployeesAccessHouseTemp = await prisma.employeesAccessHouseTemp.delete({
     *   where: {
     *     // ... filter to delete one EmployeesAccessHouseTemp
     *   }
     * })
     * 
     */
    delete<T extends EmployeesAccessHouseTempDeleteArgs>(args: SelectSubset<T, EmployeesAccessHouseTempDeleteArgs<ExtArgs>>): Prisma__EmployeesAccessHouseTempClient<$Result.GetResult<Prisma.$EmployeesAccessHouseTempPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeesAccessHouseTemp.
     * @param {EmployeesAccessHouseTempUpdateArgs} args - Arguments to update one EmployeesAccessHouseTemp.
     * @example
     * // Update one EmployeesAccessHouseTemp
     * const employeesAccessHouseTemp = await prisma.employeesAccessHouseTemp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeesAccessHouseTempUpdateArgs>(args: SelectSubset<T, EmployeesAccessHouseTempUpdateArgs<ExtArgs>>): Prisma__EmployeesAccessHouseTempClient<$Result.GetResult<Prisma.$EmployeesAccessHouseTempPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeesAccessHouseTemps.
     * @param {EmployeesAccessHouseTempDeleteManyArgs} args - Arguments to filter EmployeesAccessHouseTemps to delete.
     * @example
     * // Delete a few EmployeesAccessHouseTemps
     * const { count } = await prisma.employeesAccessHouseTemp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeesAccessHouseTempDeleteManyArgs>(args?: SelectSubset<T, EmployeesAccessHouseTempDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeesAccessHouseTemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessHouseTempUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeesAccessHouseTemps
     * const employeesAccessHouseTemp = await prisma.employeesAccessHouseTemp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeesAccessHouseTempUpdateManyArgs>(args: SelectSubset<T, EmployeesAccessHouseTempUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeesAccessHouseTemp.
     * @param {EmployeesAccessHouseTempUpsertArgs} args - Arguments to update or create a EmployeesAccessHouseTemp.
     * @example
     * // Update or create a EmployeesAccessHouseTemp
     * const employeesAccessHouseTemp = await prisma.employeesAccessHouseTemp.upsert({
     *   create: {
     *     // ... data to create a EmployeesAccessHouseTemp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeesAccessHouseTemp we want to update
     *   }
     * })
     */
    upsert<T extends EmployeesAccessHouseTempUpsertArgs>(args: SelectSubset<T, EmployeesAccessHouseTempUpsertArgs<ExtArgs>>): Prisma__EmployeesAccessHouseTempClient<$Result.GetResult<Prisma.$EmployeesAccessHouseTempPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeesAccessHouseTemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessHouseTempCountArgs} args - Arguments to filter EmployeesAccessHouseTemps to count.
     * @example
     * // Count the number of EmployeesAccessHouseTemps
     * const count = await prisma.employeesAccessHouseTemp.count({
     *   where: {
     *     // ... the filter for the EmployeesAccessHouseTemps we want to count
     *   }
     * })
    **/
    count<T extends EmployeesAccessHouseTempCountArgs>(
      args?: Subset<T, EmployeesAccessHouseTempCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeesAccessHouseTempCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeesAccessHouseTemp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessHouseTempAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeesAccessHouseTempAggregateArgs>(args: Subset<T, EmployeesAccessHouseTempAggregateArgs>): Prisma.PrismaPromise<GetEmployeesAccessHouseTempAggregateType<T>>

    /**
     * Group by EmployeesAccessHouseTemp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessHouseTempGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeesAccessHouseTempGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeesAccessHouseTempGroupByArgs['orderBy'] }
        : { orderBy?: EmployeesAccessHouseTempGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeesAccessHouseTempGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeesAccessHouseTempGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeesAccessHouseTemp model
   */
  readonly fields: EmployeesAccessHouseTempFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeesAccessHouseTemp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeesAccessHouseTempClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeesAccessHouseTemp model
   */ 
  interface EmployeesAccessHouseTempFieldRefs {
    readonly EmployeesAccessHouseTempId: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly CompanyGeneralCrmId: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly CreatedAt: FieldRef<"EmployeesAccessHouseTemp", 'DateTime'>
    readonly HouseID: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly HouseCode: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly CityName: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Street: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly HouseNumber: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly ZipCode: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly EmployeesQtyMax: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly ElectricityCounter_Start: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly ElectricityCounter_End: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly GasCounter_Start: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly GasCounter_End: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly WaterCounter_Start: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly WaterCounter_End: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly ElectricityNumber: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly GasNumber: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly WaterNumber: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly HouseField: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly ArnonaNumber: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly EvacuationDate: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly AreaMan: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly GasContainer: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly GasCompanyID: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly SleepingRooms: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Salon: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Toilet: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Baths: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly HouseCommittee: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly HouseCommitteePhone: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Status: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Name: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Street_: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly CityName_: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly ZipCode_: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Phone_1: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Phone_2: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly FaxNumber: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly StartDateContract: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly EndDateContract: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Security: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly SecurityAmount: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly PaymentFrequency: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Rant: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Comment: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly IsInsured: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly InsureEndDate: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly IsUpdate: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly LivingArea: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly HouseRelation: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly CableTypeID: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly CableInstallationdate: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly AccountNumber: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly PathNumber: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly AppartmentNum: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly IsBroker: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly BrokerName: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly BrokerPhone: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly ElectricityCode: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly GasNumberCode: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly WaterNumberCode: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly ElectricityComment: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly GasCounteComment: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly WaterCounterComment: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly AgencyFee: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly IdNumber: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly ArrivalInstructions: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly OwnerEmail: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly OwnerBankAcount: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly CustomerID: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly LocalityName: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Contractor_billing: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Floor: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly Entrance: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly OwnerBranchCode: FieldRef<"EmployeesAccessHouseTemp", 'String'>
    readonly OwnerBankID: FieldRef<"EmployeesAccessHouseTemp", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeesAccessHouseTemp findUnique
   */
  export type EmployeesAccessHouseTempFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessHouseTemp
     */
    select?: EmployeesAccessHouseTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessHouseTemp to fetch.
     */
    where: EmployeesAccessHouseTempWhereUniqueInput
  }

  /**
   * EmployeesAccessHouseTemp findUniqueOrThrow
   */
  export type EmployeesAccessHouseTempFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessHouseTemp
     */
    select?: EmployeesAccessHouseTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessHouseTemp to fetch.
     */
    where: EmployeesAccessHouseTempWhereUniqueInput
  }

  /**
   * EmployeesAccessHouseTemp findFirst
   */
  export type EmployeesAccessHouseTempFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessHouseTemp
     */
    select?: EmployeesAccessHouseTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessHouseTemp to fetch.
     */
    where?: EmployeesAccessHouseTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessHouseTemps to fetch.
     */
    orderBy?: EmployeesAccessHouseTempOrderByWithRelationInput | EmployeesAccessHouseTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeesAccessHouseTemps.
     */
    cursor?: EmployeesAccessHouseTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessHouseTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessHouseTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeesAccessHouseTemps.
     */
    distinct?: EmployeesAccessHouseTempScalarFieldEnum | EmployeesAccessHouseTempScalarFieldEnum[]
  }

  /**
   * EmployeesAccessHouseTemp findFirstOrThrow
   */
  export type EmployeesAccessHouseTempFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessHouseTemp
     */
    select?: EmployeesAccessHouseTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessHouseTemp to fetch.
     */
    where?: EmployeesAccessHouseTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessHouseTemps to fetch.
     */
    orderBy?: EmployeesAccessHouseTempOrderByWithRelationInput | EmployeesAccessHouseTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeesAccessHouseTemps.
     */
    cursor?: EmployeesAccessHouseTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessHouseTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessHouseTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeesAccessHouseTemps.
     */
    distinct?: EmployeesAccessHouseTempScalarFieldEnum | EmployeesAccessHouseTempScalarFieldEnum[]
  }

  /**
   * EmployeesAccessHouseTemp findMany
   */
  export type EmployeesAccessHouseTempFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessHouseTemp
     */
    select?: EmployeesAccessHouseTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessHouseTemps to fetch.
     */
    where?: EmployeesAccessHouseTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessHouseTemps to fetch.
     */
    orderBy?: EmployeesAccessHouseTempOrderByWithRelationInput | EmployeesAccessHouseTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeesAccessHouseTemps.
     */
    cursor?: EmployeesAccessHouseTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessHouseTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessHouseTemps.
     */
    skip?: number
    distinct?: EmployeesAccessHouseTempScalarFieldEnum | EmployeesAccessHouseTempScalarFieldEnum[]
  }

  /**
   * EmployeesAccessHouseTemp create
   */
  export type EmployeesAccessHouseTempCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessHouseTemp
     */
    select?: EmployeesAccessHouseTempSelect<ExtArgs> | null
    /**
     * The data needed to create a EmployeesAccessHouseTemp.
     */
    data: XOR<EmployeesAccessHouseTempCreateInput, EmployeesAccessHouseTempUncheckedCreateInput>
  }

  /**
   * EmployeesAccessHouseTemp createMany
   */
  export type EmployeesAccessHouseTempCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeesAccessHouseTemps.
     */
    data: EmployeesAccessHouseTempCreateManyInput | EmployeesAccessHouseTempCreateManyInput[]
  }

  /**
   * EmployeesAccessHouseTemp update
   */
  export type EmployeesAccessHouseTempUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessHouseTemp
     */
    select?: EmployeesAccessHouseTempSelect<ExtArgs> | null
    /**
     * The data needed to update a EmployeesAccessHouseTemp.
     */
    data: XOR<EmployeesAccessHouseTempUpdateInput, EmployeesAccessHouseTempUncheckedUpdateInput>
    /**
     * Choose, which EmployeesAccessHouseTemp to update.
     */
    where: EmployeesAccessHouseTempWhereUniqueInput
  }

  /**
   * EmployeesAccessHouseTemp updateMany
   */
  export type EmployeesAccessHouseTempUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeesAccessHouseTemps.
     */
    data: XOR<EmployeesAccessHouseTempUpdateManyMutationInput, EmployeesAccessHouseTempUncheckedUpdateManyInput>
    /**
     * Filter which EmployeesAccessHouseTemps to update
     */
    where?: EmployeesAccessHouseTempWhereInput
  }

  /**
   * EmployeesAccessHouseTemp upsert
   */
  export type EmployeesAccessHouseTempUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessHouseTemp
     */
    select?: EmployeesAccessHouseTempSelect<ExtArgs> | null
    /**
     * The filter to search for the EmployeesAccessHouseTemp to update in case it exists.
     */
    where: EmployeesAccessHouseTempWhereUniqueInput
    /**
     * In case the EmployeesAccessHouseTemp found by the `where` argument doesn't exist, create a new EmployeesAccessHouseTemp with this data.
     */
    create: XOR<EmployeesAccessHouseTempCreateInput, EmployeesAccessHouseTempUncheckedCreateInput>
    /**
     * In case the EmployeesAccessHouseTemp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeesAccessHouseTempUpdateInput, EmployeesAccessHouseTempUncheckedUpdateInput>
  }

  /**
   * EmployeesAccessHouseTemp delete
   */
  export type EmployeesAccessHouseTempDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessHouseTemp
     */
    select?: EmployeesAccessHouseTempSelect<ExtArgs> | null
    /**
     * Filter which EmployeesAccessHouseTemp to delete.
     */
    where: EmployeesAccessHouseTempWhereUniqueInput
  }

  /**
   * EmployeesAccessHouseTemp deleteMany
   */
  export type EmployeesAccessHouseTempDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeesAccessHouseTemps to delete
     */
    where?: EmployeesAccessHouseTempWhereInput
  }

  /**
   * EmployeesAccessHouseTemp without action
   */
  export type EmployeesAccessHouseTempDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessHouseTemp
     */
    select?: EmployeesAccessHouseTempSelect<ExtArgs> | null
  }


  /**
   * Model EmployeesAccessLkupDocumentTypeTemp
   */

  export type AggregateEmployeesAccessLkupDocumentTypeTemp = {
    _count: EmployeesAccessLkupDocumentTypeTempCountAggregateOutputType | null
    _min: EmployeesAccessLkupDocumentTypeTempMinAggregateOutputType | null
    _max: EmployeesAccessLkupDocumentTypeTempMaxAggregateOutputType | null
  }

  export type EmployeesAccessLkupDocumentTypeTempMinAggregateOutputType = {
    EmployeesAccessLkupDocumentTypeTempId: string | null
    CompanyGeneralCrmId: string | null
    CreatedAt: Date | null
    DocumemtType: string | null
  }

  export type EmployeesAccessLkupDocumentTypeTempMaxAggregateOutputType = {
    EmployeesAccessLkupDocumentTypeTempId: string | null
    CompanyGeneralCrmId: string | null
    CreatedAt: Date | null
    DocumemtType: string | null
  }

  export type EmployeesAccessLkupDocumentTypeTempCountAggregateOutputType = {
    EmployeesAccessLkupDocumentTypeTempId: number
    CompanyGeneralCrmId: number
    CreatedAt: number
    DocumemtType: number
    _all: number
  }


  export type EmployeesAccessLkupDocumentTypeTempMinAggregateInputType = {
    EmployeesAccessLkupDocumentTypeTempId?: true
    CompanyGeneralCrmId?: true
    CreatedAt?: true
    DocumemtType?: true
  }

  export type EmployeesAccessLkupDocumentTypeTempMaxAggregateInputType = {
    EmployeesAccessLkupDocumentTypeTempId?: true
    CompanyGeneralCrmId?: true
    CreatedAt?: true
    DocumemtType?: true
  }

  export type EmployeesAccessLkupDocumentTypeTempCountAggregateInputType = {
    EmployeesAccessLkupDocumentTypeTempId?: true
    CompanyGeneralCrmId?: true
    CreatedAt?: true
    DocumemtType?: true
    _all?: true
  }

  export type EmployeesAccessLkupDocumentTypeTempAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeesAccessLkupDocumentTypeTemp to aggregate.
     */
    where?: EmployeesAccessLkupDocumentTypeTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessLkupDocumentTypeTemps to fetch.
     */
    orderBy?: EmployeesAccessLkupDocumentTypeTempOrderByWithRelationInput | EmployeesAccessLkupDocumentTypeTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeesAccessLkupDocumentTypeTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessLkupDocumentTypeTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessLkupDocumentTypeTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeesAccessLkupDocumentTypeTemps
    **/
    _count?: true | EmployeesAccessLkupDocumentTypeTempCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeesAccessLkupDocumentTypeTempMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeesAccessLkupDocumentTypeTempMaxAggregateInputType
  }

  export type GetEmployeesAccessLkupDocumentTypeTempAggregateType<T extends EmployeesAccessLkupDocumentTypeTempAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeesAccessLkupDocumentTypeTemp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeesAccessLkupDocumentTypeTemp[P]>
      : GetScalarType<T[P], AggregateEmployeesAccessLkupDocumentTypeTemp[P]>
  }




  export type EmployeesAccessLkupDocumentTypeTempGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeesAccessLkupDocumentTypeTempWhereInput
    orderBy?: EmployeesAccessLkupDocumentTypeTempOrderByWithAggregationInput | EmployeesAccessLkupDocumentTypeTempOrderByWithAggregationInput[]
    by: EmployeesAccessLkupDocumentTypeTempScalarFieldEnum[] | EmployeesAccessLkupDocumentTypeTempScalarFieldEnum
    having?: EmployeesAccessLkupDocumentTypeTempScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeesAccessLkupDocumentTypeTempCountAggregateInputType | true
    _min?: EmployeesAccessLkupDocumentTypeTempMinAggregateInputType
    _max?: EmployeesAccessLkupDocumentTypeTempMaxAggregateInputType
  }

  export type EmployeesAccessLkupDocumentTypeTempGroupByOutputType = {
    EmployeesAccessLkupDocumentTypeTempId: string
    CompanyGeneralCrmId: string
    CreatedAt: Date
    DocumemtType: string | null
    _count: EmployeesAccessLkupDocumentTypeTempCountAggregateOutputType | null
    _min: EmployeesAccessLkupDocumentTypeTempMinAggregateOutputType | null
    _max: EmployeesAccessLkupDocumentTypeTempMaxAggregateOutputType | null
  }

  type GetEmployeesAccessLkupDocumentTypeTempGroupByPayload<T extends EmployeesAccessLkupDocumentTypeTempGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeesAccessLkupDocumentTypeTempGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeesAccessLkupDocumentTypeTempGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeesAccessLkupDocumentTypeTempGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeesAccessLkupDocumentTypeTempGroupByOutputType[P]>
        }
      >
    >


  export type EmployeesAccessLkupDocumentTypeTempSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmployeesAccessLkupDocumentTypeTempId?: boolean
    CompanyGeneralCrmId?: boolean
    CreatedAt?: boolean
    DocumemtType?: boolean
  }, ExtArgs["result"]["employeesAccessLkupDocumentTypeTemp"]>


  export type EmployeesAccessLkupDocumentTypeTempSelectScalar = {
    EmployeesAccessLkupDocumentTypeTempId?: boolean
    CompanyGeneralCrmId?: boolean
    CreatedAt?: boolean
    DocumemtType?: boolean
  }


  export type $EmployeesAccessLkupDocumentTypeTempPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeesAccessLkupDocumentTypeTemp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      EmployeesAccessLkupDocumentTypeTempId: string
      CompanyGeneralCrmId: string
      CreatedAt: Date
      DocumemtType: string | null
    }, ExtArgs["result"]["employeesAccessLkupDocumentTypeTemp"]>
    composites: {}
  }

  type EmployeesAccessLkupDocumentTypeTempGetPayload<S extends boolean | null | undefined | EmployeesAccessLkupDocumentTypeTempDefaultArgs> = $Result.GetResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload, S>

  type EmployeesAccessLkupDocumentTypeTempCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeesAccessLkupDocumentTypeTempFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeesAccessLkupDocumentTypeTempCountAggregateInputType | true
    }

  export interface EmployeesAccessLkupDocumentTypeTempDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeesAccessLkupDocumentTypeTemp'], meta: { name: 'EmployeesAccessLkupDocumentTypeTemp' } }
    /**
     * Find zero or one EmployeesAccessLkupDocumentTypeTemp that matches the filter.
     * @param {EmployeesAccessLkupDocumentTypeTempFindUniqueArgs} args - Arguments to find a EmployeesAccessLkupDocumentTypeTemp
     * @example
     * // Get one EmployeesAccessLkupDocumentTypeTemp
     * const employeesAccessLkupDocumentTypeTemp = await prisma.employeesAccessLkupDocumentTypeTemp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeesAccessLkupDocumentTypeTempFindUniqueArgs>(args: SelectSubset<T, EmployeesAccessLkupDocumentTypeTempFindUniqueArgs<ExtArgs>>): Prisma__EmployeesAccessLkupDocumentTypeTempClient<$Result.GetResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeesAccessLkupDocumentTypeTemp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeesAccessLkupDocumentTypeTempFindUniqueOrThrowArgs} args - Arguments to find a EmployeesAccessLkupDocumentTypeTemp
     * @example
     * // Get one EmployeesAccessLkupDocumentTypeTemp
     * const employeesAccessLkupDocumentTypeTemp = await prisma.employeesAccessLkupDocumentTypeTemp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeesAccessLkupDocumentTypeTempFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeesAccessLkupDocumentTypeTempFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeesAccessLkupDocumentTypeTempClient<$Result.GetResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeesAccessLkupDocumentTypeTemp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessLkupDocumentTypeTempFindFirstArgs} args - Arguments to find a EmployeesAccessLkupDocumentTypeTemp
     * @example
     * // Get one EmployeesAccessLkupDocumentTypeTemp
     * const employeesAccessLkupDocumentTypeTemp = await prisma.employeesAccessLkupDocumentTypeTemp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeesAccessLkupDocumentTypeTempFindFirstArgs>(args?: SelectSubset<T, EmployeesAccessLkupDocumentTypeTempFindFirstArgs<ExtArgs>>): Prisma__EmployeesAccessLkupDocumentTypeTempClient<$Result.GetResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeesAccessLkupDocumentTypeTemp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessLkupDocumentTypeTempFindFirstOrThrowArgs} args - Arguments to find a EmployeesAccessLkupDocumentTypeTemp
     * @example
     * // Get one EmployeesAccessLkupDocumentTypeTemp
     * const employeesAccessLkupDocumentTypeTemp = await prisma.employeesAccessLkupDocumentTypeTemp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeesAccessLkupDocumentTypeTempFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeesAccessLkupDocumentTypeTempFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeesAccessLkupDocumentTypeTempClient<$Result.GetResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeesAccessLkupDocumentTypeTemps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessLkupDocumentTypeTempFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeesAccessLkupDocumentTypeTemps
     * const employeesAccessLkupDocumentTypeTemps = await prisma.employeesAccessLkupDocumentTypeTemp.findMany()
     * 
     * // Get first 10 EmployeesAccessLkupDocumentTypeTemps
     * const employeesAccessLkupDocumentTypeTemps = await prisma.employeesAccessLkupDocumentTypeTemp.findMany({ take: 10 })
     * 
     * // Only select the `EmployeesAccessLkupDocumentTypeTempId`
     * const employeesAccessLkupDocumentTypeTempWithEmployeesAccessLkupDocumentTypeTempIdOnly = await prisma.employeesAccessLkupDocumentTypeTemp.findMany({ select: { EmployeesAccessLkupDocumentTypeTempId: true } })
     * 
     */
    findMany<T extends EmployeesAccessLkupDocumentTypeTempFindManyArgs>(args?: SelectSubset<T, EmployeesAccessLkupDocumentTypeTempFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeesAccessLkupDocumentTypeTemp.
     * @param {EmployeesAccessLkupDocumentTypeTempCreateArgs} args - Arguments to create a EmployeesAccessLkupDocumentTypeTemp.
     * @example
     * // Create one EmployeesAccessLkupDocumentTypeTemp
     * const EmployeesAccessLkupDocumentTypeTemp = await prisma.employeesAccessLkupDocumentTypeTemp.create({
     *   data: {
     *     // ... data to create a EmployeesAccessLkupDocumentTypeTemp
     *   }
     * })
     * 
     */
    create<T extends EmployeesAccessLkupDocumentTypeTempCreateArgs>(args: SelectSubset<T, EmployeesAccessLkupDocumentTypeTempCreateArgs<ExtArgs>>): Prisma__EmployeesAccessLkupDocumentTypeTempClient<$Result.GetResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeesAccessLkupDocumentTypeTemps.
     * @param {EmployeesAccessLkupDocumentTypeTempCreateManyArgs} args - Arguments to create many EmployeesAccessLkupDocumentTypeTemps.
     * @example
     * // Create many EmployeesAccessLkupDocumentTypeTemps
     * const employeesAccessLkupDocumentTypeTemp = await prisma.employeesAccessLkupDocumentTypeTemp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeesAccessLkupDocumentTypeTempCreateManyArgs>(args?: SelectSubset<T, EmployeesAccessLkupDocumentTypeTempCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeesAccessLkupDocumentTypeTemp.
     * @param {EmployeesAccessLkupDocumentTypeTempDeleteArgs} args - Arguments to delete one EmployeesAccessLkupDocumentTypeTemp.
     * @example
     * // Delete one EmployeesAccessLkupDocumentTypeTemp
     * const EmployeesAccessLkupDocumentTypeTemp = await prisma.employeesAccessLkupDocumentTypeTemp.delete({
     *   where: {
     *     // ... filter to delete one EmployeesAccessLkupDocumentTypeTemp
     *   }
     * })
     * 
     */
    delete<T extends EmployeesAccessLkupDocumentTypeTempDeleteArgs>(args: SelectSubset<T, EmployeesAccessLkupDocumentTypeTempDeleteArgs<ExtArgs>>): Prisma__EmployeesAccessLkupDocumentTypeTempClient<$Result.GetResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeesAccessLkupDocumentTypeTemp.
     * @param {EmployeesAccessLkupDocumentTypeTempUpdateArgs} args - Arguments to update one EmployeesAccessLkupDocumentTypeTemp.
     * @example
     * // Update one EmployeesAccessLkupDocumentTypeTemp
     * const employeesAccessLkupDocumentTypeTemp = await prisma.employeesAccessLkupDocumentTypeTemp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeesAccessLkupDocumentTypeTempUpdateArgs>(args: SelectSubset<T, EmployeesAccessLkupDocumentTypeTempUpdateArgs<ExtArgs>>): Prisma__EmployeesAccessLkupDocumentTypeTempClient<$Result.GetResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeesAccessLkupDocumentTypeTemps.
     * @param {EmployeesAccessLkupDocumentTypeTempDeleteManyArgs} args - Arguments to filter EmployeesAccessLkupDocumentTypeTemps to delete.
     * @example
     * // Delete a few EmployeesAccessLkupDocumentTypeTemps
     * const { count } = await prisma.employeesAccessLkupDocumentTypeTemp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeesAccessLkupDocumentTypeTempDeleteManyArgs>(args?: SelectSubset<T, EmployeesAccessLkupDocumentTypeTempDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeesAccessLkupDocumentTypeTemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessLkupDocumentTypeTempUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeesAccessLkupDocumentTypeTemps
     * const employeesAccessLkupDocumentTypeTemp = await prisma.employeesAccessLkupDocumentTypeTemp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeesAccessLkupDocumentTypeTempUpdateManyArgs>(args: SelectSubset<T, EmployeesAccessLkupDocumentTypeTempUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeesAccessLkupDocumentTypeTemp.
     * @param {EmployeesAccessLkupDocumentTypeTempUpsertArgs} args - Arguments to update or create a EmployeesAccessLkupDocumentTypeTemp.
     * @example
     * // Update or create a EmployeesAccessLkupDocumentTypeTemp
     * const employeesAccessLkupDocumentTypeTemp = await prisma.employeesAccessLkupDocumentTypeTemp.upsert({
     *   create: {
     *     // ... data to create a EmployeesAccessLkupDocumentTypeTemp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeesAccessLkupDocumentTypeTemp we want to update
     *   }
     * })
     */
    upsert<T extends EmployeesAccessLkupDocumentTypeTempUpsertArgs>(args: SelectSubset<T, EmployeesAccessLkupDocumentTypeTempUpsertArgs<ExtArgs>>): Prisma__EmployeesAccessLkupDocumentTypeTempClient<$Result.GetResult<Prisma.$EmployeesAccessLkupDocumentTypeTempPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeesAccessLkupDocumentTypeTemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessLkupDocumentTypeTempCountArgs} args - Arguments to filter EmployeesAccessLkupDocumentTypeTemps to count.
     * @example
     * // Count the number of EmployeesAccessLkupDocumentTypeTemps
     * const count = await prisma.employeesAccessLkupDocumentTypeTemp.count({
     *   where: {
     *     // ... the filter for the EmployeesAccessLkupDocumentTypeTemps we want to count
     *   }
     * })
    **/
    count<T extends EmployeesAccessLkupDocumentTypeTempCountArgs>(
      args?: Subset<T, EmployeesAccessLkupDocumentTypeTempCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeesAccessLkupDocumentTypeTempCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeesAccessLkupDocumentTypeTemp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessLkupDocumentTypeTempAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeesAccessLkupDocumentTypeTempAggregateArgs>(args: Subset<T, EmployeesAccessLkupDocumentTypeTempAggregateArgs>): Prisma.PrismaPromise<GetEmployeesAccessLkupDocumentTypeTempAggregateType<T>>

    /**
     * Group by EmployeesAccessLkupDocumentTypeTemp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessLkupDocumentTypeTempGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeesAccessLkupDocumentTypeTempGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeesAccessLkupDocumentTypeTempGroupByArgs['orderBy'] }
        : { orderBy?: EmployeesAccessLkupDocumentTypeTempGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeesAccessLkupDocumentTypeTempGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeesAccessLkupDocumentTypeTempGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeesAccessLkupDocumentTypeTemp model
   */
  readonly fields: EmployeesAccessLkupDocumentTypeTempFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeesAccessLkupDocumentTypeTemp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeesAccessLkupDocumentTypeTempClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeesAccessLkupDocumentTypeTemp model
   */ 
  interface EmployeesAccessLkupDocumentTypeTempFieldRefs {
    readonly EmployeesAccessLkupDocumentTypeTempId: FieldRef<"EmployeesAccessLkupDocumentTypeTemp", 'String'>
    readonly CompanyGeneralCrmId: FieldRef<"EmployeesAccessLkupDocumentTypeTemp", 'String'>
    readonly CreatedAt: FieldRef<"EmployeesAccessLkupDocumentTypeTemp", 'DateTime'>
    readonly DocumemtType: FieldRef<"EmployeesAccessLkupDocumentTypeTemp", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeesAccessLkupDocumentTypeTemp findUnique
   */
  export type EmployeesAccessLkupDocumentTypeTempFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessLkupDocumentTypeTemp
     */
    select?: EmployeesAccessLkupDocumentTypeTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessLkupDocumentTypeTemp to fetch.
     */
    where: EmployeesAccessLkupDocumentTypeTempWhereUniqueInput
  }

  /**
   * EmployeesAccessLkupDocumentTypeTemp findUniqueOrThrow
   */
  export type EmployeesAccessLkupDocumentTypeTempFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessLkupDocumentTypeTemp
     */
    select?: EmployeesAccessLkupDocumentTypeTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessLkupDocumentTypeTemp to fetch.
     */
    where: EmployeesAccessLkupDocumentTypeTempWhereUniqueInput
  }

  /**
   * EmployeesAccessLkupDocumentTypeTemp findFirst
   */
  export type EmployeesAccessLkupDocumentTypeTempFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessLkupDocumentTypeTemp
     */
    select?: EmployeesAccessLkupDocumentTypeTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessLkupDocumentTypeTemp to fetch.
     */
    where?: EmployeesAccessLkupDocumentTypeTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessLkupDocumentTypeTemps to fetch.
     */
    orderBy?: EmployeesAccessLkupDocumentTypeTempOrderByWithRelationInput | EmployeesAccessLkupDocumentTypeTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeesAccessLkupDocumentTypeTemps.
     */
    cursor?: EmployeesAccessLkupDocumentTypeTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessLkupDocumentTypeTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessLkupDocumentTypeTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeesAccessLkupDocumentTypeTemps.
     */
    distinct?: EmployeesAccessLkupDocumentTypeTempScalarFieldEnum | EmployeesAccessLkupDocumentTypeTempScalarFieldEnum[]
  }

  /**
   * EmployeesAccessLkupDocumentTypeTemp findFirstOrThrow
   */
  export type EmployeesAccessLkupDocumentTypeTempFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessLkupDocumentTypeTemp
     */
    select?: EmployeesAccessLkupDocumentTypeTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessLkupDocumentTypeTemp to fetch.
     */
    where?: EmployeesAccessLkupDocumentTypeTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessLkupDocumentTypeTemps to fetch.
     */
    orderBy?: EmployeesAccessLkupDocumentTypeTempOrderByWithRelationInput | EmployeesAccessLkupDocumentTypeTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeesAccessLkupDocumentTypeTemps.
     */
    cursor?: EmployeesAccessLkupDocumentTypeTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessLkupDocumentTypeTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessLkupDocumentTypeTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeesAccessLkupDocumentTypeTemps.
     */
    distinct?: EmployeesAccessLkupDocumentTypeTempScalarFieldEnum | EmployeesAccessLkupDocumentTypeTempScalarFieldEnum[]
  }

  /**
   * EmployeesAccessLkupDocumentTypeTemp findMany
   */
  export type EmployeesAccessLkupDocumentTypeTempFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessLkupDocumentTypeTemp
     */
    select?: EmployeesAccessLkupDocumentTypeTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessLkupDocumentTypeTemps to fetch.
     */
    where?: EmployeesAccessLkupDocumentTypeTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessLkupDocumentTypeTemps to fetch.
     */
    orderBy?: EmployeesAccessLkupDocumentTypeTempOrderByWithRelationInput | EmployeesAccessLkupDocumentTypeTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeesAccessLkupDocumentTypeTemps.
     */
    cursor?: EmployeesAccessLkupDocumentTypeTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessLkupDocumentTypeTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessLkupDocumentTypeTemps.
     */
    skip?: number
    distinct?: EmployeesAccessLkupDocumentTypeTempScalarFieldEnum | EmployeesAccessLkupDocumentTypeTempScalarFieldEnum[]
  }

  /**
   * EmployeesAccessLkupDocumentTypeTemp create
   */
  export type EmployeesAccessLkupDocumentTypeTempCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessLkupDocumentTypeTemp
     */
    select?: EmployeesAccessLkupDocumentTypeTempSelect<ExtArgs> | null
    /**
     * The data needed to create a EmployeesAccessLkupDocumentTypeTemp.
     */
    data: XOR<EmployeesAccessLkupDocumentTypeTempCreateInput, EmployeesAccessLkupDocumentTypeTempUncheckedCreateInput>
  }

  /**
   * EmployeesAccessLkupDocumentTypeTemp createMany
   */
  export type EmployeesAccessLkupDocumentTypeTempCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeesAccessLkupDocumentTypeTemps.
     */
    data: EmployeesAccessLkupDocumentTypeTempCreateManyInput | EmployeesAccessLkupDocumentTypeTempCreateManyInput[]
  }

  /**
   * EmployeesAccessLkupDocumentTypeTemp update
   */
  export type EmployeesAccessLkupDocumentTypeTempUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessLkupDocumentTypeTemp
     */
    select?: EmployeesAccessLkupDocumentTypeTempSelect<ExtArgs> | null
    /**
     * The data needed to update a EmployeesAccessLkupDocumentTypeTemp.
     */
    data: XOR<EmployeesAccessLkupDocumentTypeTempUpdateInput, EmployeesAccessLkupDocumentTypeTempUncheckedUpdateInput>
    /**
     * Choose, which EmployeesAccessLkupDocumentTypeTemp to update.
     */
    where: EmployeesAccessLkupDocumentTypeTempWhereUniqueInput
  }

  /**
   * EmployeesAccessLkupDocumentTypeTemp updateMany
   */
  export type EmployeesAccessLkupDocumentTypeTempUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeesAccessLkupDocumentTypeTemps.
     */
    data: XOR<EmployeesAccessLkupDocumentTypeTempUpdateManyMutationInput, EmployeesAccessLkupDocumentTypeTempUncheckedUpdateManyInput>
    /**
     * Filter which EmployeesAccessLkupDocumentTypeTemps to update
     */
    where?: EmployeesAccessLkupDocumentTypeTempWhereInput
  }

  /**
   * EmployeesAccessLkupDocumentTypeTemp upsert
   */
  export type EmployeesAccessLkupDocumentTypeTempUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessLkupDocumentTypeTemp
     */
    select?: EmployeesAccessLkupDocumentTypeTempSelect<ExtArgs> | null
    /**
     * The filter to search for the EmployeesAccessLkupDocumentTypeTemp to update in case it exists.
     */
    where: EmployeesAccessLkupDocumentTypeTempWhereUniqueInput
    /**
     * In case the EmployeesAccessLkupDocumentTypeTemp found by the `where` argument doesn't exist, create a new EmployeesAccessLkupDocumentTypeTemp with this data.
     */
    create: XOR<EmployeesAccessLkupDocumentTypeTempCreateInput, EmployeesAccessLkupDocumentTypeTempUncheckedCreateInput>
    /**
     * In case the EmployeesAccessLkupDocumentTypeTemp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeesAccessLkupDocumentTypeTempUpdateInput, EmployeesAccessLkupDocumentTypeTempUncheckedUpdateInput>
  }

  /**
   * EmployeesAccessLkupDocumentTypeTemp delete
   */
  export type EmployeesAccessLkupDocumentTypeTempDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessLkupDocumentTypeTemp
     */
    select?: EmployeesAccessLkupDocumentTypeTempSelect<ExtArgs> | null
    /**
     * Filter which EmployeesAccessLkupDocumentTypeTemp to delete.
     */
    where: EmployeesAccessLkupDocumentTypeTempWhereUniqueInput
  }

  /**
   * EmployeesAccessLkupDocumentTypeTemp deleteMany
   */
  export type EmployeesAccessLkupDocumentTypeTempDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeesAccessLkupDocumentTypeTemps to delete
     */
    where?: EmployeesAccessLkupDocumentTypeTempWhereInput
  }

  /**
   * EmployeesAccessLkupDocumentTypeTemp without action
   */
  export type EmployeesAccessLkupDocumentTypeTempDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessLkupDocumentTypeTemp
     */
    select?: EmployeesAccessLkupDocumentTypeTempSelect<ExtArgs> | null
  }


  /**
   * Model EmployeesAccessTemp
   */

  export type AggregateEmployeesAccessTemp = {
    _count: EmployeesAccessTempCountAggregateOutputType | null
    _min: EmployeesAccessTempMinAggregateOutputType | null
    _max: EmployeesAccessTempMaxAggregateOutputType | null
  }

  export type EmployeesAccessTempMinAggregateOutputType = {
    EmployeesAccessTempId: string | null
    CompanyGeneralCrmId: string | null
    CreatedAt: Date | null
    AgentID: string | null
    AreaMan: string | null
    AppartmentNum: string | null
    BirthDate: string | null
    CityName: string | null
    CoatReceivingDate: string | null
    CoatSize: string | null
    CountryID: string | null
    CountryName: string | null
    CourseAtatDate: string | null
    CourseAtatExpireDate: string | null
    CustomerName: string | null
    CustomerStatus: string | null
    CustomerID: string | null
    EmployeeFirstName: string | null
    EmployeeID: string | null
    EmployeeLastName: string | null
    EmployeeNumber: string | null
    EndInsuranceDate: string | null
    EntranceDate: string | null
    HealthFund: string | null
    HouseID: string | null
    HouseNumber: string | null
    InsuranceCompany: string | null
    InsuranceNumber: string | null
    InsuredNumber: string | null
    IsCourseAtat: string | null
    Isbriefing: string | null
    LocalityName: string | null
    LocalityCode: string | null
    LocalityID: string | null
    LongshirtReceivingDate: string | null
    LongshirtSize: string | null
    MobilePhone: string | null
    PantsReceivingDate: string | null
    PassportNumber: string | null
    ProfessionName: string | null
    ProfessionSecondName: string | null
    ProfessionThirdName: string | null
    ShoesNumber: string | null
    ShoesReceiveDate: string | null
    SizeOfPantes: string | null
    SizeOfshirt: string | null
    StartDate: string | null
    StatusName: string | null
    Street: string | null
    TshirReceivingDate: string | null
    briefingDate: string | null
    briefingExpireDate: string | null
    startInsuranceDate: string | null
  }

  export type EmployeesAccessTempMaxAggregateOutputType = {
    EmployeesAccessTempId: string | null
    CompanyGeneralCrmId: string | null
    CreatedAt: Date | null
    AgentID: string | null
    AreaMan: string | null
    AppartmentNum: string | null
    BirthDate: string | null
    CityName: string | null
    CoatReceivingDate: string | null
    CoatSize: string | null
    CountryID: string | null
    CountryName: string | null
    CourseAtatDate: string | null
    CourseAtatExpireDate: string | null
    CustomerName: string | null
    CustomerStatus: string | null
    CustomerID: string | null
    EmployeeFirstName: string | null
    EmployeeID: string | null
    EmployeeLastName: string | null
    EmployeeNumber: string | null
    EndInsuranceDate: string | null
    EntranceDate: string | null
    HealthFund: string | null
    HouseID: string | null
    HouseNumber: string | null
    InsuranceCompany: string | null
    InsuranceNumber: string | null
    InsuredNumber: string | null
    IsCourseAtat: string | null
    Isbriefing: string | null
    LocalityName: string | null
    LocalityCode: string | null
    LocalityID: string | null
    LongshirtReceivingDate: string | null
    LongshirtSize: string | null
    MobilePhone: string | null
    PantsReceivingDate: string | null
    PassportNumber: string | null
    ProfessionName: string | null
    ProfessionSecondName: string | null
    ProfessionThirdName: string | null
    ShoesNumber: string | null
    ShoesReceiveDate: string | null
    SizeOfPantes: string | null
    SizeOfshirt: string | null
    StartDate: string | null
    StatusName: string | null
    Street: string | null
    TshirReceivingDate: string | null
    briefingDate: string | null
    briefingExpireDate: string | null
    startInsuranceDate: string | null
  }

  export type EmployeesAccessTempCountAggregateOutputType = {
    EmployeesAccessTempId: number
    CompanyGeneralCrmId: number
    CreatedAt: number
    AgentID: number
    AreaMan: number
    AppartmentNum: number
    BirthDate: number
    CityName: number
    CoatReceivingDate: number
    CoatSize: number
    CountryID: number
    CountryName: number
    CourseAtatDate: number
    CourseAtatExpireDate: number
    CustomerName: number
    CustomerStatus: number
    CustomerID: number
    EmployeeFirstName: number
    EmployeeID: number
    EmployeeLastName: number
    EmployeeNumber: number
    EndInsuranceDate: number
    EntranceDate: number
    HealthFund: number
    HouseID: number
    HouseNumber: number
    InsuranceCompany: number
    InsuranceNumber: number
    InsuredNumber: number
    IsCourseAtat: number
    Isbriefing: number
    LocalityName: number
    LocalityCode: number
    LocalityID: number
    LongshirtReceivingDate: number
    LongshirtSize: number
    MobilePhone: number
    PantsReceivingDate: number
    PassportNumber: number
    ProfessionName: number
    ProfessionSecondName: number
    ProfessionThirdName: number
    ShoesNumber: number
    ShoesReceiveDate: number
    SizeOfPantes: number
    SizeOfshirt: number
    StartDate: number
    StatusName: number
    Street: number
    TshirReceivingDate: number
    briefingDate: number
    briefingExpireDate: number
    startInsuranceDate: number
    _all: number
  }


  export type EmployeesAccessTempMinAggregateInputType = {
    EmployeesAccessTempId?: true
    CompanyGeneralCrmId?: true
    CreatedAt?: true
    AgentID?: true
    AreaMan?: true
    AppartmentNum?: true
    BirthDate?: true
    CityName?: true
    CoatReceivingDate?: true
    CoatSize?: true
    CountryID?: true
    CountryName?: true
    CourseAtatDate?: true
    CourseAtatExpireDate?: true
    CustomerName?: true
    CustomerStatus?: true
    CustomerID?: true
    EmployeeFirstName?: true
    EmployeeID?: true
    EmployeeLastName?: true
    EmployeeNumber?: true
    EndInsuranceDate?: true
    EntranceDate?: true
    HealthFund?: true
    HouseID?: true
    HouseNumber?: true
    InsuranceCompany?: true
    InsuranceNumber?: true
    InsuredNumber?: true
    IsCourseAtat?: true
    Isbriefing?: true
    LocalityName?: true
    LocalityCode?: true
    LocalityID?: true
    LongshirtReceivingDate?: true
    LongshirtSize?: true
    MobilePhone?: true
    PantsReceivingDate?: true
    PassportNumber?: true
    ProfessionName?: true
    ProfessionSecondName?: true
    ProfessionThirdName?: true
    ShoesNumber?: true
    ShoesReceiveDate?: true
    SizeOfPantes?: true
    SizeOfshirt?: true
    StartDate?: true
    StatusName?: true
    Street?: true
    TshirReceivingDate?: true
    briefingDate?: true
    briefingExpireDate?: true
    startInsuranceDate?: true
  }

  export type EmployeesAccessTempMaxAggregateInputType = {
    EmployeesAccessTempId?: true
    CompanyGeneralCrmId?: true
    CreatedAt?: true
    AgentID?: true
    AreaMan?: true
    AppartmentNum?: true
    BirthDate?: true
    CityName?: true
    CoatReceivingDate?: true
    CoatSize?: true
    CountryID?: true
    CountryName?: true
    CourseAtatDate?: true
    CourseAtatExpireDate?: true
    CustomerName?: true
    CustomerStatus?: true
    CustomerID?: true
    EmployeeFirstName?: true
    EmployeeID?: true
    EmployeeLastName?: true
    EmployeeNumber?: true
    EndInsuranceDate?: true
    EntranceDate?: true
    HealthFund?: true
    HouseID?: true
    HouseNumber?: true
    InsuranceCompany?: true
    InsuranceNumber?: true
    InsuredNumber?: true
    IsCourseAtat?: true
    Isbriefing?: true
    LocalityName?: true
    LocalityCode?: true
    LocalityID?: true
    LongshirtReceivingDate?: true
    LongshirtSize?: true
    MobilePhone?: true
    PantsReceivingDate?: true
    PassportNumber?: true
    ProfessionName?: true
    ProfessionSecondName?: true
    ProfessionThirdName?: true
    ShoesNumber?: true
    ShoesReceiveDate?: true
    SizeOfPantes?: true
    SizeOfshirt?: true
    StartDate?: true
    StatusName?: true
    Street?: true
    TshirReceivingDate?: true
    briefingDate?: true
    briefingExpireDate?: true
    startInsuranceDate?: true
  }

  export type EmployeesAccessTempCountAggregateInputType = {
    EmployeesAccessTempId?: true
    CompanyGeneralCrmId?: true
    CreatedAt?: true
    AgentID?: true
    AreaMan?: true
    AppartmentNum?: true
    BirthDate?: true
    CityName?: true
    CoatReceivingDate?: true
    CoatSize?: true
    CountryID?: true
    CountryName?: true
    CourseAtatDate?: true
    CourseAtatExpireDate?: true
    CustomerName?: true
    CustomerStatus?: true
    CustomerID?: true
    EmployeeFirstName?: true
    EmployeeID?: true
    EmployeeLastName?: true
    EmployeeNumber?: true
    EndInsuranceDate?: true
    EntranceDate?: true
    HealthFund?: true
    HouseID?: true
    HouseNumber?: true
    InsuranceCompany?: true
    InsuranceNumber?: true
    InsuredNumber?: true
    IsCourseAtat?: true
    Isbriefing?: true
    LocalityName?: true
    LocalityCode?: true
    LocalityID?: true
    LongshirtReceivingDate?: true
    LongshirtSize?: true
    MobilePhone?: true
    PantsReceivingDate?: true
    PassportNumber?: true
    ProfessionName?: true
    ProfessionSecondName?: true
    ProfessionThirdName?: true
    ShoesNumber?: true
    ShoesReceiveDate?: true
    SizeOfPantes?: true
    SizeOfshirt?: true
    StartDate?: true
    StatusName?: true
    Street?: true
    TshirReceivingDate?: true
    briefingDate?: true
    briefingExpireDate?: true
    startInsuranceDate?: true
    _all?: true
  }

  export type EmployeesAccessTempAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeesAccessTemp to aggregate.
     */
    where?: EmployeesAccessTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessTemps to fetch.
     */
    orderBy?: EmployeesAccessTempOrderByWithRelationInput | EmployeesAccessTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeesAccessTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeesAccessTemps
    **/
    _count?: true | EmployeesAccessTempCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeesAccessTempMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeesAccessTempMaxAggregateInputType
  }

  export type GetEmployeesAccessTempAggregateType<T extends EmployeesAccessTempAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeesAccessTemp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeesAccessTemp[P]>
      : GetScalarType<T[P], AggregateEmployeesAccessTemp[P]>
  }




  export type EmployeesAccessTempGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeesAccessTempWhereInput
    orderBy?: EmployeesAccessTempOrderByWithAggregationInput | EmployeesAccessTempOrderByWithAggregationInput[]
    by: EmployeesAccessTempScalarFieldEnum[] | EmployeesAccessTempScalarFieldEnum
    having?: EmployeesAccessTempScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeesAccessTempCountAggregateInputType | true
    _min?: EmployeesAccessTempMinAggregateInputType
    _max?: EmployeesAccessTempMaxAggregateInputType
  }

  export type EmployeesAccessTempGroupByOutputType = {
    EmployeesAccessTempId: string
    CompanyGeneralCrmId: string
    CreatedAt: Date
    AgentID: string | null
    AreaMan: string | null
    AppartmentNum: string | null
    BirthDate: string | null
    CityName: string | null
    CoatReceivingDate: string | null
    CoatSize: string | null
    CountryID: string | null
    CountryName: string | null
    CourseAtatDate: string | null
    CourseAtatExpireDate: string | null
    CustomerName: string | null
    CustomerStatus: string | null
    CustomerID: string | null
    EmployeeFirstName: string | null
    EmployeeID: string | null
    EmployeeLastName: string | null
    EmployeeNumber: string | null
    EndInsuranceDate: string | null
    EntranceDate: string | null
    HealthFund: string | null
    HouseID: string | null
    HouseNumber: string | null
    InsuranceCompany: string | null
    InsuranceNumber: string | null
    InsuredNumber: string | null
    IsCourseAtat: string | null
    Isbriefing: string | null
    LocalityName: string | null
    LocalityCode: string | null
    LocalityID: string | null
    LongshirtReceivingDate: string | null
    LongshirtSize: string | null
    MobilePhone: string | null
    PantsReceivingDate: string | null
    PassportNumber: string | null
    ProfessionName: string | null
    ProfessionSecondName: string | null
    ProfessionThirdName: string | null
    ShoesNumber: string | null
    ShoesReceiveDate: string | null
    SizeOfPantes: string | null
    SizeOfshirt: string | null
    StartDate: string | null
    StatusName: string | null
    Street: string | null
    TshirReceivingDate: string | null
    briefingDate: string | null
    briefingExpireDate: string | null
    startInsuranceDate: string | null
    _count: EmployeesAccessTempCountAggregateOutputType | null
    _min: EmployeesAccessTempMinAggregateOutputType | null
    _max: EmployeesAccessTempMaxAggregateOutputType | null
  }

  type GetEmployeesAccessTempGroupByPayload<T extends EmployeesAccessTempGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeesAccessTempGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeesAccessTempGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeesAccessTempGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeesAccessTempGroupByOutputType[P]>
        }
      >
    >


  export type EmployeesAccessTempSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EmployeesAccessTempId?: boolean
    CompanyGeneralCrmId?: boolean
    CreatedAt?: boolean
    AgentID?: boolean
    AreaMan?: boolean
    AppartmentNum?: boolean
    BirthDate?: boolean
    CityName?: boolean
    CoatReceivingDate?: boolean
    CoatSize?: boolean
    CountryID?: boolean
    CountryName?: boolean
    CourseAtatDate?: boolean
    CourseAtatExpireDate?: boolean
    CustomerName?: boolean
    CustomerStatus?: boolean
    CustomerID?: boolean
    EmployeeFirstName?: boolean
    EmployeeID?: boolean
    EmployeeLastName?: boolean
    EmployeeNumber?: boolean
    EndInsuranceDate?: boolean
    EntranceDate?: boolean
    HealthFund?: boolean
    HouseID?: boolean
    HouseNumber?: boolean
    InsuranceCompany?: boolean
    InsuranceNumber?: boolean
    InsuredNumber?: boolean
    IsCourseAtat?: boolean
    Isbriefing?: boolean
    LocalityName?: boolean
    LocalityCode?: boolean
    LocalityID?: boolean
    LongshirtReceivingDate?: boolean
    LongshirtSize?: boolean
    MobilePhone?: boolean
    PantsReceivingDate?: boolean
    PassportNumber?: boolean
    ProfessionName?: boolean
    ProfessionSecondName?: boolean
    ProfessionThirdName?: boolean
    ShoesNumber?: boolean
    ShoesReceiveDate?: boolean
    SizeOfPantes?: boolean
    SizeOfshirt?: boolean
    StartDate?: boolean
    StatusName?: boolean
    Street?: boolean
    TshirReceivingDate?: boolean
    briefingDate?: boolean
    briefingExpireDate?: boolean
    startInsuranceDate?: boolean
  }, ExtArgs["result"]["employeesAccessTemp"]>


  export type EmployeesAccessTempSelectScalar = {
    EmployeesAccessTempId?: boolean
    CompanyGeneralCrmId?: boolean
    CreatedAt?: boolean
    AgentID?: boolean
    AreaMan?: boolean
    AppartmentNum?: boolean
    BirthDate?: boolean
    CityName?: boolean
    CoatReceivingDate?: boolean
    CoatSize?: boolean
    CountryID?: boolean
    CountryName?: boolean
    CourseAtatDate?: boolean
    CourseAtatExpireDate?: boolean
    CustomerName?: boolean
    CustomerStatus?: boolean
    CustomerID?: boolean
    EmployeeFirstName?: boolean
    EmployeeID?: boolean
    EmployeeLastName?: boolean
    EmployeeNumber?: boolean
    EndInsuranceDate?: boolean
    EntranceDate?: boolean
    HealthFund?: boolean
    HouseID?: boolean
    HouseNumber?: boolean
    InsuranceCompany?: boolean
    InsuranceNumber?: boolean
    InsuredNumber?: boolean
    IsCourseAtat?: boolean
    Isbriefing?: boolean
    LocalityName?: boolean
    LocalityCode?: boolean
    LocalityID?: boolean
    LongshirtReceivingDate?: boolean
    LongshirtSize?: boolean
    MobilePhone?: boolean
    PantsReceivingDate?: boolean
    PassportNumber?: boolean
    ProfessionName?: boolean
    ProfessionSecondName?: boolean
    ProfessionThirdName?: boolean
    ShoesNumber?: boolean
    ShoesReceiveDate?: boolean
    SizeOfPantes?: boolean
    SizeOfshirt?: boolean
    StartDate?: boolean
    StatusName?: boolean
    Street?: boolean
    TshirReceivingDate?: boolean
    briefingDate?: boolean
    briefingExpireDate?: boolean
    startInsuranceDate?: boolean
  }


  export type $EmployeesAccessTempPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeesAccessTemp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      EmployeesAccessTempId: string
      CompanyGeneralCrmId: string
      CreatedAt: Date
      AgentID: string | null
      AreaMan: string | null
      AppartmentNum: string | null
      BirthDate: string | null
      CityName: string | null
      CoatReceivingDate: string | null
      CoatSize: string | null
      CountryID: string | null
      CountryName: string | null
      CourseAtatDate: string | null
      CourseAtatExpireDate: string | null
      CustomerName: string | null
      CustomerStatus: string | null
      CustomerID: string | null
      EmployeeFirstName: string | null
      EmployeeID: string | null
      EmployeeLastName: string | null
      EmployeeNumber: string | null
      EndInsuranceDate: string | null
      EntranceDate: string | null
      HealthFund: string | null
      HouseID: string | null
      HouseNumber: string | null
      InsuranceCompany: string | null
      InsuranceNumber: string | null
      InsuredNumber: string | null
      IsCourseAtat: string | null
      Isbriefing: string | null
      LocalityName: string | null
      LocalityCode: string | null
      LocalityID: string | null
      LongshirtReceivingDate: string | null
      LongshirtSize: string | null
      MobilePhone: string | null
      PantsReceivingDate: string | null
      PassportNumber: string | null
      ProfessionName: string | null
      ProfessionSecondName: string | null
      ProfessionThirdName: string | null
      ShoesNumber: string | null
      ShoesReceiveDate: string | null
      SizeOfPantes: string | null
      SizeOfshirt: string | null
      StartDate: string | null
      StatusName: string | null
      Street: string | null
      TshirReceivingDate: string | null
      briefingDate: string | null
      briefingExpireDate: string | null
      startInsuranceDate: string | null
    }, ExtArgs["result"]["employeesAccessTemp"]>
    composites: {}
  }

  type EmployeesAccessTempGetPayload<S extends boolean | null | undefined | EmployeesAccessTempDefaultArgs> = $Result.GetResult<Prisma.$EmployeesAccessTempPayload, S>

  type EmployeesAccessTempCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeesAccessTempFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeesAccessTempCountAggregateInputType | true
    }

  export interface EmployeesAccessTempDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeesAccessTemp'], meta: { name: 'EmployeesAccessTemp' } }
    /**
     * Find zero or one EmployeesAccessTemp that matches the filter.
     * @param {EmployeesAccessTempFindUniqueArgs} args - Arguments to find a EmployeesAccessTemp
     * @example
     * // Get one EmployeesAccessTemp
     * const employeesAccessTemp = await prisma.employeesAccessTemp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeesAccessTempFindUniqueArgs>(args: SelectSubset<T, EmployeesAccessTempFindUniqueArgs<ExtArgs>>): Prisma__EmployeesAccessTempClient<$Result.GetResult<Prisma.$EmployeesAccessTempPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeesAccessTemp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeesAccessTempFindUniqueOrThrowArgs} args - Arguments to find a EmployeesAccessTemp
     * @example
     * // Get one EmployeesAccessTemp
     * const employeesAccessTemp = await prisma.employeesAccessTemp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeesAccessTempFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeesAccessTempFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeesAccessTempClient<$Result.GetResult<Prisma.$EmployeesAccessTempPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeesAccessTemp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessTempFindFirstArgs} args - Arguments to find a EmployeesAccessTemp
     * @example
     * // Get one EmployeesAccessTemp
     * const employeesAccessTemp = await prisma.employeesAccessTemp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeesAccessTempFindFirstArgs>(args?: SelectSubset<T, EmployeesAccessTempFindFirstArgs<ExtArgs>>): Prisma__EmployeesAccessTempClient<$Result.GetResult<Prisma.$EmployeesAccessTempPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeesAccessTemp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessTempFindFirstOrThrowArgs} args - Arguments to find a EmployeesAccessTemp
     * @example
     * // Get one EmployeesAccessTemp
     * const employeesAccessTemp = await prisma.employeesAccessTemp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeesAccessTempFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeesAccessTempFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeesAccessTempClient<$Result.GetResult<Prisma.$EmployeesAccessTempPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeesAccessTemps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessTempFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeesAccessTemps
     * const employeesAccessTemps = await prisma.employeesAccessTemp.findMany()
     * 
     * // Get first 10 EmployeesAccessTemps
     * const employeesAccessTemps = await prisma.employeesAccessTemp.findMany({ take: 10 })
     * 
     * // Only select the `EmployeesAccessTempId`
     * const employeesAccessTempWithEmployeesAccessTempIdOnly = await prisma.employeesAccessTemp.findMany({ select: { EmployeesAccessTempId: true } })
     * 
     */
    findMany<T extends EmployeesAccessTempFindManyArgs>(args?: SelectSubset<T, EmployeesAccessTempFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesAccessTempPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeesAccessTemp.
     * @param {EmployeesAccessTempCreateArgs} args - Arguments to create a EmployeesAccessTemp.
     * @example
     * // Create one EmployeesAccessTemp
     * const EmployeesAccessTemp = await prisma.employeesAccessTemp.create({
     *   data: {
     *     // ... data to create a EmployeesAccessTemp
     *   }
     * })
     * 
     */
    create<T extends EmployeesAccessTempCreateArgs>(args: SelectSubset<T, EmployeesAccessTempCreateArgs<ExtArgs>>): Prisma__EmployeesAccessTempClient<$Result.GetResult<Prisma.$EmployeesAccessTempPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeesAccessTemps.
     * @param {EmployeesAccessTempCreateManyArgs} args - Arguments to create many EmployeesAccessTemps.
     * @example
     * // Create many EmployeesAccessTemps
     * const employeesAccessTemp = await prisma.employeesAccessTemp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeesAccessTempCreateManyArgs>(args?: SelectSubset<T, EmployeesAccessTempCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeesAccessTemp.
     * @param {EmployeesAccessTempDeleteArgs} args - Arguments to delete one EmployeesAccessTemp.
     * @example
     * // Delete one EmployeesAccessTemp
     * const EmployeesAccessTemp = await prisma.employeesAccessTemp.delete({
     *   where: {
     *     // ... filter to delete one EmployeesAccessTemp
     *   }
     * })
     * 
     */
    delete<T extends EmployeesAccessTempDeleteArgs>(args: SelectSubset<T, EmployeesAccessTempDeleteArgs<ExtArgs>>): Prisma__EmployeesAccessTempClient<$Result.GetResult<Prisma.$EmployeesAccessTempPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeesAccessTemp.
     * @param {EmployeesAccessTempUpdateArgs} args - Arguments to update one EmployeesAccessTemp.
     * @example
     * // Update one EmployeesAccessTemp
     * const employeesAccessTemp = await prisma.employeesAccessTemp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeesAccessTempUpdateArgs>(args: SelectSubset<T, EmployeesAccessTempUpdateArgs<ExtArgs>>): Prisma__EmployeesAccessTempClient<$Result.GetResult<Prisma.$EmployeesAccessTempPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeesAccessTemps.
     * @param {EmployeesAccessTempDeleteManyArgs} args - Arguments to filter EmployeesAccessTemps to delete.
     * @example
     * // Delete a few EmployeesAccessTemps
     * const { count } = await prisma.employeesAccessTemp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeesAccessTempDeleteManyArgs>(args?: SelectSubset<T, EmployeesAccessTempDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeesAccessTemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessTempUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeesAccessTemps
     * const employeesAccessTemp = await prisma.employeesAccessTemp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeesAccessTempUpdateManyArgs>(args: SelectSubset<T, EmployeesAccessTempUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeesAccessTemp.
     * @param {EmployeesAccessTempUpsertArgs} args - Arguments to update or create a EmployeesAccessTemp.
     * @example
     * // Update or create a EmployeesAccessTemp
     * const employeesAccessTemp = await prisma.employeesAccessTemp.upsert({
     *   create: {
     *     // ... data to create a EmployeesAccessTemp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeesAccessTemp we want to update
     *   }
     * })
     */
    upsert<T extends EmployeesAccessTempUpsertArgs>(args: SelectSubset<T, EmployeesAccessTempUpsertArgs<ExtArgs>>): Prisma__EmployeesAccessTempClient<$Result.GetResult<Prisma.$EmployeesAccessTempPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeesAccessTemps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessTempCountArgs} args - Arguments to filter EmployeesAccessTemps to count.
     * @example
     * // Count the number of EmployeesAccessTemps
     * const count = await prisma.employeesAccessTemp.count({
     *   where: {
     *     // ... the filter for the EmployeesAccessTemps we want to count
     *   }
     * })
    **/
    count<T extends EmployeesAccessTempCountArgs>(
      args?: Subset<T, EmployeesAccessTempCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeesAccessTempCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeesAccessTemp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessTempAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeesAccessTempAggregateArgs>(args: Subset<T, EmployeesAccessTempAggregateArgs>): Prisma.PrismaPromise<GetEmployeesAccessTempAggregateType<T>>

    /**
     * Group by EmployeesAccessTemp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAccessTempGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeesAccessTempGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeesAccessTempGroupByArgs['orderBy'] }
        : { orderBy?: EmployeesAccessTempGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeesAccessTempGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeesAccessTempGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeesAccessTemp model
   */
  readonly fields: EmployeesAccessTempFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeesAccessTemp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeesAccessTempClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeesAccessTemp model
   */ 
  interface EmployeesAccessTempFieldRefs {
    readonly EmployeesAccessTempId: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly CompanyGeneralCrmId: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly CreatedAt: FieldRef<"EmployeesAccessTemp", 'DateTime'>
    readonly AgentID: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly AreaMan: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly AppartmentNum: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly BirthDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly CityName: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly CoatReceivingDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly CoatSize: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly CountryID: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly CountryName: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly CourseAtatDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly CourseAtatExpireDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly CustomerName: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly CustomerStatus: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly CustomerID: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly EmployeeFirstName: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly EmployeeID: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly EmployeeLastName: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly EmployeeNumber: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly EndInsuranceDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly EntranceDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly HealthFund: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly HouseID: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly HouseNumber: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly InsuranceCompany: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly InsuranceNumber: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly InsuredNumber: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly IsCourseAtat: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly Isbriefing: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly LocalityName: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly LocalityCode: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly LocalityID: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly LongshirtReceivingDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly LongshirtSize: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly MobilePhone: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly PantsReceivingDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly PassportNumber: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly ProfessionName: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly ProfessionSecondName: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly ProfessionThirdName: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly ShoesNumber: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly ShoesReceiveDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly SizeOfPantes: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly SizeOfshirt: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly StartDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly StatusName: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly Street: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly TshirReceivingDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly briefingDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly briefingExpireDate: FieldRef<"EmployeesAccessTemp", 'String'>
    readonly startInsuranceDate: FieldRef<"EmployeesAccessTemp", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeesAccessTemp findUnique
   */
  export type EmployeesAccessTempFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessTemp
     */
    select?: EmployeesAccessTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessTemp to fetch.
     */
    where: EmployeesAccessTempWhereUniqueInput
  }

  /**
   * EmployeesAccessTemp findUniqueOrThrow
   */
  export type EmployeesAccessTempFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessTemp
     */
    select?: EmployeesAccessTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessTemp to fetch.
     */
    where: EmployeesAccessTempWhereUniqueInput
  }

  /**
   * EmployeesAccessTemp findFirst
   */
  export type EmployeesAccessTempFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessTemp
     */
    select?: EmployeesAccessTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessTemp to fetch.
     */
    where?: EmployeesAccessTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessTemps to fetch.
     */
    orderBy?: EmployeesAccessTempOrderByWithRelationInput | EmployeesAccessTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeesAccessTemps.
     */
    cursor?: EmployeesAccessTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeesAccessTemps.
     */
    distinct?: EmployeesAccessTempScalarFieldEnum | EmployeesAccessTempScalarFieldEnum[]
  }

  /**
   * EmployeesAccessTemp findFirstOrThrow
   */
  export type EmployeesAccessTempFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessTemp
     */
    select?: EmployeesAccessTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessTemp to fetch.
     */
    where?: EmployeesAccessTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessTemps to fetch.
     */
    orderBy?: EmployeesAccessTempOrderByWithRelationInput | EmployeesAccessTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeesAccessTemps.
     */
    cursor?: EmployeesAccessTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessTemps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeesAccessTemps.
     */
    distinct?: EmployeesAccessTempScalarFieldEnum | EmployeesAccessTempScalarFieldEnum[]
  }

  /**
   * EmployeesAccessTemp findMany
   */
  export type EmployeesAccessTempFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessTemp
     */
    select?: EmployeesAccessTempSelect<ExtArgs> | null
    /**
     * Filter, which EmployeesAccessTemps to fetch.
     */
    where?: EmployeesAccessTempWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeesAccessTemps to fetch.
     */
    orderBy?: EmployeesAccessTempOrderByWithRelationInput | EmployeesAccessTempOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeesAccessTemps.
     */
    cursor?: EmployeesAccessTempWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeesAccessTemps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeesAccessTemps.
     */
    skip?: number
    distinct?: EmployeesAccessTempScalarFieldEnum | EmployeesAccessTempScalarFieldEnum[]
  }

  /**
   * EmployeesAccessTemp create
   */
  export type EmployeesAccessTempCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessTemp
     */
    select?: EmployeesAccessTempSelect<ExtArgs> | null
    /**
     * The data needed to create a EmployeesAccessTemp.
     */
    data: XOR<EmployeesAccessTempCreateInput, EmployeesAccessTempUncheckedCreateInput>
  }

  /**
   * EmployeesAccessTemp createMany
   */
  export type EmployeesAccessTempCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeesAccessTemps.
     */
    data: EmployeesAccessTempCreateManyInput | EmployeesAccessTempCreateManyInput[]
  }

  /**
   * EmployeesAccessTemp update
   */
  export type EmployeesAccessTempUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessTemp
     */
    select?: EmployeesAccessTempSelect<ExtArgs> | null
    /**
     * The data needed to update a EmployeesAccessTemp.
     */
    data: XOR<EmployeesAccessTempUpdateInput, EmployeesAccessTempUncheckedUpdateInput>
    /**
     * Choose, which EmployeesAccessTemp to update.
     */
    where: EmployeesAccessTempWhereUniqueInput
  }

  /**
   * EmployeesAccessTemp updateMany
   */
  export type EmployeesAccessTempUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeesAccessTemps.
     */
    data: XOR<EmployeesAccessTempUpdateManyMutationInput, EmployeesAccessTempUncheckedUpdateManyInput>
    /**
     * Filter which EmployeesAccessTemps to update
     */
    where?: EmployeesAccessTempWhereInput
  }

  /**
   * EmployeesAccessTemp upsert
   */
  export type EmployeesAccessTempUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessTemp
     */
    select?: EmployeesAccessTempSelect<ExtArgs> | null
    /**
     * The filter to search for the EmployeesAccessTemp to update in case it exists.
     */
    where: EmployeesAccessTempWhereUniqueInput
    /**
     * In case the EmployeesAccessTemp found by the `where` argument doesn't exist, create a new EmployeesAccessTemp with this data.
     */
    create: XOR<EmployeesAccessTempCreateInput, EmployeesAccessTempUncheckedCreateInput>
    /**
     * In case the EmployeesAccessTemp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeesAccessTempUpdateInput, EmployeesAccessTempUncheckedUpdateInput>
  }

  /**
   * EmployeesAccessTemp delete
   */
  export type EmployeesAccessTempDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessTemp
     */
    select?: EmployeesAccessTempSelect<ExtArgs> | null
    /**
     * Filter which EmployeesAccessTemp to delete.
     */
    where: EmployeesAccessTempWhereUniqueInput
  }

  /**
   * EmployeesAccessTemp deleteMany
   */
  export type EmployeesAccessTempDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeesAccessTemps to delete
     */
    where?: EmployeesAccessTempWhereInput
  }

  /**
   * EmployeesAccessTemp without action
   */
  export type EmployeesAccessTempDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesAccessTemp
     */
    select?: EmployeesAccessTempSelect<ExtArgs> | null
  }


  /**
   * Model ErrorsPhpLogs
   */

  export type AggregateErrorsPhpLogs = {
    _count: ErrorsPhpLogsCountAggregateOutputType | null
    _avg: ErrorsPhpLogsAvgAggregateOutputType | null
    _sum: ErrorsPhpLogsSumAggregateOutputType | null
    _min: ErrorsPhpLogsMinAggregateOutputType | null
    _max: ErrorsPhpLogsMaxAggregateOutputType | null
  }

  export type ErrorsPhpLogsAvgAggregateOutputType = {
    ErrorsPhpLogsId: number | null
  }

  export type ErrorsPhpLogsSumAggregateOutputType = {
    ErrorsPhpLogsId: number | null
  }

  export type ErrorsPhpLogsMinAggregateOutputType = {
    ErrorsPhpLogsId: number | null
    CreatedAt: Date | null
    tokenData: string | null
    urlController: string | null
    sendData: string | null
    errorMessg: string | null
  }

  export type ErrorsPhpLogsMaxAggregateOutputType = {
    ErrorsPhpLogsId: number | null
    CreatedAt: Date | null
    tokenData: string | null
    urlController: string | null
    sendData: string | null
    errorMessg: string | null
  }

  export type ErrorsPhpLogsCountAggregateOutputType = {
    ErrorsPhpLogsId: number
    CreatedAt: number
    tokenData: number
    urlController: number
    sendData: number
    errorMessg: number
    _all: number
  }


  export type ErrorsPhpLogsAvgAggregateInputType = {
    ErrorsPhpLogsId?: true
  }

  export type ErrorsPhpLogsSumAggregateInputType = {
    ErrorsPhpLogsId?: true
  }

  export type ErrorsPhpLogsMinAggregateInputType = {
    ErrorsPhpLogsId?: true
    CreatedAt?: true
    tokenData?: true
    urlController?: true
    sendData?: true
    errorMessg?: true
  }

  export type ErrorsPhpLogsMaxAggregateInputType = {
    ErrorsPhpLogsId?: true
    CreatedAt?: true
    tokenData?: true
    urlController?: true
    sendData?: true
    errorMessg?: true
  }

  export type ErrorsPhpLogsCountAggregateInputType = {
    ErrorsPhpLogsId?: true
    CreatedAt?: true
    tokenData?: true
    urlController?: true
    sendData?: true
    errorMessg?: true
    _all?: true
  }

  export type ErrorsPhpLogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ErrorsPhpLogs to aggregate.
     */
    where?: ErrorsPhpLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorsPhpLogs to fetch.
     */
    orderBy?: ErrorsPhpLogsOrderByWithRelationInput | ErrorsPhpLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ErrorsPhpLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorsPhpLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorsPhpLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ErrorsPhpLogs
    **/
    _count?: true | ErrorsPhpLogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ErrorsPhpLogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ErrorsPhpLogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ErrorsPhpLogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ErrorsPhpLogsMaxAggregateInputType
  }

  export type GetErrorsPhpLogsAggregateType<T extends ErrorsPhpLogsAggregateArgs> = {
        [P in keyof T & keyof AggregateErrorsPhpLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateErrorsPhpLogs[P]>
      : GetScalarType<T[P], AggregateErrorsPhpLogs[P]>
  }




  export type ErrorsPhpLogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorsPhpLogsWhereInput
    orderBy?: ErrorsPhpLogsOrderByWithAggregationInput | ErrorsPhpLogsOrderByWithAggregationInput[]
    by: ErrorsPhpLogsScalarFieldEnum[] | ErrorsPhpLogsScalarFieldEnum
    having?: ErrorsPhpLogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ErrorsPhpLogsCountAggregateInputType | true
    _avg?: ErrorsPhpLogsAvgAggregateInputType
    _sum?: ErrorsPhpLogsSumAggregateInputType
    _min?: ErrorsPhpLogsMinAggregateInputType
    _max?: ErrorsPhpLogsMaxAggregateInputType
  }

  export type ErrorsPhpLogsGroupByOutputType = {
    ErrorsPhpLogsId: number
    CreatedAt: Date | null
    tokenData: string | null
    urlController: string | null
    sendData: string | null
    errorMessg: string | null
    _count: ErrorsPhpLogsCountAggregateOutputType | null
    _avg: ErrorsPhpLogsAvgAggregateOutputType | null
    _sum: ErrorsPhpLogsSumAggregateOutputType | null
    _min: ErrorsPhpLogsMinAggregateOutputType | null
    _max: ErrorsPhpLogsMaxAggregateOutputType | null
  }

  type GetErrorsPhpLogsGroupByPayload<T extends ErrorsPhpLogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ErrorsPhpLogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ErrorsPhpLogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ErrorsPhpLogsGroupByOutputType[P]>
            : GetScalarType<T[P], ErrorsPhpLogsGroupByOutputType[P]>
        }
      >
    >


  export type ErrorsPhpLogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ErrorsPhpLogsId?: boolean
    CreatedAt?: boolean
    tokenData?: boolean
    urlController?: boolean
    sendData?: boolean
    errorMessg?: boolean
  }, ExtArgs["result"]["errorsPhpLogs"]>


  export type ErrorsPhpLogsSelectScalar = {
    ErrorsPhpLogsId?: boolean
    CreatedAt?: boolean
    tokenData?: boolean
    urlController?: boolean
    sendData?: boolean
    errorMessg?: boolean
  }


  export type $ErrorsPhpLogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ErrorsPhpLogs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ErrorsPhpLogsId: number
      CreatedAt: Date | null
      tokenData: string | null
      urlController: string | null
      sendData: string | null
      errorMessg: string | null
    }, ExtArgs["result"]["errorsPhpLogs"]>
    composites: {}
  }

  type ErrorsPhpLogsGetPayload<S extends boolean | null | undefined | ErrorsPhpLogsDefaultArgs> = $Result.GetResult<Prisma.$ErrorsPhpLogsPayload, S>

  type ErrorsPhpLogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ErrorsPhpLogsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ErrorsPhpLogsCountAggregateInputType | true
    }

  export interface ErrorsPhpLogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ErrorsPhpLogs'], meta: { name: 'ErrorsPhpLogs' } }
    /**
     * Find zero or one ErrorsPhpLogs that matches the filter.
     * @param {ErrorsPhpLogsFindUniqueArgs} args - Arguments to find a ErrorsPhpLogs
     * @example
     * // Get one ErrorsPhpLogs
     * const errorsPhpLogs = await prisma.errorsPhpLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ErrorsPhpLogsFindUniqueArgs>(args: SelectSubset<T, ErrorsPhpLogsFindUniqueArgs<ExtArgs>>): Prisma__ErrorsPhpLogsClient<$Result.GetResult<Prisma.$ErrorsPhpLogsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ErrorsPhpLogs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ErrorsPhpLogsFindUniqueOrThrowArgs} args - Arguments to find a ErrorsPhpLogs
     * @example
     * // Get one ErrorsPhpLogs
     * const errorsPhpLogs = await prisma.errorsPhpLogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ErrorsPhpLogsFindUniqueOrThrowArgs>(args: SelectSubset<T, ErrorsPhpLogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ErrorsPhpLogsClient<$Result.GetResult<Prisma.$ErrorsPhpLogsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ErrorsPhpLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsPhpLogsFindFirstArgs} args - Arguments to find a ErrorsPhpLogs
     * @example
     * // Get one ErrorsPhpLogs
     * const errorsPhpLogs = await prisma.errorsPhpLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ErrorsPhpLogsFindFirstArgs>(args?: SelectSubset<T, ErrorsPhpLogsFindFirstArgs<ExtArgs>>): Prisma__ErrorsPhpLogsClient<$Result.GetResult<Prisma.$ErrorsPhpLogsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ErrorsPhpLogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsPhpLogsFindFirstOrThrowArgs} args - Arguments to find a ErrorsPhpLogs
     * @example
     * // Get one ErrorsPhpLogs
     * const errorsPhpLogs = await prisma.errorsPhpLogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ErrorsPhpLogsFindFirstOrThrowArgs>(args?: SelectSubset<T, ErrorsPhpLogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ErrorsPhpLogsClient<$Result.GetResult<Prisma.$ErrorsPhpLogsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ErrorsPhpLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsPhpLogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ErrorsPhpLogs
     * const errorsPhpLogs = await prisma.errorsPhpLogs.findMany()
     * 
     * // Get first 10 ErrorsPhpLogs
     * const errorsPhpLogs = await prisma.errorsPhpLogs.findMany({ take: 10 })
     * 
     * // Only select the `ErrorsPhpLogsId`
     * const errorsPhpLogsWithErrorsPhpLogsIdOnly = await prisma.errorsPhpLogs.findMany({ select: { ErrorsPhpLogsId: true } })
     * 
     */
    findMany<T extends ErrorsPhpLogsFindManyArgs>(args?: SelectSubset<T, ErrorsPhpLogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorsPhpLogsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ErrorsPhpLogs.
     * @param {ErrorsPhpLogsCreateArgs} args - Arguments to create a ErrorsPhpLogs.
     * @example
     * // Create one ErrorsPhpLogs
     * const ErrorsPhpLogs = await prisma.errorsPhpLogs.create({
     *   data: {
     *     // ... data to create a ErrorsPhpLogs
     *   }
     * })
     * 
     */
    create<T extends ErrorsPhpLogsCreateArgs>(args: SelectSubset<T, ErrorsPhpLogsCreateArgs<ExtArgs>>): Prisma__ErrorsPhpLogsClient<$Result.GetResult<Prisma.$ErrorsPhpLogsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ErrorsPhpLogs.
     * @param {ErrorsPhpLogsCreateManyArgs} args - Arguments to create many ErrorsPhpLogs.
     * @example
     * // Create many ErrorsPhpLogs
     * const errorsPhpLogs = await prisma.errorsPhpLogs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ErrorsPhpLogsCreateManyArgs>(args?: SelectSubset<T, ErrorsPhpLogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ErrorsPhpLogs.
     * @param {ErrorsPhpLogsDeleteArgs} args - Arguments to delete one ErrorsPhpLogs.
     * @example
     * // Delete one ErrorsPhpLogs
     * const ErrorsPhpLogs = await prisma.errorsPhpLogs.delete({
     *   where: {
     *     // ... filter to delete one ErrorsPhpLogs
     *   }
     * })
     * 
     */
    delete<T extends ErrorsPhpLogsDeleteArgs>(args: SelectSubset<T, ErrorsPhpLogsDeleteArgs<ExtArgs>>): Prisma__ErrorsPhpLogsClient<$Result.GetResult<Prisma.$ErrorsPhpLogsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ErrorsPhpLogs.
     * @param {ErrorsPhpLogsUpdateArgs} args - Arguments to update one ErrorsPhpLogs.
     * @example
     * // Update one ErrorsPhpLogs
     * const errorsPhpLogs = await prisma.errorsPhpLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ErrorsPhpLogsUpdateArgs>(args: SelectSubset<T, ErrorsPhpLogsUpdateArgs<ExtArgs>>): Prisma__ErrorsPhpLogsClient<$Result.GetResult<Prisma.$ErrorsPhpLogsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ErrorsPhpLogs.
     * @param {ErrorsPhpLogsDeleteManyArgs} args - Arguments to filter ErrorsPhpLogs to delete.
     * @example
     * // Delete a few ErrorsPhpLogs
     * const { count } = await prisma.errorsPhpLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ErrorsPhpLogsDeleteManyArgs>(args?: SelectSubset<T, ErrorsPhpLogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ErrorsPhpLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsPhpLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ErrorsPhpLogs
     * const errorsPhpLogs = await prisma.errorsPhpLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ErrorsPhpLogsUpdateManyArgs>(args: SelectSubset<T, ErrorsPhpLogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ErrorsPhpLogs.
     * @param {ErrorsPhpLogsUpsertArgs} args - Arguments to update or create a ErrorsPhpLogs.
     * @example
     * // Update or create a ErrorsPhpLogs
     * const errorsPhpLogs = await prisma.errorsPhpLogs.upsert({
     *   create: {
     *     // ... data to create a ErrorsPhpLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ErrorsPhpLogs we want to update
     *   }
     * })
     */
    upsert<T extends ErrorsPhpLogsUpsertArgs>(args: SelectSubset<T, ErrorsPhpLogsUpsertArgs<ExtArgs>>): Prisma__ErrorsPhpLogsClient<$Result.GetResult<Prisma.$ErrorsPhpLogsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ErrorsPhpLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsPhpLogsCountArgs} args - Arguments to filter ErrorsPhpLogs to count.
     * @example
     * // Count the number of ErrorsPhpLogs
     * const count = await prisma.errorsPhpLogs.count({
     *   where: {
     *     // ... the filter for the ErrorsPhpLogs we want to count
     *   }
     * })
    **/
    count<T extends ErrorsPhpLogsCountArgs>(
      args?: Subset<T, ErrorsPhpLogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ErrorsPhpLogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ErrorsPhpLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsPhpLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ErrorsPhpLogsAggregateArgs>(args: Subset<T, ErrorsPhpLogsAggregateArgs>): Prisma.PrismaPromise<GetErrorsPhpLogsAggregateType<T>>

    /**
     * Group by ErrorsPhpLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorsPhpLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ErrorsPhpLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ErrorsPhpLogsGroupByArgs['orderBy'] }
        : { orderBy?: ErrorsPhpLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ErrorsPhpLogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetErrorsPhpLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ErrorsPhpLogs model
   */
  readonly fields: ErrorsPhpLogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ErrorsPhpLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ErrorsPhpLogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ErrorsPhpLogs model
   */ 
  interface ErrorsPhpLogsFieldRefs {
    readonly ErrorsPhpLogsId: FieldRef<"ErrorsPhpLogs", 'Int'>
    readonly CreatedAt: FieldRef<"ErrorsPhpLogs", 'DateTime'>
    readonly tokenData: FieldRef<"ErrorsPhpLogs", 'String'>
    readonly urlController: FieldRef<"ErrorsPhpLogs", 'String'>
    readonly sendData: FieldRef<"ErrorsPhpLogs", 'String'>
    readonly errorMessg: FieldRef<"ErrorsPhpLogs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ErrorsPhpLogs findUnique
   */
  export type ErrorsPhpLogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorsPhpLogs
     */
    select?: ErrorsPhpLogsSelect<ExtArgs> | null
    /**
     * Filter, which ErrorsPhpLogs to fetch.
     */
    where: ErrorsPhpLogsWhereUniqueInput
  }

  /**
   * ErrorsPhpLogs findUniqueOrThrow
   */
  export type ErrorsPhpLogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorsPhpLogs
     */
    select?: ErrorsPhpLogsSelect<ExtArgs> | null
    /**
     * Filter, which ErrorsPhpLogs to fetch.
     */
    where: ErrorsPhpLogsWhereUniqueInput
  }

  /**
   * ErrorsPhpLogs findFirst
   */
  export type ErrorsPhpLogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorsPhpLogs
     */
    select?: ErrorsPhpLogsSelect<ExtArgs> | null
    /**
     * Filter, which ErrorsPhpLogs to fetch.
     */
    where?: ErrorsPhpLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorsPhpLogs to fetch.
     */
    orderBy?: ErrorsPhpLogsOrderByWithRelationInput | ErrorsPhpLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ErrorsPhpLogs.
     */
    cursor?: ErrorsPhpLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorsPhpLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorsPhpLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ErrorsPhpLogs.
     */
    distinct?: ErrorsPhpLogsScalarFieldEnum | ErrorsPhpLogsScalarFieldEnum[]
  }

  /**
   * ErrorsPhpLogs findFirstOrThrow
   */
  export type ErrorsPhpLogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorsPhpLogs
     */
    select?: ErrorsPhpLogsSelect<ExtArgs> | null
    /**
     * Filter, which ErrorsPhpLogs to fetch.
     */
    where?: ErrorsPhpLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorsPhpLogs to fetch.
     */
    orderBy?: ErrorsPhpLogsOrderByWithRelationInput | ErrorsPhpLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ErrorsPhpLogs.
     */
    cursor?: ErrorsPhpLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorsPhpLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorsPhpLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ErrorsPhpLogs.
     */
    distinct?: ErrorsPhpLogsScalarFieldEnum | ErrorsPhpLogsScalarFieldEnum[]
  }

  /**
   * ErrorsPhpLogs findMany
   */
  export type ErrorsPhpLogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorsPhpLogs
     */
    select?: ErrorsPhpLogsSelect<ExtArgs> | null
    /**
     * Filter, which ErrorsPhpLogs to fetch.
     */
    where?: ErrorsPhpLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorsPhpLogs to fetch.
     */
    orderBy?: ErrorsPhpLogsOrderByWithRelationInput | ErrorsPhpLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ErrorsPhpLogs.
     */
    cursor?: ErrorsPhpLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorsPhpLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorsPhpLogs.
     */
    skip?: number
    distinct?: ErrorsPhpLogsScalarFieldEnum | ErrorsPhpLogsScalarFieldEnum[]
  }

  /**
   * ErrorsPhpLogs create
   */
  export type ErrorsPhpLogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorsPhpLogs
     */
    select?: ErrorsPhpLogsSelect<ExtArgs> | null
    /**
     * The data needed to create a ErrorsPhpLogs.
     */
    data?: XOR<ErrorsPhpLogsCreateInput, ErrorsPhpLogsUncheckedCreateInput>
  }

  /**
   * ErrorsPhpLogs createMany
   */
  export type ErrorsPhpLogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ErrorsPhpLogs.
     */
    data: ErrorsPhpLogsCreateManyInput | ErrorsPhpLogsCreateManyInput[]
  }

  /**
   * ErrorsPhpLogs update
   */
  export type ErrorsPhpLogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorsPhpLogs
     */
    select?: ErrorsPhpLogsSelect<ExtArgs> | null
    /**
     * The data needed to update a ErrorsPhpLogs.
     */
    data: XOR<ErrorsPhpLogsUpdateInput, ErrorsPhpLogsUncheckedUpdateInput>
    /**
     * Choose, which ErrorsPhpLogs to update.
     */
    where: ErrorsPhpLogsWhereUniqueInput
  }

  /**
   * ErrorsPhpLogs updateMany
   */
  export type ErrorsPhpLogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ErrorsPhpLogs.
     */
    data: XOR<ErrorsPhpLogsUpdateManyMutationInput, ErrorsPhpLogsUncheckedUpdateManyInput>
    /**
     * Filter which ErrorsPhpLogs to update
     */
    where?: ErrorsPhpLogsWhereInput
  }

  /**
   * ErrorsPhpLogs upsert
   */
  export type ErrorsPhpLogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorsPhpLogs
     */
    select?: ErrorsPhpLogsSelect<ExtArgs> | null
    /**
     * The filter to search for the ErrorsPhpLogs to update in case it exists.
     */
    where: ErrorsPhpLogsWhereUniqueInput
    /**
     * In case the ErrorsPhpLogs found by the `where` argument doesn't exist, create a new ErrorsPhpLogs with this data.
     */
    create: XOR<ErrorsPhpLogsCreateInput, ErrorsPhpLogsUncheckedCreateInput>
    /**
     * In case the ErrorsPhpLogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ErrorsPhpLogsUpdateInput, ErrorsPhpLogsUncheckedUpdateInput>
  }

  /**
   * ErrorsPhpLogs delete
   */
  export type ErrorsPhpLogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorsPhpLogs
     */
    select?: ErrorsPhpLogsSelect<ExtArgs> | null
    /**
     * Filter which ErrorsPhpLogs to delete.
     */
    where: ErrorsPhpLogsWhereUniqueInput
  }

  /**
   * ErrorsPhpLogs deleteMany
   */
  export type ErrorsPhpLogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ErrorsPhpLogs to delete
     */
    where?: ErrorsPhpLogsWhereInput
  }

  /**
   * ErrorsPhpLogs without action
   */
  export type ErrorsPhpLogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorsPhpLogs
     */
    select?: ErrorsPhpLogsSelect<ExtArgs> | null
  }


  /**
   * Model Lkup_ActionType
   */

  export type AggregateLkup_ActionType = {
    _count: Lkup_ActionTypeCountAggregateOutputType | null
    _avg: Lkup_ActionTypeAvgAggregateOutputType | null
    _sum: Lkup_ActionTypeSumAggregateOutputType | null
    _min: Lkup_ActionTypeMinAggregateOutputType | null
    _max: Lkup_ActionTypeMaxAggregateOutputType | null
  }

  export type Lkup_ActionTypeAvgAggregateOutputType = {
    ActionTypeID: number | null
    IsIgnoreHours: number | null
  }

  export type Lkup_ActionTypeSumAggregateOutputType = {
    ActionTypeID: number | null
    IsIgnoreHours: number | null
  }

  export type Lkup_ActionTypeMinAggregateOutputType = {
    ActionTypeID: number | null
    ActionType: string | null
    IsIgnoreHours: number | null
  }

  export type Lkup_ActionTypeMaxAggregateOutputType = {
    ActionTypeID: number | null
    ActionType: string | null
    IsIgnoreHours: number | null
  }

  export type Lkup_ActionTypeCountAggregateOutputType = {
    ActionTypeID: number
    ActionType: number
    IsIgnoreHours: number
    _all: number
  }


  export type Lkup_ActionTypeAvgAggregateInputType = {
    ActionTypeID?: true
    IsIgnoreHours?: true
  }

  export type Lkup_ActionTypeSumAggregateInputType = {
    ActionTypeID?: true
    IsIgnoreHours?: true
  }

  export type Lkup_ActionTypeMinAggregateInputType = {
    ActionTypeID?: true
    ActionType?: true
    IsIgnoreHours?: true
  }

  export type Lkup_ActionTypeMaxAggregateInputType = {
    ActionTypeID?: true
    ActionType?: true
    IsIgnoreHours?: true
  }

  export type Lkup_ActionTypeCountAggregateInputType = {
    ActionTypeID?: true
    ActionType?: true
    IsIgnoreHours?: true
    _all?: true
  }

  export type Lkup_ActionTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_ActionType to aggregate.
     */
    where?: Lkup_ActionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_ActionTypes to fetch.
     */
    orderBy?: Lkup_ActionTypeOrderByWithRelationInput | Lkup_ActionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Lkup_ActionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_ActionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_ActionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lkup_ActionTypes
    **/
    _count?: true | Lkup_ActionTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lkup_ActionTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lkup_ActionTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lkup_ActionTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lkup_ActionTypeMaxAggregateInputType
  }

  export type GetLkup_ActionTypeAggregateType<T extends Lkup_ActionTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLkup_ActionType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLkup_ActionType[P]>
      : GetScalarType<T[P], AggregateLkup_ActionType[P]>
  }




  export type Lkup_ActionTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Lkup_ActionTypeWhereInput
    orderBy?: Lkup_ActionTypeOrderByWithAggregationInput | Lkup_ActionTypeOrderByWithAggregationInput[]
    by: Lkup_ActionTypeScalarFieldEnum[] | Lkup_ActionTypeScalarFieldEnum
    having?: Lkup_ActionTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lkup_ActionTypeCountAggregateInputType | true
    _avg?: Lkup_ActionTypeAvgAggregateInputType
    _sum?: Lkup_ActionTypeSumAggregateInputType
    _min?: Lkup_ActionTypeMinAggregateInputType
    _max?: Lkup_ActionTypeMaxAggregateInputType
  }

  export type Lkup_ActionTypeGroupByOutputType = {
    ActionTypeID: number
    ActionType: string | null
    IsIgnoreHours: number | null
    _count: Lkup_ActionTypeCountAggregateOutputType | null
    _avg: Lkup_ActionTypeAvgAggregateOutputType | null
    _sum: Lkup_ActionTypeSumAggregateOutputType | null
    _min: Lkup_ActionTypeMinAggregateOutputType | null
    _max: Lkup_ActionTypeMaxAggregateOutputType | null
  }

  type GetLkup_ActionTypeGroupByPayload<T extends Lkup_ActionTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lkup_ActionTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lkup_ActionTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lkup_ActionTypeGroupByOutputType[P]>
            : GetScalarType<T[P], Lkup_ActionTypeGroupByOutputType[P]>
        }
      >
    >


  export type Lkup_ActionTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ActionTypeID?: boolean
    ActionType?: boolean
    IsIgnoreHours?: boolean
    EmployeeHours?: boolean | Lkup_ActionType$EmployeeHoursArgs<ExtArgs>
    EmployeeHoursByLocalityTotalsActionType?: boolean | Lkup_ActionType$EmployeeHoursByLocalityTotalsActionTypeArgs<ExtArgs>
    _count?: boolean | Lkup_ActionTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lkup_ActionType"]>


  export type Lkup_ActionTypeSelectScalar = {
    ActionTypeID?: boolean
    ActionType?: boolean
    IsIgnoreHours?: boolean
  }

  export type Lkup_ActionTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeHours?: boolean | Lkup_ActionType$EmployeeHoursArgs<ExtArgs>
    EmployeeHoursByLocalityTotalsActionType?: boolean | Lkup_ActionType$EmployeeHoursByLocalityTotalsActionTypeArgs<ExtArgs>
    _count?: boolean | Lkup_ActionTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Lkup_ActionTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lkup_ActionType"
    objects: {
      EmployeeHours: Prisma.$EmployeeHoursPayload<ExtArgs>[]
      EmployeeHoursByLocalityTotalsActionType: Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ActionTypeID: number
      ActionType: string | null
      IsIgnoreHours: number | null
    }, ExtArgs["result"]["lkup_ActionType"]>
    composites: {}
  }

  type Lkup_ActionTypeGetPayload<S extends boolean | null | undefined | Lkup_ActionTypeDefaultArgs> = $Result.GetResult<Prisma.$Lkup_ActionTypePayload, S>

  type Lkup_ActionTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Lkup_ActionTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lkup_ActionTypeCountAggregateInputType | true
    }

  export interface Lkup_ActionTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lkup_ActionType'], meta: { name: 'Lkup_ActionType' } }
    /**
     * Find zero or one Lkup_ActionType that matches the filter.
     * @param {Lkup_ActionTypeFindUniqueArgs} args - Arguments to find a Lkup_ActionType
     * @example
     * // Get one Lkup_ActionType
     * const lkup_ActionType = await prisma.lkup_ActionType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Lkup_ActionTypeFindUniqueArgs>(args: SelectSubset<T, Lkup_ActionTypeFindUniqueArgs<ExtArgs>>): Prisma__Lkup_ActionTypeClient<$Result.GetResult<Prisma.$Lkup_ActionTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lkup_ActionType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Lkup_ActionTypeFindUniqueOrThrowArgs} args - Arguments to find a Lkup_ActionType
     * @example
     * // Get one Lkup_ActionType
     * const lkup_ActionType = await prisma.lkup_ActionType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Lkup_ActionTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, Lkup_ActionTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Lkup_ActionTypeClient<$Result.GetResult<Prisma.$Lkup_ActionTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lkup_ActionType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_ActionTypeFindFirstArgs} args - Arguments to find a Lkup_ActionType
     * @example
     * // Get one Lkup_ActionType
     * const lkup_ActionType = await prisma.lkup_ActionType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Lkup_ActionTypeFindFirstArgs>(args?: SelectSubset<T, Lkup_ActionTypeFindFirstArgs<ExtArgs>>): Prisma__Lkup_ActionTypeClient<$Result.GetResult<Prisma.$Lkup_ActionTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lkup_ActionType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_ActionTypeFindFirstOrThrowArgs} args - Arguments to find a Lkup_ActionType
     * @example
     * // Get one Lkup_ActionType
     * const lkup_ActionType = await prisma.lkup_ActionType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Lkup_ActionTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, Lkup_ActionTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__Lkup_ActionTypeClient<$Result.GetResult<Prisma.$Lkup_ActionTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lkup_ActionTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_ActionTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lkup_ActionTypes
     * const lkup_ActionTypes = await prisma.lkup_ActionType.findMany()
     * 
     * // Get first 10 Lkup_ActionTypes
     * const lkup_ActionTypes = await prisma.lkup_ActionType.findMany({ take: 10 })
     * 
     * // Only select the `ActionTypeID`
     * const lkup_ActionTypeWithActionTypeIDOnly = await prisma.lkup_ActionType.findMany({ select: { ActionTypeID: true } })
     * 
     */
    findMany<T extends Lkup_ActionTypeFindManyArgs>(args?: SelectSubset<T, Lkup_ActionTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Lkup_ActionTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lkup_ActionType.
     * @param {Lkup_ActionTypeCreateArgs} args - Arguments to create a Lkup_ActionType.
     * @example
     * // Create one Lkup_ActionType
     * const Lkup_ActionType = await prisma.lkup_ActionType.create({
     *   data: {
     *     // ... data to create a Lkup_ActionType
     *   }
     * })
     * 
     */
    create<T extends Lkup_ActionTypeCreateArgs>(args: SelectSubset<T, Lkup_ActionTypeCreateArgs<ExtArgs>>): Prisma__Lkup_ActionTypeClient<$Result.GetResult<Prisma.$Lkup_ActionTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lkup_ActionTypes.
     * @param {Lkup_ActionTypeCreateManyArgs} args - Arguments to create many Lkup_ActionTypes.
     * @example
     * // Create many Lkup_ActionTypes
     * const lkup_ActionType = await prisma.lkup_ActionType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Lkup_ActionTypeCreateManyArgs>(args?: SelectSubset<T, Lkup_ActionTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lkup_ActionType.
     * @param {Lkup_ActionTypeDeleteArgs} args - Arguments to delete one Lkup_ActionType.
     * @example
     * // Delete one Lkup_ActionType
     * const Lkup_ActionType = await prisma.lkup_ActionType.delete({
     *   where: {
     *     // ... filter to delete one Lkup_ActionType
     *   }
     * })
     * 
     */
    delete<T extends Lkup_ActionTypeDeleteArgs>(args: SelectSubset<T, Lkup_ActionTypeDeleteArgs<ExtArgs>>): Prisma__Lkup_ActionTypeClient<$Result.GetResult<Prisma.$Lkup_ActionTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lkup_ActionType.
     * @param {Lkup_ActionTypeUpdateArgs} args - Arguments to update one Lkup_ActionType.
     * @example
     * // Update one Lkup_ActionType
     * const lkup_ActionType = await prisma.lkup_ActionType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Lkup_ActionTypeUpdateArgs>(args: SelectSubset<T, Lkup_ActionTypeUpdateArgs<ExtArgs>>): Prisma__Lkup_ActionTypeClient<$Result.GetResult<Prisma.$Lkup_ActionTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lkup_ActionTypes.
     * @param {Lkup_ActionTypeDeleteManyArgs} args - Arguments to filter Lkup_ActionTypes to delete.
     * @example
     * // Delete a few Lkup_ActionTypes
     * const { count } = await prisma.lkup_ActionType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Lkup_ActionTypeDeleteManyArgs>(args?: SelectSubset<T, Lkup_ActionTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lkup_ActionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_ActionTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lkup_ActionTypes
     * const lkup_ActionType = await prisma.lkup_ActionType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Lkup_ActionTypeUpdateManyArgs>(args: SelectSubset<T, Lkup_ActionTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lkup_ActionType.
     * @param {Lkup_ActionTypeUpsertArgs} args - Arguments to update or create a Lkup_ActionType.
     * @example
     * // Update or create a Lkup_ActionType
     * const lkup_ActionType = await prisma.lkup_ActionType.upsert({
     *   create: {
     *     // ... data to create a Lkup_ActionType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lkup_ActionType we want to update
     *   }
     * })
     */
    upsert<T extends Lkup_ActionTypeUpsertArgs>(args: SelectSubset<T, Lkup_ActionTypeUpsertArgs<ExtArgs>>): Prisma__Lkup_ActionTypeClient<$Result.GetResult<Prisma.$Lkup_ActionTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lkup_ActionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_ActionTypeCountArgs} args - Arguments to filter Lkup_ActionTypes to count.
     * @example
     * // Count the number of Lkup_ActionTypes
     * const count = await prisma.lkup_ActionType.count({
     *   where: {
     *     // ... the filter for the Lkup_ActionTypes we want to count
     *   }
     * })
    **/
    count<T extends Lkup_ActionTypeCountArgs>(
      args?: Subset<T, Lkup_ActionTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lkup_ActionTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lkup_ActionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_ActionTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lkup_ActionTypeAggregateArgs>(args: Subset<T, Lkup_ActionTypeAggregateArgs>): Prisma.PrismaPromise<GetLkup_ActionTypeAggregateType<T>>

    /**
     * Group by Lkup_ActionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lkup_ActionTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lkup_ActionTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lkup_ActionTypeGroupByArgs['orderBy'] }
        : { orderBy?: Lkup_ActionTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lkup_ActionTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLkup_ActionTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lkup_ActionType model
   */
  readonly fields: Lkup_ActionTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lkup_ActionType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Lkup_ActionTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EmployeeHours<T extends Lkup_ActionType$EmployeeHoursArgs<ExtArgs> = {}>(args?: Subset<T, Lkup_ActionType$EmployeeHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursPayload<ExtArgs>, T, "findMany"> | Null>
    EmployeeHoursByLocalityTotalsActionType<T extends Lkup_ActionType$EmployeeHoursByLocalityTotalsActionTypeArgs<ExtArgs> = {}>(args?: Subset<T, Lkup_ActionType$EmployeeHoursByLocalityTotalsActionTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeHoursByLocalityTotalsActionTypePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lkup_ActionType model
   */ 
  interface Lkup_ActionTypeFieldRefs {
    readonly ActionTypeID: FieldRef<"Lkup_ActionType", 'Int'>
    readonly ActionType: FieldRef<"Lkup_ActionType", 'String'>
    readonly IsIgnoreHours: FieldRef<"Lkup_ActionType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Lkup_ActionType findUnique
   */
  export type Lkup_ActionTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_ActionType
     */
    select?: Lkup_ActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Lkup_ActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which Lkup_ActionType to fetch.
     */
    where: Lkup_ActionTypeWhereUniqueInput
  }

  /**
   * Lkup_ActionType findUniqueOrThrow
   */
  export type Lkup_ActionTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_ActionType
     */
    select?: Lkup_ActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Lkup_ActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which Lkup_ActionType to fetch.
     */
    where: Lkup_ActionTypeWhereUniqueInput
  }

  /**
   * Lkup_ActionType findFirst
   */
  export type Lkup_ActionTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_ActionType
     */
    select?: Lkup_ActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Lkup_ActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which Lkup_ActionType to fetch.
     */
    where?: Lkup_ActionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_ActionTypes to fetch.
     */
    orderBy?: Lkup_ActionTypeOrderByWithRelationInput | Lkup_ActionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_ActionTypes.
     */
    cursor?: Lkup_ActionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_ActionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_ActionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_ActionTypes.
     */
    distinct?: Lkup_ActionTypeScalarFieldEnum | Lkup_ActionTypeScalarFieldEnum[]
  }

  /**
   * Lkup_ActionType findFirstOrThrow
   */
  export type Lkup_ActionTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_ActionType
     */
    select?: Lkup_ActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Lkup_ActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which Lkup_ActionType to fetch.
     */
    where?: Lkup_ActionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_ActionTypes to fetch.
     */
    orderBy?: Lkup_ActionTypeOrderByWithRelationInput | Lkup_ActionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lkup_ActionTypes.
     */
    cursor?: Lkup_ActionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_ActionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_ActionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lkup_ActionTypes.
     */
    distinct?: Lkup_ActionTypeScalarFieldEnum | Lkup_ActionTypeScalarFieldEnum[]
  }

  /**
   * Lkup_ActionType findMany
   */
  export type Lkup_ActionTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_ActionType
     */
    select?: Lkup_ActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Lkup_ActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which Lkup_ActionTypes to fetch.
     */
    where?: Lkup_ActionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lkup_ActionTypes to fetch.
     */
    orderBy?: Lkup_ActionTypeOrderByWithRelationInput | Lkup_ActionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lkup_ActionTypes.
     */
    cursor?: Lkup_ActionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lkup_ActionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lkup_ActionTypes.
     */
    skip?: number
    distinct?: Lkup_ActionTypeScalarFieldEnum | Lkup_ActionTypeScalarFieldEnum[]
  }

  /**
   * Lkup_ActionType create
   */
  export type Lkup_ActionTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_ActionType
     */
    select?: Lkup_ActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Lkup_ActionTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a Lkup_ActionType.
     */
    data?: XOR<Lkup_ActionTypeCreateInput, Lkup_ActionTypeUncheckedCreateInput>
  }

  /**
   * Lkup_ActionType createMany
   */
  export type Lkup_ActionTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lkup_ActionTypes.
     */
    data: Lkup_ActionTypeCreateManyInput | Lkup_ActionTypeCreateManyInput[]
  }

  /**
   * Lkup_ActionType update
   */
  export type Lkup_ActionTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_ActionType
     */
    select?: Lkup_ActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Lkup_ActionTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a Lkup_ActionType.
     */
    data: XOR<Lkup_ActionTypeUpdateInput, Lkup_ActionTypeUncheckedUpdateInput>
    /**
     * Choose, which Lkup_ActionType to update.
     */
    where: Lkup_ActionTypeWhereUniqueInput
  }

  /**
   * Lkup_ActionType updateMany
   */
  export type Lkup_ActionTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lkup_ActionTypes.
     */
    data: XOR<Lkup_ActionTypeUpdateManyMutationInput, Lkup_ActionTypeUncheckedUpdateManyInput>
    /**
     * Filter which Lkup_ActionTypes to update
     */
    where?: Lkup_ActionTypeWhereInput
  }

  /**
   * Lkup_ActionType upsert
   */
  export type Lkup_ActionTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_ActionType
     */
    select?: Lkup_ActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Lkup_ActionTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the Lkup_ActionType to update in case it exists.
     */
    where: Lkup_ActionTypeWhereUniqueInput
    /**
     * In case the Lkup_ActionType found by the `where` argument doesn't exist, create a new Lkup_ActionType with this data.
     */
    create: XOR<Lkup_ActionTypeCreateInput, Lkup_ActionTypeUncheckedCreateInput>
    /**
     * In case the Lkup_ActionType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Lkup_ActionTypeUpdateInput, Lkup_ActionTypeUncheckedUpdateInput>
  }

  /**
   * Lkup_ActionType delete
   */
  export type Lkup_ActionTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_ActionType
     */
    select?: Lkup_ActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Lkup_ActionTypeInclude<ExtArgs> | null
    /**
     * Filter which Lkup_ActionType to delete.
     */
    where: Lkup_ActionTypeWhereUniqueInput
  }

  /**
   * Lkup_ActionType deleteMany
   */
  export type Lkup_ActionTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lkup_ActionTypes to delete
     */
    where?: Lkup_ActionTypeWhereInput
  }

  /**
   * Lkup_ActionType.EmployeeHours
   */
  export type Lkup_ActionType$EmployeeHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHours
     */
    select?: EmployeeHoursSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursInclude<ExtArgs> | null
    where?: EmployeeHoursWhereInput
    orderBy?: EmployeeHoursOrderByWithRelationInput | EmployeeHoursOrderByWithRelationInput[]
    cursor?: EmployeeHoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeHoursScalarFieldEnum | EmployeeHoursScalarFieldEnum[]
  }

  /**
   * Lkup_ActionType.EmployeeHoursByLocalityTotalsActionType
   */
  export type Lkup_ActionType$EmployeeHoursByLocalityTotalsActionTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeHoursByLocalityTotalsActionType
     */
    select?: EmployeeHoursByLocalityTotalsActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeHoursByLocalityTotalsActionTypeInclude<ExtArgs> | null
    where?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
    orderBy?: EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput | EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput[]
    cursor?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum | EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum[]
  }

  /**
   * Lkup_ActionType without action
   */
  export type Lkup_ActionTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lkup_ActionType
     */
    select?: Lkup_ActionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Lkup_ActionTypeInclude<ExtArgs> | null
  }


  /**
   * Model LogEnterEmployee
   */

  export type AggregateLogEnterEmployee = {
    _count: LogEnterEmployeeCountAggregateOutputType | null
    _avg: LogEnterEmployeeAvgAggregateOutputType | null
    _sum: LogEnterEmployeeSumAggregateOutputType | null
    _min: LogEnterEmployeeMinAggregateOutputType | null
    _max: LogEnterEmployeeMaxAggregateOutputType | null
  }

  export type LogEnterEmployeeAvgAggregateOutputType = {
    LogEnterEmployee: number | null
    EmployeeID: number | null
  }

  export type LogEnterEmployeeSumAggregateOutputType = {
    LogEnterEmployee: number | null
    EmployeeID: number | null
  }

  export type LogEnterEmployeeMinAggregateOutputType = {
    LogEnterEmployee: number | null
    UserID: string | null
    CompanyID: string | null
    EmployeeID: number | null
    CreatedAt: Date | null
    ResultsData: string | null
  }

  export type LogEnterEmployeeMaxAggregateOutputType = {
    LogEnterEmployee: number | null
    UserID: string | null
    CompanyID: string | null
    EmployeeID: number | null
    CreatedAt: Date | null
    ResultsData: string | null
  }

  export type LogEnterEmployeeCountAggregateOutputType = {
    LogEnterEmployee: number
    UserID: number
    CompanyID: number
    EmployeeID: number
    CreatedAt: number
    ResultsData: number
    _all: number
  }


  export type LogEnterEmployeeAvgAggregateInputType = {
    LogEnterEmployee?: true
    EmployeeID?: true
  }

  export type LogEnterEmployeeSumAggregateInputType = {
    LogEnterEmployee?: true
    EmployeeID?: true
  }

  export type LogEnterEmployeeMinAggregateInputType = {
    LogEnterEmployee?: true
    UserID?: true
    CompanyID?: true
    EmployeeID?: true
    CreatedAt?: true
    ResultsData?: true
  }

  export type LogEnterEmployeeMaxAggregateInputType = {
    LogEnterEmployee?: true
    UserID?: true
    CompanyID?: true
    EmployeeID?: true
    CreatedAt?: true
    ResultsData?: true
  }

  export type LogEnterEmployeeCountAggregateInputType = {
    LogEnterEmployee?: true
    UserID?: true
    CompanyID?: true
    EmployeeID?: true
    CreatedAt?: true
    ResultsData?: true
    _all?: true
  }

  export type LogEnterEmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogEnterEmployee to aggregate.
     */
    where?: LogEnterEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEnterEmployees to fetch.
     */
    orderBy?: LogEnterEmployeeOrderByWithRelationInput | LogEnterEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogEnterEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEnterEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEnterEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogEnterEmployees
    **/
    _count?: true | LogEnterEmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogEnterEmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogEnterEmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogEnterEmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogEnterEmployeeMaxAggregateInputType
  }

  export type GetLogEnterEmployeeAggregateType<T extends LogEnterEmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateLogEnterEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogEnterEmployee[P]>
      : GetScalarType<T[P], AggregateLogEnterEmployee[P]>
  }




  export type LogEnterEmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogEnterEmployeeWhereInput
    orderBy?: LogEnterEmployeeOrderByWithAggregationInput | LogEnterEmployeeOrderByWithAggregationInput[]
    by: LogEnterEmployeeScalarFieldEnum[] | LogEnterEmployeeScalarFieldEnum
    having?: LogEnterEmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogEnterEmployeeCountAggregateInputType | true
    _avg?: LogEnterEmployeeAvgAggregateInputType
    _sum?: LogEnterEmployeeSumAggregateInputType
    _min?: LogEnterEmployeeMinAggregateInputType
    _max?: LogEnterEmployeeMaxAggregateInputType
  }

  export type LogEnterEmployeeGroupByOutputType = {
    LogEnterEmployee: number
    UserID: string
    CompanyID: string
    EmployeeID: number
    CreatedAt: Date | null
    ResultsData: string | null
    _count: LogEnterEmployeeCountAggregateOutputType | null
    _avg: LogEnterEmployeeAvgAggregateOutputType | null
    _sum: LogEnterEmployeeSumAggregateOutputType | null
    _min: LogEnterEmployeeMinAggregateOutputType | null
    _max: LogEnterEmployeeMaxAggregateOutputType | null
  }

  type GetLogEnterEmployeeGroupByPayload<T extends LogEnterEmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogEnterEmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogEnterEmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogEnterEmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], LogEnterEmployeeGroupByOutputType[P]>
        }
      >
    >


  export type LogEnterEmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LogEnterEmployee?: boolean
    UserID?: boolean
    CompanyID?: boolean
    EmployeeID?: boolean
    CreatedAt?: boolean
    ResultsData?: boolean
  }, ExtArgs["result"]["logEnterEmployee"]>


  export type LogEnterEmployeeSelectScalar = {
    LogEnterEmployee?: boolean
    UserID?: boolean
    CompanyID?: boolean
    EmployeeID?: boolean
    CreatedAt?: boolean
    ResultsData?: boolean
  }


  export type $LogEnterEmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogEnterEmployee"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      LogEnterEmployee: number
      UserID: string
      CompanyID: string
      EmployeeID: number
      CreatedAt: Date | null
      ResultsData: string | null
    }, ExtArgs["result"]["logEnterEmployee"]>
    composites: {}
  }

  type LogEnterEmployeeGetPayload<S extends boolean | null | undefined | LogEnterEmployeeDefaultArgs> = $Result.GetResult<Prisma.$LogEnterEmployeePayload, S>

  type LogEnterEmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogEnterEmployeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogEnterEmployeeCountAggregateInputType | true
    }

  export interface LogEnterEmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogEnterEmployee'], meta: { name: 'LogEnterEmployee' } }
    /**
     * Find zero or one LogEnterEmployee that matches the filter.
     * @param {LogEnterEmployeeFindUniqueArgs} args - Arguments to find a LogEnterEmployee
     * @example
     * // Get one LogEnterEmployee
     * const logEnterEmployee = await prisma.logEnterEmployee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogEnterEmployeeFindUniqueArgs>(args: SelectSubset<T, LogEnterEmployeeFindUniqueArgs<ExtArgs>>): Prisma__LogEnterEmployeeClient<$Result.GetResult<Prisma.$LogEnterEmployeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogEnterEmployee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogEnterEmployeeFindUniqueOrThrowArgs} args - Arguments to find a LogEnterEmployee
     * @example
     * // Get one LogEnterEmployee
     * const logEnterEmployee = await prisma.logEnterEmployee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogEnterEmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, LogEnterEmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogEnterEmployeeClient<$Result.GetResult<Prisma.$LogEnterEmployeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogEnterEmployee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEnterEmployeeFindFirstArgs} args - Arguments to find a LogEnterEmployee
     * @example
     * // Get one LogEnterEmployee
     * const logEnterEmployee = await prisma.logEnterEmployee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogEnterEmployeeFindFirstArgs>(args?: SelectSubset<T, LogEnterEmployeeFindFirstArgs<ExtArgs>>): Prisma__LogEnterEmployeeClient<$Result.GetResult<Prisma.$LogEnterEmployeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogEnterEmployee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEnterEmployeeFindFirstOrThrowArgs} args - Arguments to find a LogEnterEmployee
     * @example
     * // Get one LogEnterEmployee
     * const logEnterEmployee = await prisma.logEnterEmployee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogEnterEmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, LogEnterEmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogEnterEmployeeClient<$Result.GetResult<Prisma.$LogEnterEmployeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogEnterEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEnterEmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogEnterEmployees
     * const logEnterEmployees = await prisma.logEnterEmployee.findMany()
     * 
     * // Get first 10 LogEnterEmployees
     * const logEnterEmployees = await prisma.logEnterEmployee.findMany({ take: 10 })
     * 
     * // Only select the `LogEnterEmployee`
     * const logEnterEmployeeWithLogEnterEmployeeOnly = await prisma.logEnterEmployee.findMany({ select: { LogEnterEmployee: true } })
     * 
     */
    findMany<T extends LogEnterEmployeeFindManyArgs>(args?: SelectSubset<T, LogEnterEmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEnterEmployeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogEnterEmployee.
     * @param {LogEnterEmployeeCreateArgs} args - Arguments to create a LogEnterEmployee.
     * @example
     * // Create one LogEnterEmployee
     * const LogEnterEmployee = await prisma.logEnterEmployee.create({
     *   data: {
     *     // ... data to create a LogEnterEmployee
     *   }
     * })
     * 
     */
    create<T extends LogEnterEmployeeCreateArgs>(args: SelectSubset<T, LogEnterEmployeeCreateArgs<ExtArgs>>): Prisma__LogEnterEmployeeClient<$Result.GetResult<Prisma.$LogEnterEmployeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogEnterEmployees.
     * @param {LogEnterEmployeeCreateManyArgs} args - Arguments to create many LogEnterEmployees.
     * @example
     * // Create many LogEnterEmployees
     * const logEnterEmployee = await prisma.logEnterEmployee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogEnterEmployeeCreateManyArgs>(args?: SelectSubset<T, LogEnterEmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogEnterEmployee.
     * @param {LogEnterEmployeeDeleteArgs} args - Arguments to delete one LogEnterEmployee.
     * @example
     * // Delete one LogEnterEmployee
     * const LogEnterEmployee = await prisma.logEnterEmployee.delete({
     *   where: {
     *     // ... filter to delete one LogEnterEmployee
     *   }
     * })
     * 
     */
    delete<T extends LogEnterEmployeeDeleteArgs>(args: SelectSubset<T, LogEnterEmployeeDeleteArgs<ExtArgs>>): Prisma__LogEnterEmployeeClient<$Result.GetResult<Prisma.$LogEnterEmployeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogEnterEmployee.
     * @param {LogEnterEmployeeUpdateArgs} args - Arguments to update one LogEnterEmployee.
     * @example
     * // Update one LogEnterEmployee
     * const logEnterEmployee = await prisma.logEnterEmployee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogEnterEmployeeUpdateArgs>(args: SelectSubset<T, LogEnterEmployeeUpdateArgs<ExtArgs>>): Prisma__LogEnterEmployeeClient<$Result.GetResult<Prisma.$LogEnterEmployeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogEnterEmployees.
     * @param {LogEnterEmployeeDeleteManyArgs} args - Arguments to filter LogEnterEmployees to delete.
     * @example
     * // Delete a few LogEnterEmployees
     * const { count } = await prisma.logEnterEmployee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogEnterEmployeeDeleteManyArgs>(args?: SelectSubset<T, LogEnterEmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogEnterEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEnterEmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogEnterEmployees
     * const logEnterEmployee = await prisma.logEnterEmployee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogEnterEmployeeUpdateManyArgs>(args: SelectSubset<T, LogEnterEmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogEnterEmployee.
     * @param {LogEnterEmployeeUpsertArgs} args - Arguments to update or create a LogEnterEmployee.
     * @example
     * // Update or create a LogEnterEmployee
     * const logEnterEmployee = await prisma.logEnterEmployee.upsert({
     *   create: {
     *     // ... data to create a LogEnterEmployee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogEnterEmployee we want to update
     *   }
     * })
     */
    upsert<T extends LogEnterEmployeeUpsertArgs>(args: SelectSubset<T, LogEnterEmployeeUpsertArgs<ExtArgs>>): Prisma__LogEnterEmployeeClient<$Result.GetResult<Prisma.$LogEnterEmployeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogEnterEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEnterEmployeeCountArgs} args - Arguments to filter LogEnterEmployees to count.
     * @example
     * // Count the number of LogEnterEmployees
     * const count = await prisma.logEnterEmployee.count({
     *   where: {
     *     // ... the filter for the LogEnterEmployees we want to count
     *   }
     * })
    **/
    count<T extends LogEnterEmployeeCountArgs>(
      args?: Subset<T, LogEnterEmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogEnterEmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogEnterEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEnterEmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogEnterEmployeeAggregateArgs>(args: Subset<T, LogEnterEmployeeAggregateArgs>): Prisma.PrismaPromise<GetLogEnterEmployeeAggregateType<T>>

    /**
     * Group by LogEnterEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEnterEmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogEnterEmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogEnterEmployeeGroupByArgs['orderBy'] }
        : { orderBy?: LogEnterEmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogEnterEmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogEnterEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogEnterEmployee model
   */
  readonly fields: LogEnterEmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogEnterEmployee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogEnterEmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogEnterEmployee model
   */ 
  interface LogEnterEmployeeFieldRefs {
    readonly LogEnterEmployee: FieldRef<"LogEnterEmployee", 'Int'>
    readonly UserID: FieldRef<"LogEnterEmployee", 'String'>
    readonly CompanyID: FieldRef<"LogEnterEmployee", 'String'>
    readonly EmployeeID: FieldRef<"LogEnterEmployee", 'Int'>
    readonly CreatedAt: FieldRef<"LogEnterEmployee", 'DateTime'>
    readonly ResultsData: FieldRef<"LogEnterEmployee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LogEnterEmployee findUnique
   */
  export type LogEnterEmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEnterEmployee
     */
    select?: LogEnterEmployeeSelect<ExtArgs> | null
    /**
     * Filter, which LogEnterEmployee to fetch.
     */
    where: LogEnterEmployeeWhereUniqueInput
  }

  /**
   * LogEnterEmployee findUniqueOrThrow
   */
  export type LogEnterEmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEnterEmployee
     */
    select?: LogEnterEmployeeSelect<ExtArgs> | null
    /**
     * Filter, which LogEnterEmployee to fetch.
     */
    where: LogEnterEmployeeWhereUniqueInput
  }

  /**
   * LogEnterEmployee findFirst
   */
  export type LogEnterEmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEnterEmployee
     */
    select?: LogEnterEmployeeSelect<ExtArgs> | null
    /**
     * Filter, which LogEnterEmployee to fetch.
     */
    where?: LogEnterEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEnterEmployees to fetch.
     */
    orderBy?: LogEnterEmployeeOrderByWithRelationInput | LogEnterEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogEnterEmployees.
     */
    cursor?: LogEnterEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEnterEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEnterEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogEnterEmployees.
     */
    distinct?: LogEnterEmployeeScalarFieldEnum | LogEnterEmployeeScalarFieldEnum[]
  }

  /**
   * LogEnterEmployee findFirstOrThrow
   */
  export type LogEnterEmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEnterEmployee
     */
    select?: LogEnterEmployeeSelect<ExtArgs> | null
    /**
     * Filter, which LogEnterEmployee to fetch.
     */
    where?: LogEnterEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEnterEmployees to fetch.
     */
    orderBy?: LogEnterEmployeeOrderByWithRelationInput | LogEnterEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogEnterEmployees.
     */
    cursor?: LogEnterEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEnterEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEnterEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogEnterEmployees.
     */
    distinct?: LogEnterEmployeeScalarFieldEnum | LogEnterEmployeeScalarFieldEnum[]
  }

  /**
   * LogEnterEmployee findMany
   */
  export type LogEnterEmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEnterEmployee
     */
    select?: LogEnterEmployeeSelect<ExtArgs> | null
    /**
     * Filter, which LogEnterEmployees to fetch.
     */
    where?: LogEnterEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEnterEmployees to fetch.
     */
    orderBy?: LogEnterEmployeeOrderByWithRelationInput | LogEnterEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogEnterEmployees.
     */
    cursor?: LogEnterEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEnterEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEnterEmployees.
     */
    skip?: number
    distinct?: LogEnterEmployeeScalarFieldEnum | LogEnterEmployeeScalarFieldEnum[]
  }

  /**
   * LogEnterEmployee create
   */
  export type LogEnterEmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEnterEmployee
     */
    select?: LogEnterEmployeeSelect<ExtArgs> | null
    /**
     * The data needed to create a LogEnterEmployee.
     */
    data: XOR<LogEnterEmployeeCreateInput, LogEnterEmployeeUncheckedCreateInput>
  }

  /**
   * LogEnterEmployee createMany
   */
  export type LogEnterEmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogEnterEmployees.
     */
    data: LogEnterEmployeeCreateManyInput | LogEnterEmployeeCreateManyInput[]
  }

  /**
   * LogEnterEmployee update
   */
  export type LogEnterEmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEnterEmployee
     */
    select?: LogEnterEmployeeSelect<ExtArgs> | null
    /**
     * The data needed to update a LogEnterEmployee.
     */
    data: XOR<LogEnterEmployeeUpdateInput, LogEnterEmployeeUncheckedUpdateInput>
    /**
     * Choose, which LogEnterEmployee to update.
     */
    where: LogEnterEmployeeWhereUniqueInput
  }

  /**
   * LogEnterEmployee updateMany
   */
  export type LogEnterEmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogEnterEmployees.
     */
    data: XOR<LogEnterEmployeeUpdateManyMutationInput, LogEnterEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which LogEnterEmployees to update
     */
    where?: LogEnterEmployeeWhereInput
  }

  /**
   * LogEnterEmployee upsert
   */
  export type LogEnterEmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEnterEmployee
     */
    select?: LogEnterEmployeeSelect<ExtArgs> | null
    /**
     * The filter to search for the LogEnterEmployee to update in case it exists.
     */
    where: LogEnterEmployeeWhereUniqueInput
    /**
     * In case the LogEnterEmployee found by the `where` argument doesn't exist, create a new LogEnterEmployee with this data.
     */
    create: XOR<LogEnterEmployeeCreateInput, LogEnterEmployeeUncheckedCreateInput>
    /**
     * In case the LogEnterEmployee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogEnterEmployeeUpdateInput, LogEnterEmployeeUncheckedUpdateInput>
  }

  /**
   * LogEnterEmployee delete
   */
  export type LogEnterEmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEnterEmployee
     */
    select?: LogEnterEmployeeSelect<ExtArgs> | null
    /**
     * Filter which LogEnterEmployee to delete.
     */
    where: LogEnterEmployeeWhereUniqueInput
  }

  /**
   * LogEnterEmployee deleteMany
   */
  export type LogEnterEmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogEnterEmployees to delete
     */
    where?: LogEnterEmployeeWhereInput
  }

  /**
   * LogEnterEmployee without action
   */
  export type LogEnterEmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEnterEmployee
     */
    select?: LogEnterEmployeeSelect<ExtArgs> | null
  }


  /**
   * Model LogSearchs
   */

  export type AggregateLogSearchs = {
    _count: LogSearchsCountAggregateOutputType | null
    _avg: LogSearchsAvgAggregateOutputType | null
    _sum: LogSearchsSumAggregateOutputType | null
    _min: LogSearchsMinAggregateOutputType | null
    _max: LogSearchsMaxAggregateOutputType | null
  }

  export type LogSearchsAvgAggregateOutputType = {
    LogSearchsId: number | null
    resultsCount: number | null
  }

  export type LogSearchsSumAggregateOutputType = {
    LogSearchsId: number | null
    resultsCount: number | null
  }

  export type LogSearchsMinAggregateOutputType = {
    LogSearchsId: number | null
    UserID: string | null
    CompanyID: string | null
    CreatedAt: Date | null
    searchData: string | null
    resultsCount: number | null
  }

  export type LogSearchsMaxAggregateOutputType = {
    LogSearchsId: number | null
    UserID: string | null
    CompanyID: string | null
    CreatedAt: Date | null
    searchData: string | null
    resultsCount: number | null
  }

  export type LogSearchsCountAggregateOutputType = {
    LogSearchsId: number
    UserID: number
    CompanyID: number
    CreatedAt: number
    searchData: number
    resultsCount: number
    _all: number
  }


  export type LogSearchsAvgAggregateInputType = {
    LogSearchsId?: true
    resultsCount?: true
  }

  export type LogSearchsSumAggregateInputType = {
    LogSearchsId?: true
    resultsCount?: true
  }

  export type LogSearchsMinAggregateInputType = {
    LogSearchsId?: true
    UserID?: true
    CompanyID?: true
    CreatedAt?: true
    searchData?: true
    resultsCount?: true
  }

  export type LogSearchsMaxAggregateInputType = {
    LogSearchsId?: true
    UserID?: true
    CompanyID?: true
    CreatedAt?: true
    searchData?: true
    resultsCount?: true
  }

  export type LogSearchsCountAggregateInputType = {
    LogSearchsId?: true
    UserID?: true
    CompanyID?: true
    CreatedAt?: true
    searchData?: true
    resultsCount?: true
    _all?: true
  }

  export type LogSearchsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogSearchs to aggregate.
     */
    where?: LogSearchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSearchs to fetch.
     */
    orderBy?: LogSearchsOrderByWithRelationInput | LogSearchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogSearchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSearchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSearchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogSearchs
    **/
    _count?: true | LogSearchsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogSearchsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSearchsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogSearchsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogSearchsMaxAggregateInputType
  }

  export type GetLogSearchsAggregateType<T extends LogSearchsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogSearchs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogSearchs[P]>
      : GetScalarType<T[P], AggregateLogSearchs[P]>
  }




  export type LogSearchsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogSearchsWhereInput
    orderBy?: LogSearchsOrderByWithAggregationInput | LogSearchsOrderByWithAggregationInput[]
    by: LogSearchsScalarFieldEnum[] | LogSearchsScalarFieldEnum
    having?: LogSearchsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogSearchsCountAggregateInputType | true
    _avg?: LogSearchsAvgAggregateInputType
    _sum?: LogSearchsSumAggregateInputType
    _min?: LogSearchsMinAggregateInputType
    _max?: LogSearchsMaxAggregateInputType
  }

  export type LogSearchsGroupByOutputType = {
    LogSearchsId: number
    UserID: string
    CompanyID: string
    CreatedAt: Date | null
    searchData: string | null
    resultsCount: number | null
    _count: LogSearchsCountAggregateOutputType | null
    _avg: LogSearchsAvgAggregateOutputType | null
    _sum: LogSearchsSumAggregateOutputType | null
    _min: LogSearchsMinAggregateOutputType | null
    _max: LogSearchsMaxAggregateOutputType | null
  }

  type GetLogSearchsGroupByPayload<T extends LogSearchsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogSearchsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogSearchsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogSearchsGroupByOutputType[P]>
            : GetScalarType<T[P], LogSearchsGroupByOutputType[P]>
        }
      >
    >


  export type LogSearchsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LogSearchsId?: boolean
    UserID?: boolean
    CompanyID?: boolean
    CreatedAt?: boolean
    searchData?: boolean
    resultsCount?: boolean
  }, ExtArgs["result"]["logSearchs"]>


  export type LogSearchsSelectScalar = {
    LogSearchsId?: boolean
    UserID?: boolean
    CompanyID?: boolean
    CreatedAt?: boolean
    searchData?: boolean
    resultsCount?: boolean
  }


  export type $LogSearchsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogSearchs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      LogSearchsId: number
      UserID: string
      CompanyID: string
      CreatedAt: Date | null
      searchData: string | null
      resultsCount: number | null
    }, ExtArgs["result"]["logSearchs"]>
    composites: {}
  }

  type LogSearchsGetPayload<S extends boolean | null | undefined | LogSearchsDefaultArgs> = $Result.GetResult<Prisma.$LogSearchsPayload, S>

  type LogSearchsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogSearchsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogSearchsCountAggregateInputType | true
    }

  export interface LogSearchsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogSearchs'], meta: { name: 'LogSearchs' } }
    /**
     * Find zero or one LogSearchs that matches the filter.
     * @param {LogSearchsFindUniqueArgs} args - Arguments to find a LogSearchs
     * @example
     * // Get one LogSearchs
     * const logSearchs = await prisma.logSearchs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogSearchsFindUniqueArgs>(args: SelectSubset<T, LogSearchsFindUniqueArgs<ExtArgs>>): Prisma__LogSearchsClient<$Result.GetResult<Prisma.$LogSearchsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogSearchs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogSearchsFindUniqueOrThrowArgs} args - Arguments to find a LogSearchs
     * @example
     * // Get one LogSearchs
     * const logSearchs = await prisma.logSearchs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogSearchsFindUniqueOrThrowArgs>(args: SelectSubset<T, LogSearchsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogSearchsClient<$Result.GetResult<Prisma.$LogSearchsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogSearchs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSearchsFindFirstArgs} args - Arguments to find a LogSearchs
     * @example
     * // Get one LogSearchs
     * const logSearchs = await prisma.logSearchs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogSearchsFindFirstArgs>(args?: SelectSubset<T, LogSearchsFindFirstArgs<ExtArgs>>): Prisma__LogSearchsClient<$Result.GetResult<Prisma.$LogSearchsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogSearchs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSearchsFindFirstOrThrowArgs} args - Arguments to find a LogSearchs
     * @example
     * // Get one LogSearchs
     * const logSearchs = await prisma.logSearchs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogSearchsFindFirstOrThrowArgs>(args?: SelectSubset<T, LogSearchsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogSearchsClient<$Result.GetResult<Prisma.$LogSearchsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogSearchs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSearchsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogSearchs
     * const logSearchs = await prisma.logSearchs.findMany()
     * 
     * // Get first 10 LogSearchs
     * const logSearchs = await prisma.logSearchs.findMany({ take: 10 })
     * 
     * // Only select the `LogSearchsId`
     * const logSearchsWithLogSearchsIdOnly = await prisma.logSearchs.findMany({ select: { LogSearchsId: true } })
     * 
     */
    findMany<T extends LogSearchsFindManyArgs>(args?: SelectSubset<T, LogSearchsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogSearchsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogSearchs.
     * @param {LogSearchsCreateArgs} args - Arguments to create a LogSearchs.
     * @example
     * // Create one LogSearchs
     * const LogSearchs = await prisma.logSearchs.create({
     *   data: {
     *     // ... data to create a LogSearchs
     *   }
     * })
     * 
     */
    create<T extends LogSearchsCreateArgs>(args: SelectSubset<T, LogSearchsCreateArgs<ExtArgs>>): Prisma__LogSearchsClient<$Result.GetResult<Prisma.$LogSearchsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogSearchs.
     * @param {LogSearchsCreateManyArgs} args - Arguments to create many LogSearchs.
     * @example
     * // Create many LogSearchs
     * const logSearchs = await prisma.logSearchs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogSearchsCreateManyArgs>(args?: SelectSubset<T, LogSearchsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogSearchs.
     * @param {LogSearchsDeleteArgs} args - Arguments to delete one LogSearchs.
     * @example
     * // Delete one LogSearchs
     * const LogSearchs = await prisma.logSearchs.delete({
     *   where: {
     *     // ... filter to delete one LogSearchs
     *   }
     * })
     * 
     */
    delete<T extends LogSearchsDeleteArgs>(args: SelectSubset<T, LogSearchsDeleteArgs<ExtArgs>>): Prisma__LogSearchsClient<$Result.GetResult<Prisma.$LogSearchsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogSearchs.
     * @param {LogSearchsUpdateArgs} args - Arguments to update one LogSearchs.
     * @example
     * // Update one LogSearchs
     * const logSearchs = await prisma.logSearchs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogSearchsUpdateArgs>(args: SelectSubset<T, LogSearchsUpdateArgs<ExtArgs>>): Prisma__LogSearchsClient<$Result.GetResult<Prisma.$LogSearchsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogSearchs.
     * @param {LogSearchsDeleteManyArgs} args - Arguments to filter LogSearchs to delete.
     * @example
     * // Delete a few LogSearchs
     * const { count } = await prisma.logSearchs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogSearchsDeleteManyArgs>(args?: SelectSubset<T, LogSearchsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogSearchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSearchsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogSearchs
     * const logSearchs = await prisma.logSearchs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogSearchsUpdateManyArgs>(args: SelectSubset<T, LogSearchsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogSearchs.
     * @param {LogSearchsUpsertArgs} args - Arguments to update or create a LogSearchs.
     * @example
     * // Update or create a LogSearchs
     * const logSearchs = await prisma.logSearchs.upsert({
     *   create: {
     *     // ... data to create a LogSearchs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogSearchs we want to update
     *   }
     * })
     */
    upsert<T extends LogSearchsUpsertArgs>(args: SelectSubset<T, LogSearchsUpsertArgs<ExtArgs>>): Prisma__LogSearchsClient<$Result.GetResult<Prisma.$LogSearchsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogSearchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSearchsCountArgs} args - Arguments to filter LogSearchs to count.
     * @example
     * // Count the number of LogSearchs
     * const count = await prisma.logSearchs.count({
     *   where: {
     *     // ... the filter for the LogSearchs we want to count
     *   }
     * })
    **/
    count<T extends LogSearchsCountArgs>(
      args?: Subset<T, LogSearchsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogSearchsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogSearchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSearchsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogSearchsAggregateArgs>(args: Subset<T, LogSearchsAggregateArgs>): Prisma.PrismaPromise<GetLogSearchsAggregateType<T>>

    /**
     * Group by LogSearchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSearchsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogSearchsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogSearchsGroupByArgs['orderBy'] }
        : { orderBy?: LogSearchsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogSearchsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogSearchsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogSearchs model
   */
  readonly fields: LogSearchsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogSearchs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogSearchsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogSearchs model
   */ 
  interface LogSearchsFieldRefs {
    readonly LogSearchsId: FieldRef<"LogSearchs", 'Int'>
    readonly UserID: FieldRef<"LogSearchs", 'String'>
    readonly CompanyID: FieldRef<"LogSearchs", 'String'>
    readonly CreatedAt: FieldRef<"LogSearchs", 'DateTime'>
    readonly searchData: FieldRef<"LogSearchs", 'String'>
    readonly resultsCount: FieldRef<"LogSearchs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LogSearchs findUnique
   */
  export type LogSearchsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSearchs
     */
    select?: LogSearchsSelect<ExtArgs> | null
    /**
     * Filter, which LogSearchs to fetch.
     */
    where: LogSearchsWhereUniqueInput
  }

  /**
   * LogSearchs findUniqueOrThrow
   */
  export type LogSearchsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSearchs
     */
    select?: LogSearchsSelect<ExtArgs> | null
    /**
     * Filter, which LogSearchs to fetch.
     */
    where: LogSearchsWhereUniqueInput
  }

  /**
   * LogSearchs findFirst
   */
  export type LogSearchsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSearchs
     */
    select?: LogSearchsSelect<ExtArgs> | null
    /**
     * Filter, which LogSearchs to fetch.
     */
    where?: LogSearchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSearchs to fetch.
     */
    orderBy?: LogSearchsOrderByWithRelationInput | LogSearchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogSearchs.
     */
    cursor?: LogSearchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSearchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSearchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogSearchs.
     */
    distinct?: LogSearchsScalarFieldEnum | LogSearchsScalarFieldEnum[]
  }

  /**
   * LogSearchs findFirstOrThrow
   */
  export type LogSearchsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSearchs
     */
    select?: LogSearchsSelect<ExtArgs> | null
    /**
     * Filter, which LogSearchs to fetch.
     */
    where?: LogSearchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSearchs to fetch.
     */
    orderBy?: LogSearchsOrderByWithRelationInput | LogSearchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogSearchs.
     */
    cursor?: LogSearchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSearchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSearchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogSearchs.
     */
    distinct?: LogSearchsScalarFieldEnum | LogSearchsScalarFieldEnum[]
  }

  /**
   * LogSearchs findMany
   */
  export type LogSearchsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSearchs
     */
    select?: LogSearchsSelect<ExtArgs> | null
    /**
     * Filter, which LogSearchs to fetch.
     */
    where?: LogSearchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSearchs to fetch.
     */
    orderBy?: LogSearchsOrderByWithRelationInput | LogSearchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogSearchs.
     */
    cursor?: LogSearchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSearchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSearchs.
     */
    skip?: number
    distinct?: LogSearchsScalarFieldEnum | LogSearchsScalarFieldEnum[]
  }

  /**
   * LogSearchs create
   */
  export type LogSearchsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSearchs
     */
    select?: LogSearchsSelect<ExtArgs> | null
    /**
     * The data needed to create a LogSearchs.
     */
    data: XOR<LogSearchsCreateInput, LogSearchsUncheckedCreateInput>
  }

  /**
   * LogSearchs createMany
   */
  export type LogSearchsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogSearchs.
     */
    data: LogSearchsCreateManyInput | LogSearchsCreateManyInput[]
  }

  /**
   * LogSearchs update
   */
  export type LogSearchsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSearchs
     */
    select?: LogSearchsSelect<ExtArgs> | null
    /**
     * The data needed to update a LogSearchs.
     */
    data: XOR<LogSearchsUpdateInput, LogSearchsUncheckedUpdateInput>
    /**
     * Choose, which LogSearchs to update.
     */
    where: LogSearchsWhereUniqueInput
  }

  /**
   * LogSearchs updateMany
   */
  export type LogSearchsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogSearchs.
     */
    data: XOR<LogSearchsUpdateManyMutationInput, LogSearchsUncheckedUpdateManyInput>
    /**
     * Filter which LogSearchs to update
     */
    where?: LogSearchsWhereInput
  }

  /**
   * LogSearchs upsert
   */
  export type LogSearchsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSearchs
     */
    select?: LogSearchsSelect<ExtArgs> | null
    /**
     * The filter to search for the LogSearchs to update in case it exists.
     */
    where: LogSearchsWhereUniqueInput
    /**
     * In case the LogSearchs found by the `where` argument doesn't exist, create a new LogSearchs with this data.
     */
    create: XOR<LogSearchsCreateInput, LogSearchsUncheckedCreateInput>
    /**
     * In case the LogSearchs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogSearchsUpdateInput, LogSearchsUncheckedUpdateInput>
  }

  /**
   * LogSearchs delete
   */
  export type LogSearchsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSearchs
     */
    select?: LogSearchsSelect<ExtArgs> | null
    /**
     * Filter which LogSearchs to delete.
     */
    where: LogSearchsWhereUniqueInput
  }

  /**
   * LogSearchs deleteMany
   */
  export type LogSearchsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogSearchs to delete
     */
    where?: LogSearchsWhereInput
  }

  /**
   * LogSearchs without action
   */
  export type LogSearchsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSearchs
     */
    select?: LogSearchsSelect<ExtArgs> | null
  }


  /**
   * Model LogSignUp
   */

  export type AggregateLogSignUp = {
    _count: LogSignUpCountAggregateOutputType | null
    _avg: LogSignUpAvgAggregateOutputType | null
    _sum: LogSignUpSumAggregateOutputType | null
    _min: LogSignUpMinAggregateOutputType | null
    _max: LogSignUpMaxAggregateOutputType | null
  }

  export type LogSignUpAvgAggregateOutputType = {
    LogSignUpId: number | null
  }

  export type LogSignUpSumAggregateOutputType = {
    LogSignUpId: number | null
  }

  export type LogSignUpMinAggregateOutputType = {
    LogSignUpId: number | null
    UserID: string | null
    CompanyID: string | null
    CreatedAt: Date | null
  }

  export type LogSignUpMaxAggregateOutputType = {
    LogSignUpId: number | null
    UserID: string | null
    CompanyID: string | null
    CreatedAt: Date | null
  }

  export type LogSignUpCountAggregateOutputType = {
    LogSignUpId: number
    UserID: number
    CompanyID: number
    CreatedAt: number
    _all: number
  }


  export type LogSignUpAvgAggregateInputType = {
    LogSignUpId?: true
  }

  export type LogSignUpSumAggregateInputType = {
    LogSignUpId?: true
  }

  export type LogSignUpMinAggregateInputType = {
    LogSignUpId?: true
    UserID?: true
    CompanyID?: true
    CreatedAt?: true
  }

  export type LogSignUpMaxAggregateInputType = {
    LogSignUpId?: true
    UserID?: true
    CompanyID?: true
    CreatedAt?: true
  }

  export type LogSignUpCountAggregateInputType = {
    LogSignUpId?: true
    UserID?: true
    CompanyID?: true
    CreatedAt?: true
    _all?: true
  }

  export type LogSignUpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogSignUp to aggregate.
     */
    where?: LogSignUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSignUps to fetch.
     */
    orderBy?: LogSignUpOrderByWithRelationInput | LogSignUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogSignUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSignUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSignUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogSignUps
    **/
    _count?: true | LogSignUpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogSignUpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSignUpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogSignUpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogSignUpMaxAggregateInputType
  }

  export type GetLogSignUpAggregateType<T extends LogSignUpAggregateArgs> = {
        [P in keyof T & keyof AggregateLogSignUp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogSignUp[P]>
      : GetScalarType<T[P], AggregateLogSignUp[P]>
  }




  export type LogSignUpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogSignUpWhereInput
    orderBy?: LogSignUpOrderByWithAggregationInput | LogSignUpOrderByWithAggregationInput[]
    by: LogSignUpScalarFieldEnum[] | LogSignUpScalarFieldEnum
    having?: LogSignUpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogSignUpCountAggregateInputType | true
    _avg?: LogSignUpAvgAggregateInputType
    _sum?: LogSignUpSumAggregateInputType
    _min?: LogSignUpMinAggregateInputType
    _max?: LogSignUpMaxAggregateInputType
  }

  export type LogSignUpGroupByOutputType = {
    LogSignUpId: number
    UserID: string
    CompanyID: string
    CreatedAt: Date | null
    _count: LogSignUpCountAggregateOutputType | null
    _avg: LogSignUpAvgAggregateOutputType | null
    _sum: LogSignUpSumAggregateOutputType | null
    _min: LogSignUpMinAggregateOutputType | null
    _max: LogSignUpMaxAggregateOutputType | null
  }

  type GetLogSignUpGroupByPayload<T extends LogSignUpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogSignUpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogSignUpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogSignUpGroupByOutputType[P]>
            : GetScalarType<T[P], LogSignUpGroupByOutputType[P]>
        }
      >
    >


  export type LogSignUpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LogSignUpId?: boolean
    UserID?: boolean
    CompanyID?: boolean
    CreatedAt?: boolean
  }, ExtArgs["result"]["logSignUp"]>


  export type LogSignUpSelectScalar = {
    LogSignUpId?: boolean
    UserID?: boolean
    CompanyID?: boolean
    CreatedAt?: boolean
  }


  export type $LogSignUpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogSignUp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      LogSignUpId: number
      UserID: string
      CompanyID: string
      CreatedAt: Date | null
    }, ExtArgs["result"]["logSignUp"]>
    composites: {}
  }

  type LogSignUpGetPayload<S extends boolean | null | undefined | LogSignUpDefaultArgs> = $Result.GetResult<Prisma.$LogSignUpPayload, S>

  type LogSignUpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogSignUpFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogSignUpCountAggregateInputType | true
    }

  export interface LogSignUpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogSignUp'], meta: { name: 'LogSignUp' } }
    /**
     * Find zero or one LogSignUp that matches the filter.
     * @param {LogSignUpFindUniqueArgs} args - Arguments to find a LogSignUp
     * @example
     * // Get one LogSignUp
     * const logSignUp = await prisma.logSignUp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogSignUpFindUniqueArgs>(args: SelectSubset<T, LogSignUpFindUniqueArgs<ExtArgs>>): Prisma__LogSignUpClient<$Result.GetResult<Prisma.$LogSignUpPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogSignUp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogSignUpFindUniqueOrThrowArgs} args - Arguments to find a LogSignUp
     * @example
     * // Get one LogSignUp
     * const logSignUp = await prisma.logSignUp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogSignUpFindUniqueOrThrowArgs>(args: SelectSubset<T, LogSignUpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogSignUpClient<$Result.GetResult<Prisma.$LogSignUpPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogSignUp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSignUpFindFirstArgs} args - Arguments to find a LogSignUp
     * @example
     * // Get one LogSignUp
     * const logSignUp = await prisma.logSignUp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogSignUpFindFirstArgs>(args?: SelectSubset<T, LogSignUpFindFirstArgs<ExtArgs>>): Prisma__LogSignUpClient<$Result.GetResult<Prisma.$LogSignUpPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogSignUp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSignUpFindFirstOrThrowArgs} args - Arguments to find a LogSignUp
     * @example
     * // Get one LogSignUp
     * const logSignUp = await prisma.logSignUp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogSignUpFindFirstOrThrowArgs>(args?: SelectSubset<T, LogSignUpFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogSignUpClient<$Result.GetResult<Prisma.$LogSignUpPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogSignUps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSignUpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogSignUps
     * const logSignUps = await prisma.logSignUp.findMany()
     * 
     * // Get first 10 LogSignUps
     * const logSignUps = await prisma.logSignUp.findMany({ take: 10 })
     * 
     * // Only select the `LogSignUpId`
     * const logSignUpWithLogSignUpIdOnly = await prisma.logSignUp.findMany({ select: { LogSignUpId: true } })
     * 
     */
    findMany<T extends LogSignUpFindManyArgs>(args?: SelectSubset<T, LogSignUpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogSignUpPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogSignUp.
     * @param {LogSignUpCreateArgs} args - Arguments to create a LogSignUp.
     * @example
     * // Create one LogSignUp
     * const LogSignUp = await prisma.logSignUp.create({
     *   data: {
     *     // ... data to create a LogSignUp
     *   }
     * })
     * 
     */
    create<T extends LogSignUpCreateArgs>(args: SelectSubset<T, LogSignUpCreateArgs<ExtArgs>>): Prisma__LogSignUpClient<$Result.GetResult<Prisma.$LogSignUpPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogSignUps.
     * @param {LogSignUpCreateManyArgs} args - Arguments to create many LogSignUps.
     * @example
     * // Create many LogSignUps
     * const logSignUp = await prisma.logSignUp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogSignUpCreateManyArgs>(args?: SelectSubset<T, LogSignUpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogSignUp.
     * @param {LogSignUpDeleteArgs} args - Arguments to delete one LogSignUp.
     * @example
     * // Delete one LogSignUp
     * const LogSignUp = await prisma.logSignUp.delete({
     *   where: {
     *     // ... filter to delete one LogSignUp
     *   }
     * })
     * 
     */
    delete<T extends LogSignUpDeleteArgs>(args: SelectSubset<T, LogSignUpDeleteArgs<ExtArgs>>): Prisma__LogSignUpClient<$Result.GetResult<Prisma.$LogSignUpPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogSignUp.
     * @param {LogSignUpUpdateArgs} args - Arguments to update one LogSignUp.
     * @example
     * // Update one LogSignUp
     * const logSignUp = await prisma.logSignUp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogSignUpUpdateArgs>(args: SelectSubset<T, LogSignUpUpdateArgs<ExtArgs>>): Prisma__LogSignUpClient<$Result.GetResult<Prisma.$LogSignUpPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogSignUps.
     * @param {LogSignUpDeleteManyArgs} args - Arguments to filter LogSignUps to delete.
     * @example
     * // Delete a few LogSignUps
     * const { count } = await prisma.logSignUp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogSignUpDeleteManyArgs>(args?: SelectSubset<T, LogSignUpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogSignUps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSignUpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogSignUps
     * const logSignUp = await prisma.logSignUp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogSignUpUpdateManyArgs>(args: SelectSubset<T, LogSignUpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogSignUp.
     * @param {LogSignUpUpsertArgs} args - Arguments to update or create a LogSignUp.
     * @example
     * // Update or create a LogSignUp
     * const logSignUp = await prisma.logSignUp.upsert({
     *   create: {
     *     // ... data to create a LogSignUp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogSignUp we want to update
     *   }
     * })
     */
    upsert<T extends LogSignUpUpsertArgs>(args: SelectSubset<T, LogSignUpUpsertArgs<ExtArgs>>): Prisma__LogSignUpClient<$Result.GetResult<Prisma.$LogSignUpPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogSignUps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSignUpCountArgs} args - Arguments to filter LogSignUps to count.
     * @example
     * // Count the number of LogSignUps
     * const count = await prisma.logSignUp.count({
     *   where: {
     *     // ... the filter for the LogSignUps we want to count
     *   }
     * })
    **/
    count<T extends LogSignUpCountArgs>(
      args?: Subset<T, LogSignUpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogSignUpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogSignUp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSignUpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogSignUpAggregateArgs>(args: Subset<T, LogSignUpAggregateArgs>): Prisma.PrismaPromise<GetLogSignUpAggregateType<T>>

    /**
     * Group by LogSignUp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSignUpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogSignUpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogSignUpGroupByArgs['orderBy'] }
        : { orderBy?: LogSignUpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogSignUpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogSignUpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogSignUp model
   */
  readonly fields: LogSignUpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogSignUp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogSignUpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogSignUp model
   */ 
  interface LogSignUpFieldRefs {
    readonly LogSignUpId: FieldRef<"LogSignUp", 'Int'>
    readonly UserID: FieldRef<"LogSignUp", 'String'>
    readonly CompanyID: FieldRef<"LogSignUp", 'String'>
    readonly CreatedAt: FieldRef<"LogSignUp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LogSignUp findUnique
   */
  export type LogSignUpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSignUp
     */
    select?: LogSignUpSelect<ExtArgs> | null
    /**
     * Filter, which LogSignUp to fetch.
     */
    where: LogSignUpWhereUniqueInput
  }

  /**
   * LogSignUp findUniqueOrThrow
   */
  export type LogSignUpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSignUp
     */
    select?: LogSignUpSelect<ExtArgs> | null
    /**
     * Filter, which LogSignUp to fetch.
     */
    where: LogSignUpWhereUniqueInput
  }

  /**
   * LogSignUp findFirst
   */
  export type LogSignUpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSignUp
     */
    select?: LogSignUpSelect<ExtArgs> | null
    /**
     * Filter, which LogSignUp to fetch.
     */
    where?: LogSignUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSignUps to fetch.
     */
    orderBy?: LogSignUpOrderByWithRelationInput | LogSignUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogSignUps.
     */
    cursor?: LogSignUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSignUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSignUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogSignUps.
     */
    distinct?: LogSignUpScalarFieldEnum | LogSignUpScalarFieldEnum[]
  }

  /**
   * LogSignUp findFirstOrThrow
   */
  export type LogSignUpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSignUp
     */
    select?: LogSignUpSelect<ExtArgs> | null
    /**
     * Filter, which LogSignUp to fetch.
     */
    where?: LogSignUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSignUps to fetch.
     */
    orderBy?: LogSignUpOrderByWithRelationInput | LogSignUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogSignUps.
     */
    cursor?: LogSignUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSignUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSignUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogSignUps.
     */
    distinct?: LogSignUpScalarFieldEnum | LogSignUpScalarFieldEnum[]
  }

  /**
   * LogSignUp findMany
   */
  export type LogSignUpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSignUp
     */
    select?: LogSignUpSelect<ExtArgs> | null
    /**
     * Filter, which LogSignUps to fetch.
     */
    where?: LogSignUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSignUps to fetch.
     */
    orderBy?: LogSignUpOrderByWithRelationInput | LogSignUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogSignUps.
     */
    cursor?: LogSignUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSignUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSignUps.
     */
    skip?: number
    distinct?: LogSignUpScalarFieldEnum | LogSignUpScalarFieldEnum[]
  }

  /**
   * LogSignUp create
   */
  export type LogSignUpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSignUp
     */
    select?: LogSignUpSelect<ExtArgs> | null
    /**
     * The data needed to create a LogSignUp.
     */
    data: XOR<LogSignUpCreateInput, LogSignUpUncheckedCreateInput>
  }

  /**
   * LogSignUp createMany
   */
  export type LogSignUpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogSignUps.
     */
    data: LogSignUpCreateManyInput | LogSignUpCreateManyInput[]
  }

  /**
   * LogSignUp update
   */
  export type LogSignUpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSignUp
     */
    select?: LogSignUpSelect<ExtArgs> | null
    /**
     * The data needed to update a LogSignUp.
     */
    data: XOR<LogSignUpUpdateInput, LogSignUpUncheckedUpdateInput>
    /**
     * Choose, which LogSignUp to update.
     */
    where: LogSignUpWhereUniqueInput
  }

  /**
   * LogSignUp updateMany
   */
  export type LogSignUpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogSignUps.
     */
    data: XOR<LogSignUpUpdateManyMutationInput, LogSignUpUncheckedUpdateManyInput>
    /**
     * Filter which LogSignUps to update
     */
    where?: LogSignUpWhereInput
  }

  /**
   * LogSignUp upsert
   */
  export type LogSignUpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSignUp
     */
    select?: LogSignUpSelect<ExtArgs> | null
    /**
     * The filter to search for the LogSignUp to update in case it exists.
     */
    where: LogSignUpWhereUniqueInput
    /**
     * In case the LogSignUp found by the `where` argument doesn't exist, create a new LogSignUp with this data.
     */
    create: XOR<LogSignUpCreateInput, LogSignUpUncheckedCreateInput>
    /**
     * In case the LogSignUp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogSignUpUpdateInput, LogSignUpUncheckedUpdateInput>
  }

  /**
   * LogSignUp delete
   */
  export type LogSignUpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSignUp
     */
    select?: LogSignUpSelect<ExtArgs> | null
    /**
     * Filter which LogSignUp to delete.
     */
    where: LogSignUpWhereUniqueInput
  }

  /**
   * LogSignUp deleteMany
   */
  export type LogSignUpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogSignUps to delete
     */
    where?: LogSignUpWhereInput
  }

  /**
   * LogSignUp without action
   */
  export type LogSignUpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSignUp
     */
    select?: LogSignUpSelect<ExtArgs> | null
  }


  /**
   * Model MessagesEmployees
   */

  export type AggregateMessagesEmployees = {
    _count: MessagesEmployeesCountAggregateOutputType | null
    _avg: MessagesEmployeesAvgAggregateOutputType | null
    _sum: MessagesEmployeesSumAggregateOutputType | null
    _min: MessagesEmployeesMinAggregateOutputType | null
    _max: MessagesEmployeesMaxAggregateOutputType | null
  }

  export type MessagesEmployeesAvgAggregateOutputType = {
    SendResponseAtStatusDone: number | null
  }

  export type MessagesEmployeesSumAggregateOutputType = {
    SendResponseAtStatusDone: number | null
  }

  export type MessagesEmployeesMinAggregateOutputType = {
    MessageEmployeeId: string | null
    CreatedAt: Date | null
    FinalDateForTask: Date | null
    ReadedAt: Date | null
    DoneAt: Date | null
    SendResponseAtStatusDone: number | null
    CompanyIdGeneralCRM: string | null
    UserFromIdGeneralCRM: string | null
    UserToIdGeneralCRM: string | null
    IsReplyToMessageId: string | null
    MessageStatusId: string | null
    MessageSubject: string | null
    MessageText: string | null
    LinkEmployees: string | null
    LinkHouses: string | null
  }

  export type MessagesEmployeesMaxAggregateOutputType = {
    MessageEmployeeId: string | null
    CreatedAt: Date | null
    FinalDateForTask: Date | null
    ReadedAt: Date | null
    DoneAt: Date | null
    SendResponseAtStatusDone: number | null
    CompanyIdGeneralCRM: string | null
    UserFromIdGeneralCRM: string | null
    UserToIdGeneralCRM: string | null
    IsReplyToMessageId: string | null
    MessageStatusId: string | null
    MessageSubject: string | null
    MessageText: string | null
    LinkEmployees: string | null
    LinkHouses: string | null
  }

  export type MessagesEmployeesCountAggregateOutputType = {
    MessageEmployeeId: number
    CreatedAt: number
    FinalDateForTask: number
    ReadedAt: number
    DoneAt: number
    SendResponseAtStatusDone: number
    CompanyIdGeneralCRM: number
    UserFromIdGeneralCRM: number
    UserToIdGeneralCRM: number
    IsReplyToMessageId: number
    MessageStatusId: number
    MessageSubject: number
    MessageText: number
    LinkEmployees: number
    LinkHouses: number
    _all: number
  }


  export type MessagesEmployeesAvgAggregateInputType = {
    SendResponseAtStatusDone?: true
  }

  export type MessagesEmployeesSumAggregateInputType = {
    SendResponseAtStatusDone?: true
  }

  export type MessagesEmployeesMinAggregateInputType = {
    MessageEmployeeId?: true
    CreatedAt?: true
    FinalDateForTask?: true
    ReadedAt?: true
    DoneAt?: true
    SendResponseAtStatusDone?: true
    CompanyIdGeneralCRM?: true
    UserFromIdGeneralCRM?: true
    UserToIdGeneralCRM?: true
    IsReplyToMessageId?: true
    MessageStatusId?: true
    MessageSubject?: true
    MessageText?: true
    LinkEmployees?: true
    LinkHouses?: true
  }

  export type MessagesEmployeesMaxAggregateInputType = {
    MessageEmployeeId?: true
    CreatedAt?: true
    FinalDateForTask?: true
    ReadedAt?: true
    DoneAt?: true
    SendResponseAtStatusDone?: true
    CompanyIdGeneralCRM?: true
    UserFromIdGeneralCRM?: true
    UserToIdGeneralCRM?: true
    IsReplyToMessageId?: true
    MessageStatusId?: true
    MessageSubject?: true
    MessageText?: true
    LinkEmployees?: true
    LinkHouses?: true
  }

  export type MessagesEmployeesCountAggregateInputType = {
    MessageEmployeeId?: true
    CreatedAt?: true
    FinalDateForTask?: true
    ReadedAt?: true
    DoneAt?: true
    SendResponseAtStatusDone?: true
    CompanyIdGeneralCRM?: true
    UserFromIdGeneralCRM?: true
    UserToIdGeneralCRM?: true
    IsReplyToMessageId?: true
    MessageStatusId?: true
    MessageSubject?: true
    MessageText?: true
    LinkEmployees?: true
    LinkHouses?: true
    _all?: true
  }

  export type MessagesEmployeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessagesEmployees to aggregate.
     */
    where?: MessagesEmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessagesEmployees to fetch.
     */
    orderBy?: MessagesEmployeesOrderByWithRelationInput | MessagesEmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessagesEmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessagesEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessagesEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessagesEmployees
    **/
    _count?: true | MessagesEmployeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessagesEmployeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessagesEmployeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesEmployeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesEmployeesMaxAggregateInputType
  }

  export type GetMessagesEmployeesAggregateType<T extends MessagesEmployeesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessagesEmployees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessagesEmployees[P]>
      : GetScalarType<T[P], AggregateMessagesEmployees[P]>
  }




  export type MessagesEmployeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesEmployeesWhereInput
    orderBy?: MessagesEmployeesOrderByWithAggregationInput | MessagesEmployeesOrderByWithAggregationInput[]
    by: MessagesEmployeesScalarFieldEnum[] | MessagesEmployeesScalarFieldEnum
    having?: MessagesEmployeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesEmployeesCountAggregateInputType | true
    _avg?: MessagesEmployeesAvgAggregateInputType
    _sum?: MessagesEmployeesSumAggregateInputType
    _min?: MessagesEmployeesMinAggregateInputType
    _max?: MessagesEmployeesMaxAggregateInputType
  }

  export type MessagesEmployeesGroupByOutputType = {
    MessageEmployeeId: string
    CreatedAt: Date
    FinalDateForTask: Date | null
    ReadedAt: Date | null
    DoneAt: Date | null
    SendResponseAtStatusDone: number | null
    CompanyIdGeneralCRM: string
    UserFromIdGeneralCRM: string
    UserToIdGeneralCRM: string
    IsReplyToMessageId: string | null
    MessageStatusId: string
    MessageSubject: string | null
    MessageText: string | null
    LinkEmployees: string | null
    LinkHouses: string | null
    _count: MessagesEmployeesCountAggregateOutputType | null
    _avg: MessagesEmployeesAvgAggregateOutputType | null
    _sum: MessagesEmployeesSumAggregateOutputType | null
    _min: MessagesEmployeesMinAggregateOutputType | null
    _max: MessagesEmployeesMaxAggregateOutputType | null
  }

  type GetMessagesEmployeesGroupByPayload<T extends MessagesEmployeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesEmployeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesEmployeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesEmployeesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesEmployeesGroupByOutputType[P]>
        }
      >
    >


  export type MessagesEmployeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MessageEmployeeId?: boolean
    CreatedAt?: boolean
    FinalDateForTask?: boolean
    ReadedAt?: boolean
    DoneAt?: boolean
    SendResponseAtStatusDone?: boolean
    CompanyIdGeneralCRM?: boolean
    UserFromIdGeneralCRM?: boolean
    UserToIdGeneralCRM?: boolean
    IsReplyToMessageId?: boolean
    MessageStatusId?: boolean
    MessageSubject?: boolean
    MessageText?: boolean
    LinkEmployees?: boolean
    LinkHouses?: boolean
    MessagesEmployees?: boolean | MessagesEmployees$MessagesEmployeesArgs<ExtArgs>
    other_MessagesEmployees?: boolean | MessagesEmployees$other_MessagesEmployeesArgs<ExtArgs>
    MessagesStatus?: boolean | MessagesStatusDefaultArgs<ExtArgs>
    _count?: boolean | MessagesEmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messagesEmployees"]>


  export type MessagesEmployeesSelectScalar = {
    MessageEmployeeId?: boolean
    CreatedAt?: boolean
    FinalDateForTask?: boolean
    ReadedAt?: boolean
    DoneAt?: boolean
    SendResponseAtStatusDone?: boolean
    CompanyIdGeneralCRM?: boolean
    UserFromIdGeneralCRM?: boolean
    UserToIdGeneralCRM?: boolean
    IsReplyToMessageId?: boolean
    MessageStatusId?: boolean
    MessageSubject?: boolean
    MessageText?: boolean
    LinkEmployees?: boolean
    LinkHouses?: boolean
  }

  export type MessagesEmployeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessagesEmployees?: boolean | MessagesEmployees$MessagesEmployeesArgs<ExtArgs>
    other_MessagesEmployees?: boolean | MessagesEmployees$other_MessagesEmployeesArgs<ExtArgs>
    MessagesStatus?: boolean | MessagesStatusDefaultArgs<ExtArgs>
    _count?: boolean | MessagesEmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MessagesEmployeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessagesEmployees"
    objects: {
      MessagesEmployees: Prisma.$MessagesEmployeesPayload<ExtArgs> | null
      other_MessagesEmployees: Prisma.$MessagesEmployeesPayload<ExtArgs>[]
      MessagesStatus: Prisma.$MessagesStatusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      MessageEmployeeId: string
      CreatedAt: Date
      FinalDateForTask: Date | null
      ReadedAt: Date | null
      DoneAt: Date | null
      SendResponseAtStatusDone: number | null
      CompanyIdGeneralCRM: string
      UserFromIdGeneralCRM: string
      UserToIdGeneralCRM: string
      IsReplyToMessageId: string | null
      MessageStatusId: string
      MessageSubject: string | null
      MessageText: string | null
      LinkEmployees: string | null
      LinkHouses: string | null
    }, ExtArgs["result"]["messagesEmployees"]>
    composites: {}
  }

  type MessagesEmployeesGetPayload<S extends boolean | null | undefined | MessagesEmployeesDefaultArgs> = $Result.GetResult<Prisma.$MessagesEmployeesPayload, S>

  type MessagesEmployeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessagesEmployeesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessagesEmployeesCountAggregateInputType | true
    }

  export interface MessagesEmployeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessagesEmployees'], meta: { name: 'MessagesEmployees' } }
    /**
     * Find zero or one MessagesEmployees that matches the filter.
     * @param {MessagesEmployeesFindUniqueArgs} args - Arguments to find a MessagesEmployees
     * @example
     * // Get one MessagesEmployees
     * const messagesEmployees = await prisma.messagesEmployees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessagesEmployeesFindUniqueArgs>(args: SelectSubset<T, MessagesEmployeesFindUniqueArgs<ExtArgs>>): Prisma__MessagesEmployeesClient<$Result.GetResult<Prisma.$MessagesEmployeesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessagesEmployees that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessagesEmployeesFindUniqueOrThrowArgs} args - Arguments to find a MessagesEmployees
     * @example
     * // Get one MessagesEmployees
     * const messagesEmployees = await prisma.messagesEmployees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessagesEmployeesFindUniqueOrThrowArgs>(args: SelectSubset<T, MessagesEmployeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessagesEmployeesClient<$Result.GetResult<Prisma.$MessagesEmployeesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessagesEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesEmployeesFindFirstArgs} args - Arguments to find a MessagesEmployees
     * @example
     * // Get one MessagesEmployees
     * const messagesEmployees = await prisma.messagesEmployees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessagesEmployeesFindFirstArgs>(args?: SelectSubset<T, MessagesEmployeesFindFirstArgs<ExtArgs>>): Prisma__MessagesEmployeesClient<$Result.GetResult<Prisma.$MessagesEmployeesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessagesEmployees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesEmployeesFindFirstOrThrowArgs} args - Arguments to find a MessagesEmployees
     * @example
     * // Get one MessagesEmployees
     * const messagesEmployees = await prisma.messagesEmployees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessagesEmployeesFindFirstOrThrowArgs>(args?: SelectSubset<T, MessagesEmployeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessagesEmployeesClient<$Result.GetResult<Prisma.$MessagesEmployeesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessagesEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesEmployeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessagesEmployees
     * const messagesEmployees = await prisma.messagesEmployees.findMany()
     * 
     * // Get first 10 MessagesEmployees
     * const messagesEmployees = await prisma.messagesEmployees.findMany({ take: 10 })
     * 
     * // Only select the `MessageEmployeeId`
     * const messagesEmployeesWithMessageEmployeeIdOnly = await prisma.messagesEmployees.findMany({ select: { MessageEmployeeId: true } })
     * 
     */
    findMany<T extends MessagesEmployeesFindManyArgs>(args?: SelectSubset<T, MessagesEmployeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesEmployeesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessagesEmployees.
     * @param {MessagesEmployeesCreateArgs} args - Arguments to create a MessagesEmployees.
     * @example
     * // Create one MessagesEmployees
     * const MessagesEmployees = await prisma.messagesEmployees.create({
     *   data: {
     *     // ... data to create a MessagesEmployees
     *   }
     * })
     * 
     */
    create<T extends MessagesEmployeesCreateArgs>(args: SelectSubset<T, MessagesEmployeesCreateArgs<ExtArgs>>): Prisma__MessagesEmployeesClient<$Result.GetResult<Prisma.$MessagesEmployeesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessagesEmployees.
     * @param {MessagesEmployeesCreateManyArgs} args - Arguments to create many MessagesEmployees.
     * @example
     * // Create many MessagesEmployees
     * const messagesEmployees = await prisma.messagesEmployees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessagesEmployeesCreateManyArgs>(args?: SelectSubset<T, MessagesEmployeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessagesEmployees.
     * @param {MessagesEmployeesDeleteArgs} args - Arguments to delete one MessagesEmployees.
     * @example
     * // Delete one MessagesEmployees
     * const MessagesEmployees = await prisma.messagesEmployees.delete({
     *   where: {
     *     // ... filter to delete one MessagesEmployees
     *   }
     * })
     * 
     */
    delete<T extends MessagesEmployeesDeleteArgs>(args: SelectSubset<T, MessagesEmployeesDeleteArgs<ExtArgs>>): Prisma__MessagesEmployeesClient<$Result.GetResult<Prisma.$MessagesEmployeesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessagesEmployees.
     * @param {MessagesEmployeesUpdateArgs} args - Arguments to update one MessagesEmployees.
     * @example
     * // Update one MessagesEmployees
     * const messagesEmployees = await prisma.messagesEmployees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessagesEmployeesUpdateArgs>(args: SelectSubset<T, MessagesEmployeesUpdateArgs<ExtArgs>>): Prisma__MessagesEmployeesClient<$Result.GetResult<Prisma.$MessagesEmployeesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessagesEmployees.
     * @param {MessagesEmployeesDeleteManyArgs} args - Arguments to filter MessagesEmployees to delete.
     * @example
     * // Delete a few MessagesEmployees
     * const { count } = await prisma.messagesEmployees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessagesEmployeesDeleteManyArgs>(args?: SelectSubset<T, MessagesEmployeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessagesEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesEmployeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessagesEmployees
     * const messagesEmployees = await prisma.messagesEmployees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessagesEmployeesUpdateManyArgs>(args: SelectSubset<T, MessagesEmployeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessagesEmployees.
     * @param {MessagesEmployeesUpsertArgs} args - Arguments to update or create a MessagesEmployees.
     * @example
     * // Update or create a MessagesEmployees
     * const messagesEmployees = await prisma.messagesEmployees.upsert({
     *   create: {
     *     // ... data to create a MessagesEmployees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessagesEmployees we want to update
     *   }
     * })
     */
    upsert<T extends MessagesEmployeesUpsertArgs>(args: SelectSubset<T, MessagesEmployeesUpsertArgs<ExtArgs>>): Prisma__MessagesEmployeesClient<$Result.GetResult<Prisma.$MessagesEmployeesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessagesEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesEmployeesCountArgs} args - Arguments to filter MessagesEmployees to count.
     * @example
     * // Count the number of MessagesEmployees
     * const count = await prisma.messagesEmployees.count({
     *   where: {
     *     // ... the filter for the MessagesEmployees we want to count
     *   }
     * })
    **/
    count<T extends MessagesEmployeesCountArgs>(
      args?: Subset<T, MessagesEmployeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesEmployeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessagesEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesEmployeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesEmployeesAggregateArgs>(args: Subset<T, MessagesEmployeesAggregateArgs>): Prisma.PrismaPromise<GetMessagesEmployeesAggregateType<T>>

    /**
     * Group by MessagesEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesEmployeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessagesEmployeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessagesEmployeesGroupByArgs['orderBy'] }
        : { orderBy?: MessagesEmployeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessagesEmployeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesEmployeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessagesEmployees model
   */
  readonly fields: MessagesEmployeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessagesEmployees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessagesEmployeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MessagesEmployees<T extends MessagesEmployees$MessagesEmployeesArgs<ExtArgs> = {}>(args?: Subset<T, MessagesEmployees$MessagesEmployeesArgs<ExtArgs>>): Prisma__MessagesEmployeesClient<$Result.GetResult<Prisma.$MessagesEmployeesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    other_MessagesEmployees<T extends MessagesEmployees$other_MessagesEmployeesArgs<ExtArgs> = {}>(args?: Subset<T, MessagesEmployees$other_MessagesEmployeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesEmployeesPayload<ExtArgs>, T, "findMany"> | Null>
    MessagesStatus<T extends MessagesStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessagesStatusDefaultArgs<ExtArgs>>): Prisma__MessagesStatusClient<$Result.GetResult<Prisma.$MessagesStatusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessagesEmployees model
   */ 
  interface MessagesEmployeesFieldRefs {
    readonly MessageEmployeeId: FieldRef<"MessagesEmployees", 'String'>
    readonly CreatedAt: FieldRef<"MessagesEmployees", 'DateTime'>
    readonly FinalDateForTask: FieldRef<"MessagesEmployees", 'DateTime'>
    readonly ReadedAt: FieldRef<"MessagesEmployees", 'DateTime'>
    readonly DoneAt: FieldRef<"MessagesEmployees", 'DateTime'>
    readonly SendResponseAtStatusDone: FieldRef<"MessagesEmployees", 'Int'>
    readonly CompanyIdGeneralCRM: FieldRef<"MessagesEmployees", 'String'>
    readonly UserFromIdGeneralCRM: FieldRef<"MessagesEmployees", 'String'>
    readonly UserToIdGeneralCRM: FieldRef<"MessagesEmployees", 'String'>
    readonly IsReplyToMessageId: FieldRef<"MessagesEmployees", 'String'>
    readonly MessageStatusId: FieldRef<"MessagesEmployees", 'String'>
    readonly MessageSubject: FieldRef<"MessagesEmployees", 'String'>
    readonly MessageText: FieldRef<"MessagesEmployees", 'String'>
    readonly LinkEmployees: FieldRef<"MessagesEmployees", 'String'>
    readonly LinkHouses: FieldRef<"MessagesEmployees", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MessagesEmployees findUnique
   */
  export type MessagesEmployeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
    /**
     * Filter, which MessagesEmployees to fetch.
     */
    where: MessagesEmployeesWhereUniqueInput
  }

  /**
   * MessagesEmployees findUniqueOrThrow
   */
  export type MessagesEmployeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
    /**
     * Filter, which MessagesEmployees to fetch.
     */
    where: MessagesEmployeesWhereUniqueInput
  }

  /**
   * MessagesEmployees findFirst
   */
  export type MessagesEmployeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
    /**
     * Filter, which MessagesEmployees to fetch.
     */
    where?: MessagesEmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessagesEmployees to fetch.
     */
    orderBy?: MessagesEmployeesOrderByWithRelationInput | MessagesEmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessagesEmployees.
     */
    cursor?: MessagesEmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessagesEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessagesEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessagesEmployees.
     */
    distinct?: MessagesEmployeesScalarFieldEnum | MessagesEmployeesScalarFieldEnum[]
  }

  /**
   * MessagesEmployees findFirstOrThrow
   */
  export type MessagesEmployeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
    /**
     * Filter, which MessagesEmployees to fetch.
     */
    where?: MessagesEmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessagesEmployees to fetch.
     */
    orderBy?: MessagesEmployeesOrderByWithRelationInput | MessagesEmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessagesEmployees.
     */
    cursor?: MessagesEmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessagesEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessagesEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessagesEmployees.
     */
    distinct?: MessagesEmployeesScalarFieldEnum | MessagesEmployeesScalarFieldEnum[]
  }

  /**
   * MessagesEmployees findMany
   */
  export type MessagesEmployeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
    /**
     * Filter, which MessagesEmployees to fetch.
     */
    where?: MessagesEmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessagesEmployees to fetch.
     */
    orderBy?: MessagesEmployeesOrderByWithRelationInput | MessagesEmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessagesEmployees.
     */
    cursor?: MessagesEmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessagesEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessagesEmployees.
     */
    skip?: number
    distinct?: MessagesEmployeesScalarFieldEnum | MessagesEmployeesScalarFieldEnum[]
  }

  /**
   * MessagesEmployees create
   */
  export type MessagesEmployeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
    /**
     * The data needed to create a MessagesEmployees.
     */
    data: XOR<MessagesEmployeesCreateInput, MessagesEmployeesUncheckedCreateInput>
  }

  /**
   * MessagesEmployees createMany
   */
  export type MessagesEmployeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessagesEmployees.
     */
    data: MessagesEmployeesCreateManyInput | MessagesEmployeesCreateManyInput[]
  }

  /**
   * MessagesEmployees update
   */
  export type MessagesEmployeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
    /**
     * The data needed to update a MessagesEmployees.
     */
    data: XOR<MessagesEmployeesUpdateInput, MessagesEmployeesUncheckedUpdateInput>
    /**
     * Choose, which MessagesEmployees to update.
     */
    where: MessagesEmployeesWhereUniqueInput
  }

  /**
   * MessagesEmployees updateMany
   */
  export type MessagesEmployeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessagesEmployees.
     */
    data: XOR<MessagesEmployeesUpdateManyMutationInput, MessagesEmployeesUncheckedUpdateManyInput>
    /**
     * Filter which MessagesEmployees to update
     */
    where?: MessagesEmployeesWhereInput
  }

  /**
   * MessagesEmployees upsert
   */
  export type MessagesEmployeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
    /**
     * The filter to search for the MessagesEmployees to update in case it exists.
     */
    where: MessagesEmployeesWhereUniqueInput
    /**
     * In case the MessagesEmployees found by the `where` argument doesn't exist, create a new MessagesEmployees with this data.
     */
    create: XOR<MessagesEmployeesCreateInput, MessagesEmployeesUncheckedCreateInput>
    /**
     * In case the MessagesEmployees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessagesEmployeesUpdateInput, MessagesEmployeesUncheckedUpdateInput>
  }

  /**
   * MessagesEmployees delete
   */
  export type MessagesEmployeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
    /**
     * Filter which MessagesEmployees to delete.
     */
    where: MessagesEmployeesWhereUniqueInput
  }

  /**
   * MessagesEmployees deleteMany
   */
  export type MessagesEmployeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessagesEmployees to delete
     */
    where?: MessagesEmployeesWhereInput
  }

  /**
   * MessagesEmployees.MessagesEmployees
   */
  export type MessagesEmployees$MessagesEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
    where?: MessagesEmployeesWhereInput
  }

  /**
   * MessagesEmployees.other_MessagesEmployees
   */
  export type MessagesEmployees$other_MessagesEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
    where?: MessagesEmployeesWhereInput
    orderBy?: MessagesEmployeesOrderByWithRelationInput | MessagesEmployeesOrderByWithRelationInput[]
    cursor?: MessagesEmployeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesEmployeesScalarFieldEnum | MessagesEmployeesScalarFieldEnum[]
  }

  /**
   * MessagesEmployees without action
   */
  export type MessagesEmployeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
  }


  /**
   * Model MessagesStatus
   */

  export type AggregateMessagesStatus = {
    _count: MessagesStatusCountAggregateOutputType | null
    _avg: MessagesStatusAvgAggregateOutputType | null
    _sum: MessagesStatusSumAggregateOutputType | null
    _min: MessagesStatusMinAggregateOutputType | null
    _max: MessagesStatusMaxAggregateOutputType | null
  }

  export type MessagesStatusAvgAggregateOutputType = {
    Sort: number | null
  }

  export type MessagesStatusSumAggregateOutputType = {
    Sort: number | null
  }

  export type MessagesStatusMinAggregateOutputType = {
    MessagesStatusId: string | null
    MessagesStatusName: string | null
    CreatedAt: Date | null
    Sort: number | null
    Comments: string | null
  }

  export type MessagesStatusMaxAggregateOutputType = {
    MessagesStatusId: string | null
    MessagesStatusName: string | null
    CreatedAt: Date | null
    Sort: number | null
    Comments: string | null
  }

  export type MessagesStatusCountAggregateOutputType = {
    MessagesStatusId: number
    MessagesStatusName: number
    CreatedAt: number
    Sort: number
    Comments: number
    _all: number
  }


  export type MessagesStatusAvgAggregateInputType = {
    Sort?: true
  }

  export type MessagesStatusSumAggregateInputType = {
    Sort?: true
  }

  export type MessagesStatusMinAggregateInputType = {
    MessagesStatusId?: true
    MessagesStatusName?: true
    CreatedAt?: true
    Sort?: true
    Comments?: true
  }

  export type MessagesStatusMaxAggregateInputType = {
    MessagesStatusId?: true
    MessagesStatusName?: true
    CreatedAt?: true
    Sort?: true
    Comments?: true
  }

  export type MessagesStatusCountAggregateInputType = {
    MessagesStatusId?: true
    MessagesStatusName?: true
    CreatedAt?: true
    Sort?: true
    Comments?: true
    _all?: true
  }

  export type MessagesStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessagesStatus to aggregate.
     */
    where?: MessagesStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessagesStatuses to fetch.
     */
    orderBy?: MessagesStatusOrderByWithRelationInput | MessagesStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessagesStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessagesStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessagesStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessagesStatuses
    **/
    _count?: true | MessagesStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessagesStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessagesStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesStatusMaxAggregateInputType
  }

  export type GetMessagesStatusAggregateType<T extends MessagesStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateMessagesStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessagesStatus[P]>
      : GetScalarType<T[P], AggregateMessagesStatus[P]>
  }




  export type MessagesStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesStatusWhereInput
    orderBy?: MessagesStatusOrderByWithAggregationInput | MessagesStatusOrderByWithAggregationInput[]
    by: MessagesStatusScalarFieldEnum[] | MessagesStatusScalarFieldEnum
    having?: MessagesStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesStatusCountAggregateInputType | true
    _avg?: MessagesStatusAvgAggregateInputType
    _sum?: MessagesStatusSumAggregateInputType
    _min?: MessagesStatusMinAggregateInputType
    _max?: MessagesStatusMaxAggregateInputType
  }

  export type MessagesStatusGroupByOutputType = {
    MessagesStatusId: string
    MessagesStatusName: string
    CreatedAt: Date | null
    Sort: number
    Comments: string | null
    _count: MessagesStatusCountAggregateOutputType | null
    _avg: MessagesStatusAvgAggregateOutputType | null
    _sum: MessagesStatusSumAggregateOutputType | null
    _min: MessagesStatusMinAggregateOutputType | null
    _max: MessagesStatusMaxAggregateOutputType | null
  }

  type GetMessagesStatusGroupByPayload<T extends MessagesStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesStatusGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesStatusGroupByOutputType[P]>
        }
      >
    >


  export type MessagesStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MessagesStatusId?: boolean
    MessagesStatusName?: boolean
    CreatedAt?: boolean
    Sort?: boolean
    Comments?: boolean
    MessagesEmployees?: boolean | MessagesStatus$MessagesEmployeesArgs<ExtArgs>
    _count?: boolean | MessagesStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messagesStatus"]>


  export type MessagesStatusSelectScalar = {
    MessagesStatusId?: boolean
    MessagesStatusName?: boolean
    CreatedAt?: boolean
    Sort?: boolean
    Comments?: boolean
  }

  export type MessagesStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessagesEmployees?: boolean | MessagesStatus$MessagesEmployeesArgs<ExtArgs>
    _count?: boolean | MessagesStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MessagesStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessagesStatus"
    objects: {
      MessagesEmployees: Prisma.$MessagesEmployeesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      MessagesStatusId: string
      MessagesStatusName: string
      CreatedAt: Date | null
      Sort: number
      Comments: string | null
    }, ExtArgs["result"]["messagesStatus"]>
    composites: {}
  }

  type MessagesStatusGetPayload<S extends boolean | null | undefined | MessagesStatusDefaultArgs> = $Result.GetResult<Prisma.$MessagesStatusPayload, S>

  type MessagesStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessagesStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessagesStatusCountAggregateInputType | true
    }

  export interface MessagesStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessagesStatus'], meta: { name: 'MessagesStatus' } }
    /**
     * Find zero or one MessagesStatus that matches the filter.
     * @param {MessagesStatusFindUniqueArgs} args - Arguments to find a MessagesStatus
     * @example
     * // Get one MessagesStatus
     * const messagesStatus = await prisma.messagesStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessagesStatusFindUniqueArgs>(args: SelectSubset<T, MessagesStatusFindUniqueArgs<ExtArgs>>): Prisma__MessagesStatusClient<$Result.GetResult<Prisma.$MessagesStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessagesStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessagesStatusFindUniqueOrThrowArgs} args - Arguments to find a MessagesStatus
     * @example
     * // Get one MessagesStatus
     * const messagesStatus = await prisma.messagesStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessagesStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, MessagesStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessagesStatusClient<$Result.GetResult<Prisma.$MessagesStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessagesStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesStatusFindFirstArgs} args - Arguments to find a MessagesStatus
     * @example
     * // Get one MessagesStatus
     * const messagesStatus = await prisma.messagesStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessagesStatusFindFirstArgs>(args?: SelectSubset<T, MessagesStatusFindFirstArgs<ExtArgs>>): Prisma__MessagesStatusClient<$Result.GetResult<Prisma.$MessagesStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessagesStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesStatusFindFirstOrThrowArgs} args - Arguments to find a MessagesStatus
     * @example
     * // Get one MessagesStatus
     * const messagesStatus = await prisma.messagesStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessagesStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, MessagesStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessagesStatusClient<$Result.GetResult<Prisma.$MessagesStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessagesStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessagesStatuses
     * const messagesStatuses = await prisma.messagesStatus.findMany()
     * 
     * // Get first 10 MessagesStatuses
     * const messagesStatuses = await prisma.messagesStatus.findMany({ take: 10 })
     * 
     * // Only select the `MessagesStatusId`
     * const messagesStatusWithMessagesStatusIdOnly = await prisma.messagesStatus.findMany({ select: { MessagesStatusId: true } })
     * 
     */
    findMany<T extends MessagesStatusFindManyArgs>(args?: SelectSubset<T, MessagesStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessagesStatus.
     * @param {MessagesStatusCreateArgs} args - Arguments to create a MessagesStatus.
     * @example
     * // Create one MessagesStatus
     * const MessagesStatus = await prisma.messagesStatus.create({
     *   data: {
     *     // ... data to create a MessagesStatus
     *   }
     * })
     * 
     */
    create<T extends MessagesStatusCreateArgs>(args: SelectSubset<T, MessagesStatusCreateArgs<ExtArgs>>): Prisma__MessagesStatusClient<$Result.GetResult<Prisma.$MessagesStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessagesStatuses.
     * @param {MessagesStatusCreateManyArgs} args - Arguments to create many MessagesStatuses.
     * @example
     * // Create many MessagesStatuses
     * const messagesStatus = await prisma.messagesStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessagesStatusCreateManyArgs>(args?: SelectSubset<T, MessagesStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessagesStatus.
     * @param {MessagesStatusDeleteArgs} args - Arguments to delete one MessagesStatus.
     * @example
     * // Delete one MessagesStatus
     * const MessagesStatus = await prisma.messagesStatus.delete({
     *   where: {
     *     // ... filter to delete one MessagesStatus
     *   }
     * })
     * 
     */
    delete<T extends MessagesStatusDeleteArgs>(args: SelectSubset<T, MessagesStatusDeleteArgs<ExtArgs>>): Prisma__MessagesStatusClient<$Result.GetResult<Prisma.$MessagesStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessagesStatus.
     * @param {MessagesStatusUpdateArgs} args - Arguments to update one MessagesStatus.
     * @example
     * // Update one MessagesStatus
     * const messagesStatus = await prisma.messagesStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessagesStatusUpdateArgs>(args: SelectSubset<T, MessagesStatusUpdateArgs<ExtArgs>>): Prisma__MessagesStatusClient<$Result.GetResult<Prisma.$MessagesStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessagesStatuses.
     * @param {MessagesStatusDeleteManyArgs} args - Arguments to filter MessagesStatuses to delete.
     * @example
     * // Delete a few MessagesStatuses
     * const { count } = await prisma.messagesStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessagesStatusDeleteManyArgs>(args?: SelectSubset<T, MessagesStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessagesStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessagesStatuses
     * const messagesStatus = await prisma.messagesStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessagesStatusUpdateManyArgs>(args: SelectSubset<T, MessagesStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessagesStatus.
     * @param {MessagesStatusUpsertArgs} args - Arguments to update or create a MessagesStatus.
     * @example
     * // Update or create a MessagesStatus
     * const messagesStatus = await prisma.messagesStatus.upsert({
     *   create: {
     *     // ... data to create a MessagesStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessagesStatus we want to update
     *   }
     * })
     */
    upsert<T extends MessagesStatusUpsertArgs>(args: SelectSubset<T, MessagesStatusUpsertArgs<ExtArgs>>): Prisma__MessagesStatusClient<$Result.GetResult<Prisma.$MessagesStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessagesStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesStatusCountArgs} args - Arguments to filter MessagesStatuses to count.
     * @example
     * // Count the number of MessagesStatuses
     * const count = await prisma.messagesStatus.count({
     *   where: {
     *     // ... the filter for the MessagesStatuses we want to count
     *   }
     * })
    **/
    count<T extends MessagesStatusCountArgs>(
      args?: Subset<T, MessagesStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessagesStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesStatusAggregateArgs>(args: Subset<T, MessagesStatusAggregateArgs>): Prisma.PrismaPromise<GetMessagesStatusAggregateType<T>>

    /**
     * Group by MessagesStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessagesStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessagesStatusGroupByArgs['orderBy'] }
        : { orderBy?: MessagesStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessagesStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessagesStatus model
   */
  readonly fields: MessagesStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessagesStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessagesStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MessagesEmployees<T extends MessagesStatus$MessagesEmployeesArgs<ExtArgs> = {}>(args?: Subset<T, MessagesStatus$MessagesEmployeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesEmployeesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessagesStatus model
   */ 
  interface MessagesStatusFieldRefs {
    readonly MessagesStatusId: FieldRef<"MessagesStatus", 'String'>
    readonly MessagesStatusName: FieldRef<"MessagesStatus", 'String'>
    readonly CreatedAt: FieldRef<"MessagesStatus", 'DateTime'>
    readonly Sort: FieldRef<"MessagesStatus", 'Int'>
    readonly Comments: FieldRef<"MessagesStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MessagesStatus findUnique
   */
  export type MessagesStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesStatus
     */
    select?: MessagesStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesStatusInclude<ExtArgs> | null
    /**
     * Filter, which MessagesStatus to fetch.
     */
    where: MessagesStatusWhereUniqueInput
  }

  /**
   * MessagesStatus findUniqueOrThrow
   */
  export type MessagesStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesStatus
     */
    select?: MessagesStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesStatusInclude<ExtArgs> | null
    /**
     * Filter, which MessagesStatus to fetch.
     */
    where: MessagesStatusWhereUniqueInput
  }

  /**
   * MessagesStatus findFirst
   */
  export type MessagesStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesStatus
     */
    select?: MessagesStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesStatusInclude<ExtArgs> | null
    /**
     * Filter, which MessagesStatus to fetch.
     */
    where?: MessagesStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessagesStatuses to fetch.
     */
    orderBy?: MessagesStatusOrderByWithRelationInput | MessagesStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessagesStatuses.
     */
    cursor?: MessagesStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessagesStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessagesStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessagesStatuses.
     */
    distinct?: MessagesStatusScalarFieldEnum | MessagesStatusScalarFieldEnum[]
  }

  /**
   * MessagesStatus findFirstOrThrow
   */
  export type MessagesStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesStatus
     */
    select?: MessagesStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesStatusInclude<ExtArgs> | null
    /**
     * Filter, which MessagesStatus to fetch.
     */
    where?: MessagesStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessagesStatuses to fetch.
     */
    orderBy?: MessagesStatusOrderByWithRelationInput | MessagesStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessagesStatuses.
     */
    cursor?: MessagesStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessagesStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessagesStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessagesStatuses.
     */
    distinct?: MessagesStatusScalarFieldEnum | MessagesStatusScalarFieldEnum[]
  }

  /**
   * MessagesStatus findMany
   */
  export type MessagesStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesStatus
     */
    select?: MessagesStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesStatusInclude<ExtArgs> | null
    /**
     * Filter, which MessagesStatuses to fetch.
     */
    where?: MessagesStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessagesStatuses to fetch.
     */
    orderBy?: MessagesStatusOrderByWithRelationInput | MessagesStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessagesStatuses.
     */
    cursor?: MessagesStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessagesStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessagesStatuses.
     */
    skip?: number
    distinct?: MessagesStatusScalarFieldEnum | MessagesStatusScalarFieldEnum[]
  }

  /**
   * MessagesStatus create
   */
  export type MessagesStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesStatus
     */
    select?: MessagesStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a MessagesStatus.
     */
    data: XOR<MessagesStatusCreateInput, MessagesStatusUncheckedCreateInput>
  }

  /**
   * MessagesStatus createMany
   */
  export type MessagesStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessagesStatuses.
     */
    data: MessagesStatusCreateManyInput | MessagesStatusCreateManyInput[]
  }

  /**
   * MessagesStatus update
   */
  export type MessagesStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesStatus
     */
    select?: MessagesStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a MessagesStatus.
     */
    data: XOR<MessagesStatusUpdateInput, MessagesStatusUncheckedUpdateInput>
    /**
     * Choose, which MessagesStatus to update.
     */
    where: MessagesStatusWhereUniqueInput
  }

  /**
   * MessagesStatus updateMany
   */
  export type MessagesStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessagesStatuses.
     */
    data: XOR<MessagesStatusUpdateManyMutationInput, MessagesStatusUncheckedUpdateManyInput>
    /**
     * Filter which MessagesStatuses to update
     */
    where?: MessagesStatusWhereInput
  }

  /**
   * MessagesStatus upsert
   */
  export type MessagesStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesStatus
     */
    select?: MessagesStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the MessagesStatus to update in case it exists.
     */
    where: MessagesStatusWhereUniqueInput
    /**
     * In case the MessagesStatus found by the `where` argument doesn't exist, create a new MessagesStatus with this data.
     */
    create: XOR<MessagesStatusCreateInput, MessagesStatusUncheckedCreateInput>
    /**
     * In case the MessagesStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessagesStatusUpdateInput, MessagesStatusUncheckedUpdateInput>
  }

  /**
   * MessagesStatus delete
   */
  export type MessagesStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesStatus
     */
    select?: MessagesStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesStatusInclude<ExtArgs> | null
    /**
     * Filter which MessagesStatus to delete.
     */
    where: MessagesStatusWhereUniqueInput
  }

  /**
   * MessagesStatus deleteMany
   */
  export type MessagesStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessagesStatuses to delete
     */
    where?: MessagesStatusWhereInput
  }

  /**
   * MessagesStatus.MessagesEmployees
   */
  export type MessagesStatus$MessagesEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesEmployees
     */
    select?: MessagesEmployeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesEmployeesInclude<ExtArgs> | null
    where?: MessagesEmployeesWhereInput
    orderBy?: MessagesEmployeesOrderByWithRelationInput | MessagesEmployeesOrderByWithRelationInput[]
    cursor?: MessagesEmployeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesEmployeesScalarFieldEnum | MessagesEmployeesScalarFieldEnum[]
  }

  /**
   * MessagesStatus without action
   */
  export type MessagesStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesStatus
     */
    select?: MessagesStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesStatusInclude<ExtArgs> | null
  }


  /**
   * Model SiteConfig
   */

  export type AggregateSiteConfig = {
    _count: SiteConfigCountAggregateOutputType | null
    _avg: SiteConfigAvgAggregateOutputType | null
    _sum: SiteConfigSumAggregateOutputType | null
    _min: SiteConfigMinAggregateOutputType | null
    _max: SiteConfigMaxAggregateOutputType | null
  }

  export type SiteConfigAvgAggregateOutputType = {
    SiteConfigId: number | null
    PropertyIntValue: number | null
  }

  export type SiteConfigSumAggregateOutputType = {
    SiteConfigId: number | null
    PropertyIntValue: number | null
  }

  export type SiteConfigMinAggregateOutputType = {
    SiteConfigId: number | null
    PropertyEngName: string | null
    PropertyIntValue: number | null
    PropertyTextValue: string | null
    PropertyHebDescription: string | null
    CreatedAt: Date | null
  }

  export type SiteConfigMaxAggregateOutputType = {
    SiteConfigId: number | null
    PropertyEngName: string | null
    PropertyIntValue: number | null
    PropertyTextValue: string | null
    PropertyHebDescription: string | null
    CreatedAt: Date | null
  }

  export type SiteConfigCountAggregateOutputType = {
    SiteConfigId: number
    PropertyEngName: number
    PropertyIntValue: number
    PropertyTextValue: number
    PropertyHebDescription: number
    CreatedAt: number
    _all: number
  }


  export type SiteConfigAvgAggregateInputType = {
    SiteConfigId?: true
    PropertyIntValue?: true
  }

  export type SiteConfigSumAggregateInputType = {
    SiteConfigId?: true
    PropertyIntValue?: true
  }

  export type SiteConfigMinAggregateInputType = {
    SiteConfigId?: true
    PropertyEngName?: true
    PropertyIntValue?: true
    PropertyTextValue?: true
    PropertyHebDescription?: true
    CreatedAt?: true
  }

  export type SiteConfigMaxAggregateInputType = {
    SiteConfigId?: true
    PropertyEngName?: true
    PropertyIntValue?: true
    PropertyTextValue?: true
    PropertyHebDescription?: true
    CreatedAt?: true
  }

  export type SiteConfigCountAggregateInputType = {
    SiteConfigId?: true
    PropertyEngName?: true
    PropertyIntValue?: true
    PropertyTextValue?: true
    PropertyHebDescription?: true
    CreatedAt?: true
    _all?: true
  }

  export type SiteConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteConfig to aggregate.
     */
    where?: SiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigs to fetch.
     */
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteConfigs
    **/
    _count?: true | SiteConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SiteConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SiteConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteConfigMaxAggregateInputType
  }

  export type GetSiteConfigAggregateType<T extends SiteConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteConfig[P]>
      : GetScalarType<T[P], AggregateSiteConfig[P]>
  }




  export type SiteConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteConfigWhereInput
    orderBy?: SiteConfigOrderByWithAggregationInput | SiteConfigOrderByWithAggregationInput[]
    by: SiteConfigScalarFieldEnum[] | SiteConfigScalarFieldEnum
    having?: SiteConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteConfigCountAggregateInputType | true
    _avg?: SiteConfigAvgAggregateInputType
    _sum?: SiteConfigSumAggregateInputType
    _min?: SiteConfigMinAggregateInputType
    _max?: SiteConfigMaxAggregateInputType
  }

  export type SiteConfigGroupByOutputType = {
    SiteConfigId: number
    PropertyEngName: string
    PropertyIntValue: number | null
    PropertyTextValue: string | null
    PropertyHebDescription: string
    CreatedAt: Date | null
    _count: SiteConfigCountAggregateOutputType | null
    _avg: SiteConfigAvgAggregateOutputType | null
    _sum: SiteConfigSumAggregateOutputType | null
    _min: SiteConfigMinAggregateOutputType | null
    _max: SiteConfigMaxAggregateOutputType | null
  }

  type GetSiteConfigGroupByPayload<T extends SiteConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SiteConfigGroupByOutputType[P]>
        }
      >
    >


  export type SiteConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SiteConfigId?: boolean
    PropertyEngName?: boolean
    PropertyIntValue?: boolean
    PropertyTextValue?: boolean
    PropertyHebDescription?: boolean
    CreatedAt?: boolean
  }, ExtArgs["result"]["siteConfig"]>


  export type SiteConfigSelectScalar = {
    SiteConfigId?: boolean
    PropertyEngName?: boolean
    PropertyIntValue?: boolean
    PropertyTextValue?: boolean
    PropertyHebDescription?: boolean
    CreatedAt?: boolean
  }


  export type $SiteConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SiteConfigId: number
      PropertyEngName: string
      PropertyIntValue: number | null
      PropertyTextValue: string | null
      PropertyHebDescription: string
      CreatedAt: Date | null
    }, ExtArgs["result"]["siteConfig"]>
    composites: {}
  }

  type SiteConfigGetPayload<S extends boolean | null | undefined | SiteConfigDefaultArgs> = $Result.GetResult<Prisma.$SiteConfigPayload, S>

  type SiteConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SiteConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SiteConfigCountAggregateInputType | true
    }

  export interface SiteConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteConfig'], meta: { name: 'SiteConfig' } }
    /**
     * Find zero or one SiteConfig that matches the filter.
     * @param {SiteConfigFindUniqueArgs} args - Arguments to find a SiteConfig
     * @example
     * // Get one SiteConfig
     * const siteConfig = await prisma.siteConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteConfigFindUniqueArgs>(args: SelectSubset<T, SiteConfigFindUniqueArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SiteConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SiteConfigFindUniqueOrThrowArgs} args - Arguments to find a SiteConfig
     * @example
     * // Get one SiteConfig
     * const siteConfig = await prisma.siteConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SiteConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigFindFirstArgs} args - Arguments to find a SiteConfig
     * @example
     * // Get one SiteConfig
     * const siteConfig = await prisma.siteConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteConfigFindFirstArgs>(args?: SelectSubset<T, SiteConfigFindFirstArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SiteConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigFindFirstOrThrowArgs} args - Arguments to find a SiteConfig
     * @example
     * // Get one SiteConfig
     * const siteConfig = await prisma.siteConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SiteConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteConfigs
     * const siteConfigs = await prisma.siteConfig.findMany()
     * 
     * // Get first 10 SiteConfigs
     * const siteConfigs = await prisma.siteConfig.findMany({ take: 10 })
     * 
     * // Only select the `SiteConfigId`
     * const siteConfigWithSiteConfigIdOnly = await prisma.siteConfig.findMany({ select: { SiteConfigId: true } })
     * 
     */
    findMany<T extends SiteConfigFindManyArgs>(args?: SelectSubset<T, SiteConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SiteConfig.
     * @param {SiteConfigCreateArgs} args - Arguments to create a SiteConfig.
     * @example
     * // Create one SiteConfig
     * const SiteConfig = await prisma.siteConfig.create({
     *   data: {
     *     // ... data to create a SiteConfig
     *   }
     * })
     * 
     */
    create<T extends SiteConfigCreateArgs>(args: SelectSubset<T, SiteConfigCreateArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SiteConfigs.
     * @param {SiteConfigCreateManyArgs} args - Arguments to create many SiteConfigs.
     * @example
     * // Create many SiteConfigs
     * const siteConfig = await prisma.siteConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteConfigCreateManyArgs>(args?: SelectSubset<T, SiteConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SiteConfig.
     * @param {SiteConfigDeleteArgs} args - Arguments to delete one SiteConfig.
     * @example
     * // Delete one SiteConfig
     * const SiteConfig = await prisma.siteConfig.delete({
     *   where: {
     *     // ... filter to delete one SiteConfig
     *   }
     * })
     * 
     */
    delete<T extends SiteConfigDeleteArgs>(args: SelectSubset<T, SiteConfigDeleteArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SiteConfig.
     * @param {SiteConfigUpdateArgs} args - Arguments to update one SiteConfig.
     * @example
     * // Update one SiteConfig
     * const siteConfig = await prisma.siteConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteConfigUpdateArgs>(args: SelectSubset<T, SiteConfigUpdateArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SiteConfigs.
     * @param {SiteConfigDeleteManyArgs} args - Arguments to filter SiteConfigs to delete.
     * @example
     * // Delete a few SiteConfigs
     * const { count } = await prisma.siteConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteConfigDeleteManyArgs>(args?: SelectSubset<T, SiteConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteConfigs
     * const siteConfig = await prisma.siteConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteConfigUpdateManyArgs>(args: SelectSubset<T, SiteConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SiteConfig.
     * @param {SiteConfigUpsertArgs} args - Arguments to update or create a SiteConfig.
     * @example
     * // Update or create a SiteConfig
     * const siteConfig = await prisma.siteConfig.upsert({
     *   create: {
     *     // ... data to create a SiteConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteConfig we want to update
     *   }
     * })
     */
    upsert<T extends SiteConfigUpsertArgs>(args: SelectSubset<T, SiteConfigUpsertArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SiteConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigCountArgs} args - Arguments to filter SiteConfigs to count.
     * @example
     * // Count the number of SiteConfigs
     * const count = await prisma.siteConfig.count({
     *   where: {
     *     // ... the filter for the SiteConfigs we want to count
     *   }
     * })
    **/
    count<T extends SiteConfigCountArgs>(
      args?: Subset<T, SiteConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteConfigAggregateArgs>(args: Subset<T, SiteConfigAggregateArgs>): Prisma.PrismaPromise<GetSiteConfigAggregateType<T>>

    /**
     * Group by SiteConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteConfigGroupByArgs['orderBy'] }
        : { orderBy?: SiteConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteConfig model
   */
  readonly fields: SiteConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteConfig model
   */ 
  interface SiteConfigFieldRefs {
    readonly SiteConfigId: FieldRef<"SiteConfig", 'Int'>
    readonly PropertyEngName: FieldRef<"SiteConfig", 'String'>
    readonly PropertyIntValue: FieldRef<"SiteConfig", 'Float'>
    readonly PropertyTextValue: FieldRef<"SiteConfig", 'String'>
    readonly PropertyHebDescription: FieldRef<"SiteConfig", 'String'>
    readonly CreatedAt: FieldRef<"SiteConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteConfig findUnique
   */
  export type SiteConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Filter, which SiteConfig to fetch.
     */
    where: SiteConfigWhereUniqueInput
  }

  /**
   * SiteConfig findUniqueOrThrow
   */
  export type SiteConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Filter, which SiteConfig to fetch.
     */
    where: SiteConfigWhereUniqueInput
  }

  /**
   * SiteConfig findFirst
   */
  export type SiteConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Filter, which SiteConfig to fetch.
     */
    where?: SiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigs to fetch.
     */
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteConfigs.
     */
    cursor?: SiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteConfigs.
     */
    distinct?: SiteConfigScalarFieldEnum | SiteConfigScalarFieldEnum[]
  }

  /**
   * SiteConfig findFirstOrThrow
   */
  export type SiteConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Filter, which SiteConfig to fetch.
     */
    where?: SiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigs to fetch.
     */
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteConfigs.
     */
    cursor?: SiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteConfigs.
     */
    distinct?: SiteConfigScalarFieldEnum | SiteConfigScalarFieldEnum[]
  }

  /**
   * SiteConfig findMany
   */
  export type SiteConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Filter, which SiteConfigs to fetch.
     */
    where?: SiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigs to fetch.
     */
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteConfigs.
     */
    cursor?: SiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigs.
     */
    skip?: number
    distinct?: SiteConfigScalarFieldEnum | SiteConfigScalarFieldEnum[]
  }

  /**
   * SiteConfig create
   */
  export type SiteConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a SiteConfig.
     */
    data: XOR<SiteConfigCreateInput, SiteConfigUncheckedCreateInput>
  }

  /**
   * SiteConfig createMany
   */
  export type SiteConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteConfigs.
     */
    data: SiteConfigCreateManyInput | SiteConfigCreateManyInput[]
  }

  /**
   * SiteConfig update
   */
  export type SiteConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a SiteConfig.
     */
    data: XOR<SiteConfigUpdateInput, SiteConfigUncheckedUpdateInput>
    /**
     * Choose, which SiteConfig to update.
     */
    where: SiteConfigWhereUniqueInput
  }

  /**
   * SiteConfig updateMany
   */
  export type SiteConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteConfigs.
     */
    data: XOR<SiteConfigUpdateManyMutationInput, SiteConfigUncheckedUpdateManyInput>
    /**
     * Filter which SiteConfigs to update
     */
    where?: SiteConfigWhereInput
  }

  /**
   * SiteConfig upsert
   */
  export type SiteConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the SiteConfig to update in case it exists.
     */
    where: SiteConfigWhereUniqueInput
    /**
     * In case the SiteConfig found by the `where` argument doesn't exist, create a new SiteConfig with this data.
     */
    create: XOR<SiteConfigCreateInput, SiteConfigUncheckedCreateInput>
    /**
     * In case the SiteConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteConfigUpdateInput, SiteConfigUncheckedUpdateInput>
  }

  /**
   * SiteConfig delete
   */
  export type SiteConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Filter which SiteConfig to delete.
     */
    where: SiteConfigWhereUniqueInput
  }

  /**
   * SiteConfig deleteMany
   */
  export type SiteConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteConfigs to delete
     */
    where?: SiteConfigWhereInput
  }

  /**
   * SiteConfig without action
   */
  export type SiteConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
  }


  /**
   * Model sysdiagrams
   */

  export type AggregateSysdiagrams = {
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  export type SysdiagramsAvgAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsSumAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsMinAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Uint8Array | null
  }

  export type SysdiagramsMaxAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Uint8Array | null
  }

  export type SysdiagramsCountAggregateOutputType = {
    name: number
    principal_id: number
    diagram_id: number
    version: number
    definition: number
    _all: number
  }


  export type SysdiagramsAvgAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsSumAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsMinAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsMaxAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsCountAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
    _all?: true
  }

  export type SysdiagramsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to aggregate.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sysdiagrams
    **/
    _count?: true | SysdiagramsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SysdiagramsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SysdiagramsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SysdiagramsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type GetSysdiagramsAggregateType<T extends SysdiagramsAggregateArgs> = {
        [P in keyof T & keyof AggregateSysdiagrams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSysdiagrams[P]>
      : GetScalarType<T[P], AggregateSysdiagrams[P]>
  }




  export type sysdiagramsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sysdiagramsWhereInput
    orderBy?: sysdiagramsOrderByWithAggregationInput | sysdiagramsOrderByWithAggregationInput[]
    by: SysdiagramsScalarFieldEnum[] | SysdiagramsScalarFieldEnum
    having?: sysdiagramsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SysdiagramsCountAggregateInputType | true
    _avg?: SysdiagramsAvgAggregateInputType
    _sum?: SysdiagramsSumAggregateInputType
    _min?: SysdiagramsMinAggregateInputType
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type SysdiagramsGroupByOutputType = {
    name: string
    principal_id: number
    diagram_id: number
    version: number | null
    definition: Uint8Array | null
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  type GetSysdiagramsGroupByPayload<T extends sysdiagramsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SysdiagramsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SysdiagramsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
            : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
        }
      >
    >


  export type sysdiagramsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }, ExtArgs["result"]["sysdiagrams"]>


  export type sysdiagramsSelectScalar = {
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }


  export type $sysdiagramsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sysdiagrams"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      name: string
      principal_id: number
      diagram_id: number
      version: number | null
      definition: Uint8Array | null
    }, ExtArgs["result"]["sysdiagrams"]>
    composites: {}
  }

  type sysdiagramsGetPayload<S extends boolean | null | undefined | sysdiagramsDefaultArgs> = $Result.GetResult<Prisma.$sysdiagramsPayload, S>

  type sysdiagramsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sysdiagramsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SysdiagramsCountAggregateInputType | true
    }

  export interface sysdiagramsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sysdiagrams'], meta: { name: 'sysdiagrams' } }
    /**
     * Find zero or one Sysdiagrams that matches the filter.
     * @param {sysdiagramsFindUniqueArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sysdiagramsFindUniqueArgs>(args: SelectSubset<T, sysdiagramsFindUniqueArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sysdiagrams that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {sysdiagramsFindUniqueOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sysdiagramsFindUniqueOrThrowArgs>(args: SelectSubset<T, sysdiagramsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sysdiagramsFindFirstArgs>(args?: SelectSubset<T, sysdiagramsFindFirstArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sysdiagrams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sysdiagramsFindFirstOrThrowArgs>(args?: SelectSubset<T, sysdiagramsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany()
     * 
     * // Get first 10 Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sysdiagramsWithNameOnly = await prisma.sysdiagrams.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends sysdiagramsFindManyArgs>(args?: SelectSubset<T, sysdiagramsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sysdiagrams.
     * @param {sysdiagramsCreateArgs} args - Arguments to create a Sysdiagrams.
     * @example
     * // Create one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.create({
     *   data: {
     *     // ... data to create a Sysdiagrams
     *   }
     * })
     * 
     */
    create<T extends sysdiagramsCreateArgs>(args: SelectSubset<T, sysdiagramsCreateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sysdiagrams.
     * @param {sysdiagramsCreateManyArgs} args - Arguments to create many Sysdiagrams.
     * @example
     * // Create many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sysdiagramsCreateManyArgs>(args?: SelectSubset<T, sysdiagramsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sysdiagrams.
     * @param {sysdiagramsDeleteArgs} args - Arguments to delete one Sysdiagrams.
     * @example
     * // Delete one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.delete({
     *   where: {
     *     // ... filter to delete one Sysdiagrams
     *   }
     * })
     * 
     */
    delete<T extends sysdiagramsDeleteArgs>(args: SelectSubset<T, sysdiagramsDeleteArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sysdiagrams.
     * @param {sysdiagramsUpdateArgs} args - Arguments to update one Sysdiagrams.
     * @example
     * // Update one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sysdiagramsUpdateArgs>(args: SelectSubset<T, sysdiagramsUpdateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sysdiagrams.
     * @param {sysdiagramsDeleteManyArgs} args - Arguments to filter Sysdiagrams to delete.
     * @example
     * // Delete a few Sysdiagrams
     * const { count } = await prisma.sysdiagrams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sysdiagramsDeleteManyArgs>(args?: SelectSubset<T, sysdiagramsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sysdiagramsUpdateManyArgs>(args: SelectSubset<T, sysdiagramsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sysdiagrams.
     * @param {sysdiagramsUpsertArgs} args - Arguments to update or create a Sysdiagrams.
     * @example
     * // Update or create a Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.upsert({
     *   create: {
     *     // ... data to create a Sysdiagrams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to update
     *   }
     * })
     */
    upsert<T extends sysdiagramsUpsertArgs>(args: SelectSubset<T, sysdiagramsUpsertArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsCountArgs} args - Arguments to filter Sysdiagrams to count.
     * @example
     * // Count the number of Sysdiagrams
     * const count = await prisma.sysdiagrams.count({
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to count
     *   }
     * })
    **/
    count<T extends sysdiagramsCountArgs>(
      args?: Subset<T, sysdiagramsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SysdiagramsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysdiagramsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SysdiagramsAggregateArgs>(args: Subset<T, SysdiagramsAggregateArgs>): Prisma.PrismaPromise<GetSysdiagramsAggregateType<T>>

    /**
     * Group by Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sysdiagramsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sysdiagramsGroupByArgs['orderBy'] }
        : { orderBy?: sysdiagramsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sysdiagramsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSysdiagramsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sysdiagrams model
   */
  readonly fields: sysdiagramsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sysdiagrams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sysdiagramsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sysdiagrams model
   */ 
  interface sysdiagramsFieldRefs {
    readonly name: FieldRef<"sysdiagrams", 'String'>
    readonly principal_id: FieldRef<"sysdiagrams", 'Int'>
    readonly diagram_id: FieldRef<"sysdiagrams", 'Int'>
    readonly version: FieldRef<"sysdiagrams", 'Int'>
    readonly definition: FieldRef<"sysdiagrams", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * sysdiagrams findUnique
   */
  export type sysdiagramsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findUniqueOrThrow
   */
  export type sysdiagramsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findFirst
   */
  export type sysdiagramsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findFirstOrThrow
   */
  export type sysdiagramsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findMany
   */
  export type sysdiagramsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams create
   */
  export type sysdiagramsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * The data needed to create a sysdiagrams.
     */
    data: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
  }

  /**
   * sysdiagrams createMany
   */
  export type sysdiagramsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sysdiagrams.
     */
    data: sysdiagramsCreateManyInput | sysdiagramsCreateManyInput[]
  }

  /**
   * sysdiagrams update
   */
  export type sysdiagramsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * The data needed to update a sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
    /**
     * Choose, which sysdiagrams to update.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams updateMany
   */
  export type sysdiagramsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateManyMutationInput, sysdiagramsUncheckedUpdateManyInput>
    /**
     * Filter which sysdiagrams to update
     */
    where?: sysdiagramsWhereInput
  }

  /**
   * sysdiagrams upsert
   */
  export type sysdiagramsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * The filter to search for the sysdiagrams to update in case it exists.
     */
    where: sysdiagramsWhereUniqueInput
    /**
     * In case the sysdiagrams found by the `where` argument doesn't exist, create a new sysdiagrams with this data.
     */
    create: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
    /**
     * In case the sysdiagrams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
  }

  /**
   * sysdiagrams delete
   */
  export type sysdiagramsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Filter which sysdiagrams to delete.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams deleteMany
   */
  export type sysdiagramsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to delete
     */
    where?: sysdiagramsWhereInput
  }

  /**
   * sysdiagrams without action
   */
  export type sysdiagramsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
  }


  /**
   * Model UsersLinkedViewRole
   */

  export type AggregateUsersLinkedViewRole = {
    _count: UsersLinkedViewRoleCountAggregateOutputType | null
    _min: UsersLinkedViewRoleMinAggregateOutputType | null
    _max: UsersLinkedViewRoleMaxAggregateOutputType | null
  }

  export type UsersLinkedViewRoleMinAggregateOutputType = {
    UsersLinkedViewRoleId: string | null
    CreatedAt: Date | null
    CompanyID: string | null
    UserID: string | null
    UserViewRolesId: string | null
  }

  export type UsersLinkedViewRoleMaxAggregateOutputType = {
    UsersLinkedViewRoleId: string | null
    CreatedAt: Date | null
    CompanyID: string | null
    UserID: string | null
    UserViewRolesId: string | null
  }

  export type UsersLinkedViewRoleCountAggregateOutputType = {
    UsersLinkedViewRoleId: number
    CreatedAt: number
    CompanyID: number
    UserID: number
    UserViewRolesId: number
    _all: number
  }


  export type UsersLinkedViewRoleMinAggregateInputType = {
    UsersLinkedViewRoleId?: true
    CreatedAt?: true
    CompanyID?: true
    UserID?: true
    UserViewRolesId?: true
  }

  export type UsersLinkedViewRoleMaxAggregateInputType = {
    UsersLinkedViewRoleId?: true
    CreatedAt?: true
    CompanyID?: true
    UserID?: true
    UserViewRolesId?: true
  }

  export type UsersLinkedViewRoleCountAggregateInputType = {
    UsersLinkedViewRoleId?: true
    CreatedAt?: true
    CompanyID?: true
    UserID?: true
    UserViewRolesId?: true
    _all?: true
  }

  export type UsersLinkedViewRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersLinkedViewRole to aggregate.
     */
    where?: UsersLinkedViewRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersLinkedViewRoles to fetch.
     */
    orderBy?: UsersLinkedViewRoleOrderByWithRelationInput | UsersLinkedViewRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersLinkedViewRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersLinkedViewRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersLinkedViewRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersLinkedViewRoles
    **/
    _count?: true | UsersLinkedViewRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersLinkedViewRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersLinkedViewRoleMaxAggregateInputType
  }

  export type GetUsersLinkedViewRoleAggregateType<T extends UsersLinkedViewRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersLinkedViewRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersLinkedViewRole[P]>
      : GetScalarType<T[P], AggregateUsersLinkedViewRole[P]>
  }




  export type UsersLinkedViewRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersLinkedViewRoleWhereInput
    orderBy?: UsersLinkedViewRoleOrderByWithAggregationInput | UsersLinkedViewRoleOrderByWithAggregationInput[]
    by: UsersLinkedViewRoleScalarFieldEnum[] | UsersLinkedViewRoleScalarFieldEnum
    having?: UsersLinkedViewRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersLinkedViewRoleCountAggregateInputType | true
    _min?: UsersLinkedViewRoleMinAggregateInputType
    _max?: UsersLinkedViewRoleMaxAggregateInputType
  }

  export type UsersLinkedViewRoleGroupByOutputType = {
    UsersLinkedViewRoleId: string
    CreatedAt: Date | null
    CompanyID: string
    UserID: string
    UserViewRolesId: string
    _count: UsersLinkedViewRoleCountAggregateOutputType | null
    _min: UsersLinkedViewRoleMinAggregateOutputType | null
    _max: UsersLinkedViewRoleMaxAggregateOutputType | null
  }

  type GetUsersLinkedViewRoleGroupByPayload<T extends UsersLinkedViewRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersLinkedViewRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersLinkedViewRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersLinkedViewRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UsersLinkedViewRoleGroupByOutputType[P]>
        }
      >
    >


  export type UsersLinkedViewRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UsersLinkedViewRoleId?: boolean
    CreatedAt?: boolean
    CompanyID?: boolean
    UserID?: boolean
    UserViewRolesId?: boolean
    UserViewRoles?: boolean | UserViewRolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersLinkedViewRole"]>


  export type UsersLinkedViewRoleSelectScalar = {
    UsersLinkedViewRoleId?: boolean
    CreatedAt?: boolean
    CompanyID?: boolean
    UserID?: boolean
    UserViewRolesId?: boolean
  }

  export type UsersLinkedViewRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserViewRoles?: boolean | UserViewRolesDefaultArgs<ExtArgs>
  }

  export type $UsersLinkedViewRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsersLinkedViewRole"
    objects: {
      UserViewRoles: Prisma.$UserViewRolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      UsersLinkedViewRoleId: string
      CreatedAt: Date | null
      CompanyID: string
      UserID: string
      UserViewRolesId: string
    }, ExtArgs["result"]["usersLinkedViewRole"]>
    composites: {}
  }

  type UsersLinkedViewRoleGetPayload<S extends boolean | null | undefined | UsersLinkedViewRoleDefaultArgs> = $Result.GetResult<Prisma.$UsersLinkedViewRolePayload, S>

  type UsersLinkedViewRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersLinkedViewRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersLinkedViewRoleCountAggregateInputType | true
    }

  export interface UsersLinkedViewRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsersLinkedViewRole'], meta: { name: 'UsersLinkedViewRole' } }
    /**
     * Find zero or one UsersLinkedViewRole that matches the filter.
     * @param {UsersLinkedViewRoleFindUniqueArgs} args - Arguments to find a UsersLinkedViewRole
     * @example
     * // Get one UsersLinkedViewRole
     * const usersLinkedViewRole = await prisma.usersLinkedViewRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersLinkedViewRoleFindUniqueArgs>(args: SelectSubset<T, UsersLinkedViewRoleFindUniqueArgs<ExtArgs>>): Prisma__UsersLinkedViewRoleClient<$Result.GetResult<Prisma.$UsersLinkedViewRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsersLinkedViewRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsersLinkedViewRoleFindUniqueOrThrowArgs} args - Arguments to find a UsersLinkedViewRole
     * @example
     * // Get one UsersLinkedViewRole
     * const usersLinkedViewRole = await prisma.usersLinkedViewRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersLinkedViewRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersLinkedViewRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersLinkedViewRoleClient<$Result.GetResult<Prisma.$UsersLinkedViewRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsersLinkedViewRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLinkedViewRoleFindFirstArgs} args - Arguments to find a UsersLinkedViewRole
     * @example
     * // Get one UsersLinkedViewRole
     * const usersLinkedViewRole = await prisma.usersLinkedViewRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersLinkedViewRoleFindFirstArgs>(args?: SelectSubset<T, UsersLinkedViewRoleFindFirstArgs<ExtArgs>>): Prisma__UsersLinkedViewRoleClient<$Result.GetResult<Prisma.$UsersLinkedViewRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsersLinkedViewRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLinkedViewRoleFindFirstOrThrowArgs} args - Arguments to find a UsersLinkedViewRole
     * @example
     * // Get one UsersLinkedViewRole
     * const usersLinkedViewRole = await prisma.usersLinkedViewRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersLinkedViewRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersLinkedViewRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersLinkedViewRoleClient<$Result.GetResult<Prisma.$UsersLinkedViewRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsersLinkedViewRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLinkedViewRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersLinkedViewRoles
     * const usersLinkedViewRoles = await prisma.usersLinkedViewRole.findMany()
     * 
     * // Get first 10 UsersLinkedViewRoles
     * const usersLinkedViewRoles = await prisma.usersLinkedViewRole.findMany({ take: 10 })
     * 
     * // Only select the `UsersLinkedViewRoleId`
     * const usersLinkedViewRoleWithUsersLinkedViewRoleIdOnly = await prisma.usersLinkedViewRole.findMany({ select: { UsersLinkedViewRoleId: true } })
     * 
     */
    findMany<T extends UsersLinkedViewRoleFindManyArgs>(args?: SelectSubset<T, UsersLinkedViewRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersLinkedViewRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsersLinkedViewRole.
     * @param {UsersLinkedViewRoleCreateArgs} args - Arguments to create a UsersLinkedViewRole.
     * @example
     * // Create one UsersLinkedViewRole
     * const UsersLinkedViewRole = await prisma.usersLinkedViewRole.create({
     *   data: {
     *     // ... data to create a UsersLinkedViewRole
     *   }
     * })
     * 
     */
    create<T extends UsersLinkedViewRoleCreateArgs>(args: SelectSubset<T, UsersLinkedViewRoleCreateArgs<ExtArgs>>): Prisma__UsersLinkedViewRoleClient<$Result.GetResult<Prisma.$UsersLinkedViewRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsersLinkedViewRoles.
     * @param {UsersLinkedViewRoleCreateManyArgs} args - Arguments to create many UsersLinkedViewRoles.
     * @example
     * // Create many UsersLinkedViewRoles
     * const usersLinkedViewRole = await prisma.usersLinkedViewRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersLinkedViewRoleCreateManyArgs>(args?: SelectSubset<T, UsersLinkedViewRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersLinkedViewRole.
     * @param {UsersLinkedViewRoleDeleteArgs} args - Arguments to delete one UsersLinkedViewRole.
     * @example
     * // Delete one UsersLinkedViewRole
     * const UsersLinkedViewRole = await prisma.usersLinkedViewRole.delete({
     *   where: {
     *     // ... filter to delete one UsersLinkedViewRole
     *   }
     * })
     * 
     */
    delete<T extends UsersLinkedViewRoleDeleteArgs>(args: SelectSubset<T, UsersLinkedViewRoleDeleteArgs<ExtArgs>>): Prisma__UsersLinkedViewRoleClient<$Result.GetResult<Prisma.$UsersLinkedViewRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsersLinkedViewRole.
     * @param {UsersLinkedViewRoleUpdateArgs} args - Arguments to update one UsersLinkedViewRole.
     * @example
     * // Update one UsersLinkedViewRole
     * const usersLinkedViewRole = await prisma.usersLinkedViewRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersLinkedViewRoleUpdateArgs>(args: SelectSubset<T, UsersLinkedViewRoleUpdateArgs<ExtArgs>>): Prisma__UsersLinkedViewRoleClient<$Result.GetResult<Prisma.$UsersLinkedViewRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsersLinkedViewRoles.
     * @param {UsersLinkedViewRoleDeleteManyArgs} args - Arguments to filter UsersLinkedViewRoles to delete.
     * @example
     * // Delete a few UsersLinkedViewRoles
     * const { count } = await prisma.usersLinkedViewRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersLinkedViewRoleDeleteManyArgs>(args?: SelectSubset<T, UsersLinkedViewRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersLinkedViewRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLinkedViewRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersLinkedViewRoles
     * const usersLinkedViewRole = await prisma.usersLinkedViewRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersLinkedViewRoleUpdateManyArgs>(args: SelectSubset<T, UsersLinkedViewRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersLinkedViewRole.
     * @param {UsersLinkedViewRoleUpsertArgs} args - Arguments to update or create a UsersLinkedViewRole.
     * @example
     * // Update or create a UsersLinkedViewRole
     * const usersLinkedViewRole = await prisma.usersLinkedViewRole.upsert({
     *   create: {
     *     // ... data to create a UsersLinkedViewRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersLinkedViewRole we want to update
     *   }
     * })
     */
    upsert<T extends UsersLinkedViewRoleUpsertArgs>(args: SelectSubset<T, UsersLinkedViewRoleUpsertArgs<ExtArgs>>): Prisma__UsersLinkedViewRoleClient<$Result.GetResult<Prisma.$UsersLinkedViewRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsersLinkedViewRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLinkedViewRoleCountArgs} args - Arguments to filter UsersLinkedViewRoles to count.
     * @example
     * // Count the number of UsersLinkedViewRoles
     * const count = await prisma.usersLinkedViewRole.count({
     *   where: {
     *     // ... the filter for the UsersLinkedViewRoles we want to count
     *   }
     * })
    **/
    count<T extends UsersLinkedViewRoleCountArgs>(
      args?: Subset<T, UsersLinkedViewRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersLinkedViewRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersLinkedViewRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLinkedViewRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersLinkedViewRoleAggregateArgs>(args: Subset<T, UsersLinkedViewRoleAggregateArgs>): Prisma.PrismaPromise<GetUsersLinkedViewRoleAggregateType<T>>

    /**
     * Group by UsersLinkedViewRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLinkedViewRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersLinkedViewRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersLinkedViewRoleGroupByArgs['orderBy'] }
        : { orderBy?: UsersLinkedViewRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersLinkedViewRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersLinkedViewRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsersLinkedViewRole model
   */
  readonly fields: UsersLinkedViewRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersLinkedViewRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersLinkedViewRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserViewRoles<T extends UserViewRolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserViewRolesDefaultArgs<ExtArgs>>): Prisma__UserViewRolesClient<$Result.GetResult<Prisma.$UserViewRolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsersLinkedViewRole model
   */ 
  interface UsersLinkedViewRoleFieldRefs {
    readonly UsersLinkedViewRoleId: FieldRef<"UsersLinkedViewRole", 'String'>
    readonly CreatedAt: FieldRef<"UsersLinkedViewRole", 'DateTime'>
    readonly CompanyID: FieldRef<"UsersLinkedViewRole", 'String'>
    readonly UserID: FieldRef<"UsersLinkedViewRole", 'String'>
    readonly UserViewRolesId: FieldRef<"UsersLinkedViewRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UsersLinkedViewRole findUnique
   */
  export type UsersLinkedViewRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLinkedViewRole
     */
    select?: UsersLinkedViewRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLinkedViewRoleInclude<ExtArgs> | null
    /**
     * Filter, which UsersLinkedViewRole to fetch.
     */
    where: UsersLinkedViewRoleWhereUniqueInput
  }

  /**
   * UsersLinkedViewRole findUniqueOrThrow
   */
  export type UsersLinkedViewRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLinkedViewRole
     */
    select?: UsersLinkedViewRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLinkedViewRoleInclude<ExtArgs> | null
    /**
     * Filter, which UsersLinkedViewRole to fetch.
     */
    where: UsersLinkedViewRoleWhereUniqueInput
  }

  /**
   * UsersLinkedViewRole findFirst
   */
  export type UsersLinkedViewRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLinkedViewRole
     */
    select?: UsersLinkedViewRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLinkedViewRoleInclude<ExtArgs> | null
    /**
     * Filter, which UsersLinkedViewRole to fetch.
     */
    where?: UsersLinkedViewRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersLinkedViewRoles to fetch.
     */
    orderBy?: UsersLinkedViewRoleOrderByWithRelationInput | UsersLinkedViewRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersLinkedViewRoles.
     */
    cursor?: UsersLinkedViewRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersLinkedViewRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersLinkedViewRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersLinkedViewRoles.
     */
    distinct?: UsersLinkedViewRoleScalarFieldEnum | UsersLinkedViewRoleScalarFieldEnum[]
  }

  /**
   * UsersLinkedViewRole findFirstOrThrow
   */
  export type UsersLinkedViewRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLinkedViewRole
     */
    select?: UsersLinkedViewRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLinkedViewRoleInclude<ExtArgs> | null
    /**
     * Filter, which UsersLinkedViewRole to fetch.
     */
    where?: UsersLinkedViewRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersLinkedViewRoles to fetch.
     */
    orderBy?: UsersLinkedViewRoleOrderByWithRelationInput | UsersLinkedViewRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersLinkedViewRoles.
     */
    cursor?: UsersLinkedViewRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersLinkedViewRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersLinkedViewRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersLinkedViewRoles.
     */
    distinct?: UsersLinkedViewRoleScalarFieldEnum | UsersLinkedViewRoleScalarFieldEnum[]
  }

  /**
   * UsersLinkedViewRole findMany
   */
  export type UsersLinkedViewRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLinkedViewRole
     */
    select?: UsersLinkedViewRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLinkedViewRoleInclude<ExtArgs> | null
    /**
     * Filter, which UsersLinkedViewRoles to fetch.
     */
    where?: UsersLinkedViewRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersLinkedViewRoles to fetch.
     */
    orderBy?: UsersLinkedViewRoleOrderByWithRelationInput | UsersLinkedViewRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersLinkedViewRoles.
     */
    cursor?: UsersLinkedViewRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersLinkedViewRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersLinkedViewRoles.
     */
    skip?: number
    distinct?: UsersLinkedViewRoleScalarFieldEnum | UsersLinkedViewRoleScalarFieldEnum[]
  }

  /**
   * UsersLinkedViewRole create
   */
  export type UsersLinkedViewRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLinkedViewRole
     */
    select?: UsersLinkedViewRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLinkedViewRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UsersLinkedViewRole.
     */
    data: XOR<UsersLinkedViewRoleCreateInput, UsersLinkedViewRoleUncheckedCreateInput>
  }

  /**
   * UsersLinkedViewRole createMany
   */
  export type UsersLinkedViewRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsersLinkedViewRoles.
     */
    data: UsersLinkedViewRoleCreateManyInput | UsersLinkedViewRoleCreateManyInput[]
  }

  /**
   * UsersLinkedViewRole update
   */
  export type UsersLinkedViewRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLinkedViewRole
     */
    select?: UsersLinkedViewRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLinkedViewRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UsersLinkedViewRole.
     */
    data: XOR<UsersLinkedViewRoleUpdateInput, UsersLinkedViewRoleUncheckedUpdateInput>
    /**
     * Choose, which UsersLinkedViewRole to update.
     */
    where: UsersLinkedViewRoleWhereUniqueInput
  }

  /**
   * UsersLinkedViewRole updateMany
   */
  export type UsersLinkedViewRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsersLinkedViewRoles.
     */
    data: XOR<UsersLinkedViewRoleUpdateManyMutationInput, UsersLinkedViewRoleUncheckedUpdateManyInput>
    /**
     * Filter which UsersLinkedViewRoles to update
     */
    where?: UsersLinkedViewRoleWhereInput
  }

  /**
   * UsersLinkedViewRole upsert
   */
  export type UsersLinkedViewRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLinkedViewRole
     */
    select?: UsersLinkedViewRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLinkedViewRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UsersLinkedViewRole to update in case it exists.
     */
    where: UsersLinkedViewRoleWhereUniqueInput
    /**
     * In case the UsersLinkedViewRole found by the `where` argument doesn't exist, create a new UsersLinkedViewRole with this data.
     */
    create: XOR<UsersLinkedViewRoleCreateInput, UsersLinkedViewRoleUncheckedCreateInput>
    /**
     * In case the UsersLinkedViewRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersLinkedViewRoleUpdateInput, UsersLinkedViewRoleUncheckedUpdateInput>
  }

  /**
   * UsersLinkedViewRole delete
   */
  export type UsersLinkedViewRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLinkedViewRole
     */
    select?: UsersLinkedViewRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLinkedViewRoleInclude<ExtArgs> | null
    /**
     * Filter which UsersLinkedViewRole to delete.
     */
    where: UsersLinkedViewRoleWhereUniqueInput
  }

  /**
   * UsersLinkedViewRole deleteMany
   */
  export type UsersLinkedViewRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersLinkedViewRoles to delete
     */
    where?: UsersLinkedViewRoleWhereInput
  }

  /**
   * UsersLinkedViewRole without action
   */
  export type UsersLinkedViewRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLinkedViewRole
     */
    select?: UsersLinkedViewRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLinkedViewRoleInclude<ExtArgs> | null
  }


  /**
   * Model UserViewRoles
   */

  export type AggregateUserViewRoles = {
    _count: UserViewRolesCountAggregateOutputType | null
    _avg: UserViewRolesAvgAggregateOutputType | null
    _sum: UserViewRolesSumAggregateOutputType | null
    _min: UserViewRolesMinAggregateOutputType | null
    _max: UserViewRolesMaxAggregateOutputType | null
  }

  export type UserViewRolesAvgAggregateOutputType = {
    MaxSearchResults: number | null
  }

  export type UserViewRolesSumAggregateOutputType = {
    MaxSearchResults: number | null
  }

  export type UserViewRolesMinAggregateOutputType = {
    UserViewRolesId: string | null
    CreatedAt: Date | null
    CompanyID: string | null
    UserViewRoleName: string | null
    NotShowFields: string | null
    MaxSearchResults: number | null
    EditFields: string | null
  }

  export type UserViewRolesMaxAggregateOutputType = {
    UserViewRolesId: string | null
    CreatedAt: Date | null
    CompanyID: string | null
    UserViewRoleName: string | null
    NotShowFields: string | null
    MaxSearchResults: number | null
    EditFields: string | null
  }

  export type UserViewRolesCountAggregateOutputType = {
    UserViewRolesId: number
    CreatedAt: number
    CompanyID: number
    UserViewRoleName: number
    NotShowFields: number
    MaxSearchResults: number
    EditFields: number
    _all: number
  }


  export type UserViewRolesAvgAggregateInputType = {
    MaxSearchResults?: true
  }

  export type UserViewRolesSumAggregateInputType = {
    MaxSearchResults?: true
  }

  export type UserViewRolesMinAggregateInputType = {
    UserViewRolesId?: true
    CreatedAt?: true
    CompanyID?: true
    UserViewRoleName?: true
    NotShowFields?: true
    MaxSearchResults?: true
    EditFields?: true
  }

  export type UserViewRolesMaxAggregateInputType = {
    UserViewRolesId?: true
    CreatedAt?: true
    CompanyID?: true
    UserViewRoleName?: true
    NotShowFields?: true
    MaxSearchResults?: true
    EditFields?: true
  }

  export type UserViewRolesCountAggregateInputType = {
    UserViewRolesId?: true
    CreatedAt?: true
    CompanyID?: true
    UserViewRoleName?: true
    NotShowFields?: true
    MaxSearchResults?: true
    EditFields?: true
    _all?: true
  }

  export type UserViewRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserViewRoles to aggregate.
     */
    where?: UserViewRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserViewRoles to fetch.
     */
    orderBy?: UserViewRolesOrderByWithRelationInput | UserViewRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserViewRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserViewRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserViewRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserViewRoles
    **/
    _count?: true | UserViewRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserViewRolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserViewRolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserViewRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserViewRolesMaxAggregateInputType
  }

  export type GetUserViewRolesAggregateType<T extends UserViewRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserViewRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserViewRoles[P]>
      : GetScalarType<T[P], AggregateUserViewRoles[P]>
  }




  export type UserViewRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserViewRolesWhereInput
    orderBy?: UserViewRolesOrderByWithAggregationInput | UserViewRolesOrderByWithAggregationInput[]
    by: UserViewRolesScalarFieldEnum[] | UserViewRolesScalarFieldEnum
    having?: UserViewRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserViewRolesCountAggregateInputType | true
    _avg?: UserViewRolesAvgAggregateInputType
    _sum?: UserViewRolesSumAggregateInputType
    _min?: UserViewRolesMinAggregateInputType
    _max?: UserViewRolesMaxAggregateInputType
  }

  export type UserViewRolesGroupByOutputType = {
    UserViewRolesId: string
    CreatedAt: Date | null
    CompanyID: string
    UserViewRoleName: string
    NotShowFields: string | null
    MaxSearchResults: number | null
    EditFields: string | null
    _count: UserViewRolesCountAggregateOutputType | null
    _avg: UserViewRolesAvgAggregateOutputType | null
    _sum: UserViewRolesSumAggregateOutputType | null
    _min: UserViewRolesMinAggregateOutputType | null
    _max: UserViewRolesMaxAggregateOutputType | null
  }

  type GetUserViewRolesGroupByPayload<T extends UserViewRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserViewRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserViewRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserViewRolesGroupByOutputType[P]>
            : GetScalarType<T[P], UserViewRolesGroupByOutputType[P]>
        }
      >
    >


  export type UserViewRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserViewRolesId?: boolean
    CreatedAt?: boolean
    CompanyID?: boolean
    UserViewRoleName?: boolean
    NotShowFields?: boolean
    MaxSearchResults?: boolean
    EditFields?: boolean
    UsersLinkedViewRole?: boolean | UserViewRoles$UsersLinkedViewRoleArgs<ExtArgs>
    _count?: boolean | UserViewRolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userViewRoles"]>


  export type UserViewRolesSelectScalar = {
    UserViewRolesId?: boolean
    CreatedAt?: boolean
    CompanyID?: boolean
    UserViewRoleName?: boolean
    NotShowFields?: boolean
    MaxSearchResults?: boolean
    EditFields?: boolean
  }

  export type UserViewRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UsersLinkedViewRole?: boolean | UserViewRoles$UsersLinkedViewRoleArgs<ExtArgs>
    _count?: boolean | UserViewRolesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserViewRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserViewRoles"
    objects: {
      UsersLinkedViewRole: Prisma.$UsersLinkedViewRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      UserViewRolesId: string
      CreatedAt: Date | null
      CompanyID: string
      UserViewRoleName: string
      NotShowFields: string | null
      MaxSearchResults: number | null
      EditFields: string | null
    }, ExtArgs["result"]["userViewRoles"]>
    composites: {}
  }

  type UserViewRolesGetPayload<S extends boolean | null | undefined | UserViewRolesDefaultArgs> = $Result.GetResult<Prisma.$UserViewRolesPayload, S>

  type UserViewRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserViewRolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserViewRolesCountAggregateInputType | true
    }

  export interface UserViewRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserViewRoles'], meta: { name: 'UserViewRoles' } }
    /**
     * Find zero or one UserViewRoles that matches the filter.
     * @param {UserViewRolesFindUniqueArgs} args - Arguments to find a UserViewRoles
     * @example
     * // Get one UserViewRoles
     * const userViewRoles = await prisma.userViewRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserViewRolesFindUniqueArgs>(args: SelectSubset<T, UserViewRolesFindUniqueArgs<ExtArgs>>): Prisma__UserViewRolesClient<$Result.GetResult<Prisma.$UserViewRolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserViewRoles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserViewRolesFindUniqueOrThrowArgs} args - Arguments to find a UserViewRoles
     * @example
     * // Get one UserViewRoles
     * const userViewRoles = await prisma.userViewRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserViewRolesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserViewRolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserViewRolesClient<$Result.GetResult<Prisma.$UserViewRolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserViewRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserViewRolesFindFirstArgs} args - Arguments to find a UserViewRoles
     * @example
     * // Get one UserViewRoles
     * const userViewRoles = await prisma.userViewRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserViewRolesFindFirstArgs>(args?: SelectSubset<T, UserViewRolesFindFirstArgs<ExtArgs>>): Prisma__UserViewRolesClient<$Result.GetResult<Prisma.$UserViewRolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserViewRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserViewRolesFindFirstOrThrowArgs} args - Arguments to find a UserViewRoles
     * @example
     * // Get one UserViewRoles
     * const userViewRoles = await prisma.userViewRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserViewRolesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserViewRolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserViewRolesClient<$Result.GetResult<Prisma.$UserViewRolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserViewRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserViewRolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserViewRoles
     * const userViewRoles = await prisma.userViewRoles.findMany()
     * 
     * // Get first 10 UserViewRoles
     * const userViewRoles = await prisma.userViewRoles.findMany({ take: 10 })
     * 
     * // Only select the `UserViewRolesId`
     * const userViewRolesWithUserViewRolesIdOnly = await prisma.userViewRoles.findMany({ select: { UserViewRolesId: true } })
     * 
     */
    findMany<T extends UserViewRolesFindManyArgs>(args?: SelectSubset<T, UserViewRolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserViewRolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserViewRoles.
     * @param {UserViewRolesCreateArgs} args - Arguments to create a UserViewRoles.
     * @example
     * // Create one UserViewRoles
     * const UserViewRoles = await prisma.userViewRoles.create({
     *   data: {
     *     // ... data to create a UserViewRoles
     *   }
     * })
     * 
     */
    create<T extends UserViewRolesCreateArgs>(args: SelectSubset<T, UserViewRolesCreateArgs<ExtArgs>>): Prisma__UserViewRolesClient<$Result.GetResult<Prisma.$UserViewRolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserViewRoles.
     * @param {UserViewRolesCreateManyArgs} args - Arguments to create many UserViewRoles.
     * @example
     * // Create many UserViewRoles
     * const userViewRoles = await prisma.userViewRoles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserViewRolesCreateManyArgs>(args?: SelectSubset<T, UserViewRolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserViewRoles.
     * @param {UserViewRolesDeleteArgs} args - Arguments to delete one UserViewRoles.
     * @example
     * // Delete one UserViewRoles
     * const UserViewRoles = await prisma.userViewRoles.delete({
     *   where: {
     *     // ... filter to delete one UserViewRoles
     *   }
     * })
     * 
     */
    delete<T extends UserViewRolesDeleteArgs>(args: SelectSubset<T, UserViewRolesDeleteArgs<ExtArgs>>): Prisma__UserViewRolesClient<$Result.GetResult<Prisma.$UserViewRolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserViewRoles.
     * @param {UserViewRolesUpdateArgs} args - Arguments to update one UserViewRoles.
     * @example
     * // Update one UserViewRoles
     * const userViewRoles = await prisma.userViewRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserViewRolesUpdateArgs>(args: SelectSubset<T, UserViewRolesUpdateArgs<ExtArgs>>): Prisma__UserViewRolesClient<$Result.GetResult<Prisma.$UserViewRolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserViewRoles.
     * @param {UserViewRolesDeleteManyArgs} args - Arguments to filter UserViewRoles to delete.
     * @example
     * // Delete a few UserViewRoles
     * const { count } = await prisma.userViewRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserViewRolesDeleteManyArgs>(args?: SelectSubset<T, UserViewRolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserViewRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserViewRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserViewRoles
     * const userViewRoles = await prisma.userViewRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserViewRolesUpdateManyArgs>(args: SelectSubset<T, UserViewRolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserViewRoles.
     * @param {UserViewRolesUpsertArgs} args - Arguments to update or create a UserViewRoles.
     * @example
     * // Update or create a UserViewRoles
     * const userViewRoles = await prisma.userViewRoles.upsert({
     *   create: {
     *     // ... data to create a UserViewRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserViewRoles we want to update
     *   }
     * })
     */
    upsert<T extends UserViewRolesUpsertArgs>(args: SelectSubset<T, UserViewRolesUpsertArgs<ExtArgs>>): Prisma__UserViewRolesClient<$Result.GetResult<Prisma.$UserViewRolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserViewRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserViewRolesCountArgs} args - Arguments to filter UserViewRoles to count.
     * @example
     * // Count the number of UserViewRoles
     * const count = await prisma.userViewRoles.count({
     *   where: {
     *     // ... the filter for the UserViewRoles we want to count
     *   }
     * })
    **/
    count<T extends UserViewRolesCountArgs>(
      args?: Subset<T, UserViewRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserViewRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserViewRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserViewRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserViewRolesAggregateArgs>(args: Subset<T, UserViewRolesAggregateArgs>): Prisma.PrismaPromise<GetUserViewRolesAggregateType<T>>

    /**
     * Group by UserViewRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserViewRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserViewRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserViewRolesGroupByArgs['orderBy'] }
        : { orderBy?: UserViewRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserViewRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserViewRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserViewRoles model
   */
  readonly fields: UserViewRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserViewRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserViewRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UsersLinkedViewRole<T extends UserViewRoles$UsersLinkedViewRoleArgs<ExtArgs> = {}>(args?: Subset<T, UserViewRoles$UsersLinkedViewRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersLinkedViewRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserViewRoles model
   */ 
  interface UserViewRolesFieldRefs {
    readonly UserViewRolesId: FieldRef<"UserViewRoles", 'String'>
    readonly CreatedAt: FieldRef<"UserViewRoles", 'DateTime'>
    readonly CompanyID: FieldRef<"UserViewRoles", 'String'>
    readonly UserViewRoleName: FieldRef<"UserViewRoles", 'String'>
    readonly NotShowFields: FieldRef<"UserViewRoles", 'String'>
    readonly MaxSearchResults: FieldRef<"UserViewRoles", 'Int'>
    readonly EditFields: FieldRef<"UserViewRoles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserViewRoles findUnique
   */
  export type UserViewRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserViewRoles
     */
    select?: UserViewRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserViewRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserViewRoles to fetch.
     */
    where: UserViewRolesWhereUniqueInput
  }

  /**
   * UserViewRoles findUniqueOrThrow
   */
  export type UserViewRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserViewRoles
     */
    select?: UserViewRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserViewRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserViewRoles to fetch.
     */
    where: UserViewRolesWhereUniqueInput
  }

  /**
   * UserViewRoles findFirst
   */
  export type UserViewRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserViewRoles
     */
    select?: UserViewRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserViewRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserViewRoles to fetch.
     */
    where?: UserViewRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserViewRoles to fetch.
     */
    orderBy?: UserViewRolesOrderByWithRelationInput | UserViewRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserViewRoles.
     */
    cursor?: UserViewRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserViewRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserViewRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserViewRoles.
     */
    distinct?: UserViewRolesScalarFieldEnum | UserViewRolesScalarFieldEnum[]
  }

  /**
   * UserViewRoles findFirstOrThrow
   */
  export type UserViewRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserViewRoles
     */
    select?: UserViewRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserViewRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserViewRoles to fetch.
     */
    where?: UserViewRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserViewRoles to fetch.
     */
    orderBy?: UserViewRolesOrderByWithRelationInput | UserViewRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserViewRoles.
     */
    cursor?: UserViewRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserViewRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserViewRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserViewRoles.
     */
    distinct?: UserViewRolesScalarFieldEnum | UserViewRolesScalarFieldEnum[]
  }

  /**
   * UserViewRoles findMany
   */
  export type UserViewRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserViewRoles
     */
    select?: UserViewRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserViewRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserViewRoles to fetch.
     */
    where?: UserViewRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserViewRoles to fetch.
     */
    orderBy?: UserViewRolesOrderByWithRelationInput | UserViewRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserViewRoles.
     */
    cursor?: UserViewRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserViewRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserViewRoles.
     */
    skip?: number
    distinct?: UserViewRolesScalarFieldEnum | UserViewRolesScalarFieldEnum[]
  }

  /**
   * UserViewRoles create
   */
  export type UserViewRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserViewRoles
     */
    select?: UserViewRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserViewRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserViewRoles.
     */
    data: XOR<UserViewRolesCreateInput, UserViewRolesUncheckedCreateInput>
  }

  /**
   * UserViewRoles createMany
   */
  export type UserViewRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserViewRoles.
     */
    data: UserViewRolesCreateManyInput | UserViewRolesCreateManyInput[]
  }

  /**
   * UserViewRoles update
   */
  export type UserViewRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserViewRoles
     */
    select?: UserViewRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserViewRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserViewRoles.
     */
    data: XOR<UserViewRolesUpdateInput, UserViewRolesUncheckedUpdateInput>
    /**
     * Choose, which UserViewRoles to update.
     */
    where: UserViewRolesWhereUniqueInput
  }

  /**
   * UserViewRoles updateMany
   */
  export type UserViewRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserViewRoles.
     */
    data: XOR<UserViewRolesUpdateManyMutationInput, UserViewRolesUncheckedUpdateManyInput>
    /**
     * Filter which UserViewRoles to update
     */
    where?: UserViewRolesWhereInput
  }

  /**
   * UserViewRoles upsert
   */
  export type UserViewRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserViewRoles
     */
    select?: UserViewRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserViewRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserViewRoles to update in case it exists.
     */
    where: UserViewRolesWhereUniqueInput
    /**
     * In case the UserViewRoles found by the `where` argument doesn't exist, create a new UserViewRoles with this data.
     */
    create: XOR<UserViewRolesCreateInput, UserViewRolesUncheckedCreateInput>
    /**
     * In case the UserViewRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserViewRolesUpdateInput, UserViewRolesUncheckedUpdateInput>
  }

  /**
   * UserViewRoles delete
   */
  export type UserViewRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserViewRoles
     */
    select?: UserViewRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserViewRolesInclude<ExtArgs> | null
    /**
     * Filter which UserViewRoles to delete.
     */
    where: UserViewRolesWhereUniqueInput
  }

  /**
   * UserViewRoles deleteMany
   */
  export type UserViewRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserViewRoles to delete
     */
    where?: UserViewRolesWhereInput
  }

  /**
   * UserViewRoles.UsersLinkedViewRole
   */
  export type UserViewRoles$UsersLinkedViewRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLinkedViewRole
     */
    select?: UsersLinkedViewRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLinkedViewRoleInclude<ExtArgs> | null
    where?: UsersLinkedViewRoleWhereInput
    orderBy?: UsersLinkedViewRoleOrderByWithRelationInput | UsersLinkedViewRoleOrderByWithRelationInput[]
    cursor?: UsersLinkedViewRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersLinkedViewRoleScalarFieldEnum | UsersLinkedViewRoleScalarFieldEnum[]
  }

  /**
   * UserViewRoles without action
   */
  export type UserViewRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserViewRoles
     */
    select?: UserViewRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserViewRolesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompaniesConfigScalarFieldEnum: {
    CompanyConfigId: 'CompanyConfigId',
    CompanyIdGeneralCRM: 'CompanyIdGeneralCRM',
    CreatedAt: 'CreatedAt',
    PropertyEngName: 'PropertyEngName',
    PropertyValue: 'PropertyValue',
    PropertyTextJsonValue: 'PropertyTextJsonValue',
    PropertyHebDescription: 'PropertyHebDescription'
  };

  export type CompaniesConfigScalarFieldEnum = (typeof CompaniesConfigScalarFieldEnum)[keyof typeof CompaniesConfigScalarFieldEnum]


  export const CompanyAdminScalarFieldEnum: {
    CompanyAdminId: 'CompanyAdminId',
    CompanyID: 'CompanyID',
    CreatedAt: 'CreatedAt',
    NotShowFields: 'NotShowFields',
    MaxSearchResults: 'MaxSearchResults',
    EditFields: 'EditFields'
  };

  export type CompanyAdminScalarFieldEnum = (typeof CompanyAdminScalarFieldEnum)[keyof typeof CompanyAdminScalarFieldEnum]


  export const EmployeeHoursScalarFieldEnum: {
    EmployeeHoursId: 'EmployeeHoursId',
    CreatedAt: 'CreatedAt',
    CompanyIdGeneralCRM: 'CompanyIdGeneralCRM',
    EmployeeId: 'EmployeeId',
    EmployeeNumber: 'EmployeeNumber',
    MonthManaged: 'MonthManaged',
    YearManaged: 'YearManaged',
    LeadingDate: 'LeadingDate',
    HourStart: 'HourStart',
    HourEnd: 'HourEnd',
    HourStartSource: 'HourStartSource',
    HourEndSource: 'HourEndSource',
    RealHours: 'RealHours',
    QtyHour: 'QtyHour',
    QtyHour125: 'QtyHour125',
    QtyHour150: 'QtyHour150',
    QtyHour175: 'QtyHour175',
    QtyHour200: 'QtyHour200',
    BreakMinutes: 'BreakMinutes',
    GpsStart: 'GpsStart',
    GpsEnd: 'GpsEnd',
    EmployeeHoursByLocalityId: 'EmployeeHoursByLocalityId',
    IsManualInsert: 'IsManualInsert',
    ManualInsertUserId: 'ManualInsertUserId',
    IsRowDeleted: 'IsRowDeleted',
    ActionTypeID: 'ActionTypeID',
    DayTypeID: 'DayTypeID',
    HolidayName: 'HolidayName',
    StartEndTimeSabat: 'StartEndTimeSabat',
    IsForemanHourApproved: 'IsForemanHourApproved',
    IsForemanApproval: 'IsForemanApproval',
    ForemanApprovalGeneralCRMUserId: 'ForemanApprovalGeneralCRMUserId',
    IsComplementRow: 'IsComplementRow'
  };

  export type EmployeeHoursScalarFieldEnum = (typeof EmployeeHoursScalarFieldEnum)[keyof typeof EmployeeHoursScalarFieldEnum]


  export const EmployeeHoursByLocalityScalarFieldEnum: {
    EmployeeHoursByLocalityId: 'EmployeeHoursByLocalityId',
    CreatedAt: 'CreatedAt',
    CompanyIdGeneralCRM: 'CompanyIdGeneralCRM',
    EmployeeId: 'EmployeeId',
    NotShowEmployeeHours: 'NotShowEmployeeHours',
    EmployeeHoursLocalityId: 'EmployeeHoursLocalityId',
    HourMinStart: 'HourMinStart',
    HourMaxStop: 'HourMaxStop',
    RoundTime: 'RoundTime',
    EmployeeHoursUserId: 'EmployeeHoursUserId',
    MinimumHours2BreakTime: 'MinimumHours2BreakTime',
    BreakTime: 'BreakTime',
    AlertForMaxMonthHours: 'AlertForMaxMonthHours',
    EmployeeHoursContractId: 'EmployeeHoursContractId'
  };

  export type EmployeeHoursByLocalityScalarFieldEnum = (typeof EmployeeHoursByLocalityScalarFieldEnum)[keyof typeof EmployeeHoursByLocalityScalarFieldEnum]


  export const EmployeeHoursByLocalityTotalsScalarFieldEnum: {
    EmployeeHoursByLocalityTotalsId: 'EmployeeHoursByLocalityTotalsId',
    CreatedAt: 'CreatedAt',
    CompanyIdGeneralCRM: 'CompanyIdGeneralCRM',
    MonthManaged: 'MonthManaged',
    YearManaged: 'YearManaged',
    EmployeeId: 'EmployeeId',
    EmployeeHoursLocalityId: 'EmployeeHoursLocalityId',
    QtyHour: 'QtyHour',
    QtyHour125: 'QtyHour125',
    QtyHour150: 'QtyHour150',
    QtyHour175: 'QtyHour175',
    QtyHour200: 'QtyHour200',
    RealHours: 'RealHours',
    BreakMinutes: 'BreakMinutes',
    WorkedDays: 'WorkedDays',
    IsCloseSalary: 'IsCloseSalary'
  };

  export type EmployeeHoursByLocalityTotalsScalarFieldEnum = (typeof EmployeeHoursByLocalityTotalsScalarFieldEnum)[keyof typeof EmployeeHoursByLocalityTotalsScalarFieldEnum]


  export const EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum: {
    EmployeeHoursByLocalityTotalsActionTypeId: 'EmployeeHoursByLocalityTotalsActionTypeId',
    CreatedAt: 'CreatedAt',
    EmployeeHoursByLocalityTotalsId: 'EmployeeHoursByLocalityTotalsId',
    ActionTypeId: 'ActionTypeId',
    TotalActionType: 'TotalActionType'
  };

  export type EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum = (typeof EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum)[keyof typeof EmployeeHoursByLocalityTotalsActionTypeScalarFieldEnum]


  export const EmployeeHoursCompaniesSmsAlertScalarFieldEnum: {
    CompaniesSmsAlertId: 'CompaniesSmsAlertId',
    CompanyIdGeneralCRM: 'CompanyIdGeneralCRM',
    CreatedAt: 'CreatedAt',
    EmployeeID: 'EmployeeID',
    SmsNumber: 'SmsNumber',
    SmsResponse: 'SmsResponse',
    UserSend: 'UserSend'
  };

  export type EmployeeHoursCompaniesSmsAlertScalarFieldEnum = (typeof EmployeeHoursCompaniesSmsAlertScalarFieldEnum)[keyof typeof EmployeeHoursCompaniesSmsAlertScalarFieldEnum]


  export const EmployeeHoursContractsScalarFieldEnum: {
    EmployeeHoursContractsId: 'EmployeeHoursContractsId',
    CreatedAt: 'CreatedAt',
    Active: 'Active',
    HebrewName: 'HebrewName',
    Comments: 'Comments',
    JsonData: 'JsonData',
    CompanyIdGeneralCRM: 'CompanyIdGeneralCRM',
    HoursWeek: 'HoursWeek',
    NumberDayInWeek: 'NumberDayInWeek',
    IsExtraHoursWeekCalc: 'IsExtraHoursWeekCalc',
    IsNightShiftCalc: 'IsNightShiftCalc'
  };

  export type EmployeeHoursContractsScalarFieldEnum = (typeof EmployeeHoursContractsScalarFieldEnum)[keyof typeof EmployeeHoursContractsScalarFieldEnum]


  export const EmployeeHoursForemansConfigScalarFieldEnum: {
    EmployeeHoursForemanConfigId: 'EmployeeHoursForemanConfigId',
    CreatedAt: 'CreatedAt',
    CompanyIdGeneralCRM: 'CompanyIdGeneralCRM',
    ForemanUserGeneralCRM: 'ForemanUserGeneralCRM',
    CanEdit: 'CanEdit',
    NotShowSourceHours: 'NotShowSourceHours'
  };

  export type EmployeeHoursForemansConfigScalarFieldEnum = (typeof EmployeeHoursForemansConfigScalarFieldEnum)[keyof typeof EmployeeHoursForemansConfigScalarFieldEnum]


  export const EmployeeHoursLocalitiesScalarFieldEnum: {
    EmployeeHoursLocalityId: 'EmployeeHoursLocalityId',
    CreatedAt: 'CreatedAt',
    NotShowLocality: 'NotShowLocality',
    LocalityName: 'LocalityName',
    LocalityNameEng: 'LocalityNameEng',
    CompanyIdGeneralCRM: 'CompanyIdGeneralCRM',
    Address: 'Address',
    Gps: 'Gps',
    GpsRadius: 'GpsRadius',
    AddressAccess: 'AddressAccess',
    LocalityIDAccess: 'LocalityIDAccess',
    LocalityCodeAccess: 'LocalityCodeAccess',
    CustomerIDAccess: 'CustomerIDAccess',
    CustomerNameAccess: 'CustomerNameAccess',
    ForemanGeneralCRMUserId: 'ForemanGeneralCRMUserId',
    HourMinStart: 'HourMinStart',
    HourMaxStop: 'HourMaxStop',
    RoundTime: 'RoundTime',
    MinimumHours2BreakTime: 'MinimumHours2BreakTime',
    BreakTime: 'BreakTime',
    AlertForMaxMonthHours: 'AlertForMaxMonthHours',
    RestrictDayHoursAbove12: 'RestrictDayHoursAbove12',
    RestrictWeekExtraHoursAbove16: 'RestrictWeekExtraHoursAbove16',
    RestrictGpsActive: 'RestrictGpsActive'
  };

  export type EmployeeHoursLocalitiesScalarFieldEnum = (typeof EmployeeHoursLocalitiesScalarFieldEnum)[keyof typeof EmployeeHoursLocalitiesScalarFieldEnum]


  export const EmployeeHoursUsersScalarFieldEnum: {
    EmployeeHoursUsersId: 'EmployeeHoursUsersId',
    CreatedAt: 'CreatedAt',
    CompanyIdGeneralCRM: 'CompanyIdGeneralCRM',
    EmployeeId: 'EmployeeId',
    MobileNumber: 'MobileNumber',
    UserName: 'UserName',
    Password: 'Password',
    IsAdmin: 'IsAdmin',
    LastEntry: 'LastEntry',
    IsAllowAccess2WebSite: 'IsAllowAccess2WebSite',
    PhoneData: 'PhoneData',
    CookieError: 'CookieError'
  };

  export type EmployeeHoursUsersScalarFieldEnum = (typeof EmployeeHoursUsersScalarFieldEnum)[keyof typeof EmployeeHoursUsersScalarFieldEnum]


  export const EmployeesAccessDocumentsTempScalarFieldEnum: {
    EmployeesAccessDocumentTempId: 'EmployeesAccessDocumentTempId',
    CompanyGeneralCrmId: 'CompanyGeneralCrmId',
    CreatedAt: 'CreatedAt',
    EmployeeID: 'EmployeeID',
    DocumemtID: 'DocumemtID',
    Date: 'Date',
    DocumemtType: 'DocumemtType',
    Comment: 'Comment',
    DocumentName: 'DocumentName'
  };

  export type EmployeesAccessDocumentsTempScalarFieldEnum = (typeof EmployeesAccessDocumentsTempScalarFieldEnum)[keyof typeof EmployeesAccessDocumentsTempScalarFieldEnum]


  export const EmployeesAccessHouseTempScalarFieldEnum: {
    EmployeesAccessHouseTempId: 'EmployeesAccessHouseTempId',
    CompanyGeneralCrmId: 'CompanyGeneralCrmId',
    CreatedAt: 'CreatedAt',
    HouseID: 'HouseID',
    HouseCode: 'HouseCode',
    CityName: 'CityName',
    Street: 'Street',
    HouseNumber: 'HouseNumber',
    ZipCode: 'ZipCode',
    EmployeesQtyMax: 'EmployeesQtyMax',
    ElectricityCounter_Start: 'ElectricityCounter_Start',
    ElectricityCounter_End: 'ElectricityCounter_End',
    GasCounter_Start: 'GasCounter_Start',
    GasCounter_End: 'GasCounter_End',
    WaterCounter_Start: 'WaterCounter_Start',
    WaterCounter_End: 'WaterCounter_End',
    ElectricityNumber: 'ElectricityNumber',
    GasNumber: 'GasNumber',
    WaterNumber: 'WaterNumber',
    HouseField: 'HouseField',
    ArnonaNumber: 'ArnonaNumber',
    EvacuationDate: 'EvacuationDate',
    AreaMan: 'AreaMan',
    GasContainer: 'GasContainer',
    GasCompanyID: 'GasCompanyID',
    SleepingRooms: 'SleepingRooms',
    Salon: 'Salon',
    Toilet: 'Toilet',
    Baths: 'Baths',
    HouseCommittee: 'HouseCommittee',
    HouseCommitteePhone: 'HouseCommitteePhone',
    Status: 'Status',
    Name: 'Name',
    Street_: 'Street_',
    CityName_: 'CityName_',
    ZipCode_: 'ZipCode_',
    Phone_1: 'Phone_1',
    Phone_2: 'Phone_2',
    FaxNumber: 'FaxNumber',
    StartDateContract: 'StartDateContract',
    EndDateContract: 'EndDateContract',
    Security: 'Security',
    SecurityAmount: 'SecurityAmount',
    PaymentFrequency: 'PaymentFrequency',
    Rant: 'Rant',
    Comment: 'Comment',
    IsInsured: 'IsInsured',
    InsureEndDate: 'InsureEndDate',
    IsUpdate: 'IsUpdate',
    LivingArea: 'LivingArea',
    HouseRelation: 'HouseRelation',
    CableTypeID: 'CableTypeID',
    CableInstallationdate: 'CableInstallationdate',
    AccountNumber: 'AccountNumber',
    PathNumber: 'PathNumber',
    AppartmentNum: 'AppartmentNum',
    IsBroker: 'IsBroker',
    BrokerName: 'BrokerName',
    BrokerPhone: 'BrokerPhone',
    ElectricityCode: 'ElectricityCode',
    GasNumberCode: 'GasNumberCode',
    WaterNumberCode: 'WaterNumberCode',
    ElectricityComment: 'ElectricityComment',
    GasCounteComment: 'GasCounteComment',
    WaterCounterComment: 'WaterCounterComment',
    AgencyFee: 'AgencyFee',
    IdNumber: 'IdNumber',
    ArrivalInstructions: 'ArrivalInstructions',
    OwnerEmail: 'OwnerEmail',
    OwnerBankAcount: 'OwnerBankAcount',
    CustomerID: 'CustomerID',
    LocalityName: 'LocalityName',
    Contractor_billing: 'Contractor_billing',
    Floor: 'Floor',
    Entrance: 'Entrance',
    OwnerBranchCode: 'OwnerBranchCode',
    OwnerBankID: 'OwnerBankID'
  };

  export type EmployeesAccessHouseTempScalarFieldEnum = (typeof EmployeesAccessHouseTempScalarFieldEnum)[keyof typeof EmployeesAccessHouseTempScalarFieldEnum]


  export const EmployeesAccessLkupDocumentTypeTempScalarFieldEnum: {
    EmployeesAccessLkupDocumentTypeTempId: 'EmployeesAccessLkupDocumentTypeTempId',
    CompanyGeneralCrmId: 'CompanyGeneralCrmId',
    CreatedAt: 'CreatedAt',
    DocumemtType: 'DocumemtType'
  };

  export type EmployeesAccessLkupDocumentTypeTempScalarFieldEnum = (typeof EmployeesAccessLkupDocumentTypeTempScalarFieldEnum)[keyof typeof EmployeesAccessLkupDocumentTypeTempScalarFieldEnum]


  export const EmployeesAccessTempScalarFieldEnum: {
    EmployeesAccessTempId: 'EmployeesAccessTempId',
    CompanyGeneralCrmId: 'CompanyGeneralCrmId',
    CreatedAt: 'CreatedAt',
    AgentID: 'AgentID',
    AreaMan: 'AreaMan',
    AppartmentNum: 'AppartmentNum',
    BirthDate: 'BirthDate',
    CityName: 'CityName',
    CoatReceivingDate: 'CoatReceivingDate',
    CoatSize: 'CoatSize',
    CountryID: 'CountryID',
    CountryName: 'CountryName',
    CourseAtatDate: 'CourseAtatDate',
    CourseAtatExpireDate: 'CourseAtatExpireDate',
    CustomerName: 'CustomerName',
    CustomerStatus: 'CustomerStatus',
    CustomerID: 'CustomerID',
    EmployeeFirstName: 'EmployeeFirstName',
    EmployeeID: 'EmployeeID',
    EmployeeLastName: 'EmployeeLastName',
    EmployeeNumber: 'EmployeeNumber',
    EndInsuranceDate: 'EndInsuranceDate',
    EntranceDate: 'EntranceDate',
    HealthFund: 'HealthFund',
    HouseID: 'HouseID',
    HouseNumber: 'HouseNumber',
    InsuranceCompany: 'InsuranceCompany',
    InsuranceNumber: 'InsuranceNumber',
    InsuredNumber: 'InsuredNumber',
    IsCourseAtat: 'IsCourseAtat',
    Isbriefing: 'Isbriefing',
    LocalityName: 'LocalityName',
    LocalityCode: 'LocalityCode',
    LocalityID: 'LocalityID',
    LongshirtReceivingDate: 'LongshirtReceivingDate',
    LongshirtSize: 'LongshirtSize',
    MobilePhone: 'MobilePhone',
    PantsReceivingDate: 'PantsReceivingDate',
    PassportNumber: 'PassportNumber',
    ProfessionName: 'ProfessionName',
    ProfessionSecondName: 'ProfessionSecondName',
    ProfessionThirdName: 'ProfessionThirdName',
    ShoesNumber: 'ShoesNumber',
    ShoesReceiveDate: 'ShoesReceiveDate',
    SizeOfPantes: 'SizeOfPantes',
    SizeOfshirt: 'SizeOfshirt',
    StartDate: 'StartDate',
    StatusName: 'StatusName',
    Street: 'Street',
    TshirReceivingDate: 'TshirReceivingDate',
    briefingDate: 'briefingDate',
    briefingExpireDate: 'briefingExpireDate',
    startInsuranceDate: 'startInsuranceDate'
  };

  export type EmployeesAccessTempScalarFieldEnum = (typeof EmployeesAccessTempScalarFieldEnum)[keyof typeof EmployeesAccessTempScalarFieldEnum]


  export const ErrorsPhpLogsScalarFieldEnum: {
    ErrorsPhpLogsId: 'ErrorsPhpLogsId',
    CreatedAt: 'CreatedAt',
    tokenData: 'tokenData',
    urlController: 'urlController',
    sendData: 'sendData',
    errorMessg: 'errorMessg'
  };

  export type ErrorsPhpLogsScalarFieldEnum = (typeof ErrorsPhpLogsScalarFieldEnum)[keyof typeof ErrorsPhpLogsScalarFieldEnum]


  export const Lkup_ActionTypeScalarFieldEnum: {
    ActionTypeID: 'ActionTypeID',
    ActionType: 'ActionType',
    IsIgnoreHours: 'IsIgnoreHours'
  };

  export type Lkup_ActionTypeScalarFieldEnum = (typeof Lkup_ActionTypeScalarFieldEnum)[keyof typeof Lkup_ActionTypeScalarFieldEnum]


  export const LogEnterEmployeeScalarFieldEnum: {
    LogEnterEmployee: 'LogEnterEmployee',
    UserID: 'UserID',
    CompanyID: 'CompanyID',
    EmployeeID: 'EmployeeID',
    CreatedAt: 'CreatedAt',
    ResultsData: 'ResultsData'
  };

  export type LogEnterEmployeeScalarFieldEnum = (typeof LogEnterEmployeeScalarFieldEnum)[keyof typeof LogEnterEmployeeScalarFieldEnum]


  export const LogSearchsScalarFieldEnum: {
    LogSearchsId: 'LogSearchsId',
    UserID: 'UserID',
    CompanyID: 'CompanyID',
    CreatedAt: 'CreatedAt',
    searchData: 'searchData',
    resultsCount: 'resultsCount'
  };

  export type LogSearchsScalarFieldEnum = (typeof LogSearchsScalarFieldEnum)[keyof typeof LogSearchsScalarFieldEnum]


  export const LogSignUpScalarFieldEnum: {
    LogSignUpId: 'LogSignUpId',
    UserID: 'UserID',
    CompanyID: 'CompanyID',
    CreatedAt: 'CreatedAt'
  };

  export type LogSignUpScalarFieldEnum = (typeof LogSignUpScalarFieldEnum)[keyof typeof LogSignUpScalarFieldEnum]


  export const MessagesEmployeesScalarFieldEnum: {
    MessageEmployeeId: 'MessageEmployeeId',
    CreatedAt: 'CreatedAt',
    FinalDateForTask: 'FinalDateForTask',
    ReadedAt: 'ReadedAt',
    DoneAt: 'DoneAt',
    SendResponseAtStatusDone: 'SendResponseAtStatusDone',
    CompanyIdGeneralCRM: 'CompanyIdGeneralCRM',
    UserFromIdGeneralCRM: 'UserFromIdGeneralCRM',
    UserToIdGeneralCRM: 'UserToIdGeneralCRM',
    IsReplyToMessageId: 'IsReplyToMessageId',
    MessageStatusId: 'MessageStatusId',
    MessageSubject: 'MessageSubject',
    MessageText: 'MessageText',
    LinkEmployees: 'LinkEmployees',
    LinkHouses: 'LinkHouses'
  };

  export type MessagesEmployeesScalarFieldEnum = (typeof MessagesEmployeesScalarFieldEnum)[keyof typeof MessagesEmployeesScalarFieldEnum]


  export const MessagesStatusScalarFieldEnum: {
    MessagesStatusId: 'MessagesStatusId',
    MessagesStatusName: 'MessagesStatusName',
    CreatedAt: 'CreatedAt',
    Sort: 'Sort',
    Comments: 'Comments'
  };

  export type MessagesStatusScalarFieldEnum = (typeof MessagesStatusScalarFieldEnum)[keyof typeof MessagesStatusScalarFieldEnum]


  export const SiteConfigScalarFieldEnum: {
    SiteConfigId: 'SiteConfigId',
    PropertyEngName: 'PropertyEngName',
    PropertyIntValue: 'PropertyIntValue',
    PropertyTextValue: 'PropertyTextValue',
    PropertyHebDescription: 'PropertyHebDescription',
    CreatedAt: 'CreatedAt'
  };

  export type SiteConfigScalarFieldEnum = (typeof SiteConfigScalarFieldEnum)[keyof typeof SiteConfigScalarFieldEnum]


  export const SysdiagramsScalarFieldEnum: {
    name: 'name',
    principal_id: 'principal_id',
    diagram_id: 'diagram_id',
    version: 'version',
    definition: 'definition'
  };

  export type SysdiagramsScalarFieldEnum = (typeof SysdiagramsScalarFieldEnum)[keyof typeof SysdiagramsScalarFieldEnum]


  export const UsersLinkedViewRoleScalarFieldEnum: {
    UsersLinkedViewRoleId: 'UsersLinkedViewRoleId',
    CreatedAt: 'CreatedAt',
    CompanyID: 'CompanyID',
    UserID: 'UserID',
    UserViewRolesId: 'UserViewRolesId'
  };

  export type UsersLinkedViewRoleScalarFieldEnum = (typeof UsersLinkedViewRoleScalarFieldEnum)[keyof typeof UsersLinkedViewRoleScalarFieldEnum]


  export const UserViewRolesScalarFieldEnum: {
    UserViewRolesId: 'UserViewRolesId',
    CreatedAt: 'CreatedAt',
    CompanyID: 'CompanyID',
    UserViewRoleName: 'UserViewRoleName',
    NotShowFields: 'NotShowFields',
    MaxSearchResults: 'MaxSearchResults',
    EditFields: 'EditFields'
  };

  export type UserViewRolesScalarFieldEnum = (typeof UserViewRolesScalarFieldEnum)[keyof typeof UserViewRolesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    
  /**
   * Deep Input Types
   */


  export type CompaniesConfigWhereInput = {
    AND?: CompaniesConfigWhereInput | CompaniesConfigWhereInput[]
    OR?: CompaniesConfigWhereInput[]
    NOT?: CompaniesConfigWhereInput | CompaniesConfigWhereInput[]
    CompanyConfigId?: IntFilter<"CompaniesConfig"> | number
    CompanyIdGeneralCRM?: StringFilter<"CompaniesConfig"> | string
    CreatedAt?: DateTimeNullableFilter<"CompaniesConfig"> | Date | string | null
    PropertyEngName?: StringFilter<"CompaniesConfig"> | string
    PropertyValue?: FloatNullableFilter<"CompaniesConfig"> | number | null
    PropertyTextJsonValue?: StringNullableFilter<"CompaniesConfig"> | string | null
    PropertyHebDescription?: StringFilter<"CompaniesConfig"> | string
  }

  export type CompaniesConfigOrderByWithRelationInput = {
    CompanyConfigId?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    PropertyEngName?: SortOrder
    PropertyValue?: SortOrderInput | SortOrder
    PropertyTextJsonValue?: SortOrderInput | SortOrder
    PropertyHebDescription?: SortOrder
  }

  export type CompaniesConfigWhereUniqueInput = Prisma.AtLeast<{
    CompanyConfigId?: number
    AND?: CompaniesConfigWhereInput | CompaniesConfigWhereInput[]
    OR?: CompaniesConfigWhereInput[]
    NOT?: CompaniesConfigWhereInput | CompaniesConfigWhereInput[]
    CompanyIdGeneralCRM?: StringFilter<"CompaniesConfig"> | string
    CreatedAt?: DateTimeNullableFilter<"CompaniesConfig"> | Date | string | null
    PropertyEngName?: StringFilter<"CompaniesConfig"> | string
    PropertyValue?: FloatNullableFilter<"CompaniesConfig"> | number | null
    PropertyTextJsonValue?: StringNullableFilter<"CompaniesConfig"> | string | null
    PropertyHebDescription?: StringFilter<"CompaniesConfig"> | string
  }, "CompanyConfigId">

  export type CompaniesConfigOrderByWithAggregationInput = {
    CompanyConfigId?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    PropertyEngName?: SortOrder
    PropertyValue?: SortOrderInput | SortOrder
    PropertyTextJsonValue?: SortOrderInput | SortOrder
    PropertyHebDescription?: SortOrder
    _count?: CompaniesConfigCountOrderByAggregateInput
    _avg?: CompaniesConfigAvgOrderByAggregateInput
    _max?: CompaniesConfigMaxOrderByAggregateInput
    _min?: CompaniesConfigMinOrderByAggregateInput
    _sum?: CompaniesConfigSumOrderByAggregateInput
  }

  export type CompaniesConfigScalarWhereWithAggregatesInput = {
    AND?: CompaniesConfigScalarWhereWithAggregatesInput | CompaniesConfigScalarWhereWithAggregatesInput[]
    OR?: CompaniesConfigScalarWhereWithAggregatesInput[]
    NOT?: CompaniesConfigScalarWhereWithAggregatesInput | CompaniesConfigScalarWhereWithAggregatesInput[]
    CompanyConfigId?: IntWithAggregatesFilter<"CompaniesConfig"> | number
    CompanyIdGeneralCRM?: StringWithAggregatesFilter<"CompaniesConfig"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"CompaniesConfig"> | Date | string | null
    PropertyEngName?: StringWithAggregatesFilter<"CompaniesConfig"> | string
    PropertyValue?: FloatNullableWithAggregatesFilter<"CompaniesConfig"> | number | null
    PropertyTextJsonValue?: StringNullableWithAggregatesFilter<"CompaniesConfig"> | string | null
    PropertyHebDescription?: StringWithAggregatesFilter<"CompaniesConfig"> | string
  }

  export type CompanyAdminWhereInput = {
    AND?: CompanyAdminWhereInput | CompanyAdminWhereInput[]
    OR?: CompanyAdminWhereInput[]
    NOT?: CompanyAdminWhereInput | CompanyAdminWhereInput[]
    CompanyAdminId?: StringFilter<"CompanyAdmin"> | string
    CompanyID?: StringFilter<"CompanyAdmin"> | string
    CreatedAt?: DateTimeNullableFilter<"CompanyAdmin"> | Date | string | null
    NotShowFields?: StringNullableFilter<"CompanyAdmin"> | string | null
    MaxSearchResults?: IntNullableFilter<"CompanyAdmin"> | number | null
    EditFields?: StringNullableFilter<"CompanyAdmin"> | string | null
  }

  export type CompanyAdminOrderByWithRelationInput = {
    CompanyAdminId?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    NotShowFields?: SortOrderInput | SortOrder
    MaxSearchResults?: SortOrderInput | SortOrder
    EditFields?: SortOrderInput | SortOrder
  }

  export type CompanyAdminWhereUniqueInput = Prisma.AtLeast<{
    CompanyAdminId?: string
    CompanyID?: string
    AND?: CompanyAdminWhereInput | CompanyAdminWhereInput[]
    OR?: CompanyAdminWhereInput[]
    NOT?: CompanyAdminWhereInput | CompanyAdminWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"CompanyAdmin"> | Date | string | null
    NotShowFields?: StringNullableFilter<"CompanyAdmin"> | string | null
    MaxSearchResults?: IntNullableFilter<"CompanyAdmin"> | number | null
    EditFields?: StringNullableFilter<"CompanyAdmin"> | string | null
  }, "CompanyAdminId" | "CompanyID">

  export type CompanyAdminOrderByWithAggregationInput = {
    CompanyAdminId?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    NotShowFields?: SortOrderInput | SortOrder
    MaxSearchResults?: SortOrderInput | SortOrder
    EditFields?: SortOrderInput | SortOrder
    _count?: CompanyAdminCountOrderByAggregateInput
    _avg?: CompanyAdminAvgOrderByAggregateInput
    _max?: CompanyAdminMaxOrderByAggregateInput
    _min?: CompanyAdminMinOrderByAggregateInput
    _sum?: CompanyAdminSumOrderByAggregateInput
  }

  export type CompanyAdminScalarWhereWithAggregatesInput = {
    AND?: CompanyAdminScalarWhereWithAggregatesInput | CompanyAdminScalarWhereWithAggregatesInput[]
    OR?: CompanyAdminScalarWhereWithAggregatesInput[]
    NOT?: CompanyAdminScalarWhereWithAggregatesInput | CompanyAdminScalarWhereWithAggregatesInput[]
    CompanyAdminId?: StringWithAggregatesFilter<"CompanyAdmin"> | string
    CompanyID?: StringWithAggregatesFilter<"CompanyAdmin"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"CompanyAdmin"> | Date | string | null
    NotShowFields?: StringNullableWithAggregatesFilter<"CompanyAdmin"> | string | null
    MaxSearchResults?: IntNullableWithAggregatesFilter<"CompanyAdmin"> | number | null
    EditFields?: StringNullableWithAggregatesFilter<"CompanyAdmin"> | string | null
  }

  export type EmployeeHoursWhereInput = {
    AND?: EmployeeHoursWhereInput | EmployeeHoursWhereInput[]
    OR?: EmployeeHoursWhereInput[]
    NOT?: EmployeeHoursWhereInput | EmployeeHoursWhereInput[]
    EmployeeHoursId?: StringFilter<"EmployeeHours"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHours"> | string
    EmployeeId?: IntFilter<"EmployeeHours"> | number
    EmployeeNumber?: IntFilter<"EmployeeHours"> | number
    MonthManaged?: IntFilter<"EmployeeHours"> | number
    YearManaged?: IntFilter<"EmployeeHours"> | number
    LeadingDate?: DateTimeFilter<"EmployeeHours"> | Date | string
    HourStart?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    HourEnd?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    HourStartSource?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    HourEndSource?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    RealHours?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour125?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour150?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour175?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour200?: FloatNullableFilter<"EmployeeHours"> | number | null
    BreakMinutes?: FloatNullableFilter<"EmployeeHours"> | number | null
    GpsStart?: StringNullableFilter<"EmployeeHours"> | string | null
    GpsEnd?: StringNullableFilter<"EmployeeHours"> | string | null
    EmployeeHoursByLocalityId?: StringFilter<"EmployeeHours"> | string
    IsManualInsert?: IntNullableFilter<"EmployeeHours"> | number | null
    ManualInsertUserId?: StringNullableFilter<"EmployeeHours"> | string | null
    IsRowDeleted?: IntNullableFilter<"EmployeeHours"> | number | null
    ActionTypeID?: IntNullableFilter<"EmployeeHours"> | number | null
    DayTypeID?: IntNullableFilter<"EmployeeHours"> | number | null
    HolidayName?: StringNullableFilter<"EmployeeHours"> | string | null
    StartEndTimeSabat?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    IsForemanHourApproved?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    IsForemanApproval?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    ForemanApprovalGeneralCRMUserId?: StringNullableFilter<"EmployeeHours"> | string | null
    IsComplementRow?: IntNullableFilter<"EmployeeHours"> | number | null
    Lkup_ActionType?: XOR<Lkup_ActionTypeNullableScalarRelationFilter, Lkup_ActionTypeWhereInput> | null
    EmployeeHoursByLocality?: XOR<EmployeeHoursByLocalityScalarRelationFilter, EmployeeHoursByLocalityWhereInput>
  }

  export type EmployeeHoursOrderByWithRelationInput = {
    EmployeeHoursId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    EmployeeNumber?: SortOrder
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    LeadingDate?: SortOrder
    HourStart?: SortOrderInput | SortOrder
    HourEnd?: SortOrderInput | SortOrder
    HourStartSource?: SortOrderInput | SortOrder
    HourEndSource?: SortOrderInput | SortOrder
    RealHours?: SortOrderInput | SortOrder
    QtyHour?: SortOrderInput | SortOrder
    QtyHour125?: SortOrderInput | SortOrder
    QtyHour150?: SortOrderInput | SortOrder
    QtyHour175?: SortOrderInput | SortOrder
    QtyHour200?: SortOrderInput | SortOrder
    BreakMinutes?: SortOrderInput | SortOrder
    GpsStart?: SortOrderInput | SortOrder
    GpsEnd?: SortOrderInput | SortOrder
    EmployeeHoursByLocalityId?: SortOrder
    IsManualInsert?: SortOrderInput | SortOrder
    ManualInsertUserId?: SortOrderInput | SortOrder
    IsRowDeleted?: SortOrderInput | SortOrder
    ActionTypeID?: SortOrderInput | SortOrder
    DayTypeID?: SortOrderInput | SortOrder
    HolidayName?: SortOrderInput | SortOrder
    StartEndTimeSabat?: SortOrderInput | SortOrder
    IsForemanHourApproved?: SortOrderInput | SortOrder
    IsForemanApproval?: SortOrderInput | SortOrder
    ForemanApprovalGeneralCRMUserId?: SortOrderInput | SortOrder
    IsComplementRow?: SortOrderInput | SortOrder
    Lkup_ActionType?: Lkup_ActionTypeOrderByWithRelationInput
    EmployeeHoursByLocality?: EmployeeHoursByLocalityOrderByWithRelationInput
  }

  export type EmployeeHoursWhereUniqueInput = Prisma.AtLeast<{
    EmployeeHoursId?: string
    AND?: EmployeeHoursWhereInput | EmployeeHoursWhereInput[]
    OR?: EmployeeHoursWhereInput[]
    NOT?: EmployeeHoursWhereInput | EmployeeHoursWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHours"> | string
    EmployeeId?: IntFilter<"EmployeeHours"> | number
    EmployeeNumber?: IntFilter<"EmployeeHours"> | number
    MonthManaged?: IntFilter<"EmployeeHours"> | number
    YearManaged?: IntFilter<"EmployeeHours"> | number
    LeadingDate?: DateTimeFilter<"EmployeeHours"> | Date | string
    HourStart?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    HourEnd?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    HourStartSource?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    HourEndSource?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    RealHours?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour125?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour150?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour175?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour200?: FloatNullableFilter<"EmployeeHours"> | number | null
    BreakMinutes?: FloatNullableFilter<"EmployeeHours"> | number | null
    GpsStart?: StringNullableFilter<"EmployeeHours"> | string | null
    GpsEnd?: StringNullableFilter<"EmployeeHours"> | string | null
    EmployeeHoursByLocalityId?: StringFilter<"EmployeeHours"> | string
    IsManualInsert?: IntNullableFilter<"EmployeeHours"> | number | null
    ManualInsertUserId?: StringNullableFilter<"EmployeeHours"> | string | null
    IsRowDeleted?: IntNullableFilter<"EmployeeHours"> | number | null
    ActionTypeID?: IntNullableFilter<"EmployeeHours"> | number | null
    DayTypeID?: IntNullableFilter<"EmployeeHours"> | number | null
    HolidayName?: StringNullableFilter<"EmployeeHours"> | string | null
    StartEndTimeSabat?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    IsForemanHourApproved?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    IsForemanApproval?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    ForemanApprovalGeneralCRMUserId?: StringNullableFilter<"EmployeeHours"> | string | null
    IsComplementRow?: IntNullableFilter<"EmployeeHours"> | number | null
    Lkup_ActionType?: XOR<Lkup_ActionTypeNullableScalarRelationFilter, Lkup_ActionTypeWhereInput> | null
    EmployeeHoursByLocality?: XOR<EmployeeHoursByLocalityScalarRelationFilter, EmployeeHoursByLocalityWhereInput>
  }, "EmployeeHoursId">

  export type EmployeeHoursOrderByWithAggregationInput = {
    EmployeeHoursId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    EmployeeNumber?: SortOrder
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    LeadingDate?: SortOrder
    HourStart?: SortOrderInput | SortOrder
    HourEnd?: SortOrderInput | SortOrder
    HourStartSource?: SortOrderInput | SortOrder
    HourEndSource?: SortOrderInput | SortOrder
    RealHours?: SortOrderInput | SortOrder
    QtyHour?: SortOrderInput | SortOrder
    QtyHour125?: SortOrderInput | SortOrder
    QtyHour150?: SortOrderInput | SortOrder
    QtyHour175?: SortOrderInput | SortOrder
    QtyHour200?: SortOrderInput | SortOrder
    BreakMinutes?: SortOrderInput | SortOrder
    GpsStart?: SortOrderInput | SortOrder
    GpsEnd?: SortOrderInput | SortOrder
    EmployeeHoursByLocalityId?: SortOrder
    IsManualInsert?: SortOrderInput | SortOrder
    ManualInsertUserId?: SortOrderInput | SortOrder
    IsRowDeleted?: SortOrderInput | SortOrder
    ActionTypeID?: SortOrderInput | SortOrder
    DayTypeID?: SortOrderInput | SortOrder
    HolidayName?: SortOrderInput | SortOrder
    StartEndTimeSabat?: SortOrderInput | SortOrder
    IsForemanHourApproved?: SortOrderInput | SortOrder
    IsForemanApproval?: SortOrderInput | SortOrder
    ForemanApprovalGeneralCRMUserId?: SortOrderInput | SortOrder
    IsComplementRow?: SortOrderInput | SortOrder
    _count?: EmployeeHoursCountOrderByAggregateInput
    _avg?: EmployeeHoursAvgOrderByAggregateInput
    _max?: EmployeeHoursMaxOrderByAggregateInput
    _min?: EmployeeHoursMinOrderByAggregateInput
    _sum?: EmployeeHoursSumOrderByAggregateInput
  }

  export type EmployeeHoursScalarWhereWithAggregatesInput = {
    AND?: EmployeeHoursScalarWhereWithAggregatesInput | EmployeeHoursScalarWhereWithAggregatesInput[]
    OR?: EmployeeHoursScalarWhereWithAggregatesInput[]
    NOT?: EmployeeHoursScalarWhereWithAggregatesInput | EmployeeHoursScalarWhereWithAggregatesInput[]
    EmployeeHoursId?: StringWithAggregatesFilter<"EmployeeHours"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeHours"> | Date | string | null
    CompanyIdGeneralCRM?: StringWithAggregatesFilter<"EmployeeHours"> | string
    EmployeeId?: IntWithAggregatesFilter<"EmployeeHours"> | number
    EmployeeNumber?: IntWithAggregatesFilter<"EmployeeHours"> | number
    MonthManaged?: IntWithAggregatesFilter<"EmployeeHours"> | number
    YearManaged?: IntWithAggregatesFilter<"EmployeeHours"> | number
    LeadingDate?: DateTimeWithAggregatesFilter<"EmployeeHours"> | Date | string
    HourStart?: DateTimeNullableWithAggregatesFilter<"EmployeeHours"> | Date | string | null
    HourEnd?: DateTimeNullableWithAggregatesFilter<"EmployeeHours"> | Date | string | null
    HourStartSource?: DateTimeNullableWithAggregatesFilter<"EmployeeHours"> | Date | string | null
    HourEndSource?: DateTimeNullableWithAggregatesFilter<"EmployeeHours"> | Date | string | null
    RealHours?: FloatNullableWithAggregatesFilter<"EmployeeHours"> | number | null
    QtyHour?: FloatNullableWithAggregatesFilter<"EmployeeHours"> | number | null
    QtyHour125?: FloatNullableWithAggregatesFilter<"EmployeeHours"> | number | null
    QtyHour150?: FloatNullableWithAggregatesFilter<"EmployeeHours"> | number | null
    QtyHour175?: FloatNullableWithAggregatesFilter<"EmployeeHours"> | number | null
    QtyHour200?: FloatNullableWithAggregatesFilter<"EmployeeHours"> | number | null
    BreakMinutes?: FloatNullableWithAggregatesFilter<"EmployeeHours"> | number | null
    GpsStart?: StringNullableWithAggregatesFilter<"EmployeeHours"> | string | null
    GpsEnd?: StringNullableWithAggregatesFilter<"EmployeeHours"> | string | null
    EmployeeHoursByLocalityId?: StringWithAggregatesFilter<"EmployeeHours"> | string
    IsManualInsert?: IntNullableWithAggregatesFilter<"EmployeeHours"> | number | null
    ManualInsertUserId?: StringNullableWithAggregatesFilter<"EmployeeHours"> | string | null
    IsRowDeleted?: IntNullableWithAggregatesFilter<"EmployeeHours"> | number | null
    ActionTypeID?: IntNullableWithAggregatesFilter<"EmployeeHours"> | number | null
    DayTypeID?: IntNullableWithAggregatesFilter<"EmployeeHours"> | number | null
    HolidayName?: StringNullableWithAggregatesFilter<"EmployeeHours"> | string | null
    StartEndTimeSabat?: DateTimeNullableWithAggregatesFilter<"EmployeeHours"> | Date | string | null
    IsForemanHourApproved?: DateTimeNullableWithAggregatesFilter<"EmployeeHours"> | Date | string | null
    IsForemanApproval?: DateTimeNullableWithAggregatesFilter<"EmployeeHours"> | Date | string | null
    ForemanApprovalGeneralCRMUserId?: StringNullableWithAggregatesFilter<"EmployeeHours"> | string | null
    IsComplementRow?: IntNullableWithAggregatesFilter<"EmployeeHours"> | number | null
  }

  export type EmployeeHoursByLocalityWhereInput = {
    AND?: EmployeeHoursByLocalityWhereInput | EmployeeHoursByLocalityWhereInput[]
    OR?: EmployeeHoursByLocalityWhereInput[]
    NOT?: EmployeeHoursByLocalityWhereInput | EmployeeHoursByLocalityWhereInput[]
    EmployeeHoursByLocalityId?: StringFilter<"EmployeeHoursByLocality"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursByLocality"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursByLocality"> | string
    EmployeeId?: IntFilter<"EmployeeHoursByLocality"> | number
    NotShowEmployeeHours?: IntNullableFilter<"EmployeeHoursByLocality"> | number | null
    EmployeeHoursLocalityId?: StringFilter<"EmployeeHoursByLocality"> | string
    HourMinStart?: DateTimeNullableFilter<"EmployeeHoursByLocality"> | Date | string | null
    HourMaxStop?: DateTimeNullableFilter<"EmployeeHoursByLocality"> | Date | string | null
    RoundTime?: StringNullableFilter<"EmployeeHoursByLocality"> | string | null
    EmployeeHoursUserId?: StringFilter<"EmployeeHoursByLocality"> | string
    MinimumHours2BreakTime?: FloatFilter<"EmployeeHoursByLocality"> | number
    BreakTime?: IntNullableFilter<"EmployeeHoursByLocality"> | number | null
    AlertForMaxMonthHours?: FloatNullableFilter<"EmployeeHoursByLocality"> | number | null
    EmployeeHoursContractId?: StringFilter<"EmployeeHoursByLocality"> | string
    EmployeeHours?: EmployeeHoursListRelationFilter
    EmployeeHoursUsers?: XOR<EmployeeHoursUsersScalarRelationFilter, EmployeeHoursUsersWhereInput>
    EmployeeHoursContracts?: XOR<EmployeeHoursContractsScalarRelationFilter, EmployeeHoursContractsWhereInput>
    EmployeeHoursLocalities?: XOR<EmployeeHoursLocalitiesScalarRelationFilter, EmployeeHoursLocalitiesWhereInput>
  }

  export type EmployeeHoursByLocalityOrderByWithRelationInput = {
    EmployeeHoursByLocalityId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    NotShowEmployeeHours?: SortOrderInput | SortOrder
    EmployeeHoursLocalityId?: SortOrder
    HourMinStart?: SortOrderInput | SortOrder
    HourMaxStop?: SortOrderInput | SortOrder
    RoundTime?: SortOrderInput | SortOrder
    EmployeeHoursUserId?: SortOrder
    MinimumHours2BreakTime?: SortOrder
    BreakTime?: SortOrderInput | SortOrder
    AlertForMaxMonthHours?: SortOrderInput | SortOrder
    EmployeeHoursContractId?: SortOrder
    EmployeeHours?: EmployeeHoursOrderByRelationAggregateInput
    EmployeeHoursUsers?: EmployeeHoursUsersOrderByWithRelationInput
    EmployeeHoursContracts?: EmployeeHoursContractsOrderByWithRelationInput
    EmployeeHoursLocalities?: EmployeeHoursLocalitiesOrderByWithRelationInput
  }

  export type EmployeeHoursByLocalityWhereUniqueInput = Prisma.AtLeast<{
    EmployeeHoursByLocalityId?: string
    AND?: EmployeeHoursByLocalityWhereInput | EmployeeHoursByLocalityWhereInput[]
    OR?: EmployeeHoursByLocalityWhereInput[]
    NOT?: EmployeeHoursByLocalityWhereInput | EmployeeHoursByLocalityWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursByLocality"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursByLocality"> | string
    EmployeeId?: IntFilter<"EmployeeHoursByLocality"> | number
    NotShowEmployeeHours?: IntNullableFilter<"EmployeeHoursByLocality"> | number | null
    EmployeeHoursLocalityId?: StringFilter<"EmployeeHoursByLocality"> | string
    HourMinStart?: DateTimeNullableFilter<"EmployeeHoursByLocality"> | Date | string | null
    HourMaxStop?: DateTimeNullableFilter<"EmployeeHoursByLocality"> | Date | string | null
    RoundTime?: StringNullableFilter<"EmployeeHoursByLocality"> | string | null
    EmployeeHoursUserId?: StringFilter<"EmployeeHoursByLocality"> | string
    MinimumHours2BreakTime?: FloatFilter<"EmployeeHoursByLocality"> | number
    BreakTime?: IntNullableFilter<"EmployeeHoursByLocality"> | number | null
    AlertForMaxMonthHours?: FloatNullableFilter<"EmployeeHoursByLocality"> | number | null
    EmployeeHoursContractId?: StringFilter<"EmployeeHoursByLocality"> | string
    EmployeeHours?: EmployeeHoursListRelationFilter
    EmployeeHoursUsers?: XOR<EmployeeHoursUsersScalarRelationFilter, EmployeeHoursUsersWhereInput>
    EmployeeHoursContracts?: XOR<EmployeeHoursContractsScalarRelationFilter, EmployeeHoursContractsWhereInput>
    EmployeeHoursLocalities?: XOR<EmployeeHoursLocalitiesScalarRelationFilter, EmployeeHoursLocalitiesWhereInput>
  }, "EmployeeHoursByLocalityId">

  export type EmployeeHoursByLocalityOrderByWithAggregationInput = {
    EmployeeHoursByLocalityId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    NotShowEmployeeHours?: SortOrderInput | SortOrder
    EmployeeHoursLocalityId?: SortOrder
    HourMinStart?: SortOrderInput | SortOrder
    HourMaxStop?: SortOrderInput | SortOrder
    RoundTime?: SortOrderInput | SortOrder
    EmployeeHoursUserId?: SortOrder
    MinimumHours2BreakTime?: SortOrder
    BreakTime?: SortOrderInput | SortOrder
    AlertForMaxMonthHours?: SortOrderInput | SortOrder
    EmployeeHoursContractId?: SortOrder
    _count?: EmployeeHoursByLocalityCountOrderByAggregateInput
    _avg?: EmployeeHoursByLocalityAvgOrderByAggregateInput
    _max?: EmployeeHoursByLocalityMaxOrderByAggregateInput
    _min?: EmployeeHoursByLocalityMinOrderByAggregateInput
    _sum?: EmployeeHoursByLocalitySumOrderByAggregateInput
  }

  export type EmployeeHoursByLocalityScalarWhereWithAggregatesInput = {
    AND?: EmployeeHoursByLocalityScalarWhereWithAggregatesInput | EmployeeHoursByLocalityScalarWhereWithAggregatesInput[]
    OR?: EmployeeHoursByLocalityScalarWhereWithAggregatesInput[]
    NOT?: EmployeeHoursByLocalityScalarWhereWithAggregatesInput | EmployeeHoursByLocalityScalarWhereWithAggregatesInput[]
    EmployeeHoursByLocalityId?: StringWithAggregatesFilter<"EmployeeHoursByLocality"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursByLocality"> | Date | string | null
    CompanyIdGeneralCRM?: StringWithAggregatesFilter<"EmployeeHoursByLocality"> | string
    EmployeeId?: IntWithAggregatesFilter<"EmployeeHoursByLocality"> | number
    NotShowEmployeeHours?: IntNullableWithAggregatesFilter<"EmployeeHoursByLocality"> | number | null
    EmployeeHoursLocalityId?: StringWithAggregatesFilter<"EmployeeHoursByLocality"> | string
    HourMinStart?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursByLocality"> | Date | string | null
    HourMaxStop?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursByLocality"> | Date | string | null
    RoundTime?: StringNullableWithAggregatesFilter<"EmployeeHoursByLocality"> | string | null
    EmployeeHoursUserId?: StringWithAggregatesFilter<"EmployeeHoursByLocality"> | string
    MinimumHours2BreakTime?: FloatWithAggregatesFilter<"EmployeeHoursByLocality"> | number
    BreakTime?: IntNullableWithAggregatesFilter<"EmployeeHoursByLocality"> | number | null
    AlertForMaxMonthHours?: FloatNullableWithAggregatesFilter<"EmployeeHoursByLocality"> | number | null
    EmployeeHoursContractId?: StringWithAggregatesFilter<"EmployeeHoursByLocality"> | string
  }

  export type EmployeeHoursByLocalityTotalsWhereInput = {
    AND?: EmployeeHoursByLocalityTotalsWhereInput | EmployeeHoursByLocalityTotalsWhereInput[]
    OR?: EmployeeHoursByLocalityTotalsWhereInput[]
    NOT?: EmployeeHoursByLocalityTotalsWhereInput | EmployeeHoursByLocalityTotalsWhereInput[]
    EmployeeHoursByLocalityTotalsId?: StringFilter<"EmployeeHoursByLocalityTotals"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursByLocalityTotals"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursByLocalityTotals"> | string
    MonthManaged?: IntFilter<"EmployeeHoursByLocalityTotals"> | number
    YearManaged?: IntFilter<"EmployeeHoursByLocalityTotals"> | number
    EmployeeId?: IntFilter<"EmployeeHoursByLocalityTotals"> | number
    EmployeeHoursLocalityId?: StringFilter<"EmployeeHoursByLocalityTotals"> | string
    QtyHour?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour125?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour150?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour175?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour200?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    RealHours?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    BreakMinutes?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    WorkedDays?: IntNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    IsCloseSalary?: IntFilter<"EmployeeHoursByLocalityTotals"> | number
    EmployeeHoursLocalities?: XOR<EmployeeHoursLocalitiesScalarRelationFilter, EmployeeHoursLocalitiesWhereInput>
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeListRelationFilter
  }

  export type EmployeeHoursByLocalityTotalsOrderByWithRelationInput = {
    EmployeeHoursByLocalityTotalsId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    EmployeeId?: SortOrder
    EmployeeHoursLocalityId?: SortOrder
    QtyHour?: SortOrderInput | SortOrder
    QtyHour125?: SortOrderInput | SortOrder
    QtyHour150?: SortOrderInput | SortOrder
    QtyHour175?: SortOrderInput | SortOrder
    QtyHour200?: SortOrderInput | SortOrder
    RealHours?: SortOrderInput | SortOrder
    BreakMinutes?: SortOrderInput | SortOrder
    WorkedDays?: SortOrderInput | SortOrder
    IsCloseSalary?: SortOrder
    EmployeeHoursLocalities?: EmployeeHoursLocalitiesOrderByWithRelationInput
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeOrderByRelationAggregateInput
  }

  export type EmployeeHoursByLocalityTotalsWhereUniqueInput = Prisma.AtLeast<{
    EmployeeHoursByLocalityTotalsId?: string
    AND?: EmployeeHoursByLocalityTotalsWhereInput | EmployeeHoursByLocalityTotalsWhereInput[]
    OR?: EmployeeHoursByLocalityTotalsWhereInput[]
    NOT?: EmployeeHoursByLocalityTotalsWhereInput | EmployeeHoursByLocalityTotalsWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursByLocalityTotals"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursByLocalityTotals"> | string
    MonthManaged?: IntFilter<"EmployeeHoursByLocalityTotals"> | number
    YearManaged?: IntFilter<"EmployeeHoursByLocalityTotals"> | number
    EmployeeId?: IntFilter<"EmployeeHoursByLocalityTotals"> | number
    EmployeeHoursLocalityId?: StringFilter<"EmployeeHoursByLocalityTotals"> | string
    QtyHour?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour125?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour150?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour175?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour200?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    RealHours?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    BreakMinutes?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    WorkedDays?: IntNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    IsCloseSalary?: IntFilter<"EmployeeHoursByLocalityTotals"> | number
    EmployeeHoursLocalities?: XOR<EmployeeHoursLocalitiesScalarRelationFilter, EmployeeHoursLocalitiesWhereInput>
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeListRelationFilter
  }, "EmployeeHoursByLocalityTotalsId">

  export type EmployeeHoursByLocalityTotalsOrderByWithAggregationInput = {
    EmployeeHoursByLocalityTotalsId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    EmployeeId?: SortOrder
    EmployeeHoursLocalityId?: SortOrder
    QtyHour?: SortOrderInput | SortOrder
    QtyHour125?: SortOrderInput | SortOrder
    QtyHour150?: SortOrderInput | SortOrder
    QtyHour175?: SortOrderInput | SortOrder
    QtyHour200?: SortOrderInput | SortOrder
    RealHours?: SortOrderInput | SortOrder
    BreakMinutes?: SortOrderInput | SortOrder
    WorkedDays?: SortOrderInput | SortOrder
    IsCloseSalary?: SortOrder
    _count?: EmployeeHoursByLocalityTotalsCountOrderByAggregateInput
    _avg?: EmployeeHoursByLocalityTotalsAvgOrderByAggregateInput
    _max?: EmployeeHoursByLocalityTotalsMaxOrderByAggregateInput
    _min?: EmployeeHoursByLocalityTotalsMinOrderByAggregateInput
    _sum?: EmployeeHoursByLocalityTotalsSumOrderByAggregateInput
  }

  export type EmployeeHoursByLocalityTotalsScalarWhereWithAggregatesInput = {
    AND?: EmployeeHoursByLocalityTotalsScalarWhereWithAggregatesInput | EmployeeHoursByLocalityTotalsScalarWhereWithAggregatesInput[]
    OR?: EmployeeHoursByLocalityTotalsScalarWhereWithAggregatesInput[]
    NOT?: EmployeeHoursByLocalityTotalsScalarWhereWithAggregatesInput | EmployeeHoursByLocalityTotalsScalarWhereWithAggregatesInput[]
    EmployeeHoursByLocalityTotalsId?: StringWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | Date | string | null
    CompanyIdGeneralCRM?: StringWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | string
    MonthManaged?: IntWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | number
    YearManaged?: IntWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | number
    EmployeeId?: IntWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | number
    EmployeeHoursLocalityId?: StringWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | string
    QtyHour?: FloatNullableWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour125?: FloatNullableWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour150?: FloatNullableWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour175?: FloatNullableWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour200?: FloatNullableWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | number | null
    RealHours?: FloatNullableWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | number | null
    BreakMinutes?: FloatNullableWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | number | null
    WorkedDays?: IntNullableWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | number | null
    IsCloseSalary?: IntWithAggregatesFilter<"EmployeeHoursByLocalityTotals"> | number
  }

  export type EmployeeHoursByLocalityTotalsActionTypeWhereInput = {
    AND?: EmployeeHoursByLocalityTotalsActionTypeWhereInput | EmployeeHoursByLocalityTotalsActionTypeWhereInput[]
    OR?: EmployeeHoursByLocalityTotalsActionTypeWhereInput[]
    NOT?: EmployeeHoursByLocalityTotalsActionTypeWhereInput | EmployeeHoursByLocalityTotalsActionTypeWhereInput[]
    EmployeeHoursByLocalityTotalsActionTypeId?: StringFilter<"EmployeeHoursByLocalityTotalsActionType"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursByLocalityTotalsActionType"> | Date | string | null
    EmployeeHoursByLocalityTotalsId?: StringFilter<"EmployeeHoursByLocalityTotalsActionType"> | string
    ActionTypeId?: IntFilter<"EmployeeHoursByLocalityTotalsActionType"> | number
    TotalActionType?: FloatFilter<"EmployeeHoursByLocalityTotalsActionType"> | number
    Lkup_ActionType?: XOR<Lkup_ActionTypeScalarRelationFilter, Lkup_ActionTypeWhereInput>
    EmployeeHoursByLocalityTotals?: XOR<EmployeeHoursByLocalityTotalsScalarRelationFilter, EmployeeHoursByLocalityTotalsWhereInput>
  }

  export type EmployeeHoursByLocalityTotalsActionTypeOrderByWithRelationInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    EmployeeHoursByLocalityTotalsId?: SortOrder
    ActionTypeId?: SortOrder
    TotalActionType?: SortOrder
    Lkup_ActionType?: Lkup_ActionTypeOrderByWithRelationInput
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsOrderByWithRelationInput
  }

  export type EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput = Prisma.AtLeast<{
    EmployeeHoursByLocalityTotalsActionTypeId?: string
    AND?: EmployeeHoursByLocalityTotalsActionTypeWhereInput | EmployeeHoursByLocalityTotalsActionTypeWhereInput[]
    OR?: EmployeeHoursByLocalityTotalsActionTypeWhereInput[]
    NOT?: EmployeeHoursByLocalityTotalsActionTypeWhereInput | EmployeeHoursByLocalityTotalsActionTypeWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursByLocalityTotalsActionType"> | Date | string | null
    EmployeeHoursByLocalityTotalsId?: StringFilter<"EmployeeHoursByLocalityTotalsActionType"> | string
    ActionTypeId?: IntFilter<"EmployeeHoursByLocalityTotalsActionType"> | number
    TotalActionType?: FloatFilter<"EmployeeHoursByLocalityTotalsActionType"> | number
    Lkup_ActionType?: XOR<Lkup_ActionTypeScalarRelationFilter, Lkup_ActionTypeWhereInput>
    EmployeeHoursByLocalityTotals?: XOR<EmployeeHoursByLocalityTotalsScalarRelationFilter, EmployeeHoursByLocalityTotalsWhereInput>
  }, "EmployeeHoursByLocalityTotalsActionTypeId">

  export type EmployeeHoursByLocalityTotalsActionTypeOrderByWithAggregationInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    EmployeeHoursByLocalityTotalsId?: SortOrder
    ActionTypeId?: SortOrder
    TotalActionType?: SortOrder
    _count?: EmployeeHoursByLocalityTotalsActionTypeCountOrderByAggregateInput
    _avg?: EmployeeHoursByLocalityTotalsActionTypeAvgOrderByAggregateInput
    _max?: EmployeeHoursByLocalityTotalsActionTypeMaxOrderByAggregateInput
    _min?: EmployeeHoursByLocalityTotalsActionTypeMinOrderByAggregateInput
    _sum?: EmployeeHoursByLocalityTotalsActionTypeSumOrderByAggregateInput
  }

  export type EmployeeHoursByLocalityTotalsActionTypeScalarWhereWithAggregatesInput = {
    AND?: EmployeeHoursByLocalityTotalsActionTypeScalarWhereWithAggregatesInput | EmployeeHoursByLocalityTotalsActionTypeScalarWhereWithAggregatesInput[]
    OR?: EmployeeHoursByLocalityTotalsActionTypeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeHoursByLocalityTotalsActionTypeScalarWhereWithAggregatesInput | EmployeeHoursByLocalityTotalsActionTypeScalarWhereWithAggregatesInput[]
    EmployeeHoursByLocalityTotalsActionTypeId?: StringWithAggregatesFilter<"EmployeeHoursByLocalityTotalsActionType"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursByLocalityTotalsActionType"> | Date | string | null
    EmployeeHoursByLocalityTotalsId?: StringWithAggregatesFilter<"EmployeeHoursByLocalityTotalsActionType"> | string
    ActionTypeId?: IntWithAggregatesFilter<"EmployeeHoursByLocalityTotalsActionType"> | number
    TotalActionType?: FloatWithAggregatesFilter<"EmployeeHoursByLocalityTotalsActionType"> | number
  }

  export type EmployeeHoursCompaniesSmsAlertWhereInput = {
    AND?: EmployeeHoursCompaniesSmsAlertWhereInput | EmployeeHoursCompaniesSmsAlertWhereInput[]
    OR?: EmployeeHoursCompaniesSmsAlertWhereInput[]
    NOT?: EmployeeHoursCompaniesSmsAlertWhereInput | EmployeeHoursCompaniesSmsAlertWhereInput[]
    CompaniesSmsAlertId?: IntFilter<"EmployeeHoursCompaniesSmsAlert"> | number
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursCompaniesSmsAlert"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursCompaniesSmsAlert"> | Date | string | null
    EmployeeID?: IntNullableFilter<"EmployeeHoursCompaniesSmsAlert"> | number | null
    SmsNumber?: StringFilter<"EmployeeHoursCompaniesSmsAlert"> | string
    SmsResponse?: StringNullableFilter<"EmployeeHoursCompaniesSmsAlert"> | string | null
    UserSend?: StringFilter<"EmployeeHoursCompaniesSmsAlert"> | string
  }

  export type EmployeeHoursCompaniesSmsAlertOrderByWithRelationInput = {
    CompaniesSmsAlertId?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    EmployeeID?: SortOrderInput | SortOrder
    SmsNumber?: SortOrder
    SmsResponse?: SortOrderInput | SortOrder
    UserSend?: SortOrder
  }

  export type EmployeeHoursCompaniesSmsAlertWhereUniqueInput = Prisma.AtLeast<{
    CompaniesSmsAlertId?: number
    AND?: EmployeeHoursCompaniesSmsAlertWhereInput | EmployeeHoursCompaniesSmsAlertWhereInput[]
    OR?: EmployeeHoursCompaniesSmsAlertWhereInput[]
    NOT?: EmployeeHoursCompaniesSmsAlertWhereInput | EmployeeHoursCompaniesSmsAlertWhereInput[]
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursCompaniesSmsAlert"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursCompaniesSmsAlert"> | Date | string | null
    EmployeeID?: IntNullableFilter<"EmployeeHoursCompaniesSmsAlert"> | number | null
    SmsNumber?: StringFilter<"EmployeeHoursCompaniesSmsAlert"> | string
    SmsResponse?: StringNullableFilter<"EmployeeHoursCompaniesSmsAlert"> | string | null
    UserSend?: StringFilter<"EmployeeHoursCompaniesSmsAlert"> | string
  }, "CompaniesSmsAlertId">

  export type EmployeeHoursCompaniesSmsAlertOrderByWithAggregationInput = {
    CompaniesSmsAlertId?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    EmployeeID?: SortOrderInput | SortOrder
    SmsNumber?: SortOrder
    SmsResponse?: SortOrderInput | SortOrder
    UserSend?: SortOrder
    _count?: EmployeeHoursCompaniesSmsAlertCountOrderByAggregateInput
    _avg?: EmployeeHoursCompaniesSmsAlertAvgOrderByAggregateInput
    _max?: EmployeeHoursCompaniesSmsAlertMaxOrderByAggregateInput
    _min?: EmployeeHoursCompaniesSmsAlertMinOrderByAggregateInput
    _sum?: EmployeeHoursCompaniesSmsAlertSumOrderByAggregateInput
  }

  export type EmployeeHoursCompaniesSmsAlertScalarWhereWithAggregatesInput = {
    AND?: EmployeeHoursCompaniesSmsAlertScalarWhereWithAggregatesInput | EmployeeHoursCompaniesSmsAlertScalarWhereWithAggregatesInput[]
    OR?: EmployeeHoursCompaniesSmsAlertScalarWhereWithAggregatesInput[]
    NOT?: EmployeeHoursCompaniesSmsAlertScalarWhereWithAggregatesInput | EmployeeHoursCompaniesSmsAlertScalarWhereWithAggregatesInput[]
    CompaniesSmsAlertId?: IntWithAggregatesFilter<"EmployeeHoursCompaniesSmsAlert"> | number
    CompanyIdGeneralCRM?: StringWithAggregatesFilter<"EmployeeHoursCompaniesSmsAlert"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursCompaniesSmsAlert"> | Date | string | null
    EmployeeID?: IntNullableWithAggregatesFilter<"EmployeeHoursCompaniesSmsAlert"> | number | null
    SmsNumber?: StringWithAggregatesFilter<"EmployeeHoursCompaniesSmsAlert"> | string
    SmsResponse?: StringNullableWithAggregatesFilter<"EmployeeHoursCompaniesSmsAlert"> | string | null
    UserSend?: StringWithAggregatesFilter<"EmployeeHoursCompaniesSmsAlert"> | string
  }

  export type EmployeeHoursContractsWhereInput = {
    AND?: EmployeeHoursContractsWhereInput | EmployeeHoursContractsWhereInput[]
    OR?: EmployeeHoursContractsWhereInput[]
    NOT?: EmployeeHoursContractsWhereInput | EmployeeHoursContractsWhereInput[]
    EmployeeHoursContractsId?: StringFilter<"EmployeeHoursContracts"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursContracts"> | Date | string | null
    Active?: IntFilter<"EmployeeHoursContracts"> | number
    HebrewName?: StringFilter<"EmployeeHoursContracts"> | string
    Comments?: StringNullableFilter<"EmployeeHoursContracts"> | string | null
    JsonData?: StringFilter<"EmployeeHoursContracts"> | string
    CompanyIdGeneralCRM?: StringNullableFilter<"EmployeeHoursContracts"> | string | null
    HoursWeek?: FloatFilter<"EmployeeHoursContracts"> | number
    NumberDayInWeek?: IntFilter<"EmployeeHoursContracts"> | number
    IsExtraHoursWeekCalc?: IntNullableFilter<"EmployeeHoursContracts"> | number | null
    IsNightShiftCalc?: IntNullableFilter<"EmployeeHoursContracts"> | number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityListRelationFilter
  }

  export type EmployeeHoursContractsOrderByWithRelationInput = {
    EmployeeHoursContractsId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    Active?: SortOrder
    HebrewName?: SortOrder
    Comments?: SortOrderInput | SortOrder
    JsonData?: SortOrder
    CompanyIdGeneralCRM?: SortOrderInput | SortOrder
    HoursWeek?: SortOrder
    NumberDayInWeek?: SortOrder
    IsExtraHoursWeekCalc?: SortOrderInput | SortOrder
    IsNightShiftCalc?: SortOrderInput | SortOrder
    EmployeeHoursByLocality?: EmployeeHoursByLocalityOrderByRelationAggregateInput
  }

  export type EmployeeHoursContractsWhereUniqueInput = Prisma.AtLeast<{
    EmployeeHoursContractsId?: string
    AND?: EmployeeHoursContractsWhereInput | EmployeeHoursContractsWhereInput[]
    OR?: EmployeeHoursContractsWhereInput[]
    NOT?: EmployeeHoursContractsWhereInput | EmployeeHoursContractsWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursContracts"> | Date | string | null
    Active?: IntFilter<"EmployeeHoursContracts"> | number
    HebrewName?: StringFilter<"EmployeeHoursContracts"> | string
    Comments?: StringNullableFilter<"EmployeeHoursContracts"> | string | null
    JsonData?: StringFilter<"EmployeeHoursContracts"> | string
    CompanyIdGeneralCRM?: StringNullableFilter<"EmployeeHoursContracts"> | string | null
    HoursWeek?: FloatFilter<"EmployeeHoursContracts"> | number
    NumberDayInWeek?: IntFilter<"EmployeeHoursContracts"> | number
    IsExtraHoursWeekCalc?: IntNullableFilter<"EmployeeHoursContracts"> | number | null
    IsNightShiftCalc?: IntNullableFilter<"EmployeeHoursContracts"> | number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityListRelationFilter
  }, "EmployeeHoursContractsId">

  export type EmployeeHoursContractsOrderByWithAggregationInput = {
    EmployeeHoursContractsId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    Active?: SortOrder
    HebrewName?: SortOrder
    Comments?: SortOrderInput | SortOrder
    JsonData?: SortOrder
    CompanyIdGeneralCRM?: SortOrderInput | SortOrder
    HoursWeek?: SortOrder
    NumberDayInWeek?: SortOrder
    IsExtraHoursWeekCalc?: SortOrderInput | SortOrder
    IsNightShiftCalc?: SortOrderInput | SortOrder
    _count?: EmployeeHoursContractsCountOrderByAggregateInput
    _avg?: EmployeeHoursContractsAvgOrderByAggregateInput
    _max?: EmployeeHoursContractsMaxOrderByAggregateInput
    _min?: EmployeeHoursContractsMinOrderByAggregateInput
    _sum?: EmployeeHoursContractsSumOrderByAggregateInput
  }

  export type EmployeeHoursContractsScalarWhereWithAggregatesInput = {
    AND?: EmployeeHoursContractsScalarWhereWithAggregatesInput | EmployeeHoursContractsScalarWhereWithAggregatesInput[]
    OR?: EmployeeHoursContractsScalarWhereWithAggregatesInput[]
    NOT?: EmployeeHoursContractsScalarWhereWithAggregatesInput | EmployeeHoursContractsScalarWhereWithAggregatesInput[]
    EmployeeHoursContractsId?: StringWithAggregatesFilter<"EmployeeHoursContracts"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursContracts"> | Date | string | null
    Active?: IntWithAggregatesFilter<"EmployeeHoursContracts"> | number
    HebrewName?: StringWithAggregatesFilter<"EmployeeHoursContracts"> | string
    Comments?: StringNullableWithAggregatesFilter<"EmployeeHoursContracts"> | string | null
    JsonData?: StringWithAggregatesFilter<"EmployeeHoursContracts"> | string
    CompanyIdGeneralCRM?: StringNullableWithAggregatesFilter<"EmployeeHoursContracts"> | string | null
    HoursWeek?: FloatWithAggregatesFilter<"EmployeeHoursContracts"> | number
    NumberDayInWeek?: IntWithAggregatesFilter<"EmployeeHoursContracts"> | number
    IsExtraHoursWeekCalc?: IntNullableWithAggregatesFilter<"EmployeeHoursContracts"> | number | null
    IsNightShiftCalc?: IntNullableWithAggregatesFilter<"EmployeeHoursContracts"> | number | null
  }

  export type EmployeeHoursForemansConfigWhereInput = {
    AND?: EmployeeHoursForemansConfigWhereInput | EmployeeHoursForemansConfigWhereInput[]
    OR?: EmployeeHoursForemansConfigWhereInput[]
    NOT?: EmployeeHoursForemansConfigWhereInput | EmployeeHoursForemansConfigWhereInput[]
    EmployeeHoursForemanConfigId?: StringFilter<"EmployeeHoursForemansConfig"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursForemansConfig"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursForemansConfig"> | string
    ForemanUserGeneralCRM?: StringFilter<"EmployeeHoursForemansConfig"> | string
    CanEdit?: IntNullableFilter<"EmployeeHoursForemansConfig"> | number | null
    NotShowSourceHours?: IntNullableFilter<"EmployeeHoursForemansConfig"> | number | null
  }

  export type EmployeeHoursForemansConfigOrderByWithRelationInput = {
    EmployeeHoursForemanConfigId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    ForemanUserGeneralCRM?: SortOrder
    CanEdit?: SortOrderInput | SortOrder
    NotShowSourceHours?: SortOrderInput | SortOrder
  }

  export type EmployeeHoursForemansConfigWhereUniqueInput = Prisma.AtLeast<{
    EmployeeHoursForemanConfigId?: string
    ForemanUserGeneralCRM?: string
    AND?: EmployeeHoursForemansConfigWhereInput | EmployeeHoursForemansConfigWhereInput[]
    OR?: EmployeeHoursForemansConfigWhereInput[]
    NOT?: EmployeeHoursForemansConfigWhereInput | EmployeeHoursForemansConfigWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursForemansConfig"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursForemansConfig"> | string
    CanEdit?: IntNullableFilter<"EmployeeHoursForemansConfig"> | number | null
    NotShowSourceHours?: IntNullableFilter<"EmployeeHoursForemansConfig"> | number | null
  }, "EmployeeHoursForemanConfigId" | "ForemanUserGeneralCRM">

  export type EmployeeHoursForemansConfigOrderByWithAggregationInput = {
    EmployeeHoursForemanConfigId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    ForemanUserGeneralCRM?: SortOrder
    CanEdit?: SortOrderInput | SortOrder
    NotShowSourceHours?: SortOrderInput | SortOrder
    _count?: EmployeeHoursForemansConfigCountOrderByAggregateInput
    _avg?: EmployeeHoursForemansConfigAvgOrderByAggregateInput
    _max?: EmployeeHoursForemansConfigMaxOrderByAggregateInput
    _min?: EmployeeHoursForemansConfigMinOrderByAggregateInput
    _sum?: EmployeeHoursForemansConfigSumOrderByAggregateInput
  }

  export type EmployeeHoursForemansConfigScalarWhereWithAggregatesInput = {
    AND?: EmployeeHoursForemansConfigScalarWhereWithAggregatesInput | EmployeeHoursForemansConfigScalarWhereWithAggregatesInput[]
    OR?: EmployeeHoursForemansConfigScalarWhereWithAggregatesInput[]
    NOT?: EmployeeHoursForemansConfigScalarWhereWithAggregatesInput | EmployeeHoursForemansConfigScalarWhereWithAggregatesInput[]
    EmployeeHoursForemanConfigId?: StringWithAggregatesFilter<"EmployeeHoursForemansConfig"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursForemansConfig"> | Date | string | null
    CompanyIdGeneralCRM?: StringWithAggregatesFilter<"EmployeeHoursForemansConfig"> | string
    ForemanUserGeneralCRM?: StringWithAggregatesFilter<"EmployeeHoursForemansConfig"> | string
    CanEdit?: IntNullableWithAggregatesFilter<"EmployeeHoursForemansConfig"> | number | null
    NotShowSourceHours?: IntNullableWithAggregatesFilter<"EmployeeHoursForemansConfig"> | number | null
  }

  export type EmployeeHoursLocalitiesWhereInput = {
    AND?: EmployeeHoursLocalitiesWhereInput | EmployeeHoursLocalitiesWhereInput[]
    OR?: EmployeeHoursLocalitiesWhereInput[]
    NOT?: EmployeeHoursLocalitiesWhereInput | EmployeeHoursLocalitiesWhereInput[]
    EmployeeHoursLocalityId?: StringFilter<"EmployeeHoursLocalities"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursLocalities"> | Date | string | null
    NotShowLocality?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    LocalityName?: StringFilter<"EmployeeHoursLocalities"> | string
    LocalityNameEng?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursLocalities"> | string
    Address?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    Gps?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    GpsRadius?: IntFilter<"EmployeeHoursLocalities"> | number
    AddressAccess?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    LocalityIDAccess?: IntFilter<"EmployeeHoursLocalities"> | number
    LocalityCodeAccess?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    CustomerIDAccess?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    CustomerNameAccess?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    ForemanGeneralCRMUserId?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    HourMinStart?: DateTimeNullableFilter<"EmployeeHoursLocalities"> | Date | string | null
    HourMaxStop?: DateTimeNullableFilter<"EmployeeHoursLocalities"> | Date | string | null
    RoundTime?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    MinimumHours2BreakTime?: FloatNullableFilter<"EmployeeHoursLocalities"> | number | null
    BreakTime?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    AlertForMaxMonthHours?: FloatNullableFilter<"EmployeeHoursLocalities"> | number | null
    RestrictDayHoursAbove12?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    RestrictWeekExtraHoursAbove16?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    RestrictGpsActive?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityListRelationFilter
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsListRelationFilter
  }

  export type EmployeeHoursLocalitiesOrderByWithRelationInput = {
    EmployeeHoursLocalityId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    NotShowLocality?: SortOrderInput | SortOrder
    LocalityName?: SortOrder
    LocalityNameEng?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    Address?: SortOrderInput | SortOrder
    Gps?: SortOrderInput | SortOrder
    GpsRadius?: SortOrder
    AddressAccess?: SortOrderInput | SortOrder
    LocalityIDAccess?: SortOrder
    LocalityCodeAccess?: SortOrderInput | SortOrder
    CustomerIDAccess?: SortOrderInput | SortOrder
    CustomerNameAccess?: SortOrderInput | SortOrder
    ForemanGeneralCRMUserId?: SortOrderInput | SortOrder
    HourMinStart?: SortOrderInput | SortOrder
    HourMaxStop?: SortOrderInput | SortOrder
    RoundTime?: SortOrderInput | SortOrder
    MinimumHours2BreakTime?: SortOrderInput | SortOrder
    BreakTime?: SortOrderInput | SortOrder
    AlertForMaxMonthHours?: SortOrderInput | SortOrder
    RestrictDayHoursAbove12?: SortOrderInput | SortOrder
    RestrictWeekExtraHoursAbove16?: SortOrderInput | SortOrder
    RestrictGpsActive?: SortOrderInput | SortOrder
    EmployeeHoursByLocality?: EmployeeHoursByLocalityOrderByRelationAggregateInput
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsOrderByRelationAggregateInput
  }

  export type EmployeeHoursLocalitiesWhereUniqueInput = Prisma.AtLeast<{
    EmployeeHoursLocalityId?: string
    AND?: EmployeeHoursLocalitiesWhereInput | EmployeeHoursLocalitiesWhereInput[]
    OR?: EmployeeHoursLocalitiesWhereInput[]
    NOT?: EmployeeHoursLocalitiesWhereInput | EmployeeHoursLocalitiesWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursLocalities"> | Date | string | null
    NotShowLocality?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    LocalityName?: StringFilter<"EmployeeHoursLocalities"> | string
    LocalityNameEng?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursLocalities"> | string
    Address?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    Gps?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    GpsRadius?: IntFilter<"EmployeeHoursLocalities"> | number
    AddressAccess?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    LocalityIDAccess?: IntFilter<"EmployeeHoursLocalities"> | number
    LocalityCodeAccess?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    CustomerIDAccess?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    CustomerNameAccess?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    ForemanGeneralCRMUserId?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    HourMinStart?: DateTimeNullableFilter<"EmployeeHoursLocalities"> | Date | string | null
    HourMaxStop?: DateTimeNullableFilter<"EmployeeHoursLocalities"> | Date | string | null
    RoundTime?: StringNullableFilter<"EmployeeHoursLocalities"> | string | null
    MinimumHours2BreakTime?: FloatNullableFilter<"EmployeeHoursLocalities"> | number | null
    BreakTime?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    AlertForMaxMonthHours?: FloatNullableFilter<"EmployeeHoursLocalities"> | number | null
    RestrictDayHoursAbove12?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    RestrictWeekExtraHoursAbove16?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    RestrictGpsActive?: IntNullableFilter<"EmployeeHoursLocalities"> | number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityListRelationFilter
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsListRelationFilter
  }, "EmployeeHoursLocalityId">

  export type EmployeeHoursLocalitiesOrderByWithAggregationInput = {
    EmployeeHoursLocalityId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    NotShowLocality?: SortOrderInput | SortOrder
    LocalityName?: SortOrder
    LocalityNameEng?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    Address?: SortOrderInput | SortOrder
    Gps?: SortOrderInput | SortOrder
    GpsRadius?: SortOrder
    AddressAccess?: SortOrderInput | SortOrder
    LocalityIDAccess?: SortOrder
    LocalityCodeAccess?: SortOrderInput | SortOrder
    CustomerIDAccess?: SortOrderInput | SortOrder
    CustomerNameAccess?: SortOrderInput | SortOrder
    ForemanGeneralCRMUserId?: SortOrderInput | SortOrder
    HourMinStart?: SortOrderInput | SortOrder
    HourMaxStop?: SortOrderInput | SortOrder
    RoundTime?: SortOrderInput | SortOrder
    MinimumHours2BreakTime?: SortOrderInput | SortOrder
    BreakTime?: SortOrderInput | SortOrder
    AlertForMaxMonthHours?: SortOrderInput | SortOrder
    RestrictDayHoursAbove12?: SortOrderInput | SortOrder
    RestrictWeekExtraHoursAbove16?: SortOrderInput | SortOrder
    RestrictGpsActive?: SortOrderInput | SortOrder
    _count?: EmployeeHoursLocalitiesCountOrderByAggregateInput
    _avg?: EmployeeHoursLocalitiesAvgOrderByAggregateInput
    _max?: EmployeeHoursLocalitiesMaxOrderByAggregateInput
    _min?: EmployeeHoursLocalitiesMinOrderByAggregateInput
    _sum?: EmployeeHoursLocalitiesSumOrderByAggregateInput
  }

  export type EmployeeHoursLocalitiesScalarWhereWithAggregatesInput = {
    AND?: EmployeeHoursLocalitiesScalarWhereWithAggregatesInput | EmployeeHoursLocalitiesScalarWhereWithAggregatesInput[]
    OR?: EmployeeHoursLocalitiesScalarWhereWithAggregatesInput[]
    NOT?: EmployeeHoursLocalitiesScalarWhereWithAggregatesInput | EmployeeHoursLocalitiesScalarWhereWithAggregatesInput[]
    EmployeeHoursLocalityId?: StringWithAggregatesFilter<"EmployeeHoursLocalities"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | Date | string | null
    NotShowLocality?: IntNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | number | null
    LocalityName?: StringWithAggregatesFilter<"EmployeeHoursLocalities"> | string
    LocalityNameEng?: StringNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | string | null
    CompanyIdGeneralCRM?: StringWithAggregatesFilter<"EmployeeHoursLocalities"> | string
    Address?: StringNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | string | null
    Gps?: StringNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | string | null
    GpsRadius?: IntWithAggregatesFilter<"EmployeeHoursLocalities"> | number
    AddressAccess?: StringNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | string | null
    LocalityIDAccess?: IntWithAggregatesFilter<"EmployeeHoursLocalities"> | number
    LocalityCodeAccess?: IntNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | number | null
    CustomerIDAccess?: IntNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | number | null
    CustomerNameAccess?: StringNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | string | null
    ForemanGeneralCRMUserId?: StringNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | string | null
    HourMinStart?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | Date | string | null
    HourMaxStop?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | Date | string | null
    RoundTime?: StringNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | string | null
    MinimumHours2BreakTime?: FloatNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | number | null
    BreakTime?: IntNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | number | null
    AlertForMaxMonthHours?: FloatNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | number | null
    RestrictDayHoursAbove12?: IntNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | number | null
    RestrictWeekExtraHoursAbove16?: IntNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | number | null
    RestrictGpsActive?: IntNullableWithAggregatesFilter<"EmployeeHoursLocalities"> | number | null
  }

  export type EmployeeHoursUsersWhereInput = {
    AND?: EmployeeHoursUsersWhereInput | EmployeeHoursUsersWhereInput[]
    OR?: EmployeeHoursUsersWhereInput[]
    NOT?: EmployeeHoursUsersWhereInput | EmployeeHoursUsersWhereInput[]
    EmployeeHoursUsersId?: StringFilter<"EmployeeHoursUsers"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursUsers"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursUsers"> | string
    EmployeeId?: IntFilter<"EmployeeHoursUsers"> | number
    MobileNumber?: StringNullableFilter<"EmployeeHoursUsers"> | string | null
    UserName?: StringFilter<"EmployeeHoursUsers"> | string
    Password?: StringFilter<"EmployeeHoursUsers"> | string
    IsAdmin?: IntFilter<"EmployeeHoursUsers"> | number
    LastEntry?: DateTimeNullableFilter<"EmployeeHoursUsers"> | Date | string | null
    IsAllowAccess2WebSite?: IntFilter<"EmployeeHoursUsers"> | number
    PhoneData?: StringNullableFilter<"EmployeeHoursUsers"> | string | null
    CookieError?: DateTimeNullableFilter<"EmployeeHoursUsers"> | Date | string | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityListRelationFilter
  }

  export type EmployeeHoursUsersOrderByWithRelationInput = {
    EmployeeHoursUsersId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    MobileNumber?: SortOrderInput | SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IsAdmin?: SortOrder
    LastEntry?: SortOrderInput | SortOrder
    IsAllowAccess2WebSite?: SortOrder
    PhoneData?: SortOrderInput | SortOrder
    CookieError?: SortOrderInput | SortOrder
    EmployeeHoursByLocality?: EmployeeHoursByLocalityOrderByRelationAggregateInput
  }

  export type EmployeeHoursUsersWhereUniqueInput = Prisma.AtLeast<{
    EmployeeHoursUsersId?: string
    UserName?: string
    AND?: EmployeeHoursUsersWhereInput | EmployeeHoursUsersWhereInput[]
    OR?: EmployeeHoursUsersWhereInput[]
    NOT?: EmployeeHoursUsersWhereInput | EmployeeHoursUsersWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursUsers"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursUsers"> | string
    EmployeeId?: IntFilter<"EmployeeHoursUsers"> | number
    MobileNumber?: StringNullableFilter<"EmployeeHoursUsers"> | string | null
    Password?: StringFilter<"EmployeeHoursUsers"> | string
    IsAdmin?: IntFilter<"EmployeeHoursUsers"> | number
    LastEntry?: DateTimeNullableFilter<"EmployeeHoursUsers"> | Date | string | null
    IsAllowAccess2WebSite?: IntFilter<"EmployeeHoursUsers"> | number
    PhoneData?: StringNullableFilter<"EmployeeHoursUsers"> | string | null
    CookieError?: DateTimeNullableFilter<"EmployeeHoursUsers"> | Date | string | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityListRelationFilter
  }, "EmployeeHoursUsersId" | "UserName">

  export type EmployeeHoursUsersOrderByWithAggregationInput = {
    EmployeeHoursUsersId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    MobileNumber?: SortOrderInput | SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IsAdmin?: SortOrder
    LastEntry?: SortOrderInput | SortOrder
    IsAllowAccess2WebSite?: SortOrder
    PhoneData?: SortOrderInput | SortOrder
    CookieError?: SortOrderInput | SortOrder
    _count?: EmployeeHoursUsersCountOrderByAggregateInput
    _avg?: EmployeeHoursUsersAvgOrderByAggregateInput
    _max?: EmployeeHoursUsersMaxOrderByAggregateInput
    _min?: EmployeeHoursUsersMinOrderByAggregateInput
    _sum?: EmployeeHoursUsersSumOrderByAggregateInput
  }

  export type EmployeeHoursUsersScalarWhereWithAggregatesInput = {
    AND?: EmployeeHoursUsersScalarWhereWithAggregatesInput | EmployeeHoursUsersScalarWhereWithAggregatesInput[]
    OR?: EmployeeHoursUsersScalarWhereWithAggregatesInput[]
    NOT?: EmployeeHoursUsersScalarWhereWithAggregatesInput | EmployeeHoursUsersScalarWhereWithAggregatesInput[]
    EmployeeHoursUsersId?: StringWithAggregatesFilter<"EmployeeHoursUsers"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursUsers"> | Date | string | null
    CompanyIdGeneralCRM?: StringWithAggregatesFilter<"EmployeeHoursUsers"> | string
    EmployeeId?: IntWithAggregatesFilter<"EmployeeHoursUsers"> | number
    MobileNumber?: StringNullableWithAggregatesFilter<"EmployeeHoursUsers"> | string | null
    UserName?: StringWithAggregatesFilter<"EmployeeHoursUsers"> | string
    Password?: StringWithAggregatesFilter<"EmployeeHoursUsers"> | string
    IsAdmin?: IntWithAggregatesFilter<"EmployeeHoursUsers"> | number
    LastEntry?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursUsers"> | Date | string | null
    IsAllowAccess2WebSite?: IntWithAggregatesFilter<"EmployeeHoursUsers"> | number
    PhoneData?: StringNullableWithAggregatesFilter<"EmployeeHoursUsers"> | string | null
    CookieError?: DateTimeNullableWithAggregatesFilter<"EmployeeHoursUsers"> | Date | string | null
  }

  export type EmployeesAccessDocumentsTempWhereInput = {
    AND?: EmployeesAccessDocumentsTempWhereInput | EmployeesAccessDocumentsTempWhereInput[]
    OR?: EmployeesAccessDocumentsTempWhereInput[]
    NOT?: EmployeesAccessDocumentsTempWhereInput | EmployeesAccessDocumentsTempWhereInput[]
    EmployeesAccessDocumentTempId?: StringFilter<"EmployeesAccessDocumentsTemp"> | string
    CompanyGeneralCrmId?: StringFilter<"EmployeesAccessDocumentsTemp"> | string
    CreatedAt?: DateTimeFilter<"EmployeesAccessDocumentsTemp"> | Date | string
    EmployeeID?: StringNullableFilter<"EmployeesAccessDocumentsTemp"> | string | null
    DocumemtID?: StringNullableFilter<"EmployeesAccessDocumentsTemp"> | string | null
    Date?: StringNullableFilter<"EmployeesAccessDocumentsTemp"> | string | null
    DocumemtType?: StringNullableFilter<"EmployeesAccessDocumentsTemp"> | string | null
    Comment?: StringNullableFilter<"EmployeesAccessDocumentsTemp"> | string | null
    DocumentName?: StringNullableFilter<"EmployeesAccessDocumentsTemp"> | string | null
  }

  export type EmployeesAccessDocumentsTempOrderByWithRelationInput = {
    EmployeesAccessDocumentTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    EmployeeID?: SortOrderInput | SortOrder
    DocumemtID?: SortOrderInput | SortOrder
    Date?: SortOrderInput | SortOrder
    DocumemtType?: SortOrderInput | SortOrder
    Comment?: SortOrderInput | SortOrder
    DocumentName?: SortOrderInput | SortOrder
  }

  export type EmployeesAccessDocumentsTempWhereUniqueInput = Prisma.AtLeast<{
    EmployeesAccessDocumentTempId?: string
    AND?: EmployeesAccessDocumentsTempWhereInput | EmployeesAccessDocumentsTempWhereInput[]
    OR?: EmployeesAccessDocumentsTempWhereInput[]
    NOT?: EmployeesAccessDocumentsTempWhereInput | EmployeesAccessDocumentsTempWhereInput[]
    CompanyGeneralCrmId?: StringFilter<"EmployeesAccessDocumentsTemp"> | string
    CreatedAt?: DateTimeFilter<"EmployeesAccessDocumentsTemp"> | Date | string
    EmployeeID?: StringNullableFilter<"EmployeesAccessDocumentsTemp"> | string | null
    DocumemtID?: StringNullableFilter<"EmployeesAccessDocumentsTemp"> | string | null
    Date?: StringNullableFilter<"EmployeesAccessDocumentsTemp"> | string | null
    DocumemtType?: StringNullableFilter<"EmployeesAccessDocumentsTemp"> | string | null
    Comment?: StringNullableFilter<"EmployeesAccessDocumentsTemp"> | string | null
    DocumentName?: StringNullableFilter<"EmployeesAccessDocumentsTemp"> | string | null
  }, "EmployeesAccessDocumentTempId">

  export type EmployeesAccessDocumentsTempOrderByWithAggregationInput = {
    EmployeesAccessDocumentTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    EmployeeID?: SortOrderInput | SortOrder
    DocumemtID?: SortOrderInput | SortOrder
    Date?: SortOrderInput | SortOrder
    DocumemtType?: SortOrderInput | SortOrder
    Comment?: SortOrderInput | SortOrder
    DocumentName?: SortOrderInput | SortOrder
    _count?: EmployeesAccessDocumentsTempCountOrderByAggregateInput
    _max?: EmployeesAccessDocumentsTempMaxOrderByAggregateInput
    _min?: EmployeesAccessDocumentsTempMinOrderByAggregateInput
  }

  export type EmployeesAccessDocumentsTempScalarWhereWithAggregatesInput = {
    AND?: EmployeesAccessDocumentsTempScalarWhereWithAggregatesInput | EmployeesAccessDocumentsTempScalarWhereWithAggregatesInput[]
    OR?: EmployeesAccessDocumentsTempScalarWhereWithAggregatesInput[]
    NOT?: EmployeesAccessDocumentsTempScalarWhereWithAggregatesInput | EmployeesAccessDocumentsTempScalarWhereWithAggregatesInput[]
    EmployeesAccessDocumentTempId?: StringWithAggregatesFilter<"EmployeesAccessDocumentsTemp"> | string
    CompanyGeneralCrmId?: StringWithAggregatesFilter<"EmployeesAccessDocumentsTemp"> | string
    CreatedAt?: DateTimeWithAggregatesFilter<"EmployeesAccessDocumentsTemp"> | Date | string
    EmployeeID?: StringNullableWithAggregatesFilter<"EmployeesAccessDocumentsTemp"> | string | null
    DocumemtID?: StringNullableWithAggregatesFilter<"EmployeesAccessDocumentsTemp"> | string | null
    Date?: StringNullableWithAggregatesFilter<"EmployeesAccessDocumentsTemp"> | string | null
    DocumemtType?: StringNullableWithAggregatesFilter<"EmployeesAccessDocumentsTemp"> | string | null
    Comment?: StringNullableWithAggregatesFilter<"EmployeesAccessDocumentsTemp"> | string | null
    DocumentName?: StringNullableWithAggregatesFilter<"EmployeesAccessDocumentsTemp"> | string | null
  }

  export type EmployeesAccessHouseTempWhereInput = {
    AND?: EmployeesAccessHouseTempWhereInput | EmployeesAccessHouseTempWhereInput[]
    OR?: EmployeesAccessHouseTempWhereInput[]
    NOT?: EmployeesAccessHouseTempWhereInput | EmployeesAccessHouseTempWhereInput[]
    EmployeesAccessHouseTempId?: StringFilter<"EmployeesAccessHouseTemp"> | string
    CompanyGeneralCrmId?: StringFilter<"EmployeesAccessHouseTemp"> | string
    CreatedAt?: DateTimeFilter<"EmployeesAccessHouseTemp"> | Date | string
    HouseID?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseCode?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    CityName?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Street?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ZipCode?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    EmployeesQtyMax?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityCounter_Start?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityCounter_End?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasCounter_Start?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasCounter_End?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterCounter_Start?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterCounter_End?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseField?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ArnonaNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    EvacuationDate?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    AreaMan?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasContainer?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasCompanyID?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    SleepingRooms?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Salon?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Toilet?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Baths?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseCommittee?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseCommitteePhone?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Status?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Name?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Street_?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    CityName_?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ZipCode_?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Phone_1?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Phone_2?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    FaxNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    StartDateContract?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    EndDateContract?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Security?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    SecurityAmount?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    PaymentFrequency?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Rant?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Comment?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    IsInsured?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    InsureEndDate?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    IsUpdate?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    LivingArea?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseRelation?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    CableTypeID?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    CableInstallationdate?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    AccountNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    PathNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    AppartmentNum?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    IsBroker?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    BrokerName?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    BrokerPhone?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityCode?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasNumberCode?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterNumberCode?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityComment?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasCounteComment?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterCounterComment?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    AgencyFee?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    IdNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ArrivalInstructions?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    OwnerEmail?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    OwnerBankAcount?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    CustomerID?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    LocalityName?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Contractor_billing?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Floor?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Entrance?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    OwnerBranchCode?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    OwnerBankID?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
  }

  export type EmployeesAccessHouseTempOrderByWithRelationInput = {
    EmployeesAccessHouseTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    HouseID?: SortOrderInput | SortOrder
    HouseCode?: SortOrderInput | SortOrder
    CityName?: SortOrderInput | SortOrder
    Street?: SortOrderInput | SortOrder
    HouseNumber?: SortOrderInput | SortOrder
    ZipCode?: SortOrderInput | SortOrder
    EmployeesQtyMax?: SortOrderInput | SortOrder
    ElectricityCounter_Start?: SortOrderInput | SortOrder
    ElectricityCounter_End?: SortOrderInput | SortOrder
    GasCounter_Start?: SortOrderInput | SortOrder
    GasCounter_End?: SortOrderInput | SortOrder
    WaterCounter_Start?: SortOrderInput | SortOrder
    WaterCounter_End?: SortOrderInput | SortOrder
    ElectricityNumber?: SortOrderInput | SortOrder
    GasNumber?: SortOrderInput | SortOrder
    WaterNumber?: SortOrderInput | SortOrder
    HouseField?: SortOrderInput | SortOrder
    ArnonaNumber?: SortOrderInput | SortOrder
    EvacuationDate?: SortOrderInput | SortOrder
    AreaMan?: SortOrderInput | SortOrder
    GasContainer?: SortOrderInput | SortOrder
    GasCompanyID?: SortOrderInput | SortOrder
    SleepingRooms?: SortOrderInput | SortOrder
    Salon?: SortOrderInput | SortOrder
    Toilet?: SortOrderInput | SortOrder
    Baths?: SortOrderInput | SortOrder
    HouseCommittee?: SortOrderInput | SortOrder
    HouseCommitteePhone?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Name?: SortOrderInput | SortOrder
    Street_?: SortOrderInput | SortOrder
    CityName_?: SortOrderInput | SortOrder
    ZipCode_?: SortOrderInput | SortOrder
    Phone_1?: SortOrderInput | SortOrder
    Phone_2?: SortOrderInput | SortOrder
    FaxNumber?: SortOrderInput | SortOrder
    StartDateContract?: SortOrderInput | SortOrder
    EndDateContract?: SortOrderInput | SortOrder
    Security?: SortOrderInput | SortOrder
    SecurityAmount?: SortOrderInput | SortOrder
    PaymentFrequency?: SortOrderInput | SortOrder
    Rant?: SortOrderInput | SortOrder
    Comment?: SortOrderInput | SortOrder
    IsInsured?: SortOrderInput | SortOrder
    InsureEndDate?: SortOrderInput | SortOrder
    IsUpdate?: SortOrderInput | SortOrder
    LivingArea?: SortOrderInput | SortOrder
    HouseRelation?: SortOrderInput | SortOrder
    CableTypeID?: SortOrderInput | SortOrder
    CableInstallationdate?: SortOrderInput | SortOrder
    AccountNumber?: SortOrderInput | SortOrder
    PathNumber?: SortOrderInput | SortOrder
    AppartmentNum?: SortOrderInput | SortOrder
    IsBroker?: SortOrderInput | SortOrder
    BrokerName?: SortOrderInput | SortOrder
    BrokerPhone?: SortOrderInput | SortOrder
    ElectricityCode?: SortOrderInput | SortOrder
    GasNumberCode?: SortOrderInput | SortOrder
    WaterNumberCode?: SortOrderInput | SortOrder
    ElectricityComment?: SortOrderInput | SortOrder
    GasCounteComment?: SortOrderInput | SortOrder
    WaterCounterComment?: SortOrderInput | SortOrder
    AgencyFee?: SortOrderInput | SortOrder
    IdNumber?: SortOrderInput | SortOrder
    ArrivalInstructions?: SortOrderInput | SortOrder
    OwnerEmail?: SortOrderInput | SortOrder
    OwnerBankAcount?: SortOrderInput | SortOrder
    CustomerID?: SortOrderInput | SortOrder
    LocalityName?: SortOrderInput | SortOrder
    Contractor_billing?: SortOrderInput | SortOrder
    Floor?: SortOrderInput | SortOrder
    Entrance?: SortOrderInput | SortOrder
    OwnerBranchCode?: SortOrderInput | SortOrder
    OwnerBankID?: SortOrderInput | SortOrder
  }

  export type EmployeesAccessHouseTempWhereUniqueInput = Prisma.AtLeast<{
    EmployeesAccessHouseTempId?: string
    AND?: EmployeesAccessHouseTempWhereInput | EmployeesAccessHouseTempWhereInput[]
    OR?: EmployeesAccessHouseTempWhereInput[]
    NOT?: EmployeesAccessHouseTempWhereInput | EmployeesAccessHouseTempWhereInput[]
    CompanyGeneralCrmId?: StringFilter<"EmployeesAccessHouseTemp"> | string
    CreatedAt?: DateTimeFilter<"EmployeesAccessHouseTemp"> | Date | string
    HouseID?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseCode?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    CityName?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Street?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ZipCode?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    EmployeesQtyMax?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityCounter_Start?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityCounter_End?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasCounter_Start?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasCounter_End?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterCounter_Start?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterCounter_End?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseField?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ArnonaNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    EvacuationDate?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    AreaMan?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasContainer?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasCompanyID?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    SleepingRooms?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Salon?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Toilet?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Baths?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseCommittee?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseCommitteePhone?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Status?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Name?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Street_?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    CityName_?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ZipCode_?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Phone_1?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Phone_2?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    FaxNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    StartDateContract?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    EndDateContract?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Security?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    SecurityAmount?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    PaymentFrequency?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Rant?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Comment?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    IsInsured?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    InsureEndDate?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    IsUpdate?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    LivingArea?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseRelation?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    CableTypeID?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    CableInstallationdate?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    AccountNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    PathNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    AppartmentNum?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    IsBroker?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    BrokerName?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    BrokerPhone?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityCode?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasNumberCode?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterNumberCode?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityComment?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    GasCounteComment?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterCounterComment?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    AgencyFee?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    IdNumber?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    ArrivalInstructions?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    OwnerEmail?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    OwnerBankAcount?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    CustomerID?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    LocalityName?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Contractor_billing?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Floor?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    Entrance?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    OwnerBranchCode?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
    OwnerBankID?: StringNullableFilter<"EmployeesAccessHouseTemp"> | string | null
  }, "EmployeesAccessHouseTempId">

  export type EmployeesAccessHouseTempOrderByWithAggregationInput = {
    EmployeesAccessHouseTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    HouseID?: SortOrderInput | SortOrder
    HouseCode?: SortOrderInput | SortOrder
    CityName?: SortOrderInput | SortOrder
    Street?: SortOrderInput | SortOrder
    HouseNumber?: SortOrderInput | SortOrder
    ZipCode?: SortOrderInput | SortOrder
    EmployeesQtyMax?: SortOrderInput | SortOrder
    ElectricityCounter_Start?: SortOrderInput | SortOrder
    ElectricityCounter_End?: SortOrderInput | SortOrder
    GasCounter_Start?: SortOrderInput | SortOrder
    GasCounter_End?: SortOrderInput | SortOrder
    WaterCounter_Start?: SortOrderInput | SortOrder
    WaterCounter_End?: SortOrderInput | SortOrder
    ElectricityNumber?: SortOrderInput | SortOrder
    GasNumber?: SortOrderInput | SortOrder
    WaterNumber?: SortOrderInput | SortOrder
    HouseField?: SortOrderInput | SortOrder
    ArnonaNumber?: SortOrderInput | SortOrder
    EvacuationDate?: SortOrderInput | SortOrder
    AreaMan?: SortOrderInput | SortOrder
    GasContainer?: SortOrderInput | SortOrder
    GasCompanyID?: SortOrderInput | SortOrder
    SleepingRooms?: SortOrderInput | SortOrder
    Salon?: SortOrderInput | SortOrder
    Toilet?: SortOrderInput | SortOrder
    Baths?: SortOrderInput | SortOrder
    HouseCommittee?: SortOrderInput | SortOrder
    HouseCommitteePhone?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Name?: SortOrderInput | SortOrder
    Street_?: SortOrderInput | SortOrder
    CityName_?: SortOrderInput | SortOrder
    ZipCode_?: SortOrderInput | SortOrder
    Phone_1?: SortOrderInput | SortOrder
    Phone_2?: SortOrderInput | SortOrder
    FaxNumber?: SortOrderInput | SortOrder
    StartDateContract?: SortOrderInput | SortOrder
    EndDateContract?: SortOrderInput | SortOrder
    Security?: SortOrderInput | SortOrder
    SecurityAmount?: SortOrderInput | SortOrder
    PaymentFrequency?: SortOrderInput | SortOrder
    Rant?: SortOrderInput | SortOrder
    Comment?: SortOrderInput | SortOrder
    IsInsured?: SortOrderInput | SortOrder
    InsureEndDate?: SortOrderInput | SortOrder
    IsUpdate?: SortOrderInput | SortOrder
    LivingArea?: SortOrderInput | SortOrder
    HouseRelation?: SortOrderInput | SortOrder
    CableTypeID?: SortOrderInput | SortOrder
    CableInstallationdate?: SortOrderInput | SortOrder
    AccountNumber?: SortOrderInput | SortOrder
    PathNumber?: SortOrderInput | SortOrder
    AppartmentNum?: SortOrderInput | SortOrder
    IsBroker?: SortOrderInput | SortOrder
    BrokerName?: SortOrderInput | SortOrder
    BrokerPhone?: SortOrderInput | SortOrder
    ElectricityCode?: SortOrderInput | SortOrder
    GasNumberCode?: SortOrderInput | SortOrder
    WaterNumberCode?: SortOrderInput | SortOrder
    ElectricityComment?: SortOrderInput | SortOrder
    GasCounteComment?: SortOrderInput | SortOrder
    WaterCounterComment?: SortOrderInput | SortOrder
    AgencyFee?: SortOrderInput | SortOrder
    IdNumber?: SortOrderInput | SortOrder
    ArrivalInstructions?: SortOrderInput | SortOrder
    OwnerEmail?: SortOrderInput | SortOrder
    OwnerBankAcount?: SortOrderInput | SortOrder
    CustomerID?: SortOrderInput | SortOrder
    LocalityName?: SortOrderInput | SortOrder
    Contractor_billing?: SortOrderInput | SortOrder
    Floor?: SortOrderInput | SortOrder
    Entrance?: SortOrderInput | SortOrder
    OwnerBranchCode?: SortOrderInput | SortOrder
    OwnerBankID?: SortOrderInput | SortOrder
    _count?: EmployeesAccessHouseTempCountOrderByAggregateInput
    _max?: EmployeesAccessHouseTempMaxOrderByAggregateInput
    _min?: EmployeesAccessHouseTempMinOrderByAggregateInput
  }

  export type EmployeesAccessHouseTempScalarWhereWithAggregatesInput = {
    AND?: EmployeesAccessHouseTempScalarWhereWithAggregatesInput | EmployeesAccessHouseTempScalarWhereWithAggregatesInput[]
    OR?: EmployeesAccessHouseTempScalarWhereWithAggregatesInput[]
    NOT?: EmployeesAccessHouseTempScalarWhereWithAggregatesInput | EmployeesAccessHouseTempScalarWhereWithAggregatesInput[]
    EmployeesAccessHouseTempId?: StringWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string
    CompanyGeneralCrmId?: StringWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string
    CreatedAt?: DateTimeWithAggregatesFilter<"EmployeesAccessHouseTemp"> | Date | string
    HouseID?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseCode?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    CityName?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Street?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    ZipCode?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    EmployeesQtyMax?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityCounter_Start?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityCounter_End?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    GasCounter_Start?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    GasCounter_End?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterCounter_Start?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterCounter_End?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    GasNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseField?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    ArnonaNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    EvacuationDate?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    AreaMan?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    GasContainer?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    GasCompanyID?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    SleepingRooms?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Salon?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Toilet?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Baths?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseCommittee?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseCommitteePhone?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Status?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Name?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Street_?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    CityName_?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    ZipCode_?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Phone_1?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Phone_2?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    FaxNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    StartDateContract?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    EndDateContract?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Security?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    SecurityAmount?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    PaymentFrequency?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Rant?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Comment?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    IsInsured?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    InsureEndDate?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    IsUpdate?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    LivingArea?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    HouseRelation?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    CableTypeID?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    CableInstallationdate?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    AccountNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    PathNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    AppartmentNum?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    IsBroker?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    BrokerName?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    BrokerPhone?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityCode?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    GasNumberCode?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterNumberCode?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    ElectricityComment?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    GasCounteComment?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    WaterCounterComment?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    AgencyFee?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    IdNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    ArrivalInstructions?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    OwnerEmail?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    OwnerBankAcount?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    CustomerID?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    LocalityName?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Contractor_billing?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Floor?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    Entrance?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    OwnerBranchCode?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
    OwnerBankID?: StringNullableWithAggregatesFilter<"EmployeesAccessHouseTemp"> | string | null
  }

  export type EmployeesAccessLkupDocumentTypeTempWhereInput = {
    AND?: EmployeesAccessLkupDocumentTypeTempWhereInput | EmployeesAccessLkupDocumentTypeTempWhereInput[]
    OR?: EmployeesAccessLkupDocumentTypeTempWhereInput[]
    NOT?: EmployeesAccessLkupDocumentTypeTempWhereInput | EmployeesAccessLkupDocumentTypeTempWhereInput[]
    EmployeesAccessLkupDocumentTypeTempId?: StringFilter<"EmployeesAccessLkupDocumentTypeTemp"> | string
    CompanyGeneralCrmId?: StringFilter<"EmployeesAccessLkupDocumentTypeTemp"> | string
    CreatedAt?: DateTimeFilter<"EmployeesAccessLkupDocumentTypeTemp"> | Date | string
    DocumemtType?: StringNullableFilter<"EmployeesAccessLkupDocumentTypeTemp"> | string | null
  }

  export type EmployeesAccessLkupDocumentTypeTempOrderByWithRelationInput = {
    EmployeesAccessLkupDocumentTypeTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    DocumemtType?: SortOrderInput | SortOrder
  }

  export type EmployeesAccessLkupDocumentTypeTempWhereUniqueInput = Prisma.AtLeast<{
    EmployeesAccessLkupDocumentTypeTempId?: string
    AND?: EmployeesAccessLkupDocumentTypeTempWhereInput | EmployeesAccessLkupDocumentTypeTempWhereInput[]
    OR?: EmployeesAccessLkupDocumentTypeTempWhereInput[]
    NOT?: EmployeesAccessLkupDocumentTypeTempWhereInput | EmployeesAccessLkupDocumentTypeTempWhereInput[]
    CompanyGeneralCrmId?: StringFilter<"EmployeesAccessLkupDocumentTypeTemp"> | string
    CreatedAt?: DateTimeFilter<"EmployeesAccessLkupDocumentTypeTemp"> | Date | string
    DocumemtType?: StringNullableFilter<"EmployeesAccessLkupDocumentTypeTemp"> | string | null
  }, "EmployeesAccessLkupDocumentTypeTempId">

  export type EmployeesAccessLkupDocumentTypeTempOrderByWithAggregationInput = {
    EmployeesAccessLkupDocumentTypeTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    DocumemtType?: SortOrderInput | SortOrder
    _count?: EmployeesAccessLkupDocumentTypeTempCountOrderByAggregateInput
    _max?: EmployeesAccessLkupDocumentTypeTempMaxOrderByAggregateInput
    _min?: EmployeesAccessLkupDocumentTypeTempMinOrderByAggregateInput
  }

  export type EmployeesAccessLkupDocumentTypeTempScalarWhereWithAggregatesInput = {
    AND?: EmployeesAccessLkupDocumentTypeTempScalarWhereWithAggregatesInput | EmployeesAccessLkupDocumentTypeTempScalarWhereWithAggregatesInput[]
    OR?: EmployeesAccessLkupDocumentTypeTempScalarWhereWithAggregatesInput[]
    NOT?: EmployeesAccessLkupDocumentTypeTempScalarWhereWithAggregatesInput | EmployeesAccessLkupDocumentTypeTempScalarWhereWithAggregatesInput[]
    EmployeesAccessLkupDocumentTypeTempId?: StringWithAggregatesFilter<"EmployeesAccessLkupDocumentTypeTemp"> | string
    CompanyGeneralCrmId?: StringWithAggregatesFilter<"EmployeesAccessLkupDocumentTypeTemp"> | string
    CreatedAt?: DateTimeWithAggregatesFilter<"EmployeesAccessLkupDocumentTypeTemp"> | Date | string
    DocumemtType?: StringNullableWithAggregatesFilter<"EmployeesAccessLkupDocumentTypeTemp"> | string | null
  }

  export type EmployeesAccessTempWhereInput = {
    AND?: EmployeesAccessTempWhereInput | EmployeesAccessTempWhereInput[]
    OR?: EmployeesAccessTempWhereInput[]
    NOT?: EmployeesAccessTempWhereInput | EmployeesAccessTempWhereInput[]
    EmployeesAccessTempId?: StringFilter<"EmployeesAccessTemp"> | string
    CompanyGeneralCrmId?: StringFilter<"EmployeesAccessTemp"> | string
    CreatedAt?: DateTimeFilter<"EmployeesAccessTemp"> | Date | string
    AgentID?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    AreaMan?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    AppartmentNum?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    BirthDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CityName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CoatReceivingDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CoatSize?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CountryID?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CountryName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CourseAtatDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CourseAtatExpireDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CustomerName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CustomerStatus?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CustomerID?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    EmployeeFirstName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    EmployeeID?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    EmployeeLastName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    EmployeeNumber?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    EndInsuranceDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    EntranceDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    HealthFund?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    HouseID?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    HouseNumber?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    InsuranceCompany?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    InsuranceNumber?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    InsuredNumber?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    IsCourseAtat?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    Isbriefing?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    LocalityName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    LocalityCode?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    LocalityID?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    LongshirtReceivingDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    LongshirtSize?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    MobilePhone?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    PantsReceivingDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    PassportNumber?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    ProfessionName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    ProfessionSecondName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    ProfessionThirdName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    ShoesNumber?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    ShoesReceiveDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    SizeOfPantes?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    SizeOfshirt?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    StartDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    StatusName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    Street?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    TshirReceivingDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    briefingDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    briefingExpireDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    startInsuranceDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
  }

  export type EmployeesAccessTempOrderByWithRelationInput = {
    EmployeesAccessTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    AgentID?: SortOrderInput | SortOrder
    AreaMan?: SortOrderInput | SortOrder
    AppartmentNum?: SortOrderInput | SortOrder
    BirthDate?: SortOrderInput | SortOrder
    CityName?: SortOrderInput | SortOrder
    CoatReceivingDate?: SortOrderInput | SortOrder
    CoatSize?: SortOrderInput | SortOrder
    CountryID?: SortOrderInput | SortOrder
    CountryName?: SortOrderInput | SortOrder
    CourseAtatDate?: SortOrderInput | SortOrder
    CourseAtatExpireDate?: SortOrderInput | SortOrder
    CustomerName?: SortOrderInput | SortOrder
    CustomerStatus?: SortOrderInput | SortOrder
    CustomerID?: SortOrderInput | SortOrder
    EmployeeFirstName?: SortOrderInput | SortOrder
    EmployeeID?: SortOrderInput | SortOrder
    EmployeeLastName?: SortOrderInput | SortOrder
    EmployeeNumber?: SortOrderInput | SortOrder
    EndInsuranceDate?: SortOrderInput | SortOrder
    EntranceDate?: SortOrderInput | SortOrder
    HealthFund?: SortOrderInput | SortOrder
    HouseID?: SortOrderInput | SortOrder
    HouseNumber?: SortOrderInput | SortOrder
    InsuranceCompany?: SortOrderInput | SortOrder
    InsuranceNumber?: SortOrderInput | SortOrder
    InsuredNumber?: SortOrderInput | SortOrder
    IsCourseAtat?: SortOrderInput | SortOrder
    Isbriefing?: SortOrderInput | SortOrder
    LocalityName?: SortOrderInput | SortOrder
    LocalityCode?: SortOrderInput | SortOrder
    LocalityID?: SortOrderInput | SortOrder
    LongshirtReceivingDate?: SortOrderInput | SortOrder
    LongshirtSize?: SortOrderInput | SortOrder
    MobilePhone?: SortOrderInput | SortOrder
    PantsReceivingDate?: SortOrderInput | SortOrder
    PassportNumber?: SortOrderInput | SortOrder
    ProfessionName?: SortOrderInput | SortOrder
    ProfessionSecondName?: SortOrderInput | SortOrder
    ProfessionThirdName?: SortOrderInput | SortOrder
    ShoesNumber?: SortOrderInput | SortOrder
    ShoesReceiveDate?: SortOrderInput | SortOrder
    SizeOfPantes?: SortOrderInput | SortOrder
    SizeOfshirt?: SortOrderInput | SortOrder
    StartDate?: SortOrderInput | SortOrder
    StatusName?: SortOrderInput | SortOrder
    Street?: SortOrderInput | SortOrder
    TshirReceivingDate?: SortOrderInput | SortOrder
    briefingDate?: SortOrderInput | SortOrder
    briefingExpireDate?: SortOrderInput | SortOrder
    startInsuranceDate?: SortOrderInput | SortOrder
  }

  export type EmployeesAccessTempWhereUniqueInput = Prisma.AtLeast<{
    EmployeesAccessTempId?: string
    AND?: EmployeesAccessTempWhereInput | EmployeesAccessTempWhereInput[]
    OR?: EmployeesAccessTempWhereInput[]
    NOT?: EmployeesAccessTempWhereInput | EmployeesAccessTempWhereInput[]
    CompanyGeneralCrmId?: StringFilter<"EmployeesAccessTemp"> | string
    CreatedAt?: DateTimeFilter<"EmployeesAccessTemp"> | Date | string
    AgentID?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    AreaMan?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    AppartmentNum?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    BirthDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CityName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CoatReceivingDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CoatSize?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CountryID?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CountryName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CourseAtatDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CourseAtatExpireDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CustomerName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CustomerStatus?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    CustomerID?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    EmployeeFirstName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    EmployeeID?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    EmployeeLastName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    EmployeeNumber?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    EndInsuranceDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    EntranceDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    HealthFund?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    HouseID?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    HouseNumber?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    InsuranceCompany?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    InsuranceNumber?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    InsuredNumber?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    IsCourseAtat?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    Isbriefing?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    LocalityName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    LocalityCode?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    LocalityID?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    LongshirtReceivingDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    LongshirtSize?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    MobilePhone?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    PantsReceivingDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    PassportNumber?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    ProfessionName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    ProfessionSecondName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    ProfessionThirdName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    ShoesNumber?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    ShoesReceiveDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    SizeOfPantes?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    SizeOfshirt?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    StartDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    StatusName?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    Street?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    TshirReceivingDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    briefingDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    briefingExpireDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
    startInsuranceDate?: StringNullableFilter<"EmployeesAccessTemp"> | string | null
  }, "EmployeesAccessTempId">

  export type EmployeesAccessTempOrderByWithAggregationInput = {
    EmployeesAccessTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    AgentID?: SortOrderInput | SortOrder
    AreaMan?: SortOrderInput | SortOrder
    AppartmentNum?: SortOrderInput | SortOrder
    BirthDate?: SortOrderInput | SortOrder
    CityName?: SortOrderInput | SortOrder
    CoatReceivingDate?: SortOrderInput | SortOrder
    CoatSize?: SortOrderInput | SortOrder
    CountryID?: SortOrderInput | SortOrder
    CountryName?: SortOrderInput | SortOrder
    CourseAtatDate?: SortOrderInput | SortOrder
    CourseAtatExpireDate?: SortOrderInput | SortOrder
    CustomerName?: SortOrderInput | SortOrder
    CustomerStatus?: SortOrderInput | SortOrder
    CustomerID?: SortOrderInput | SortOrder
    EmployeeFirstName?: SortOrderInput | SortOrder
    EmployeeID?: SortOrderInput | SortOrder
    EmployeeLastName?: SortOrderInput | SortOrder
    EmployeeNumber?: SortOrderInput | SortOrder
    EndInsuranceDate?: SortOrderInput | SortOrder
    EntranceDate?: SortOrderInput | SortOrder
    HealthFund?: SortOrderInput | SortOrder
    HouseID?: SortOrderInput | SortOrder
    HouseNumber?: SortOrderInput | SortOrder
    InsuranceCompany?: SortOrderInput | SortOrder
    InsuranceNumber?: SortOrderInput | SortOrder
    InsuredNumber?: SortOrderInput | SortOrder
    IsCourseAtat?: SortOrderInput | SortOrder
    Isbriefing?: SortOrderInput | SortOrder
    LocalityName?: SortOrderInput | SortOrder
    LocalityCode?: SortOrderInput | SortOrder
    LocalityID?: SortOrderInput | SortOrder
    LongshirtReceivingDate?: SortOrderInput | SortOrder
    LongshirtSize?: SortOrderInput | SortOrder
    MobilePhone?: SortOrderInput | SortOrder
    PantsReceivingDate?: SortOrderInput | SortOrder
    PassportNumber?: SortOrderInput | SortOrder
    ProfessionName?: SortOrderInput | SortOrder
    ProfessionSecondName?: SortOrderInput | SortOrder
    ProfessionThirdName?: SortOrderInput | SortOrder
    ShoesNumber?: SortOrderInput | SortOrder
    ShoesReceiveDate?: SortOrderInput | SortOrder
    SizeOfPantes?: SortOrderInput | SortOrder
    SizeOfshirt?: SortOrderInput | SortOrder
    StartDate?: SortOrderInput | SortOrder
    StatusName?: SortOrderInput | SortOrder
    Street?: SortOrderInput | SortOrder
    TshirReceivingDate?: SortOrderInput | SortOrder
    briefingDate?: SortOrderInput | SortOrder
    briefingExpireDate?: SortOrderInput | SortOrder
    startInsuranceDate?: SortOrderInput | SortOrder
    _count?: EmployeesAccessTempCountOrderByAggregateInput
    _max?: EmployeesAccessTempMaxOrderByAggregateInput
    _min?: EmployeesAccessTempMinOrderByAggregateInput
  }

  export type EmployeesAccessTempScalarWhereWithAggregatesInput = {
    AND?: EmployeesAccessTempScalarWhereWithAggregatesInput | EmployeesAccessTempScalarWhereWithAggregatesInput[]
    OR?: EmployeesAccessTempScalarWhereWithAggregatesInput[]
    NOT?: EmployeesAccessTempScalarWhereWithAggregatesInput | EmployeesAccessTempScalarWhereWithAggregatesInput[]
    EmployeesAccessTempId?: StringWithAggregatesFilter<"EmployeesAccessTemp"> | string
    CompanyGeneralCrmId?: StringWithAggregatesFilter<"EmployeesAccessTemp"> | string
    CreatedAt?: DateTimeWithAggregatesFilter<"EmployeesAccessTemp"> | Date | string
    AgentID?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    AreaMan?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    AppartmentNum?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    BirthDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    CityName?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    CoatReceivingDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    CoatSize?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    CountryID?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    CountryName?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    CourseAtatDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    CourseAtatExpireDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    CustomerName?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    CustomerStatus?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    CustomerID?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    EmployeeFirstName?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    EmployeeID?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    EmployeeLastName?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    EmployeeNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    EndInsuranceDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    EntranceDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    HealthFund?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    HouseID?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    HouseNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    InsuranceCompany?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    InsuranceNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    InsuredNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    IsCourseAtat?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    Isbriefing?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    LocalityName?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    LocalityCode?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    LocalityID?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    LongshirtReceivingDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    LongshirtSize?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    MobilePhone?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    PantsReceivingDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    PassportNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    ProfessionName?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    ProfessionSecondName?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    ProfessionThirdName?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    ShoesNumber?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    ShoesReceiveDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    SizeOfPantes?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    SizeOfshirt?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    StartDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    StatusName?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    Street?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    TshirReceivingDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    briefingDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    briefingExpireDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
    startInsuranceDate?: StringNullableWithAggregatesFilter<"EmployeesAccessTemp"> | string | null
  }

  export type ErrorsPhpLogsWhereInput = {
    AND?: ErrorsPhpLogsWhereInput | ErrorsPhpLogsWhereInput[]
    OR?: ErrorsPhpLogsWhereInput[]
    NOT?: ErrorsPhpLogsWhereInput | ErrorsPhpLogsWhereInput[]
    ErrorsPhpLogsId?: IntFilter<"ErrorsPhpLogs"> | number
    CreatedAt?: DateTimeNullableFilter<"ErrorsPhpLogs"> | Date | string | null
    tokenData?: StringNullableFilter<"ErrorsPhpLogs"> | string | null
    urlController?: StringNullableFilter<"ErrorsPhpLogs"> | string | null
    sendData?: StringNullableFilter<"ErrorsPhpLogs"> | string | null
    errorMessg?: StringNullableFilter<"ErrorsPhpLogs"> | string | null
  }

  export type ErrorsPhpLogsOrderByWithRelationInput = {
    ErrorsPhpLogsId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    tokenData?: SortOrderInput | SortOrder
    urlController?: SortOrderInput | SortOrder
    sendData?: SortOrderInput | SortOrder
    errorMessg?: SortOrderInput | SortOrder
  }

  export type ErrorsPhpLogsWhereUniqueInput = Prisma.AtLeast<{
    ErrorsPhpLogsId?: number
    AND?: ErrorsPhpLogsWhereInput | ErrorsPhpLogsWhereInput[]
    OR?: ErrorsPhpLogsWhereInput[]
    NOT?: ErrorsPhpLogsWhereInput | ErrorsPhpLogsWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"ErrorsPhpLogs"> | Date | string | null
    tokenData?: StringNullableFilter<"ErrorsPhpLogs"> | string | null
    urlController?: StringNullableFilter<"ErrorsPhpLogs"> | string | null
    sendData?: StringNullableFilter<"ErrorsPhpLogs"> | string | null
    errorMessg?: StringNullableFilter<"ErrorsPhpLogs"> | string | null
  }, "ErrorsPhpLogsId">

  export type ErrorsPhpLogsOrderByWithAggregationInput = {
    ErrorsPhpLogsId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    tokenData?: SortOrderInput | SortOrder
    urlController?: SortOrderInput | SortOrder
    sendData?: SortOrderInput | SortOrder
    errorMessg?: SortOrderInput | SortOrder
    _count?: ErrorsPhpLogsCountOrderByAggregateInput
    _avg?: ErrorsPhpLogsAvgOrderByAggregateInput
    _max?: ErrorsPhpLogsMaxOrderByAggregateInput
    _min?: ErrorsPhpLogsMinOrderByAggregateInput
    _sum?: ErrorsPhpLogsSumOrderByAggregateInput
  }

  export type ErrorsPhpLogsScalarWhereWithAggregatesInput = {
    AND?: ErrorsPhpLogsScalarWhereWithAggregatesInput | ErrorsPhpLogsScalarWhereWithAggregatesInput[]
    OR?: ErrorsPhpLogsScalarWhereWithAggregatesInput[]
    NOT?: ErrorsPhpLogsScalarWhereWithAggregatesInput | ErrorsPhpLogsScalarWhereWithAggregatesInput[]
    ErrorsPhpLogsId?: IntWithAggregatesFilter<"ErrorsPhpLogs"> | number
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"ErrorsPhpLogs"> | Date | string | null
    tokenData?: StringNullableWithAggregatesFilter<"ErrorsPhpLogs"> | string | null
    urlController?: StringNullableWithAggregatesFilter<"ErrorsPhpLogs"> | string | null
    sendData?: StringNullableWithAggregatesFilter<"ErrorsPhpLogs"> | string | null
    errorMessg?: StringNullableWithAggregatesFilter<"ErrorsPhpLogs"> | string | null
  }

  export type Lkup_ActionTypeWhereInput = {
    AND?: Lkup_ActionTypeWhereInput | Lkup_ActionTypeWhereInput[]
    OR?: Lkup_ActionTypeWhereInput[]
    NOT?: Lkup_ActionTypeWhereInput | Lkup_ActionTypeWhereInput[]
    ActionTypeID?: IntFilter<"Lkup_ActionType"> | number
    ActionType?: StringNullableFilter<"Lkup_ActionType"> | string | null
    IsIgnoreHours?: IntNullableFilter<"Lkup_ActionType"> | number | null
    EmployeeHours?: EmployeeHoursListRelationFilter
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeListRelationFilter
  }

  export type Lkup_ActionTypeOrderByWithRelationInput = {
    ActionTypeID?: SortOrder
    ActionType?: SortOrderInput | SortOrder
    IsIgnoreHours?: SortOrderInput | SortOrder
    EmployeeHours?: EmployeeHoursOrderByRelationAggregateInput
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeOrderByRelationAggregateInput
  }

  export type Lkup_ActionTypeWhereUniqueInput = Prisma.AtLeast<{
    ActionTypeID?: number
    AND?: Lkup_ActionTypeWhereInput | Lkup_ActionTypeWhereInput[]
    OR?: Lkup_ActionTypeWhereInput[]
    NOT?: Lkup_ActionTypeWhereInput | Lkup_ActionTypeWhereInput[]
    ActionType?: StringNullableFilter<"Lkup_ActionType"> | string | null
    IsIgnoreHours?: IntNullableFilter<"Lkup_ActionType"> | number | null
    EmployeeHours?: EmployeeHoursListRelationFilter
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeListRelationFilter
  }, "ActionTypeID">

  export type Lkup_ActionTypeOrderByWithAggregationInput = {
    ActionTypeID?: SortOrder
    ActionType?: SortOrderInput | SortOrder
    IsIgnoreHours?: SortOrderInput | SortOrder
    _count?: Lkup_ActionTypeCountOrderByAggregateInput
    _avg?: Lkup_ActionTypeAvgOrderByAggregateInput
    _max?: Lkup_ActionTypeMaxOrderByAggregateInput
    _min?: Lkup_ActionTypeMinOrderByAggregateInput
    _sum?: Lkup_ActionTypeSumOrderByAggregateInput
  }

  export type Lkup_ActionTypeScalarWhereWithAggregatesInput = {
    AND?: Lkup_ActionTypeScalarWhereWithAggregatesInput | Lkup_ActionTypeScalarWhereWithAggregatesInput[]
    OR?: Lkup_ActionTypeScalarWhereWithAggregatesInput[]
    NOT?: Lkup_ActionTypeScalarWhereWithAggregatesInput | Lkup_ActionTypeScalarWhereWithAggregatesInput[]
    ActionTypeID?: IntWithAggregatesFilter<"Lkup_ActionType"> | number
    ActionType?: StringNullableWithAggregatesFilter<"Lkup_ActionType"> | string | null
    IsIgnoreHours?: IntNullableWithAggregatesFilter<"Lkup_ActionType"> | number | null
  }

  export type LogEnterEmployeeWhereInput = {
    AND?: LogEnterEmployeeWhereInput | LogEnterEmployeeWhereInput[]
    OR?: LogEnterEmployeeWhereInput[]
    NOT?: LogEnterEmployeeWhereInput | LogEnterEmployeeWhereInput[]
    LogEnterEmployee?: IntFilter<"LogEnterEmployee"> | number
    UserID?: StringFilter<"LogEnterEmployee"> | string
    CompanyID?: StringFilter<"LogEnterEmployee"> | string
    EmployeeID?: IntFilter<"LogEnterEmployee"> | number
    CreatedAt?: DateTimeNullableFilter<"LogEnterEmployee"> | Date | string | null
    ResultsData?: StringNullableFilter<"LogEnterEmployee"> | string | null
  }

  export type LogEnterEmployeeOrderByWithRelationInput = {
    LogEnterEmployee?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    EmployeeID?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    ResultsData?: SortOrderInput | SortOrder
  }

  export type LogEnterEmployeeWhereUniqueInput = Prisma.AtLeast<{
    LogEnterEmployee?: number
    AND?: LogEnterEmployeeWhereInput | LogEnterEmployeeWhereInput[]
    OR?: LogEnterEmployeeWhereInput[]
    NOT?: LogEnterEmployeeWhereInput | LogEnterEmployeeWhereInput[]
    UserID?: StringFilter<"LogEnterEmployee"> | string
    CompanyID?: StringFilter<"LogEnterEmployee"> | string
    EmployeeID?: IntFilter<"LogEnterEmployee"> | number
    CreatedAt?: DateTimeNullableFilter<"LogEnterEmployee"> | Date | string | null
    ResultsData?: StringNullableFilter<"LogEnterEmployee"> | string | null
  }, "LogEnterEmployee">

  export type LogEnterEmployeeOrderByWithAggregationInput = {
    LogEnterEmployee?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    EmployeeID?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    ResultsData?: SortOrderInput | SortOrder
    _count?: LogEnterEmployeeCountOrderByAggregateInput
    _avg?: LogEnterEmployeeAvgOrderByAggregateInput
    _max?: LogEnterEmployeeMaxOrderByAggregateInput
    _min?: LogEnterEmployeeMinOrderByAggregateInput
    _sum?: LogEnterEmployeeSumOrderByAggregateInput
  }

  export type LogEnterEmployeeScalarWhereWithAggregatesInput = {
    AND?: LogEnterEmployeeScalarWhereWithAggregatesInput | LogEnterEmployeeScalarWhereWithAggregatesInput[]
    OR?: LogEnterEmployeeScalarWhereWithAggregatesInput[]
    NOT?: LogEnterEmployeeScalarWhereWithAggregatesInput | LogEnterEmployeeScalarWhereWithAggregatesInput[]
    LogEnterEmployee?: IntWithAggregatesFilter<"LogEnterEmployee"> | number
    UserID?: StringWithAggregatesFilter<"LogEnterEmployee"> | string
    CompanyID?: StringWithAggregatesFilter<"LogEnterEmployee"> | string
    EmployeeID?: IntWithAggregatesFilter<"LogEnterEmployee"> | number
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"LogEnterEmployee"> | Date | string | null
    ResultsData?: StringNullableWithAggregatesFilter<"LogEnterEmployee"> | string | null
  }

  export type LogSearchsWhereInput = {
    AND?: LogSearchsWhereInput | LogSearchsWhereInput[]
    OR?: LogSearchsWhereInput[]
    NOT?: LogSearchsWhereInput | LogSearchsWhereInput[]
    LogSearchsId?: IntFilter<"LogSearchs"> | number
    UserID?: StringFilter<"LogSearchs"> | string
    CompanyID?: StringFilter<"LogSearchs"> | string
    CreatedAt?: DateTimeNullableFilter<"LogSearchs"> | Date | string | null
    searchData?: StringNullableFilter<"LogSearchs"> | string | null
    resultsCount?: IntNullableFilter<"LogSearchs"> | number | null
  }

  export type LogSearchsOrderByWithRelationInput = {
    LogSearchsId?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    searchData?: SortOrderInput | SortOrder
    resultsCount?: SortOrderInput | SortOrder
  }

  export type LogSearchsWhereUniqueInput = Prisma.AtLeast<{
    LogSearchsId?: number
    AND?: LogSearchsWhereInput | LogSearchsWhereInput[]
    OR?: LogSearchsWhereInput[]
    NOT?: LogSearchsWhereInput | LogSearchsWhereInput[]
    UserID?: StringFilter<"LogSearchs"> | string
    CompanyID?: StringFilter<"LogSearchs"> | string
    CreatedAt?: DateTimeNullableFilter<"LogSearchs"> | Date | string | null
    searchData?: StringNullableFilter<"LogSearchs"> | string | null
    resultsCount?: IntNullableFilter<"LogSearchs"> | number | null
  }, "LogSearchsId">

  export type LogSearchsOrderByWithAggregationInput = {
    LogSearchsId?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    searchData?: SortOrderInput | SortOrder
    resultsCount?: SortOrderInput | SortOrder
    _count?: LogSearchsCountOrderByAggregateInput
    _avg?: LogSearchsAvgOrderByAggregateInput
    _max?: LogSearchsMaxOrderByAggregateInput
    _min?: LogSearchsMinOrderByAggregateInput
    _sum?: LogSearchsSumOrderByAggregateInput
  }

  export type LogSearchsScalarWhereWithAggregatesInput = {
    AND?: LogSearchsScalarWhereWithAggregatesInput | LogSearchsScalarWhereWithAggregatesInput[]
    OR?: LogSearchsScalarWhereWithAggregatesInput[]
    NOT?: LogSearchsScalarWhereWithAggregatesInput | LogSearchsScalarWhereWithAggregatesInput[]
    LogSearchsId?: IntWithAggregatesFilter<"LogSearchs"> | number
    UserID?: StringWithAggregatesFilter<"LogSearchs"> | string
    CompanyID?: StringWithAggregatesFilter<"LogSearchs"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"LogSearchs"> | Date | string | null
    searchData?: StringNullableWithAggregatesFilter<"LogSearchs"> | string | null
    resultsCount?: IntNullableWithAggregatesFilter<"LogSearchs"> | number | null
  }

  export type LogSignUpWhereInput = {
    AND?: LogSignUpWhereInput | LogSignUpWhereInput[]
    OR?: LogSignUpWhereInput[]
    NOT?: LogSignUpWhereInput | LogSignUpWhereInput[]
    LogSignUpId?: IntFilter<"LogSignUp"> | number
    UserID?: StringFilter<"LogSignUp"> | string
    CompanyID?: StringFilter<"LogSignUp"> | string
    CreatedAt?: DateTimeNullableFilter<"LogSignUp"> | Date | string | null
  }

  export type LogSignUpOrderByWithRelationInput = {
    LogSignUpId?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
  }

  export type LogSignUpWhereUniqueInput = Prisma.AtLeast<{
    LogSignUpId?: number
    AND?: LogSignUpWhereInput | LogSignUpWhereInput[]
    OR?: LogSignUpWhereInput[]
    NOT?: LogSignUpWhereInput | LogSignUpWhereInput[]
    UserID?: StringFilter<"LogSignUp"> | string
    CompanyID?: StringFilter<"LogSignUp"> | string
    CreatedAt?: DateTimeNullableFilter<"LogSignUp"> | Date | string | null
  }, "LogSignUpId">

  export type LogSignUpOrderByWithAggregationInput = {
    LogSignUpId?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    _count?: LogSignUpCountOrderByAggregateInput
    _avg?: LogSignUpAvgOrderByAggregateInput
    _max?: LogSignUpMaxOrderByAggregateInput
    _min?: LogSignUpMinOrderByAggregateInput
    _sum?: LogSignUpSumOrderByAggregateInput
  }

  export type LogSignUpScalarWhereWithAggregatesInput = {
    AND?: LogSignUpScalarWhereWithAggregatesInput | LogSignUpScalarWhereWithAggregatesInput[]
    OR?: LogSignUpScalarWhereWithAggregatesInput[]
    NOT?: LogSignUpScalarWhereWithAggregatesInput | LogSignUpScalarWhereWithAggregatesInput[]
    LogSignUpId?: IntWithAggregatesFilter<"LogSignUp"> | number
    UserID?: StringWithAggregatesFilter<"LogSignUp"> | string
    CompanyID?: StringWithAggregatesFilter<"LogSignUp"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"LogSignUp"> | Date | string | null
  }

  export type MessagesEmployeesWhereInput = {
    AND?: MessagesEmployeesWhereInput | MessagesEmployeesWhereInput[]
    OR?: MessagesEmployeesWhereInput[]
    NOT?: MessagesEmployeesWhereInput | MessagesEmployeesWhereInput[]
    MessageEmployeeId?: StringFilter<"MessagesEmployees"> | string
    CreatedAt?: DateTimeFilter<"MessagesEmployees"> | Date | string
    FinalDateForTask?: DateTimeNullableFilter<"MessagesEmployees"> | Date | string | null
    ReadedAt?: DateTimeNullableFilter<"MessagesEmployees"> | Date | string | null
    DoneAt?: DateTimeNullableFilter<"MessagesEmployees"> | Date | string | null
    SendResponseAtStatusDone?: IntNullableFilter<"MessagesEmployees"> | number | null
    CompanyIdGeneralCRM?: StringFilter<"MessagesEmployees"> | string
    UserFromIdGeneralCRM?: StringFilter<"MessagesEmployees"> | string
    UserToIdGeneralCRM?: StringFilter<"MessagesEmployees"> | string
    IsReplyToMessageId?: StringNullableFilter<"MessagesEmployees"> | string | null
    MessageStatusId?: StringFilter<"MessagesEmployees"> | string
    MessageSubject?: StringNullableFilter<"MessagesEmployees"> | string | null
    MessageText?: StringNullableFilter<"MessagesEmployees"> | string | null
    LinkEmployees?: StringNullableFilter<"MessagesEmployees"> | string | null
    LinkHouses?: StringNullableFilter<"MessagesEmployees"> | string | null
    MessagesEmployees?: XOR<MessagesEmployeesNullableScalarRelationFilter, MessagesEmployeesWhereInput> | null
    other_MessagesEmployees?: MessagesEmployeesListRelationFilter
    MessagesStatus?: XOR<MessagesStatusScalarRelationFilter, MessagesStatusWhereInput>
  }

  export type MessagesEmployeesOrderByWithRelationInput = {
    MessageEmployeeId?: SortOrder
    CreatedAt?: SortOrder
    FinalDateForTask?: SortOrderInput | SortOrder
    ReadedAt?: SortOrderInput | SortOrder
    DoneAt?: SortOrderInput | SortOrder
    SendResponseAtStatusDone?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    UserFromIdGeneralCRM?: SortOrder
    UserToIdGeneralCRM?: SortOrder
    IsReplyToMessageId?: SortOrderInput | SortOrder
    MessageStatusId?: SortOrder
    MessageSubject?: SortOrderInput | SortOrder
    MessageText?: SortOrderInput | SortOrder
    LinkEmployees?: SortOrderInput | SortOrder
    LinkHouses?: SortOrderInput | SortOrder
    MessagesEmployees?: MessagesEmployeesOrderByWithRelationInput
    other_MessagesEmployees?: MessagesEmployeesOrderByRelationAggregateInput
    MessagesStatus?: MessagesStatusOrderByWithRelationInput
  }

  export type MessagesEmployeesWhereUniqueInput = Prisma.AtLeast<{
    MessageEmployeeId?: string
    AND?: MessagesEmployeesWhereInput | MessagesEmployeesWhereInput[]
    OR?: MessagesEmployeesWhereInput[]
    NOT?: MessagesEmployeesWhereInput | MessagesEmployeesWhereInput[]
    CreatedAt?: DateTimeFilter<"MessagesEmployees"> | Date | string
    FinalDateForTask?: DateTimeNullableFilter<"MessagesEmployees"> | Date | string | null
    ReadedAt?: DateTimeNullableFilter<"MessagesEmployees"> | Date | string | null
    DoneAt?: DateTimeNullableFilter<"MessagesEmployees"> | Date | string | null
    SendResponseAtStatusDone?: IntNullableFilter<"MessagesEmployees"> | number | null
    CompanyIdGeneralCRM?: StringFilter<"MessagesEmployees"> | string
    UserFromIdGeneralCRM?: StringFilter<"MessagesEmployees"> | string
    UserToIdGeneralCRM?: StringFilter<"MessagesEmployees"> | string
    IsReplyToMessageId?: StringNullableFilter<"MessagesEmployees"> | string | null
    MessageStatusId?: StringFilter<"MessagesEmployees"> | string
    MessageSubject?: StringNullableFilter<"MessagesEmployees"> | string | null
    MessageText?: StringNullableFilter<"MessagesEmployees"> | string | null
    LinkEmployees?: StringNullableFilter<"MessagesEmployees"> | string | null
    LinkHouses?: StringNullableFilter<"MessagesEmployees"> | string | null
    MessagesEmployees?: XOR<MessagesEmployeesNullableScalarRelationFilter, MessagesEmployeesWhereInput> | null
    other_MessagesEmployees?: MessagesEmployeesListRelationFilter
    MessagesStatus?: XOR<MessagesStatusScalarRelationFilter, MessagesStatusWhereInput>
  }, "MessageEmployeeId">

  export type MessagesEmployeesOrderByWithAggregationInput = {
    MessageEmployeeId?: SortOrder
    CreatedAt?: SortOrder
    FinalDateForTask?: SortOrderInput | SortOrder
    ReadedAt?: SortOrderInput | SortOrder
    DoneAt?: SortOrderInput | SortOrder
    SendResponseAtStatusDone?: SortOrderInput | SortOrder
    CompanyIdGeneralCRM?: SortOrder
    UserFromIdGeneralCRM?: SortOrder
    UserToIdGeneralCRM?: SortOrder
    IsReplyToMessageId?: SortOrderInput | SortOrder
    MessageStatusId?: SortOrder
    MessageSubject?: SortOrderInput | SortOrder
    MessageText?: SortOrderInput | SortOrder
    LinkEmployees?: SortOrderInput | SortOrder
    LinkHouses?: SortOrderInput | SortOrder
    _count?: MessagesEmployeesCountOrderByAggregateInput
    _avg?: MessagesEmployeesAvgOrderByAggregateInput
    _max?: MessagesEmployeesMaxOrderByAggregateInput
    _min?: MessagesEmployeesMinOrderByAggregateInput
    _sum?: MessagesEmployeesSumOrderByAggregateInput
  }

  export type MessagesEmployeesScalarWhereWithAggregatesInput = {
    AND?: MessagesEmployeesScalarWhereWithAggregatesInput | MessagesEmployeesScalarWhereWithAggregatesInput[]
    OR?: MessagesEmployeesScalarWhereWithAggregatesInput[]
    NOT?: MessagesEmployeesScalarWhereWithAggregatesInput | MessagesEmployeesScalarWhereWithAggregatesInput[]
    MessageEmployeeId?: StringWithAggregatesFilter<"MessagesEmployees"> | string
    CreatedAt?: DateTimeWithAggregatesFilter<"MessagesEmployees"> | Date | string
    FinalDateForTask?: DateTimeNullableWithAggregatesFilter<"MessagesEmployees"> | Date | string | null
    ReadedAt?: DateTimeNullableWithAggregatesFilter<"MessagesEmployees"> | Date | string | null
    DoneAt?: DateTimeNullableWithAggregatesFilter<"MessagesEmployees"> | Date | string | null
    SendResponseAtStatusDone?: IntNullableWithAggregatesFilter<"MessagesEmployees"> | number | null
    CompanyIdGeneralCRM?: StringWithAggregatesFilter<"MessagesEmployees"> | string
    UserFromIdGeneralCRM?: StringWithAggregatesFilter<"MessagesEmployees"> | string
    UserToIdGeneralCRM?: StringWithAggregatesFilter<"MessagesEmployees"> | string
    IsReplyToMessageId?: StringNullableWithAggregatesFilter<"MessagesEmployees"> | string | null
    MessageStatusId?: StringWithAggregatesFilter<"MessagesEmployees"> | string
    MessageSubject?: StringNullableWithAggregatesFilter<"MessagesEmployees"> | string | null
    MessageText?: StringNullableWithAggregatesFilter<"MessagesEmployees"> | string | null
    LinkEmployees?: StringNullableWithAggregatesFilter<"MessagesEmployees"> | string | null
    LinkHouses?: StringNullableWithAggregatesFilter<"MessagesEmployees"> | string | null
  }

  export type MessagesStatusWhereInput = {
    AND?: MessagesStatusWhereInput | MessagesStatusWhereInput[]
    OR?: MessagesStatusWhereInput[]
    NOT?: MessagesStatusWhereInput | MessagesStatusWhereInput[]
    MessagesStatusId?: StringFilter<"MessagesStatus"> | string
    MessagesStatusName?: StringFilter<"MessagesStatus"> | string
    CreatedAt?: DateTimeNullableFilter<"MessagesStatus"> | Date | string | null
    Sort?: IntFilter<"MessagesStatus"> | number
    Comments?: StringNullableFilter<"MessagesStatus"> | string | null
    MessagesEmployees?: MessagesEmployeesListRelationFilter
  }

  export type MessagesStatusOrderByWithRelationInput = {
    MessagesStatusId?: SortOrder
    MessagesStatusName?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    Sort?: SortOrder
    Comments?: SortOrderInput | SortOrder
    MessagesEmployees?: MessagesEmployeesOrderByRelationAggregateInput
  }

  export type MessagesStatusWhereUniqueInput = Prisma.AtLeast<{
    MessagesStatusId?: string
    AND?: MessagesStatusWhereInput | MessagesStatusWhereInput[]
    OR?: MessagesStatusWhereInput[]
    NOT?: MessagesStatusWhereInput | MessagesStatusWhereInput[]
    MessagesStatusName?: StringFilter<"MessagesStatus"> | string
    CreatedAt?: DateTimeNullableFilter<"MessagesStatus"> | Date | string | null
    Sort?: IntFilter<"MessagesStatus"> | number
    Comments?: StringNullableFilter<"MessagesStatus"> | string | null
    MessagesEmployees?: MessagesEmployeesListRelationFilter
  }, "MessagesStatusId">

  export type MessagesStatusOrderByWithAggregationInput = {
    MessagesStatusId?: SortOrder
    MessagesStatusName?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    Sort?: SortOrder
    Comments?: SortOrderInput | SortOrder
    _count?: MessagesStatusCountOrderByAggregateInput
    _avg?: MessagesStatusAvgOrderByAggregateInput
    _max?: MessagesStatusMaxOrderByAggregateInput
    _min?: MessagesStatusMinOrderByAggregateInput
    _sum?: MessagesStatusSumOrderByAggregateInput
  }

  export type MessagesStatusScalarWhereWithAggregatesInput = {
    AND?: MessagesStatusScalarWhereWithAggregatesInput | MessagesStatusScalarWhereWithAggregatesInput[]
    OR?: MessagesStatusScalarWhereWithAggregatesInput[]
    NOT?: MessagesStatusScalarWhereWithAggregatesInput | MessagesStatusScalarWhereWithAggregatesInput[]
    MessagesStatusId?: StringWithAggregatesFilter<"MessagesStatus"> | string
    MessagesStatusName?: StringWithAggregatesFilter<"MessagesStatus"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"MessagesStatus"> | Date | string | null
    Sort?: IntWithAggregatesFilter<"MessagesStatus"> | number
    Comments?: StringNullableWithAggregatesFilter<"MessagesStatus"> | string | null
  }

  export type SiteConfigWhereInput = {
    AND?: SiteConfigWhereInput | SiteConfigWhereInput[]
    OR?: SiteConfigWhereInput[]
    NOT?: SiteConfigWhereInput | SiteConfigWhereInput[]
    SiteConfigId?: IntFilter<"SiteConfig"> | number
    PropertyEngName?: StringFilter<"SiteConfig"> | string
    PropertyIntValue?: FloatNullableFilter<"SiteConfig"> | number | null
    PropertyTextValue?: StringNullableFilter<"SiteConfig"> | string | null
    PropertyHebDescription?: StringFilter<"SiteConfig"> | string
    CreatedAt?: DateTimeNullableFilter<"SiteConfig"> | Date | string | null
  }

  export type SiteConfigOrderByWithRelationInput = {
    SiteConfigId?: SortOrder
    PropertyEngName?: SortOrder
    PropertyIntValue?: SortOrderInput | SortOrder
    PropertyTextValue?: SortOrderInput | SortOrder
    PropertyHebDescription?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
  }

  export type SiteConfigWhereUniqueInput = Prisma.AtLeast<{
    SiteConfigId?: number
    AND?: SiteConfigWhereInput | SiteConfigWhereInput[]
    OR?: SiteConfigWhereInput[]
    NOT?: SiteConfigWhereInput | SiteConfigWhereInput[]
    PropertyEngName?: StringFilter<"SiteConfig"> | string
    PropertyIntValue?: FloatNullableFilter<"SiteConfig"> | number | null
    PropertyTextValue?: StringNullableFilter<"SiteConfig"> | string | null
    PropertyHebDescription?: StringFilter<"SiteConfig"> | string
    CreatedAt?: DateTimeNullableFilter<"SiteConfig"> | Date | string | null
  }, "SiteConfigId">

  export type SiteConfigOrderByWithAggregationInput = {
    SiteConfigId?: SortOrder
    PropertyEngName?: SortOrder
    PropertyIntValue?: SortOrderInput | SortOrder
    PropertyTextValue?: SortOrderInput | SortOrder
    PropertyHebDescription?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    _count?: SiteConfigCountOrderByAggregateInput
    _avg?: SiteConfigAvgOrderByAggregateInput
    _max?: SiteConfigMaxOrderByAggregateInput
    _min?: SiteConfigMinOrderByAggregateInput
    _sum?: SiteConfigSumOrderByAggregateInput
  }

  export type SiteConfigScalarWhereWithAggregatesInput = {
    AND?: SiteConfigScalarWhereWithAggregatesInput | SiteConfigScalarWhereWithAggregatesInput[]
    OR?: SiteConfigScalarWhereWithAggregatesInput[]
    NOT?: SiteConfigScalarWhereWithAggregatesInput | SiteConfigScalarWhereWithAggregatesInput[]
    SiteConfigId?: IntWithAggregatesFilter<"SiteConfig"> | number
    PropertyEngName?: StringWithAggregatesFilter<"SiteConfig"> | string
    PropertyIntValue?: FloatNullableWithAggregatesFilter<"SiteConfig"> | number | null
    PropertyTextValue?: StringNullableWithAggregatesFilter<"SiteConfig"> | string | null
    PropertyHebDescription?: StringWithAggregatesFilter<"SiteConfig"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"SiteConfig"> | Date | string | null
  }

  export type sysdiagramsWhereInput = {
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    diagram_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Uint8Array | null
  }

  export type sysdiagramsOrderByWithRelationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
  }

  export type sysdiagramsWhereUniqueInput = Prisma.AtLeast<{
    diagram_id?: number
    principal_id_name?: sysdiagramsPrincipal_idNameCompoundUniqueInput
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Uint8Array | null
  }, "diagram_id" | "principal_id_name">

  export type sysdiagramsOrderByWithAggregationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
    _count?: sysdiagramsCountOrderByAggregateInput
    _avg?: sysdiagramsAvgOrderByAggregateInput
    _max?: sysdiagramsMaxOrderByAggregateInput
    _min?: sysdiagramsMinOrderByAggregateInput
    _sum?: sysdiagramsSumOrderByAggregateInput
  }

  export type sysdiagramsScalarWhereWithAggregatesInput = {
    AND?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    OR?: sysdiagramsScalarWhereWithAggregatesInput[]
    NOT?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"sysdiagrams"> | string
    principal_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    diagram_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    version?: IntNullableWithAggregatesFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableWithAggregatesFilter<"sysdiagrams"> | Uint8Array | null
  }

  export type UsersLinkedViewRoleWhereInput = {
    AND?: UsersLinkedViewRoleWhereInput | UsersLinkedViewRoleWhereInput[]
    OR?: UsersLinkedViewRoleWhereInput[]
    NOT?: UsersLinkedViewRoleWhereInput | UsersLinkedViewRoleWhereInput[]
    UsersLinkedViewRoleId?: StringFilter<"UsersLinkedViewRole"> | string
    CreatedAt?: DateTimeNullableFilter<"UsersLinkedViewRole"> | Date | string | null
    CompanyID?: StringFilter<"UsersLinkedViewRole"> | string
    UserID?: StringFilter<"UsersLinkedViewRole"> | string
    UserViewRolesId?: StringFilter<"UsersLinkedViewRole"> | string
    UserViewRoles?: XOR<UserViewRolesScalarRelationFilter, UserViewRolesWhereInput>
  }

  export type UsersLinkedViewRoleOrderByWithRelationInput = {
    UsersLinkedViewRoleId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyID?: SortOrder
    UserID?: SortOrder
    UserViewRolesId?: SortOrder
    UserViewRoles?: UserViewRolesOrderByWithRelationInput
  }

  export type UsersLinkedViewRoleWhereUniqueInput = Prisma.AtLeast<{
    UsersLinkedViewRoleId?: string
    UserID?: string
    AND?: UsersLinkedViewRoleWhereInput | UsersLinkedViewRoleWhereInput[]
    OR?: UsersLinkedViewRoleWhereInput[]
    NOT?: UsersLinkedViewRoleWhereInput | UsersLinkedViewRoleWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"UsersLinkedViewRole"> | Date | string | null
    CompanyID?: StringFilter<"UsersLinkedViewRole"> | string
    UserViewRolesId?: StringFilter<"UsersLinkedViewRole"> | string
    UserViewRoles?: XOR<UserViewRolesScalarRelationFilter, UserViewRolesWhereInput>
  }, "UsersLinkedViewRoleId" | "UserID">

  export type UsersLinkedViewRoleOrderByWithAggregationInput = {
    UsersLinkedViewRoleId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyID?: SortOrder
    UserID?: SortOrder
    UserViewRolesId?: SortOrder
    _count?: UsersLinkedViewRoleCountOrderByAggregateInput
    _max?: UsersLinkedViewRoleMaxOrderByAggregateInput
    _min?: UsersLinkedViewRoleMinOrderByAggregateInput
  }

  export type UsersLinkedViewRoleScalarWhereWithAggregatesInput = {
    AND?: UsersLinkedViewRoleScalarWhereWithAggregatesInput | UsersLinkedViewRoleScalarWhereWithAggregatesInput[]
    OR?: UsersLinkedViewRoleScalarWhereWithAggregatesInput[]
    NOT?: UsersLinkedViewRoleScalarWhereWithAggregatesInput | UsersLinkedViewRoleScalarWhereWithAggregatesInput[]
    UsersLinkedViewRoleId?: StringWithAggregatesFilter<"UsersLinkedViewRole"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"UsersLinkedViewRole"> | Date | string | null
    CompanyID?: StringWithAggregatesFilter<"UsersLinkedViewRole"> | string
    UserID?: StringWithAggregatesFilter<"UsersLinkedViewRole"> | string
    UserViewRolesId?: StringWithAggregatesFilter<"UsersLinkedViewRole"> | string
  }

  export type UserViewRolesWhereInput = {
    AND?: UserViewRolesWhereInput | UserViewRolesWhereInput[]
    OR?: UserViewRolesWhereInput[]
    NOT?: UserViewRolesWhereInput | UserViewRolesWhereInput[]
    UserViewRolesId?: StringFilter<"UserViewRoles"> | string
    CreatedAt?: DateTimeNullableFilter<"UserViewRoles"> | Date | string | null
    CompanyID?: StringFilter<"UserViewRoles"> | string
    UserViewRoleName?: StringFilter<"UserViewRoles"> | string
    NotShowFields?: StringNullableFilter<"UserViewRoles"> | string | null
    MaxSearchResults?: IntNullableFilter<"UserViewRoles"> | number | null
    EditFields?: StringNullableFilter<"UserViewRoles"> | string | null
    UsersLinkedViewRole?: UsersLinkedViewRoleListRelationFilter
  }

  export type UserViewRolesOrderByWithRelationInput = {
    UserViewRolesId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyID?: SortOrder
    UserViewRoleName?: SortOrder
    NotShowFields?: SortOrderInput | SortOrder
    MaxSearchResults?: SortOrderInput | SortOrder
    EditFields?: SortOrderInput | SortOrder
    UsersLinkedViewRole?: UsersLinkedViewRoleOrderByRelationAggregateInput
  }

  export type UserViewRolesWhereUniqueInput = Prisma.AtLeast<{
    UserViewRolesId?: string
    AND?: UserViewRolesWhereInput | UserViewRolesWhereInput[]
    OR?: UserViewRolesWhereInput[]
    NOT?: UserViewRolesWhereInput | UserViewRolesWhereInput[]
    CreatedAt?: DateTimeNullableFilter<"UserViewRoles"> | Date | string | null
    CompanyID?: StringFilter<"UserViewRoles"> | string
    UserViewRoleName?: StringFilter<"UserViewRoles"> | string
    NotShowFields?: StringNullableFilter<"UserViewRoles"> | string | null
    MaxSearchResults?: IntNullableFilter<"UserViewRoles"> | number | null
    EditFields?: StringNullableFilter<"UserViewRoles"> | string | null
    UsersLinkedViewRole?: UsersLinkedViewRoleListRelationFilter
  }, "UserViewRolesId">

  export type UserViewRolesOrderByWithAggregationInput = {
    UserViewRolesId?: SortOrder
    CreatedAt?: SortOrderInput | SortOrder
    CompanyID?: SortOrder
    UserViewRoleName?: SortOrder
    NotShowFields?: SortOrderInput | SortOrder
    MaxSearchResults?: SortOrderInput | SortOrder
    EditFields?: SortOrderInput | SortOrder
    _count?: UserViewRolesCountOrderByAggregateInput
    _avg?: UserViewRolesAvgOrderByAggregateInput
    _max?: UserViewRolesMaxOrderByAggregateInput
    _min?: UserViewRolesMinOrderByAggregateInput
    _sum?: UserViewRolesSumOrderByAggregateInput
  }

  export type UserViewRolesScalarWhereWithAggregatesInput = {
    AND?: UserViewRolesScalarWhereWithAggregatesInput | UserViewRolesScalarWhereWithAggregatesInput[]
    OR?: UserViewRolesScalarWhereWithAggregatesInput[]
    NOT?: UserViewRolesScalarWhereWithAggregatesInput | UserViewRolesScalarWhereWithAggregatesInput[]
    UserViewRolesId?: StringWithAggregatesFilter<"UserViewRoles"> | string
    CreatedAt?: DateTimeNullableWithAggregatesFilter<"UserViewRoles"> | Date | string | null
    CompanyID?: StringWithAggregatesFilter<"UserViewRoles"> | string
    UserViewRoleName?: StringWithAggregatesFilter<"UserViewRoles"> | string
    NotShowFields?: StringNullableWithAggregatesFilter<"UserViewRoles"> | string | null
    MaxSearchResults?: IntNullableWithAggregatesFilter<"UserViewRoles"> | number | null
    EditFields?: StringNullableWithAggregatesFilter<"UserViewRoles"> | string | null
  }

  export type CompaniesConfigCreateInput = {
    CompanyIdGeneralCRM: string
    CreatedAt?: Date | string | null
    PropertyEngName: string
    PropertyValue?: number | null
    PropertyTextJsonValue?: string | null
    PropertyHebDescription: string
  }

  export type CompaniesConfigUncheckedCreateInput = {
    CompanyConfigId?: number
    CompanyIdGeneralCRM: string
    CreatedAt?: Date | string | null
    PropertyEngName: string
    PropertyValue?: number | null
    PropertyTextJsonValue?: string | null
    PropertyHebDescription: string
  }

  export type CompaniesConfigUpdateInput = {
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PropertyEngName?: StringFieldUpdateOperationsInput | string
    PropertyValue?: NullableFloatFieldUpdateOperationsInput | number | null
    PropertyTextJsonValue?: NullableStringFieldUpdateOperationsInput | string | null
    PropertyHebDescription?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesConfigUncheckedUpdateInput = {
    CompanyConfigId?: IntFieldUpdateOperationsInput | number
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PropertyEngName?: StringFieldUpdateOperationsInput | string
    PropertyValue?: NullableFloatFieldUpdateOperationsInput | number | null
    PropertyTextJsonValue?: NullableStringFieldUpdateOperationsInput | string | null
    PropertyHebDescription?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesConfigCreateManyInput = {
    CompanyIdGeneralCRM: string
    CreatedAt?: Date | string | null
    PropertyEngName: string
    PropertyValue?: number | null
    PropertyTextJsonValue?: string | null
    PropertyHebDescription: string
  }

  export type CompaniesConfigUpdateManyMutationInput = {
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PropertyEngName?: StringFieldUpdateOperationsInput | string
    PropertyValue?: NullableFloatFieldUpdateOperationsInput | number | null
    PropertyTextJsonValue?: NullableStringFieldUpdateOperationsInput | string | null
    PropertyHebDescription?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesConfigUncheckedUpdateManyInput = {
    CompanyConfigId?: IntFieldUpdateOperationsInput | number
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PropertyEngName?: StringFieldUpdateOperationsInput | string
    PropertyValue?: NullableFloatFieldUpdateOperationsInput | number | null
    PropertyTextJsonValue?: NullableStringFieldUpdateOperationsInput | string | null
    PropertyHebDescription?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyAdminCreateInput = {
    CompanyAdminId?: string
    CompanyID: string
    CreatedAt?: Date | string | null
    NotShowFields?: string | null
    MaxSearchResults?: number | null
    EditFields?: string | null
  }

  export type CompanyAdminUncheckedCreateInput = {
    CompanyAdminId?: string
    CompanyID: string
    CreatedAt?: Date | string | null
    NotShowFields?: string | null
    MaxSearchResults?: number | null
    EditFields?: string | null
  }

  export type CompanyAdminUpdateInput = {
    CompanyAdminId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NotShowFields?: NullableStringFieldUpdateOperationsInput | string | null
    MaxSearchResults?: NullableIntFieldUpdateOperationsInput | number | null
    EditFields?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyAdminUncheckedUpdateInput = {
    CompanyAdminId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NotShowFields?: NullableStringFieldUpdateOperationsInput | string | null
    MaxSearchResults?: NullableIntFieldUpdateOperationsInput | number | null
    EditFields?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyAdminCreateManyInput = {
    CompanyAdminId?: string
    CompanyID: string
    CreatedAt?: Date | string | null
    NotShowFields?: string | null
    MaxSearchResults?: number | null
    EditFields?: string | null
  }

  export type CompanyAdminUpdateManyMutationInput = {
    CompanyAdminId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NotShowFields?: NullableStringFieldUpdateOperationsInput | string | null
    MaxSearchResults?: NullableIntFieldUpdateOperationsInput | number | null
    EditFields?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyAdminUncheckedUpdateManyInput = {
    CompanyAdminId?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NotShowFields?: NullableStringFieldUpdateOperationsInput | string | null
    MaxSearchResults?: NullableIntFieldUpdateOperationsInput | number | null
    EditFields?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeHoursCreateInput = {
    EmployeeHoursId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    EmployeeNumber: number
    MonthManaged: number
    YearManaged: number
    LeadingDate: Date | string
    HourStart?: Date | string | null
    HourEnd?: Date | string | null
    HourStartSource?: Date | string | null
    HourEndSource?: Date | string | null
    RealHours?: number | null
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    BreakMinutes?: number | null
    GpsStart?: string | null
    GpsEnd?: string | null
    IsManualInsert?: number | null
    ManualInsertUserId?: string | null
    IsRowDeleted?: number | null
    DayTypeID?: number | null
    HolidayName?: string | null
    StartEndTimeSabat?: Date | string | null
    IsForemanHourApproved?: Date | string | null
    IsForemanApproval?: Date | string | null
    ForemanApprovalGeneralCRMUserId?: string | null
    IsComplementRow?: number | null
    Lkup_ActionType?: Lkup_ActionTypeCreateNestedOneWithoutEmployeeHoursInput
    EmployeeHoursByLocality: EmployeeHoursByLocalityCreateNestedOneWithoutEmployeeHoursInput
  }

  export type EmployeeHoursUncheckedCreateInput = {
    EmployeeHoursId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    EmployeeNumber: number
    MonthManaged: number
    YearManaged: number
    LeadingDate: Date | string
    HourStart?: Date | string | null
    HourEnd?: Date | string | null
    HourStartSource?: Date | string | null
    HourEndSource?: Date | string | null
    RealHours?: number | null
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    BreakMinutes?: number | null
    GpsStart?: string | null
    GpsEnd?: string | null
    EmployeeHoursByLocalityId: string
    IsManualInsert?: number | null
    ManualInsertUserId?: string | null
    IsRowDeleted?: number | null
    ActionTypeID?: number | null
    DayTypeID?: number | null
    HolidayName?: string | null
    StartEndTimeSabat?: Date | string | null
    IsForemanHourApproved?: Date | string | null
    IsForemanApproval?: Date | string | null
    ForemanApprovalGeneralCRMUserId?: string | null
    IsComplementRow?: number | null
  }

  export type EmployeeHoursUpdateInput = {
    EmployeeHoursId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeNumber?: IntFieldUpdateOperationsInput | number
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    LeadingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    HourStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourStartSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEndSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    GpsStart?: NullableStringFieldUpdateOperationsInput | string | null
    GpsEnd?: NullableStringFieldUpdateOperationsInput | string | null
    IsManualInsert?: NullableIntFieldUpdateOperationsInput | number | null
    ManualInsertUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsRowDeleted?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanHourApproved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanApproval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ForemanApprovalGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsComplementRow?: NullableIntFieldUpdateOperationsInput | number | null
    Lkup_ActionType?: Lkup_ActionTypeUpdateOneWithoutEmployeeHoursNestedInput
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUpdateOneRequiredWithoutEmployeeHoursNestedInput
  }

  export type EmployeeHoursUncheckedUpdateInput = {
    EmployeeHoursId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeNumber?: IntFieldUpdateOperationsInput | number
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    LeadingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    HourStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourStartSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEndSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    GpsStart?: NullableStringFieldUpdateOperationsInput | string | null
    GpsEnd?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    IsManualInsert?: NullableIntFieldUpdateOperationsInput | number | null
    ManualInsertUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsRowDeleted?: NullableIntFieldUpdateOperationsInput | number | null
    ActionTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanHourApproved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanApproval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ForemanApprovalGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsComplementRow?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursCreateManyInput = {
    EmployeeHoursId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    EmployeeNumber: number
    MonthManaged: number
    YearManaged: number
    LeadingDate: Date | string
    HourStart?: Date | string | null
    HourEnd?: Date | string | null
    HourStartSource?: Date | string | null
    HourEndSource?: Date | string | null
    RealHours?: number | null
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    BreakMinutes?: number | null
    GpsStart?: string | null
    GpsEnd?: string | null
    EmployeeHoursByLocalityId: string
    IsManualInsert?: number | null
    ManualInsertUserId?: string | null
    IsRowDeleted?: number | null
    ActionTypeID?: number | null
    DayTypeID?: number | null
    HolidayName?: string | null
    StartEndTimeSabat?: Date | string | null
    IsForemanHourApproved?: Date | string | null
    IsForemanApproval?: Date | string | null
    ForemanApprovalGeneralCRMUserId?: string | null
    IsComplementRow?: number | null
  }

  export type EmployeeHoursUpdateManyMutationInput = {
    EmployeeHoursId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeNumber?: IntFieldUpdateOperationsInput | number
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    LeadingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    HourStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourStartSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEndSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    GpsStart?: NullableStringFieldUpdateOperationsInput | string | null
    GpsEnd?: NullableStringFieldUpdateOperationsInput | string | null
    IsManualInsert?: NullableIntFieldUpdateOperationsInput | number | null
    ManualInsertUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsRowDeleted?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanHourApproved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanApproval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ForemanApprovalGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsComplementRow?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursUncheckedUpdateManyInput = {
    EmployeeHoursId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeNumber?: IntFieldUpdateOperationsInput | number
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    LeadingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    HourStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourStartSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEndSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    GpsStart?: NullableStringFieldUpdateOperationsInput | string | null
    GpsEnd?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    IsManualInsert?: NullableIntFieldUpdateOperationsInput | number | null
    ManualInsertUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsRowDeleted?: NullableIntFieldUpdateOperationsInput | number | null
    ActionTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanHourApproved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanApproval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ForemanApprovalGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsComplementRow?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursByLocalityCreateInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHours?: EmployeeHoursCreateNestedManyWithoutEmployeeHoursByLocalityInput
    EmployeeHoursUsers: EmployeeHoursUsersCreateNestedOneWithoutEmployeeHoursByLocalityInput
    EmployeeHoursContracts: EmployeeHoursContractsCreateNestedOneWithoutEmployeeHoursByLocalityInput
    EmployeeHoursLocalities: EmployeeHoursLocalitiesCreateNestedOneWithoutEmployeeHoursByLocalityInput
  }

  export type EmployeeHoursByLocalityUncheckedCreateInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    EmployeeHoursLocalityId: string
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    EmployeeHoursUserId: string
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHoursContractId: string
    EmployeeHours?: EmployeeHoursUncheckedCreateNestedManyWithoutEmployeeHoursByLocalityInput
  }

  export type EmployeeHoursByLocalityUpdateInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHours?: EmployeeHoursUpdateManyWithoutEmployeeHoursByLocalityNestedInput
    EmployeeHoursUsers?: EmployeeHoursUsersUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput
    EmployeeHoursContracts?: EmployeeHoursContractsUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput
    EmployeeHoursLocalities?: EmployeeHoursLocalitiesUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput
  }

  export type EmployeeHoursByLocalityUncheckedUpdateInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeHoursUserId?: StringFieldUpdateOperationsInput | string
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHoursContractId?: StringFieldUpdateOperationsInput | string
    EmployeeHours?: EmployeeHoursUncheckedUpdateManyWithoutEmployeeHoursByLocalityNestedInput
  }

  export type EmployeeHoursByLocalityCreateManyInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    EmployeeHoursLocalityId: string
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    EmployeeHoursUserId: string
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHoursContractId: string
  }

  export type EmployeeHoursByLocalityUpdateManyMutationInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursByLocalityUncheckedUpdateManyInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeHoursUserId?: StringFieldUpdateOperationsInput | string
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHoursContractId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeHoursByLocalityTotalsCreateInput = {
    EmployeeHoursByLocalityTotalsId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    MonthManaged: number
    YearManaged: number
    EmployeeId: number
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    RealHours?: number | null
    BreakMinutes?: number | null
    WorkedDays?: number | null
    IsCloseSalary?: number
    EmployeeHoursLocalities: EmployeeHoursLocalitiesCreateNestedOneWithoutEmployeeHoursByLocalityTotalsInput
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeCreateNestedManyWithoutEmployeeHoursByLocalityTotalsInput
  }

  export type EmployeeHoursByLocalityTotalsUncheckedCreateInput = {
    EmployeeHoursByLocalityTotalsId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    MonthManaged: number
    YearManaged: number
    EmployeeId: number
    EmployeeHoursLocalityId: string
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    RealHours?: number | null
    BreakMinutes?: number | null
    WorkedDays?: number | null
    IsCloseSalary?: number
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateNestedManyWithoutEmployeeHoursByLocalityTotalsInput
  }

  export type EmployeeHoursByLocalityTotalsUpdateInput = {
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    EmployeeId?: IntFieldUpdateOperationsInput | number
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    WorkedDays?: NullableIntFieldUpdateOperationsInput | number | null
    IsCloseSalary?: IntFieldUpdateOperationsInput | number
    EmployeeHoursLocalities?: EmployeeHoursLocalitiesUpdateOneRequiredWithoutEmployeeHoursByLocalityTotalsNestedInput
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithoutEmployeeHoursByLocalityTotalsNestedInput
  }

  export type EmployeeHoursByLocalityTotalsUncheckedUpdateInput = {
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    WorkedDays?: NullableIntFieldUpdateOperationsInput | number | null
    IsCloseSalary?: IntFieldUpdateOperationsInput | number
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateManyWithoutEmployeeHoursByLocalityTotalsNestedInput
  }

  export type EmployeeHoursByLocalityTotalsCreateManyInput = {
    EmployeeHoursByLocalityTotalsId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    MonthManaged: number
    YearManaged: number
    EmployeeId: number
    EmployeeHoursLocalityId: string
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    RealHours?: number | null
    BreakMinutes?: number | null
    WorkedDays?: number | null
    IsCloseSalary?: number
  }

  export type EmployeeHoursByLocalityTotalsUpdateManyMutationInput = {
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    EmployeeId?: IntFieldUpdateOperationsInput | number
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    WorkedDays?: NullableIntFieldUpdateOperationsInput | number | null
    IsCloseSalary?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeHoursByLocalityTotalsUncheckedUpdateManyInput = {
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    WorkedDays?: NullableIntFieldUpdateOperationsInput | number | null
    IsCloseSalary?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCreateInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: string
    CreatedAt?: Date | string | null
    TotalActionType: number
    Lkup_ActionType: Lkup_ActionTypeCreateNestedOneWithoutEmployeeHoursByLocalityTotalsActionTypeInput
    EmployeeHoursByLocalityTotals: EmployeeHoursByLocalityTotalsCreateNestedOneWithoutEmployeeHoursByLocalityTotalsActionTypeInput
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: string
    CreatedAt?: Date | string | null
    EmployeeHoursByLocalityTotalsId: string
    ActionTypeId: number
    TotalActionType: number
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUpdateInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalActionType?: FloatFieldUpdateOperationsInput | number
    Lkup_ActionType?: Lkup_ActionTypeUpdateOneRequiredWithoutEmployeeHoursByLocalityTotalsActionTypeNestedInput
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsUpdateOneRequiredWithoutEmployeeHoursByLocalityTotalsActionTypeNestedInput
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    ActionTypeId?: IntFieldUpdateOperationsInput | number
    TotalActionType?: FloatFieldUpdateOperationsInput | number
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCreateManyInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: string
    CreatedAt?: Date | string | null
    EmployeeHoursByLocalityTotalsId: string
    ActionTypeId: number
    TotalActionType: number
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUpdateManyMutationInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalActionType?: FloatFieldUpdateOperationsInput | number
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateManyInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    ActionTypeId?: IntFieldUpdateOperationsInput | number
    TotalActionType?: FloatFieldUpdateOperationsInput | number
  }

  export type EmployeeHoursCompaniesSmsAlertCreateInput = {
    CompanyIdGeneralCRM: string
    CreatedAt?: Date | string | null
    EmployeeID?: number | null
    SmsNumber: string
    SmsResponse?: string | null
    UserSend: string
  }

  export type EmployeeHoursCompaniesSmsAlertUncheckedCreateInput = {
    CompaniesSmsAlertId?: number
    CompanyIdGeneralCRM: string
    CreatedAt?: Date | string | null
    EmployeeID?: number | null
    SmsNumber: string
    SmsResponse?: string | null
    UserSend: string
  }

  export type EmployeeHoursCompaniesSmsAlertUpdateInput = {
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmployeeID?: NullableIntFieldUpdateOperationsInput | number | null
    SmsNumber?: StringFieldUpdateOperationsInput | string
    SmsResponse?: NullableStringFieldUpdateOperationsInput | string | null
    UserSend?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeHoursCompaniesSmsAlertUncheckedUpdateInput = {
    CompaniesSmsAlertId?: IntFieldUpdateOperationsInput | number
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmployeeID?: NullableIntFieldUpdateOperationsInput | number | null
    SmsNumber?: StringFieldUpdateOperationsInput | string
    SmsResponse?: NullableStringFieldUpdateOperationsInput | string | null
    UserSend?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeHoursCompaniesSmsAlertCreateManyInput = {
    CompanyIdGeneralCRM: string
    CreatedAt?: Date | string | null
    EmployeeID?: number | null
    SmsNumber: string
    SmsResponse?: string | null
    UserSend: string
  }

  export type EmployeeHoursCompaniesSmsAlertUpdateManyMutationInput = {
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmployeeID?: NullableIntFieldUpdateOperationsInput | number | null
    SmsNumber?: StringFieldUpdateOperationsInput | string
    SmsResponse?: NullableStringFieldUpdateOperationsInput | string | null
    UserSend?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeHoursCompaniesSmsAlertUncheckedUpdateManyInput = {
    CompaniesSmsAlertId?: IntFieldUpdateOperationsInput | number
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmployeeID?: NullableIntFieldUpdateOperationsInput | number | null
    SmsNumber?: StringFieldUpdateOperationsInput | string
    SmsResponse?: NullableStringFieldUpdateOperationsInput | string | null
    UserSend?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeHoursContractsCreateInput = {
    EmployeeHoursContractsId?: string
    CreatedAt?: Date | string | null
    Active: number
    HebrewName: string
    Comments?: string | null
    JsonData: string
    CompanyIdGeneralCRM?: string | null
    HoursWeek: number
    NumberDayInWeek: number
    IsExtraHoursWeekCalc?: number | null
    IsNightShiftCalc?: number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityCreateNestedManyWithoutEmployeeHoursContractsInput
  }

  export type EmployeeHoursContractsUncheckedCreateInput = {
    EmployeeHoursContractsId?: string
    CreatedAt?: Date | string | null
    Active: number
    HebrewName: string
    Comments?: string | null
    JsonData: string
    CompanyIdGeneralCRM?: string | null
    HoursWeek: number
    NumberDayInWeek: number
    IsExtraHoursWeekCalc?: number | null
    IsNightShiftCalc?: number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUncheckedCreateNestedManyWithoutEmployeeHoursContractsInput
  }

  export type EmployeeHoursContractsUpdateInput = {
    EmployeeHoursContractsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: IntFieldUpdateOperationsInput | number
    HebrewName?: StringFieldUpdateOperationsInput | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    JsonData?: StringFieldUpdateOperationsInput | string
    CompanyIdGeneralCRM?: NullableStringFieldUpdateOperationsInput | string | null
    HoursWeek?: FloatFieldUpdateOperationsInput | number
    NumberDayInWeek?: IntFieldUpdateOperationsInput | number
    IsExtraHoursWeekCalc?: NullableIntFieldUpdateOperationsInput | number | null
    IsNightShiftCalc?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUpdateManyWithoutEmployeeHoursContractsNestedInput
  }

  export type EmployeeHoursContractsUncheckedUpdateInput = {
    EmployeeHoursContractsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: IntFieldUpdateOperationsInput | number
    HebrewName?: StringFieldUpdateOperationsInput | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    JsonData?: StringFieldUpdateOperationsInput | string
    CompanyIdGeneralCRM?: NullableStringFieldUpdateOperationsInput | string | null
    HoursWeek?: FloatFieldUpdateOperationsInput | number
    NumberDayInWeek?: IntFieldUpdateOperationsInput | number
    IsExtraHoursWeekCalc?: NullableIntFieldUpdateOperationsInput | number | null
    IsNightShiftCalc?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursContractsNestedInput
  }

  export type EmployeeHoursContractsCreateManyInput = {
    EmployeeHoursContractsId?: string
    CreatedAt?: Date | string | null
    Active: number
    HebrewName: string
    Comments?: string | null
    JsonData: string
    CompanyIdGeneralCRM?: string | null
    HoursWeek: number
    NumberDayInWeek: number
    IsExtraHoursWeekCalc?: number | null
    IsNightShiftCalc?: number | null
  }

  export type EmployeeHoursContractsUpdateManyMutationInput = {
    EmployeeHoursContractsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: IntFieldUpdateOperationsInput | number
    HebrewName?: StringFieldUpdateOperationsInput | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    JsonData?: StringFieldUpdateOperationsInput | string
    CompanyIdGeneralCRM?: NullableStringFieldUpdateOperationsInput | string | null
    HoursWeek?: FloatFieldUpdateOperationsInput | number
    NumberDayInWeek?: IntFieldUpdateOperationsInput | number
    IsExtraHoursWeekCalc?: NullableIntFieldUpdateOperationsInput | number | null
    IsNightShiftCalc?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursContractsUncheckedUpdateManyInput = {
    EmployeeHoursContractsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: IntFieldUpdateOperationsInput | number
    HebrewName?: StringFieldUpdateOperationsInput | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    JsonData?: StringFieldUpdateOperationsInput | string
    CompanyIdGeneralCRM?: NullableStringFieldUpdateOperationsInput | string | null
    HoursWeek?: FloatFieldUpdateOperationsInput | number
    NumberDayInWeek?: IntFieldUpdateOperationsInput | number
    IsExtraHoursWeekCalc?: NullableIntFieldUpdateOperationsInput | number | null
    IsNightShiftCalc?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursForemansConfigCreateInput = {
    EmployeeHoursForemanConfigId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    ForemanUserGeneralCRM: string
    CanEdit?: number | null
    NotShowSourceHours?: number | null
  }

  export type EmployeeHoursForemansConfigUncheckedCreateInput = {
    EmployeeHoursForemanConfigId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    ForemanUserGeneralCRM: string
    CanEdit?: number | null
    NotShowSourceHours?: number | null
  }

  export type EmployeeHoursForemansConfigUpdateInput = {
    EmployeeHoursForemanConfigId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    ForemanUserGeneralCRM?: StringFieldUpdateOperationsInput | string
    CanEdit?: NullableIntFieldUpdateOperationsInput | number | null
    NotShowSourceHours?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursForemansConfigUncheckedUpdateInput = {
    EmployeeHoursForemanConfigId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    ForemanUserGeneralCRM?: StringFieldUpdateOperationsInput | string
    CanEdit?: NullableIntFieldUpdateOperationsInput | number | null
    NotShowSourceHours?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursForemansConfigCreateManyInput = {
    EmployeeHoursForemanConfigId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    ForemanUserGeneralCRM: string
    CanEdit?: number | null
    NotShowSourceHours?: number | null
  }

  export type EmployeeHoursForemansConfigUpdateManyMutationInput = {
    EmployeeHoursForemanConfigId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    ForemanUserGeneralCRM?: StringFieldUpdateOperationsInput | string
    CanEdit?: NullableIntFieldUpdateOperationsInput | number | null
    NotShowSourceHours?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursForemansConfigUncheckedUpdateManyInput = {
    EmployeeHoursForemanConfigId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    ForemanUserGeneralCRM?: StringFieldUpdateOperationsInput | string
    CanEdit?: NullableIntFieldUpdateOperationsInput | number | null
    NotShowSourceHours?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursLocalitiesCreateInput = {
    EmployeeHoursLocalityId?: string
    CreatedAt?: Date | string | null
    NotShowLocality?: number | null
    LocalityName: string
    LocalityNameEng?: string | null
    CompanyIdGeneralCRM: string
    Address?: string | null
    Gps?: string | null
    GpsRadius: number
    AddressAccess?: string | null
    LocalityIDAccess: number
    LocalityCodeAccess?: number | null
    CustomerIDAccess?: number | null
    CustomerNameAccess?: string | null
    ForemanGeneralCRMUserId?: string | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number | null
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    RestrictDayHoursAbove12?: number | null
    RestrictWeekExtraHoursAbove16?: number | null
    RestrictGpsActive?: number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityCreateNestedManyWithoutEmployeeHoursLocalitiesInput
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsCreateNestedManyWithoutEmployeeHoursLocalitiesInput
  }

  export type EmployeeHoursLocalitiesUncheckedCreateInput = {
    EmployeeHoursLocalityId?: string
    CreatedAt?: Date | string | null
    NotShowLocality?: number | null
    LocalityName: string
    LocalityNameEng?: string | null
    CompanyIdGeneralCRM: string
    Address?: string | null
    Gps?: string | null
    GpsRadius: number
    AddressAccess?: string | null
    LocalityIDAccess: number
    LocalityCodeAccess?: number | null
    CustomerIDAccess?: number | null
    CustomerNameAccess?: string | null
    ForemanGeneralCRMUserId?: string | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number | null
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    RestrictDayHoursAbove12?: number | null
    RestrictWeekExtraHoursAbove16?: number | null
    RestrictGpsActive?: number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUncheckedCreateNestedManyWithoutEmployeeHoursLocalitiesInput
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsUncheckedCreateNestedManyWithoutEmployeeHoursLocalitiesInput
  }

  export type EmployeeHoursLocalitiesUpdateInput = {
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NotShowLocality?: NullableIntFieldUpdateOperationsInput | number | null
    LocalityName?: StringFieldUpdateOperationsInput | string
    LocalityNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Gps?: NullableStringFieldUpdateOperationsInput | string | null
    GpsRadius?: IntFieldUpdateOperationsInput | number
    AddressAccess?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityIDAccess?: IntFieldUpdateOperationsInput | number
    LocalityCodeAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerIDAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerNameAccess?: NullableStringFieldUpdateOperationsInput | string | null
    ForemanGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    RestrictDayHoursAbove12?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictWeekExtraHoursAbove16?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictGpsActive?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUpdateManyWithoutEmployeeHoursLocalitiesNestedInput
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsUpdateManyWithoutEmployeeHoursLocalitiesNestedInput
  }

  export type EmployeeHoursLocalitiesUncheckedUpdateInput = {
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NotShowLocality?: NullableIntFieldUpdateOperationsInput | number | null
    LocalityName?: StringFieldUpdateOperationsInput | string
    LocalityNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Gps?: NullableStringFieldUpdateOperationsInput | string | null
    GpsRadius?: IntFieldUpdateOperationsInput | number
    AddressAccess?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityIDAccess?: IntFieldUpdateOperationsInput | number
    LocalityCodeAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerIDAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerNameAccess?: NullableStringFieldUpdateOperationsInput | string | null
    ForemanGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    RestrictDayHoursAbove12?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictWeekExtraHoursAbove16?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictGpsActive?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursLocalitiesNestedInput
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsUncheckedUpdateManyWithoutEmployeeHoursLocalitiesNestedInput
  }

  export type EmployeeHoursLocalitiesCreateManyInput = {
    EmployeeHoursLocalityId?: string
    CreatedAt?: Date | string | null
    NotShowLocality?: number | null
    LocalityName: string
    LocalityNameEng?: string | null
    CompanyIdGeneralCRM: string
    Address?: string | null
    Gps?: string | null
    GpsRadius: number
    AddressAccess?: string | null
    LocalityIDAccess: number
    LocalityCodeAccess?: number | null
    CustomerIDAccess?: number | null
    CustomerNameAccess?: string | null
    ForemanGeneralCRMUserId?: string | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number | null
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    RestrictDayHoursAbove12?: number | null
    RestrictWeekExtraHoursAbove16?: number | null
    RestrictGpsActive?: number | null
  }

  export type EmployeeHoursLocalitiesUpdateManyMutationInput = {
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NotShowLocality?: NullableIntFieldUpdateOperationsInput | number | null
    LocalityName?: StringFieldUpdateOperationsInput | string
    LocalityNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Gps?: NullableStringFieldUpdateOperationsInput | string | null
    GpsRadius?: IntFieldUpdateOperationsInput | number
    AddressAccess?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityIDAccess?: IntFieldUpdateOperationsInput | number
    LocalityCodeAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerIDAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerNameAccess?: NullableStringFieldUpdateOperationsInput | string | null
    ForemanGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    RestrictDayHoursAbove12?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictWeekExtraHoursAbove16?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictGpsActive?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursLocalitiesUncheckedUpdateManyInput = {
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NotShowLocality?: NullableIntFieldUpdateOperationsInput | number | null
    LocalityName?: StringFieldUpdateOperationsInput | string
    LocalityNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Gps?: NullableStringFieldUpdateOperationsInput | string | null
    GpsRadius?: IntFieldUpdateOperationsInput | number
    AddressAccess?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityIDAccess?: IntFieldUpdateOperationsInput | number
    LocalityCodeAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerIDAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerNameAccess?: NullableStringFieldUpdateOperationsInput | string | null
    ForemanGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    RestrictDayHoursAbove12?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictWeekExtraHoursAbove16?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictGpsActive?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursUsersCreateInput = {
    EmployeeHoursUsersId: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    MobileNumber?: string | null
    UserName: string
    Password: string
    IsAdmin?: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    PhoneData?: string | null
    CookieError?: Date | string | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityCreateNestedManyWithoutEmployeeHoursUsersInput
  }

  export type EmployeeHoursUsersUncheckedCreateInput = {
    EmployeeHoursUsersId: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    MobileNumber?: string | null
    UserName: string
    Password: string
    IsAdmin?: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    PhoneData?: string | null
    CookieError?: Date | string | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUncheckedCreateNestedManyWithoutEmployeeHoursUsersInput
  }

  export type EmployeeHoursUsersUpdateInput = {
    EmployeeHoursUsersId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    PhoneData?: NullableStringFieldUpdateOperationsInput | string | null
    CookieError?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUpdateManyWithoutEmployeeHoursUsersNestedInput
  }

  export type EmployeeHoursUsersUncheckedUpdateInput = {
    EmployeeHoursUsersId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    PhoneData?: NullableStringFieldUpdateOperationsInput | string | null
    CookieError?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursUsersNestedInput
  }

  export type EmployeeHoursUsersCreateManyInput = {
    EmployeeHoursUsersId: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    MobileNumber?: string | null
    UserName: string
    Password: string
    IsAdmin?: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    PhoneData?: string | null
    CookieError?: Date | string | null
  }

  export type EmployeeHoursUsersUpdateManyMutationInput = {
    EmployeeHoursUsersId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    PhoneData?: NullableStringFieldUpdateOperationsInput | string | null
    CookieError?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeHoursUsersUncheckedUpdateManyInput = {
    EmployeeHoursUsersId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    PhoneData?: NullableStringFieldUpdateOperationsInput | string | null
    CookieError?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeesAccessDocumentsTempCreateInput = {
    EmployeesAccessDocumentTempId?: string
    CompanyGeneralCrmId: string
    CreatedAt?: Date | string
    EmployeeID?: string | null
    DocumemtID?: string | null
    Date?: string | null
    DocumemtType?: string | null
    Comment?: string | null
    DocumentName?: string | null
  }

  export type EmployeesAccessDocumentsTempUncheckedCreateInput = {
    EmployeesAccessDocumentTempId?: string
    CompanyGeneralCrmId: string
    CreatedAt?: Date | string
    EmployeeID?: string | null
    DocumemtID?: string | null
    Date?: string | null
    DocumemtType?: string | null
    Comment?: string | null
    DocumentName?: string | null
  }

  export type EmployeesAccessDocumentsTempUpdateInput = {
    EmployeesAccessDocumentTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EmployeeID?: NullableStringFieldUpdateOperationsInput | string | null
    DocumemtID?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableStringFieldUpdateOperationsInput | string | null
    DocumemtType?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    DocumentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessDocumentsTempUncheckedUpdateInput = {
    EmployeesAccessDocumentTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EmployeeID?: NullableStringFieldUpdateOperationsInput | string | null
    DocumemtID?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableStringFieldUpdateOperationsInput | string | null
    DocumemtType?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    DocumentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessDocumentsTempCreateManyInput = {
    EmployeesAccessDocumentTempId?: string
    CompanyGeneralCrmId: string
    CreatedAt?: Date | string
    EmployeeID?: string | null
    DocumemtID?: string | null
    Date?: string | null
    DocumemtType?: string | null
    Comment?: string | null
    DocumentName?: string | null
  }

  export type EmployeesAccessDocumentsTempUpdateManyMutationInput = {
    EmployeesAccessDocumentTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EmployeeID?: NullableStringFieldUpdateOperationsInput | string | null
    DocumemtID?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableStringFieldUpdateOperationsInput | string | null
    DocumemtType?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    DocumentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessDocumentsTempUncheckedUpdateManyInput = {
    EmployeesAccessDocumentTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EmployeeID?: NullableStringFieldUpdateOperationsInput | string | null
    DocumemtID?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableStringFieldUpdateOperationsInput | string | null
    DocumemtType?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    DocumentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessHouseTempCreateInput = {
    EmployeesAccessHouseTempId?: string
    CompanyGeneralCrmId: string
    CreatedAt?: Date | string
    HouseID?: string | null
    HouseCode?: string | null
    CityName?: string | null
    Street?: string | null
    HouseNumber?: string | null
    ZipCode?: string | null
    EmployeesQtyMax?: string | null
    ElectricityCounter_Start?: string | null
    ElectricityCounter_End?: string | null
    GasCounter_Start?: string | null
    GasCounter_End?: string | null
    WaterCounter_Start?: string | null
    WaterCounter_End?: string | null
    ElectricityNumber?: string | null
    GasNumber?: string | null
    WaterNumber?: string | null
    HouseField?: string | null
    ArnonaNumber?: string | null
    EvacuationDate?: string | null
    AreaMan?: string | null
    GasContainer?: string | null
    GasCompanyID?: string | null
    SleepingRooms?: string | null
    Salon?: string | null
    Toilet?: string | null
    Baths?: string | null
    HouseCommittee?: string | null
    HouseCommitteePhone?: string | null
    Status?: string | null
    Name?: string | null
    Street_?: string | null
    CityName_?: string | null
    ZipCode_?: string | null
    Phone_1?: string | null
    Phone_2?: string | null
    FaxNumber?: string | null
    StartDateContract?: string | null
    EndDateContract?: string | null
    Security?: string | null
    SecurityAmount?: string | null
    PaymentFrequency?: string | null
    Rant?: string | null
    Comment?: string | null
    IsInsured?: string | null
    InsureEndDate?: string | null
    IsUpdate?: string | null
    LivingArea?: string | null
    HouseRelation?: string | null
    CableTypeID?: string | null
    CableInstallationdate?: string | null
    AccountNumber?: string | null
    PathNumber?: string | null
    AppartmentNum?: string | null
    IsBroker?: string | null
    BrokerName?: string | null
    BrokerPhone?: string | null
    ElectricityCode?: string | null
    GasNumberCode?: string | null
    WaterNumberCode?: string | null
    ElectricityComment?: string | null
    GasCounteComment?: string | null
    WaterCounterComment?: string | null
    AgencyFee?: string | null
    IdNumber?: string | null
    ArrivalInstructions?: string | null
    OwnerEmail?: string | null
    OwnerBankAcount?: string | null
    CustomerID?: string | null
    LocalityName?: string | null
    Contractor_billing?: string | null
    Floor?: string | null
    Entrance?: string | null
    OwnerBranchCode?: string | null
    OwnerBankID?: string | null
  }

  export type EmployeesAccessHouseTempUncheckedCreateInput = {
    EmployeesAccessHouseTempId?: string
    CompanyGeneralCrmId: string
    CreatedAt?: Date | string
    HouseID?: string | null
    HouseCode?: string | null
    CityName?: string | null
    Street?: string | null
    HouseNumber?: string | null
    ZipCode?: string | null
    EmployeesQtyMax?: string | null
    ElectricityCounter_Start?: string | null
    ElectricityCounter_End?: string | null
    GasCounter_Start?: string | null
    GasCounter_End?: string | null
    WaterCounter_Start?: string | null
    WaterCounter_End?: string | null
    ElectricityNumber?: string | null
    GasNumber?: string | null
    WaterNumber?: string | null
    HouseField?: string | null
    ArnonaNumber?: string | null
    EvacuationDate?: string | null
    AreaMan?: string | null
    GasContainer?: string | null
    GasCompanyID?: string | null
    SleepingRooms?: string | null
    Salon?: string | null
    Toilet?: string | null
    Baths?: string | null
    HouseCommittee?: string | null
    HouseCommitteePhone?: string | null
    Status?: string | null
    Name?: string | null
    Street_?: string | null
    CityName_?: string | null
    ZipCode_?: string | null
    Phone_1?: string | null
    Phone_2?: string | null
    FaxNumber?: string | null
    StartDateContract?: string | null
    EndDateContract?: string | null
    Security?: string | null
    SecurityAmount?: string | null
    PaymentFrequency?: string | null
    Rant?: string | null
    Comment?: string | null
    IsInsured?: string | null
    InsureEndDate?: string | null
    IsUpdate?: string | null
    LivingArea?: string | null
    HouseRelation?: string | null
    CableTypeID?: string | null
    CableInstallationdate?: string | null
    AccountNumber?: string | null
    PathNumber?: string | null
    AppartmentNum?: string | null
    IsBroker?: string | null
    BrokerName?: string | null
    BrokerPhone?: string | null
    ElectricityCode?: string | null
    GasNumberCode?: string | null
    WaterNumberCode?: string | null
    ElectricityComment?: string | null
    GasCounteComment?: string | null
    WaterCounterComment?: string | null
    AgencyFee?: string | null
    IdNumber?: string | null
    ArrivalInstructions?: string | null
    OwnerEmail?: string | null
    OwnerBankAcount?: string | null
    CustomerID?: string | null
    LocalityName?: string | null
    Contractor_billing?: string | null
    Floor?: string | null
    Entrance?: string | null
    OwnerBranchCode?: string | null
    OwnerBankID?: string | null
  }

  export type EmployeesAccessHouseTempUpdateInput = {
    EmployeesAccessHouseTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HouseID?: NullableStringFieldUpdateOperationsInput | string | null
    HouseCode?: NullableStringFieldUpdateOperationsInput | string | null
    CityName?: NullableStringFieldUpdateOperationsInput | string | null
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    HouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeesQtyMax?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityCounter_Start?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityCounter_End?: NullableStringFieldUpdateOperationsInput | string | null
    GasCounter_Start?: NullableStringFieldUpdateOperationsInput | string | null
    GasCounter_End?: NullableStringFieldUpdateOperationsInput | string | null
    WaterCounter_Start?: NullableStringFieldUpdateOperationsInput | string | null
    WaterCounter_End?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    GasNumber?: NullableStringFieldUpdateOperationsInput | string | null
    WaterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    HouseField?: NullableStringFieldUpdateOperationsInput | string | null
    ArnonaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EvacuationDate?: NullableStringFieldUpdateOperationsInput | string | null
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    GasContainer?: NullableStringFieldUpdateOperationsInput | string | null
    GasCompanyID?: NullableStringFieldUpdateOperationsInput | string | null
    SleepingRooms?: NullableStringFieldUpdateOperationsInput | string | null
    Salon?: NullableStringFieldUpdateOperationsInput | string | null
    Toilet?: NullableStringFieldUpdateOperationsInput | string | null
    Baths?: NullableStringFieldUpdateOperationsInput | string | null
    HouseCommittee?: NullableStringFieldUpdateOperationsInput | string | null
    HouseCommitteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Street_?: NullableStringFieldUpdateOperationsInput | string | null
    CityName_?: NullableStringFieldUpdateOperationsInput | string | null
    ZipCode_?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    FaxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    StartDateContract?: NullableStringFieldUpdateOperationsInput | string | null
    EndDateContract?: NullableStringFieldUpdateOperationsInput | string | null
    Security?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityAmount?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    Rant?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    IsInsured?: NullableStringFieldUpdateOperationsInput | string | null
    InsureEndDate?: NullableStringFieldUpdateOperationsInput | string | null
    IsUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    LivingArea?: NullableStringFieldUpdateOperationsInput | string | null
    HouseRelation?: NullableStringFieldUpdateOperationsInput | string | null
    CableTypeID?: NullableStringFieldUpdateOperationsInput | string | null
    CableInstallationdate?: NullableStringFieldUpdateOperationsInput | string | null
    AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PathNumber?: NullableStringFieldUpdateOperationsInput | string | null
    AppartmentNum?: NullableStringFieldUpdateOperationsInput | string | null
    IsBroker?: NullableStringFieldUpdateOperationsInput | string | null
    BrokerName?: NullableStringFieldUpdateOperationsInput | string | null
    BrokerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityCode?: NullableStringFieldUpdateOperationsInput | string | null
    GasNumberCode?: NullableStringFieldUpdateOperationsInput | string | null
    WaterNumberCode?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityComment?: NullableStringFieldUpdateOperationsInput | string | null
    GasCounteComment?: NullableStringFieldUpdateOperationsInput | string | null
    WaterCounterComment?: NullableStringFieldUpdateOperationsInput | string | null
    AgencyFee?: NullableStringFieldUpdateOperationsInput | string | null
    IdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerBankAcount?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerID?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityName?: NullableStringFieldUpdateOperationsInput | string | null
    Contractor_billing?: NullableStringFieldUpdateOperationsInput | string | null
    Floor?: NullableStringFieldUpdateOperationsInput | string | null
    Entrance?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerBranchCode?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerBankID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessHouseTempUncheckedUpdateInput = {
    EmployeesAccessHouseTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HouseID?: NullableStringFieldUpdateOperationsInput | string | null
    HouseCode?: NullableStringFieldUpdateOperationsInput | string | null
    CityName?: NullableStringFieldUpdateOperationsInput | string | null
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    HouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeesQtyMax?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityCounter_Start?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityCounter_End?: NullableStringFieldUpdateOperationsInput | string | null
    GasCounter_Start?: NullableStringFieldUpdateOperationsInput | string | null
    GasCounter_End?: NullableStringFieldUpdateOperationsInput | string | null
    WaterCounter_Start?: NullableStringFieldUpdateOperationsInput | string | null
    WaterCounter_End?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    GasNumber?: NullableStringFieldUpdateOperationsInput | string | null
    WaterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    HouseField?: NullableStringFieldUpdateOperationsInput | string | null
    ArnonaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EvacuationDate?: NullableStringFieldUpdateOperationsInput | string | null
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    GasContainer?: NullableStringFieldUpdateOperationsInput | string | null
    GasCompanyID?: NullableStringFieldUpdateOperationsInput | string | null
    SleepingRooms?: NullableStringFieldUpdateOperationsInput | string | null
    Salon?: NullableStringFieldUpdateOperationsInput | string | null
    Toilet?: NullableStringFieldUpdateOperationsInput | string | null
    Baths?: NullableStringFieldUpdateOperationsInput | string | null
    HouseCommittee?: NullableStringFieldUpdateOperationsInput | string | null
    HouseCommitteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Street_?: NullableStringFieldUpdateOperationsInput | string | null
    CityName_?: NullableStringFieldUpdateOperationsInput | string | null
    ZipCode_?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    FaxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    StartDateContract?: NullableStringFieldUpdateOperationsInput | string | null
    EndDateContract?: NullableStringFieldUpdateOperationsInput | string | null
    Security?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityAmount?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    Rant?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    IsInsured?: NullableStringFieldUpdateOperationsInput | string | null
    InsureEndDate?: NullableStringFieldUpdateOperationsInput | string | null
    IsUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    LivingArea?: NullableStringFieldUpdateOperationsInput | string | null
    HouseRelation?: NullableStringFieldUpdateOperationsInput | string | null
    CableTypeID?: NullableStringFieldUpdateOperationsInput | string | null
    CableInstallationdate?: NullableStringFieldUpdateOperationsInput | string | null
    AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PathNumber?: NullableStringFieldUpdateOperationsInput | string | null
    AppartmentNum?: NullableStringFieldUpdateOperationsInput | string | null
    IsBroker?: NullableStringFieldUpdateOperationsInput | string | null
    BrokerName?: NullableStringFieldUpdateOperationsInput | string | null
    BrokerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityCode?: NullableStringFieldUpdateOperationsInput | string | null
    GasNumberCode?: NullableStringFieldUpdateOperationsInput | string | null
    WaterNumberCode?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityComment?: NullableStringFieldUpdateOperationsInput | string | null
    GasCounteComment?: NullableStringFieldUpdateOperationsInput | string | null
    WaterCounterComment?: NullableStringFieldUpdateOperationsInput | string | null
    AgencyFee?: NullableStringFieldUpdateOperationsInput | string | null
    IdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerBankAcount?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerID?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityName?: NullableStringFieldUpdateOperationsInput | string | null
    Contractor_billing?: NullableStringFieldUpdateOperationsInput | string | null
    Floor?: NullableStringFieldUpdateOperationsInput | string | null
    Entrance?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerBranchCode?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerBankID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessHouseTempCreateManyInput = {
    EmployeesAccessHouseTempId?: string
    CompanyGeneralCrmId: string
    CreatedAt?: Date | string
    HouseID?: string | null
    HouseCode?: string | null
    CityName?: string | null
    Street?: string | null
    HouseNumber?: string | null
    ZipCode?: string | null
    EmployeesQtyMax?: string | null
    ElectricityCounter_Start?: string | null
    ElectricityCounter_End?: string | null
    GasCounter_Start?: string | null
    GasCounter_End?: string | null
    WaterCounter_Start?: string | null
    WaterCounter_End?: string | null
    ElectricityNumber?: string | null
    GasNumber?: string | null
    WaterNumber?: string | null
    HouseField?: string | null
    ArnonaNumber?: string | null
    EvacuationDate?: string | null
    AreaMan?: string | null
    GasContainer?: string | null
    GasCompanyID?: string | null
    SleepingRooms?: string | null
    Salon?: string | null
    Toilet?: string | null
    Baths?: string | null
    HouseCommittee?: string | null
    HouseCommitteePhone?: string | null
    Status?: string | null
    Name?: string | null
    Street_?: string | null
    CityName_?: string | null
    ZipCode_?: string | null
    Phone_1?: string | null
    Phone_2?: string | null
    FaxNumber?: string | null
    StartDateContract?: string | null
    EndDateContract?: string | null
    Security?: string | null
    SecurityAmount?: string | null
    PaymentFrequency?: string | null
    Rant?: string | null
    Comment?: string | null
    IsInsured?: string | null
    InsureEndDate?: string | null
    IsUpdate?: string | null
    LivingArea?: string | null
    HouseRelation?: string | null
    CableTypeID?: string | null
    CableInstallationdate?: string | null
    AccountNumber?: string | null
    PathNumber?: string | null
    AppartmentNum?: string | null
    IsBroker?: string | null
    BrokerName?: string | null
    BrokerPhone?: string | null
    ElectricityCode?: string | null
    GasNumberCode?: string | null
    WaterNumberCode?: string | null
    ElectricityComment?: string | null
    GasCounteComment?: string | null
    WaterCounterComment?: string | null
    AgencyFee?: string | null
    IdNumber?: string | null
    ArrivalInstructions?: string | null
    OwnerEmail?: string | null
    OwnerBankAcount?: string | null
    CustomerID?: string | null
    LocalityName?: string | null
    Contractor_billing?: string | null
    Floor?: string | null
    Entrance?: string | null
    OwnerBranchCode?: string | null
    OwnerBankID?: string | null
  }

  export type EmployeesAccessHouseTempUpdateManyMutationInput = {
    EmployeesAccessHouseTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HouseID?: NullableStringFieldUpdateOperationsInput | string | null
    HouseCode?: NullableStringFieldUpdateOperationsInput | string | null
    CityName?: NullableStringFieldUpdateOperationsInput | string | null
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    HouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeesQtyMax?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityCounter_Start?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityCounter_End?: NullableStringFieldUpdateOperationsInput | string | null
    GasCounter_Start?: NullableStringFieldUpdateOperationsInput | string | null
    GasCounter_End?: NullableStringFieldUpdateOperationsInput | string | null
    WaterCounter_Start?: NullableStringFieldUpdateOperationsInput | string | null
    WaterCounter_End?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    GasNumber?: NullableStringFieldUpdateOperationsInput | string | null
    WaterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    HouseField?: NullableStringFieldUpdateOperationsInput | string | null
    ArnonaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EvacuationDate?: NullableStringFieldUpdateOperationsInput | string | null
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    GasContainer?: NullableStringFieldUpdateOperationsInput | string | null
    GasCompanyID?: NullableStringFieldUpdateOperationsInput | string | null
    SleepingRooms?: NullableStringFieldUpdateOperationsInput | string | null
    Salon?: NullableStringFieldUpdateOperationsInput | string | null
    Toilet?: NullableStringFieldUpdateOperationsInput | string | null
    Baths?: NullableStringFieldUpdateOperationsInput | string | null
    HouseCommittee?: NullableStringFieldUpdateOperationsInput | string | null
    HouseCommitteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Street_?: NullableStringFieldUpdateOperationsInput | string | null
    CityName_?: NullableStringFieldUpdateOperationsInput | string | null
    ZipCode_?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    FaxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    StartDateContract?: NullableStringFieldUpdateOperationsInput | string | null
    EndDateContract?: NullableStringFieldUpdateOperationsInput | string | null
    Security?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityAmount?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    Rant?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    IsInsured?: NullableStringFieldUpdateOperationsInput | string | null
    InsureEndDate?: NullableStringFieldUpdateOperationsInput | string | null
    IsUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    LivingArea?: NullableStringFieldUpdateOperationsInput | string | null
    HouseRelation?: NullableStringFieldUpdateOperationsInput | string | null
    CableTypeID?: NullableStringFieldUpdateOperationsInput | string | null
    CableInstallationdate?: NullableStringFieldUpdateOperationsInput | string | null
    AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PathNumber?: NullableStringFieldUpdateOperationsInput | string | null
    AppartmentNum?: NullableStringFieldUpdateOperationsInput | string | null
    IsBroker?: NullableStringFieldUpdateOperationsInput | string | null
    BrokerName?: NullableStringFieldUpdateOperationsInput | string | null
    BrokerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityCode?: NullableStringFieldUpdateOperationsInput | string | null
    GasNumberCode?: NullableStringFieldUpdateOperationsInput | string | null
    WaterNumberCode?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityComment?: NullableStringFieldUpdateOperationsInput | string | null
    GasCounteComment?: NullableStringFieldUpdateOperationsInput | string | null
    WaterCounterComment?: NullableStringFieldUpdateOperationsInput | string | null
    AgencyFee?: NullableStringFieldUpdateOperationsInput | string | null
    IdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerBankAcount?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerID?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityName?: NullableStringFieldUpdateOperationsInput | string | null
    Contractor_billing?: NullableStringFieldUpdateOperationsInput | string | null
    Floor?: NullableStringFieldUpdateOperationsInput | string | null
    Entrance?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerBranchCode?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerBankID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessHouseTempUncheckedUpdateManyInput = {
    EmployeesAccessHouseTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    HouseID?: NullableStringFieldUpdateOperationsInput | string | null
    HouseCode?: NullableStringFieldUpdateOperationsInput | string | null
    CityName?: NullableStringFieldUpdateOperationsInput | string | null
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    HouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeesQtyMax?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityCounter_Start?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityCounter_End?: NullableStringFieldUpdateOperationsInput | string | null
    GasCounter_Start?: NullableStringFieldUpdateOperationsInput | string | null
    GasCounter_End?: NullableStringFieldUpdateOperationsInput | string | null
    WaterCounter_Start?: NullableStringFieldUpdateOperationsInput | string | null
    WaterCounter_End?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    GasNumber?: NullableStringFieldUpdateOperationsInput | string | null
    WaterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    HouseField?: NullableStringFieldUpdateOperationsInput | string | null
    ArnonaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EvacuationDate?: NullableStringFieldUpdateOperationsInput | string | null
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    GasContainer?: NullableStringFieldUpdateOperationsInput | string | null
    GasCompanyID?: NullableStringFieldUpdateOperationsInput | string | null
    SleepingRooms?: NullableStringFieldUpdateOperationsInput | string | null
    Salon?: NullableStringFieldUpdateOperationsInput | string | null
    Toilet?: NullableStringFieldUpdateOperationsInput | string | null
    Baths?: NullableStringFieldUpdateOperationsInput | string | null
    HouseCommittee?: NullableStringFieldUpdateOperationsInput | string | null
    HouseCommitteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Street_?: NullableStringFieldUpdateOperationsInput | string | null
    CityName_?: NullableStringFieldUpdateOperationsInput | string | null
    ZipCode_?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_1?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_2?: NullableStringFieldUpdateOperationsInput | string | null
    FaxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    StartDateContract?: NullableStringFieldUpdateOperationsInput | string | null
    EndDateContract?: NullableStringFieldUpdateOperationsInput | string | null
    Security?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityAmount?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    Rant?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: NullableStringFieldUpdateOperationsInput | string | null
    IsInsured?: NullableStringFieldUpdateOperationsInput | string | null
    InsureEndDate?: NullableStringFieldUpdateOperationsInput | string | null
    IsUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    LivingArea?: NullableStringFieldUpdateOperationsInput | string | null
    HouseRelation?: NullableStringFieldUpdateOperationsInput | string | null
    CableTypeID?: NullableStringFieldUpdateOperationsInput | string | null
    CableInstallationdate?: NullableStringFieldUpdateOperationsInput | string | null
    AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PathNumber?: NullableStringFieldUpdateOperationsInput | string | null
    AppartmentNum?: NullableStringFieldUpdateOperationsInput | string | null
    IsBroker?: NullableStringFieldUpdateOperationsInput | string | null
    BrokerName?: NullableStringFieldUpdateOperationsInput | string | null
    BrokerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityCode?: NullableStringFieldUpdateOperationsInput | string | null
    GasNumberCode?: NullableStringFieldUpdateOperationsInput | string | null
    WaterNumberCode?: NullableStringFieldUpdateOperationsInput | string | null
    ElectricityComment?: NullableStringFieldUpdateOperationsInput | string | null
    GasCounteComment?: NullableStringFieldUpdateOperationsInput | string | null
    WaterCounterComment?: NullableStringFieldUpdateOperationsInput | string | null
    AgencyFee?: NullableStringFieldUpdateOperationsInput | string | null
    IdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ArrivalInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerBankAcount?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerID?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityName?: NullableStringFieldUpdateOperationsInput | string | null
    Contractor_billing?: NullableStringFieldUpdateOperationsInput | string | null
    Floor?: NullableStringFieldUpdateOperationsInput | string | null
    Entrance?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerBranchCode?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerBankID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessLkupDocumentTypeTempCreateInput = {
    EmployeesAccessLkupDocumentTypeTempId?: string
    CompanyGeneralCrmId: string
    CreatedAt?: Date | string
    DocumemtType?: string | null
  }

  export type EmployeesAccessLkupDocumentTypeTempUncheckedCreateInput = {
    EmployeesAccessLkupDocumentTypeTempId?: string
    CompanyGeneralCrmId: string
    CreatedAt?: Date | string
    DocumemtType?: string | null
  }

  export type EmployeesAccessLkupDocumentTypeTempUpdateInput = {
    EmployeesAccessLkupDocumentTypeTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DocumemtType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessLkupDocumentTypeTempUncheckedUpdateInput = {
    EmployeesAccessLkupDocumentTypeTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DocumemtType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessLkupDocumentTypeTempCreateManyInput = {
    EmployeesAccessLkupDocumentTypeTempId?: string
    CompanyGeneralCrmId: string
    CreatedAt?: Date | string
    DocumemtType?: string | null
  }

  export type EmployeesAccessLkupDocumentTypeTempUpdateManyMutationInput = {
    EmployeesAccessLkupDocumentTypeTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DocumemtType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessLkupDocumentTypeTempUncheckedUpdateManyInput = {
    EmployeesAccessLkupDocumentTypeTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DocumemtType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessTempCreateInput = {
    EmployeesAccessTempId?: string
    CompanyGeneralCrmId: string
    CreatedAt?: Date | string
    AgentID?: string | null
    AreaMan?: string | null
    AppartmentNum?: string | null
    BirthDate?: string | null
    CityName?: string | null
    CoatReceivingDate?: string | null
    CoatSize?: string | null
    CountryID?: string | null
    CountryName?: string | null
    CourseAtatDate?: string | null
    CourseAtatExpireDate?: string | null
    CustomerName?: string | null
    CustomerStatus?: string | null
    CustomerID?: string | null
    EmployeeFirstName?: string | null
    EmployeeID?: string | null
    EmployeeLastName?: string | null
    EmployeeNumber?: string | null
    EndInsuranceDate?: string | null
    EntranceDate?: string | null
    HealthFund?: string | null
    HouseID?: string | null
    HouseNumber?: string | null
    InsuranceCompany?: string | null
    InsuranceNumber?: string | null
    InsuredNumber?: string | null
    IsCourseAtat?: string | null
    Isbriefing?: string | null
    LocalityName?: string | null
    LocalityCode?: string | null
    LocalityID?: string | null
    LongshirtReceivingDate?: string | null
    LongshirtSize?: string | null
    MobilePhone?: string | null
    PantsReceivingDate?: string | null
    PassportNumber?: string | null
    ProfessionName?: string | null
    ProfessionSecondName?: string | null
    ProfessionThirdName?: string | null
    ShoesNumber?: string | null
    ShoesReceiveDate?: string | null
    SizeOfPantes?: string | null
    SizeOfshirt?: string | null
    StartDate?: string | null
    StatusName?: string | null
    Street?: string | null
    TshirReceivingDate?: string | null
    briefingDate?: string | null
    briefingExpireDate?: string | null
    startInsuranceDate?: string | null
  }

  export type EmployeesAccessTempUncheckedCreateInput = {
    EmployeesAccessTempId?: string
    CompanyGeneralCrmId: string
    CreatedAt?: Date | string
    AgentID?: string | null
    AreaMan?: string | null
    AppartmentNum?: string | null
    BirthDate?: string | null
    CityName?: string | null
    CoatReceivingDate?: string | null
    CoatSize?: string | null
    CountryID?: string | null
    CountryName?: string | null
    CourseAtatDate?: string | null
    CourseAtatExpireDate?: string | null
    CustomerName?: string | null
    CustomerStatus?: string | null
    CustomerID?: string | null
    EmployeeFirstName?: string | null
    EmployeeID?: string | null
    EmployeeLastName?: string | null
    EmployeeNumber?: string | null
    EndInsuranceDate?: string | null
    EntranceDate?: string | null
    HealthFund?: string | null
    HouseID?: string | null
    HouseNumber?: string | null
    InsuranceCompany?: string | null
    InsuranceNumber?: string | null
    InsuredNumber?: string | null
    IsCourseAtat?: string | null
    Isbriefing?: string | null
    LocalityName?: string | null
    LocalityCode?: string | null
    LocalityID?: string | null
    LongshirtReceivingDate?: string | null
    LongshirtSize?: string | null
    MobilePhone?: string | null
    PantsReceivingDate?: string | null
    PassportNumber?: string | null
    ProfessionName?: string | null
    ProfessionSecondName?: string | null
    ProfessionThirdName?: string | null
    ShoesNumber?: string | null
    ShoesReceiveDate?: string | null
    SizeOfPantes?: string | null
    SizeOfshirt?: string | null
    StartDate?: string | null
    StatusName?: string | null
    Street?: string | null
    TshirReceivingDate?: string | null
    briefingDate?: string | null
    briefingExpireDate?: string | null
    startInsuranceDate?: string | null
  }

  export type EmployeesAccessTempUpdateInput = {
    EmployeesAccessTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AgentID?: NullableStringFieldUpdateOperationsInput | string | null
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    AppartmentNum?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDate?: NullableStringFieldUpdateOperationsInput | string | null
    CityName?: NullableStringFieldUpdateOperationsInput | string | null
    CoatReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    CoatSize?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: NullableStringFieldUpdateOperationsInput | string | null
    CountryName?: NullableStringFieldUpdateOperationsInput | string | null
    CourseAtatDate?: NullableStringFieldUpdateOperationsInput | string | null
    CourseAtatExpireDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerStatus?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerID?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeID?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeLastName?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EndInsuranceDate?: NullableStringFieldUpdateOperationsInput | string | null
    EntranceDate?: NullableStringFieldUpdateOperationsInput | string | null
    HealthFund?: NullableStringFieldUpdateOperationsInput | string | null
    HouseID?: NullableStringFieldUpdateOperationsInput | string | null
    HouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    InsuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    InsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    InsuredNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsCourseAtat?: NullableStringFieldUpdateOperationsInput | string | null
    Isbriefing?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityName?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityCode?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityID?: NullableStringFieldUpdateOperationsInput | string | null
    LongshirtReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    LongshirtSize?: NullableStringFieldUpdateOperationsInput | string | null
    MobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    PantsReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    PassportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ProfessionName?: NullableStringFieldUpdateOperationsInput | string | null
    ProfessionSecondName?: NullableStringFieldUpdateOperationsInput | string | null
    ProfessionThirdName?: NullableStringFieldUpdateOperationsInput | string | null
    ShoesNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ShoesReceiveDate?: NullableStringFieldUpdateOperationsInput | string | null
    SizeOfPantes?: NullableStringFieldUpdateOperationsInput | string | null
    SizeOfshirt?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusName?: NullableStringFieldUpdateOperationsInput | string | null
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    TshirReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    briefingDate?: NullableStringFieldUpdateOperationsInput | string | null
    briefingExpireDate?: NullableStringFieldUpdateOperationsInput | string | null
    startInsuranceDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessTempUncheckedUpdateInput = {
    EmployeesAccessTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AgentID?: NullableStringFieldUpdateOperationsInput | string | null
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    AppartmentNum?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDate?: NullableStringFieldUpdateOperationsInput | string | null
    CityName?: NullableStringFieldUpdateOperationsInput | string | null
    CoatReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    CoatSize?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: NullableStringFieldUpdateOperationsInput | string | null
    CountryName?: NullableStringFieldUpdateOperationsInput | string | null
    CourseAtatDate?: NullableStringFieldUpdateOperationsInput | string | null
    CourseAtatExpireDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerStatus?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerID?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeID?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeLastName?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EndInsuranceDate?: NullableStringFieldUpdateOperationsInput | string | null
    EntranceDate?: NullableStringFieldUpdateOperationsInput | string | null
    HealthFund?: NullableStringFieldUpdateOperationsInput | string | null
    HouseID?: NullableStringFieldUpdateOperationsInput | string | null
    HouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    InsuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    InsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    InsuredNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsCourseAtat?: NullableStringFieldUpdateOperationsInput | string | null
    Isbriefing?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityName?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityCode?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityID?: NullableStringFieldUpdateOperationsInput | string | null
    LongshirtReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    LongshirtSize?: NullableStringFieldUpdateOperationsInput | string | null
    MobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    PantsReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    PassportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ProfessionName?: NullableStringFieldUpdateOperationsInput | string | null
    ProfessionSecondName?: NullableStringFieldUpdateOperationsInput | string | null
    ProfessionThirdName?: NullableStringFieldUpdateOperationsInput | string | null
    ShoesNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ShoesReceiveDate?: NullableStringFieldUpdateOperationsInput | string | null
    SizeOfPantes?: NullableStringFieldUpdateOperationsInput | string | null
    SizeOfshirt?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusName?: NullableStringFieldUpdateOperationsInput | string | null
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    TshirReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    briefingDate?: NullableStringFieldUpdateOperationsInput | string | null
    briefingExpireDate?: NullableStringFieldUpdateOperationsInput | string | null
    startInsuranceDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessTempCreateManyInput = {
    EmployeesAccessTempId?: string
    CompanyGeneralCrmId: string
    CreatedAt?: Date | string
    AgentID?: string | null
    AreaMan?: string | null
    AppartmentNum?: string | null
    BirthDate?: string | null
    CityName?: string | null
    CoatReceivingDate?: string | null
    CoatSize?: string | null
    CountryID?: string | null
    CountryName?: string | null
    CourseAtatDate?: string | null
    CourseAtatExpireDate?: string | null
    CustomerName?: string | null
    CustomerStatus?: string | null
    CustomerID?: string | null
    EmployeeFirstName?: string | null
    EmployeeID?: string | null
    EmployeeLastName?: string | null
    EmployeeNumber?: string | null
    EndInsuranceDate?: string | null
    EntranceDate?: string | null
    HealthFund?: string | null
    HouseID?: string | null
    HouseNumber?: string | null
    InsuranceCompany?: string | null
    InsuranceNumber?: string | null
    InsuredNumber?: string | null
    IsCourseAtat?: string | null
    Isbriefing?: string | null
    LocalityName?: string | null
    LocalityCode?: string | null
    LocalityID?: string | null
    LongshirtReceivingDate?: string | null
    LongshirtSize?: string | null
    MobilePhone?: string | null
    PantsReceivingDate?: string | null
    PassportNumber?: string | null
    ProfessionName?: string | null
    ProfessionSecondName?: string | null
    ProfessionThirdName?: string | null
    ShoesNumber?: string | null
    ShoesReceiveDate?: string | null
    SizeOfPantes?: string | null
    SizeOfshirt?: string | null
    StartDate?: string | null
    StatusName?: string | null
    Street?: string | null
    TshirReceivingDate?: string | null
    briefingDate?: string | null
    briefingExpireDate?: string | null
    startInsuranceDate?: string | null
  }

  export type EmployeesAccessTempUpdateManyMutationInput = {
    EmployeesAccessTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AgentID?: NullableStringFieldUpdateOperationsInput | string | null
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    AppartmentNum?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDate?: NullableStringFieldUpdateOperationsInput | string | null
    CityName?: NullableStringFieldUpdateOperationsInput | string | null
    CoatReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    CoatSize?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: NullableStringFieldUpdateOperationsInput | string | null
    CountryName?: NullableStringFieldUpdateOperationsInput | string | null
    CourseAtatDate?: NullableStringFieldUpdateOperationsInput | string | null
    CourseAtatExpireDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerStatus?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerID?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeID?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeLastName?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EndInsuranceDate?: NullableStringFieldUpdateOperationsInput | string | null
    EntranceDate?: NullableStringFieldUpdateOperationsInput | string | null
    HealthFund?: NullableStringFieldUpdateOperationsInput | string | null
    HouseID?: NullableStringFieldUpdateOperationsInput | string | null
    HouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    InsuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    InsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    InsuredNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsCourseAtat?: NullableStringFieldUpdateOperationsInput | string | null
    Isbriefing?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityName?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityCode?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityID?: NullableStringFieldUpdateOperationsInput | string | null
    LongshirtReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    LongshirtSize?: NullableStringFieldUpdateOperationsInput | string | null
    MobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    PantsReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    PassportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ProfessionName?: NullableStringFieldUpdateOperationsInput | string | null
    ProfessionSecondName?: NullableStringFieldUpdateOperationsInput | string | null
    ProfessionThirdName?: NullableStringFieldUpdateOperationsInput | string | null
    ShoesNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ShoesReceiveDate?: NullableStringFieldUpdateOperationsInput | string | null
    SizeOfPantes?: NullableStringFieldUpdateOperationsInput | string | null
    SizeOfshirt?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusName?: NullableStringFieldUpdateOperationsInput | string | null
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    TshirReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    briefingDate?: NullableStringFieldUpdateOperationsInput | string | null
    briefingExpireDate?: NullableStringFieldUpdateOperationsInput | string | null
    startInsuranceDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeesAccessTempUncheckedUpdateManyInput = {
    EmployeesAccessTempId?: StringFieldUpdateOperationsInput | string
    CompanyGeneralCrmId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AgentID?: NullableStringFieldUpdateOperationsInput | string | null
    AreaMan?: NullableStringFieldUpdateOperationsInput | string | null
    AppartmentNum?: NullableStringFieldUpdateOperationsInput | string | null
    BirthDate?: NullableStringFieldUpdateOperationsInput | string | null
    CityName?: NullableStringFieldUpdateOperationsInput | string | null
    CoatReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    CoatSize?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: NullableStringFieldUpdateOperationsInput | string | null
    CountryName?: NullableStringFieldUpdateOperationsInput | string | null
    CourseAtatDate?: NullableStringFieldUpdateOperationsInput | string | null
    CourseAtatExpireDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerStatus?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerID?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeID?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeLastName?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EndInsuranceDate?: NullableStringFieldUpdateOperationsInput | string | null
    EntranceDate?: NullableStringFieldUpdateOperationsInput | string | null
    HealthFund?: NullableStringFieldUpdateOperationsInput | string | null
    HouseID?: NullableStringFieldUpdateOperationsInput | string | null
    HouseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    InsuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    InsuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    InsuredNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsCourseAtat?: NullableStringFieldUpdateOperationsInput | string | null
    Isbriefing?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityName?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityCode?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityID?: NullableStringFieldUpdateOperationsInput | string | null
    LongshirtReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    LongshirtSize?: NullableStringFieldUpdateOperationsInput | string | null
    MobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    PantsReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    PassportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ProfessionName?: NullableStringFieldUpdateOperationsInput | string | null
    ProfessionSecondName?: NullableStringFieldUpdateOperationsInput | string | null
    ProfessionThirdName?: NullableStringFieldUpdateOperationsInput | string | null
    ShoesNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ShoesReceiveDate?: NullableStringFieldUpdateOperationsInput | string | null
    SizeOfPantes?: NullableStringFieldUpdateOperationsInput | string | null
    SizeOfshirt?: NullableStringFieldUpdateOperationsInput | string | null
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusName?: NullableStringFieldUpdateOperationsInput | string | null
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    TshirReceivingDate?: NullableStringFieldUpdateOperationsInput | string | null
    briefingDate?: NullableStringFieldUpdateOperationsInput | string | null
    briefingExpireDate?: NullableStringFieldUpdateOperationsInput | string | null
    startInsuranceDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ErrorsPhpLogsCreateInput = {
    CreatedAt?: Date | string | null
    tokenData?: string | null
    urlController?: string | null
    sendData?: string | null
    errorMessg?: string | null
  }

  export type ErrorsPhpLogsUncheckedCreateInput = {
    ErrorsPhpLogsId?: number
    CreatedAt?: Date | string | null
    tokenData?: string | null
    urlController?: string | null
    sendData?: string | null
    errorMessg?: string | null
  }

  export type ErrorsPhpLogsUpdateInput = {
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenData?: NullableStringFieldUpdateOperationsInput | string | null
    urlController?: NullableStringFieldUpdateOperationsInput | string | null
    sendData?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ErrorsPhpLogsUncheckedUpdateInput = {
    ErrorsPhpLogsId?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenData?: NullableStringFieldUpdateOperationsInput | string | null
    urlController?: NullableStringFieldUpdateOperationsInput | string | null
    sendData?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ErrorsPhpLogsCreateManyInput = {
    CreatedAt?: Date | string | null
    tokenData?: string | null
    urlController?: string | null
    sendData?: string | null
    errorMessg?: string | null
  }

  export type ErrorsPhpLogsUpdateManyMutationInput = {
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenData?: NullableStringFieldUpdateOperationsInput | string | null
    urlController?: NullableStringFieldUpdateOperationsInput | string | null
    sendData?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ErrorsPhpLogsUncheckedUpdateManyInput = {
    ErrorsPhpLogsId?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenData?: NullableStringFieldUpdateOperationsInput | string | null
    urlController?: NullableStringFieldUpdateOperationsInput | string | null
    sendData?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Lkup_ActionTypeCreateInput = {
    ActionType?: string | null
    IsIgnoreHours?: number | null
    EmployeeHours?: EmployeeHoursCreateNestedManyWithoutLkup_ActionTypeInput
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeCreateNestedManyWithoutLkup_ActionTypeInput
  }

  export type Lkup_ActionTypeUncheckedCreateInput = {
    ActionTypeID?: number
    ActionType?: string | null
    IsIgnoreHours?: number | null
    EmployeeHours?: EmployeeHoursUncheckedCreateNestedManyWithoutLkup_ActionTypeInput
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateNestedManyWithoutLkup_ActionTypeInput
  }

  export type Lkup_ActionTypeUpdateInput = {
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    IsIgnoreHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHours?: EmployeeHoursUpdateManyWithoutLkup_ActionTypeNestedInput
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithoutLkup_ActionTypeNestedInput
  }

  export type Lkup_ActionTypeUncheckedUpdateInput = {
    ActionTypeID?: IntFieldUpdateOperationsInput | number
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    IsIgnoreHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHours?: EmployeeHoursUncheckedUpdateManyWithoutLkup_ActionTypeNestedInput
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateManyWithoutLkup_ActionTypeNestedInput
  }

  export type Lkup_ActionTypeCreateManyInput = {
    ActionType?: string | null
    IsIgnoreHours?: number | null
  }

  export type Lkup_ActionTypeUpdateManyMutationInput = {
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    IsIgnoreHours?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Lkup_ActionTypeUncheckedUpdateManyInput = {
    ActionTypeID?: IntFieldUpdateOperationsInput | number
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    IsIgnoreHours?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LogEnterEmployeeCreateInput = {
    UserID: string
    CompanyID: string
    EmployeeID: number
    CreatedAt?: Date | string | null
    ResultsData?: string | null
  }

  export type LogEnterEmployeeUncheckedCreateInput = {
    LogEnterEmployee?: number
    UserID: string
    CompanyID: string
    EmployeeID: number
    CreatedAt?: Date | string | null
    ResultsData?: string | null
  }

  export type LogEnterEmployeeUpdateInput = {
    UserID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    EmployeeID?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ResultsData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogEnterEmployeeUncheckedUpdateInput = {
    LogEnterEmployee?: IntFieldUpdateOperationsInput | number
    UserID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    EmployeeID?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ResultsData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogEnterEmployeeCreateManyInput = {
    UserID: string
    CompanyID: string
    EmployeeID: number
    CreatedAt?: Date | string | null
    ResultsData?: string | null
  }

  export type LogEnterEmployeeUpdateManyMutationInput = {
    UserID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    EmployeeID?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ResultsData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogEnterEmployeeUncheckedUpdateManyInput = {
    LogEnterEmployee?: IntFieldUpdateOperationsInput | number
    UserID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    EmployeeID?: IntFieldUpdateOperationsInput | number
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ResultsData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogSearchsCreateInput = {
    UserID: string
    CompanyID: string
    CreatedAt?: Date | string | null
    searchData?: string | null
    resultsCount?: number | null
  }

  export type LogSearchsUncheckedCreateInput = {
    LogSearchsId?: number
    UserID: string
    CompanyID: string
    CreatedAt?: Date | string | null
    searchData?: string | null
    resultsCount?: number | null
  }

  export type LogSearchsUpdateInput = {
    UserID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    searchData?: NullableStringFieldUpdateOperationsInput | string | null
    resultsCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LogSearchsUncheckedUpdateInput = {
    LogSearchsId?: IntFieldUpdateOperationsInput | number
    UserID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    searchData?: NullableStringFieldUpdateOperationsInput | string | null
    resultsCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LogSearchsCreateManyInput = {
    UserID: string
    CompanyID: string
    CreatedAt?: Date | string | null
    searchData?: string | null
    resultsCount?: number | null
  }

  export type LogSearchsUpdateManyMutationInput = {
    UserID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    searchData?: NullableStringFieldUpdateOperationsInput | string | null
    resultsCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LogSearchsUncheckedUpdateManyInput = {
    LogSearchsId?: IntFieldUpdateOperationsInput | number
    UserID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    searchData?: NullableStringFieldUpdateOperationsInput | string | null
    resultsCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LogSignUpCreateInput = {
    UserID: string
    CompanyID: string
    CreatedAt?: Date | string | null
  }

  export type LogSignUpUncheckedCreateInput = {
    LogSignUpId?: number
    UserID: string
    CompanyID: string
    CreatedAt?: Date | string | null
  }

  export type LogSignUpUpdateInput = {
    UserID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogSignUpUncheckedUpdateInput = {
    LogSignUpId?: IntFieldUpdateOperationsInput | number
    UserID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogSignUpCreateManyInput = {
    UserID: string
    CompanyID: string
    CreatedAt?: Date | string | null
  }

  export type LogSignUpUpdateManyMutationInput = {
    UserID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogSignUpUncheckedUpdateManyInput = {
    LogSignUpId?: IntFieldUpdateOperationsInput | number
    UserID?: StringFieldUpdateOperationsInput | string
    CompanyID?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessagesEmployeesCreateInput = {
    MessageEmployeeId?: string
    CreatedAt?: Date | string
    FinalDateForTask?: Date | string | null
    ReadedAt?: Date | string | null
    DoneAt?: Date | string | null
    SendResponseAtStatusDone?: number | null
    CompanyIdGeneralCRM: string
    UserFromIdGeneralCRM: string
    UserToIdGeneralCRM: string
    MessageSubject?: string | null
    MessageText?: string | null
    LinkEmployees?: string | null
    LinkHouses?: string | null
    MessagesEmployees?: MessagesEmployeesCreateNestedOneWithoutOther_MessagesEmployeesInput
    other_MessagesEmployees?: MessagesEmployeesCreateNestedManyWithoutMessagesEmployeesInput
    MessagesStatus?: MessagesStatusCreateNestedOneWithoutMessagesEmployeesInput
  }

  export type MessagesEmployeesUncheckedCreateInput = {
    MessageEmployeeId?: string
    CreatedAt?: Date | string
    FinalDateForTask?: Date | string | null
    ReadedAt?: Date | string | null
    DoneAt?: Date | string | null
    SendResponseAtStatusDone?: number | null
    CompanyIdGeneralCRM: string
    UserFromIdGeneralCRM: string
    UserToIdGeneralCRM: string
    IsReplyToMessageId?: string | null
    MessageStatusId?: string
    MessageSubject?: string | null
    MessageText?: string | null
    LinkEmployees?: string | null
    LinkHouses?: string | null
    other_MessagesEmployees?: MessagesEmployeesUncheckedCreateNestedManyWithoutMessagesEmployeesInput
  }

  export type MessagesEmployeesUpdateInput = {
    MessageEmployeeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FinalDateForTask?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DoneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SendResponseAtStatusDone?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserFromIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserToIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MessageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    MessageText?: NullableStringFieldUpdateOperationsInput | string | null
    LinkEmployees?: NullableStringFieldUpdateOperationsInput | string | null
    LinkHouses?: NullableStringFieldUpdateOperationsInput | string | null
    MessagesEmployees?: MessagesEmployeesUpdateOneWithoutOther_MessagesEmployeesNestedInput
    other_MessagesEmployees?: MessagesEmployeesUpdateManyWithoutMessagesEmployeesNestedInput
    MessagesStatus?: MessagesStatusUpdateOneRequiredWithoutMessagesEmployeesNestedInput
  }

  export type MessagesEmployeesUncheckedUpdateInput = {
    MessageEmployeeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FinalDateForTask?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DoneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SendResponseAtStatusDone?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserFromIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserToIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    IsReplyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    MessageStatusId?: StringFieldUpdateOperationsInput | string
    MessageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    MessageText?: NullableStringFieldUpdateOperationsInput | string | null
    LinkEmployees?: NullableStringFieldUpdateOperationsInput | string | null
    LinkHouses?: NullableStringFieldUpdateOperationsInput | string | null
    other_MessagesEmployees?: MessagesEmployeesUncheckedUpdateManyWithoutMessagesEmployeesNestedInput
  }

  export type MessagesEmployeesCreateManyInput = {
    MessageEmployeeId?: string
    CreatedAt?: Date | string
    FinalDateForTask?: Date | string | null
    ReadedAt?: Date | string | null
    DoneAt?: Date | string | null
    SendResponseAtStatusDone?: number | null
    CompanyIdGeneralCRM: string
    UserFromIdGeneralCRM: string
    UserToIdGeneralCRM: string
    IsReplyToMessageId?: string | null
    MessageStatusId?: string
    MessageSubject?: string | null
    MessageText?: string | null
    LinkEmployees?: string | null
    LinkHouses?: string | null
  }

  export type MessagesEmployeesUpdateManyMutationInput = {
    MessageEmployeeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FinalDateForTask?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DoneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SendResponseAtStatusDone?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserFromIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserToIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MessageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    MessageText?: NullableStringFieldUpdateOperationsInput | string | null
    LinkEmployees?: NullableStringFieldUpdateOperationsInput | string | null
    LinkHouses?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessagesEmployeesUncheckedUpdateManyInput = {
    MessageEmployeeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FinalDateForTask?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DoneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SendResponseAtStatusDone?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserFromIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserToIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    IsReplyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    MessageStatusId?: StringFieldUpdateOperationsInput | string
    MessageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    MessageText?: NullableStringFieldUpdateOperationsInput | string | null
    LinkEmployees?: NullableStringFieldUpdateOperationsInput | string | null
    LinkHouses?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessagesStatusCreateInput = {
    MessagesStatusId?: string
    MessagesStatusName: string
    CreatedAt?: Date | string | null
    Sort?: number
    Comments?: string | null
    MessagesEmployees?: MessagesEmployeesCreateNestedManyWithoutMessagesStatusInput
  }

  export type MessagesStatusUncheckedCreateInput = {
    MessagesStatusId?: string
    MessagesStatusName: string
    CreatedAt?: Date | string | null
    Sort?: number
    Comments?: string | null
    MessagesEmployees?: MessagesEmployeesUncheckedCreateNestedManyWithoutMessagesStatusInput
  }

  export type MessagesStatusUpdateInput = {
    MessagesStatusId?: StringFieldUpdateOperationsInput | string
    MessagesStatusName?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Sort?: IntFieldUpdateOperationsInput | number
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    MessagesEmployees?: MessagesEmployeesUpdateManyWithoutMessagesStatusNestedInput
  }

  export type MessagesStatusUncheckedUpdateInput = {
    MessagesStatusId?: StringFieldUpdateOperationsInput | string
    MessagesStatusName?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Sort?: IntFieldUpdateOperationsInput | number
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    MessagesEmployees?: MessagesEmployeesUncheckedUpdateManyWithoutMessagesStatusNestedInput
  }

  export type MessagesStatusCreateManyInput = {
    MessagesStatusId?: string
    MessagesStatusName: string
    CreatedAt?: Date | string | null
    Sort?: number
    Comments?: string | null
  }

  export type MessagesStatusUpdateManyMutationInput = {
    MessagesStatusId?: StringFieldUpdateOperationsInput | string
    MessagesStatusName?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Sort?: IntFieldUpdateOperationsInput | number
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessagesStatusUncheckedUpdateManyInput = {
    MessagesStatusId?: StringFieldUpdateOperationsInput | string
    MessagesStatusName?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Sort?: IntFieldUpdateOperationsInput | number
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SiteConfigCreateInput = {
    PropertyEngName: string
    PropertyIntValue?: number | null
    PropertyTextValue?: string | null
    PropertyHebDescription: string
    CreatedAt?: Date | string | null
  }

  export type SiteConfigUncheckedCreateInput = {
    SiteConfigId?: number
    PropertyEngName: string
    PropertyIntValue?: number | null
    PropertyTextValue?: string | null
    PropertyHebDescription: string
    CreatedAt?: Date | string | null
  }

  export type SiteConfigUpdateInput = {
    PropertyEngName?: StringFieldUpdateOperationsInput | string
    PropertyIntValue?: NullableFloatFieldUpdateOperationsInput | number | null
    PropertyTextValue?: NullableStringFieldUpdateOperationsInput | string | null
    PropertyHebDescription?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteConfigUncheckedUpdateInput = {
    SiteConfigId?: IntFieldUpdateOperationsInput | number
    PropertyEngName?: StringFieldUpdateOperationsInput | string
    PropertyIntValue?: NullableFloatFieldUpdateOperationsInput | number | null
    PropertyTextValue?: NullableStringFieldUpdateOperationsInput | string | null
    PropertyHebDescription?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteConfigCreateManyInput = {
    PropertyEngName: string
    PropertyIntValue?: number | null
    PropertyTextValue?: string | null
    PropertyHebDescription: string
    CreatedAt?: Date | string | null
  }

  export type SiteConfigUpdateManyMutationInput = {
    PropertyEngName?: StringFieldUpdateOperationsInput | string
    PropertyIntValue?: NullableFloatFieldUpdateOperationsInput | number | null
    PropertyTextValue?: NullableStringFieldUpdateOperationsInput | string | null
    PropertyHebDescription?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SiteConfigUncheckedUpdateManyInput = {
    SiteConfigId?: IntFieldUpdateOperationsInput | number
    PropertyEngName?: StringFieldUpdateOperationsInput | string
    PropertyIntValue?: NullableFloatFieldUpdateOperationsInput | number | null
    PropertyTextValue?: NullableStringFieldUpdateOperationsInput | string | null
    PropertyHebDescription?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sysdiagramsCreateInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUncheckedCreateInput = {
    name: string
    principal_id: number
    diagram_id?: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsCreateManyInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type UsersLinkedViewRoleCreateInput = {
    UsersLinkedViewRoleId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserID: string
    UserViewRoles: UserViewRolesCreateNestedOneWithoutUsersLinkedViewRoleInput
  }

  export type UsersLinkedViewRoleUncheckedCreateInput = {
    UsersLinkedViewRoleId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserID: string
    UserViewRolesId: string
  }

  export type UsersLinkedViewRoleUpdateInput = {
    UsersLinkedViewRoleId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserID?: StringFieldUpdateOperationsInput | string
    UserViewRoles?: UserViewRolesUpdateOneRequiredWithoutUsersLinkedViewRoleNestedInput
  }

  export type UsersLinkedViewRoleUncheckedUpdateInput = {
    UsersLinkedViewRoleId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserID?: StringFieldUpdateOperationsInput | string
    UserViewRolesId?: StringFieldUpdateOperationsInput | string
  }

  export type UsersLinkedViewRoleCreateManyInput = {
    UsersLinkedViewRoleId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserID: string
    UserViewRolesId: string
  }

  export type UsersLinkedViewRoleUpdateManyMutationInput = {
    UsersLinkedViewRoleId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserID?: StringFieldUpdateOperationsInput | string
  }

  export type UsersLinkedViewRoleUncheckedUpdateManyInput = {
    UsersLinkedViewRoleId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserID?: StringFieldUpdateOperationsInput | string
    UserViewRolesId?: StringFieldUpdateOperationsInput | string
  }

  export type UserViewRolesCreateInput = {
    UserViewRolesId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserViewRoleName: string
    NotShowFields?: string | null
    MaxSearchResults?: number | null
    EditFields?: string | null
    UsersLinkedViewRole?: UsersLinkedViewRoleCreateNestedManyWithoutUserViewRolesInput
  }

  export type UserViewRolesUncheckedCreateInput = {
    UserViewRolesId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserViewRoleName: string
    NotShowFields?: string | null
    MaxSearchResults?: number | null
    EditFields?: string | null
    UsersLinkedViewRole?: UsersLinkedViewRoleUncheckedCreateNestedManyWithoutUserViewRolesInput
  }

  export type UserViewRolesUpdateInput = {
    UserViewRolesId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserViewRoleName?: StringFieldUpdateOperationsInput | string
    NotShowFields?: NullableStringFieldUpdateOperationsInput | string | null
    MaxSearchResults?: NullableIntFieldUpdateOperationsInput | number | null
    EditFields?: NullableStringFieldUpdateOperationsInput | string | null
    UsersLinkedViewRole?: UsersLinkedViewRoleUpdateManyWithoutUserViewRolesNestedInput
  }

  export type UserViewRolesUncheckedUpdateInput = {
    UserViewRolesId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserViewRoleName?: StringFieldUpdateOperationsInput | string
    NotShowFields?: NullableStringFieldUpdateOperationsInput | string | null
    MaxSearchResults?: NullableIntFieldUpdateOperationsInput | number | null
    EditFields?: NullableStringFieldUpdateOperationsInput | string | null
    UsersLinkedViewRole?: UsersLinkedViewRoleUncheckedUpdateManyWithoutUserViewRolesNestedInput
  }

  export type UserViewRolesCreateManyInput = {
    UserViewRolesId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserViewRoleName: string
    NotShowFields?: string | null
    MaxSearchResults?: number | null
    EditFields?: string | null
  }

  export type UserViewRolesUpdateManyMutationInput = {
    UserViewRolesId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserViewRoleName?: StringFieldUpdateOperationsInput | string
    NotShowFields?: NullableStringFieldUpdateOperationsInput | string | null
    MaxSearchResults?: NullableIntFieldUpdateOperationsInput | number | null
    EditFields?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserViewRolesUncheckedUpdateManyInput = {
    UserViewRolesId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserViewRoleName?: StringFieldUpdateOperationsInput | string
    NotShowFields?: NullableStringFieldUpdateOperationsInput | string | null
    MaxSearchResults?: NullableIntFieldUpdateOperationsInput | number | null
    EditFields?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CompaniesConfigCountOrderByAggregateInput = {
    CompanyConfigId?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    CreatedAt?: SortOrder
    PropertyEngName?: SortOrder
    PropertyValue?: SortOrder
    PropertyTextJsonValue?: SortOrder
    PropertyHebDescription?: SortOrder
  }

  export type CompaniesConfigAvgOrderByAggregateInput = {
    CompanyConfigId?: SortOrder
    PropertyValue?: SortOrder
  }

  export type CompaniesConfigMaxOrderByAggregateInput = {
    CompanyConfigId?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    CreatedAt?: SortOrder
    PropertyEngName?: SortOrder
    PropertyValue?: SortOrder
    PropertyTextJsonValue?: SortOrder
    PropertyHebDescription?: SortOrder
  }

  export type CompaniesConfigMinOrderByAggregateInput = {
    CompanyConfigId?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    CreatedAt?: SortOrder
    PropertyEngName?: SortOrder
    PropertyValue?: SortOrder
    PropertyTextJsonValue?: SortOrder
    PropertyHebDescription?: SortOrder
  }

  export type CompaniesConfigSumOrderByAggregateInput = {
    CompanyConfigId?: SortOrder
    PropertyValue?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CompanyAdminCountOrderByAggregateInput = {
    CompanyAdminId?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrder
    NotShowFields?: SortOrder
    MaxSearchResults?: SortOrder
    EditFields?: SortOrder
  }

  export type CompanyAdminAvgOrderByAggregateInput = {
    MaxSearchResults?: SortOrder
  }

  export type CompanyAdminMaxOrderByAggregateInput = {
    CompanyAdminId?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrder
    NotShowFields?: SortOrder
    MaxSearchResults?: SortOrder
    EditFields?: SortOrder
  }

  export type CompanyAdminMinOrderByAggregateInput = {
    CompanyAdminId?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrder
    NotShowFields?: SortOrder
    MaxSearchResults?: SortOrder
    EditFields?: SortOrder
  }

  export type CompanyAdminSumOrderByAggregateInput = {
    MaxSearchResults?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Lkup_ActionTypeNullableScalarRelationFilter = {
    is?: Lkup_ActionTypeWhereInput | null
    isNot?: Lkup_ActionTypeWhereInput | null
  }

  export type EmployeeHoursByLocalityScalarRelationFilter = {
    is?: EmployeeHoursByLocalityWhereInput
    isNot?: EmployeeHoursByLocalityWhereInput
  }

  export type EmployeeHoursCountOrderByAggregateInput = {
    EmployeeHoursId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    EmployeeNumber?: SortOrder
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    LeadingDate?: SortOrder
    HourStart?: SortOrder
    HourEnd?: SortOrder
    HourStartSource?: SortOrder
    HourEndSource?: SortOrder
    RealHours?: SortOrder
    QtyHour?: SortOrder
    QtyHour125?: SortOrder
    QtyHour150?: SortOrder
    QtyHour175?: SortOrder
    QtyHour200?: SortOrder
    BreakMinutes?: SortOrder
    GpsStart?: SortOrder
    GpsEnd?: SortOrder
    EmployeeHoursByLocalityId?: SortOrder
    IsManualInsert?: SortOrder
    ManualInsertUserId?: SortOrder
    IsRowDeleted?: SortOrder
    ActionTypeID?: SortOrder
    DayTypeID?: SortOrder
    HolidayName?: SortOrder
    StartEndTimeSabat?: SortOrder
    IsForemanHourApproved?: SortOrder
    IsForemanApproval?: SortOrder
    ForemanApprovalGeneralCRMUserId?: SortOrder
    IsComplementRow?: SortOrder
  }

  export type EmployeeHoursAvgOrderByAggregateInput = {
    EmployeeId?: SortOrder
    EmployeeNumber?: SortOrder
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    RealHours?: SortOrder
    QtyHour?: SortOrder
    QtyHour125?: SortOrder
    QtyHour150?: SortOrder
    QtyHour175?: SortOrder
    QtyHour200?: SortOrder
    BreakMinutes?: SortOrder
    IsManualInsert?: SortOrder
    IsRowDeleted?: SortOrder
    ActionTypeID?: SortOrder
    DayTypeID?: SortOrder
    IsComplementRow?: SortOrder
  }

  export type EmployeeHoursMaxOrderByAggregateInput = {
    EmployeeHoursId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    EmployeeNumber?: SortOrder
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    LeadingDate?: SortOrder
    HourStart?: SortOrder
    HourEnd?: SortOrder
    HourStartSource?: SortOrder
    HourEndSource?: SortOrder
    RealHours?: SortOrder
    QtyHour?: SortOrder
    QtyHour125?: SortOrder
    QtyHour150?: SortOrder
    QtyHour175?: SortOrder
    QtyHour200?: SortOrder
    BreakMinutes?: SortOrder
    GpsStart?: SortOrder
    GpsEnd?: SortOrder
    EmployeeHoursByLocalityId?: SortOrder
    IsManualInsert?: SortOrder
    ManualInsertUserId?: SortOrder
    IsRowDeleted?: SortOrder
    ActionTypeID?: SortOrder
    DayTypeID?: SortOrder
    HolidayName?: SortOrder
    StartEndTimeSabat?: SortOrder
    IsForemanHourApproved?: SortOrder
    IsForemanApproval?: SortOrder
    ForemanApprovalGeneralCRMUserId?: SortOrder
    IsComplementRow?: SortOrder
  }

  export type EmployeeHoursMinOrderByAggregateInput = {
    EmployeeHoursId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    EmployeeNumber?: SortOrder
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    LeadingDate?: SortOrder
    HourStart?: SortOrder
    HourEnd?: SortOrder
    HourStartSource?: SortOrder
    HourEndSource?: SortOrder
    RealHours?: SortOrder
    QtyHour?: SortOrder
    QtyHour125?: SortOrder
    QtyHour150?: SortOrder
    QtyHour175?: SortOrder
    QtyHour200?: SortOrder
    BreakMinutes?: SortOrder
    GpsStart?: SortOrder
    GpsEnd?: SortOrder
    EmployeeHoursByLocalityId?: SortOrder
    IsManualInsert?: SortOrder
    ManualInsertUserId?: SortOrder
    IsRowDeleted?: SortOrder
    ActionTypeID?: SortOrder
    DayTypeID?: SortOrder
    HolidayName?: SortOrder
    StartEndTimeSabat?: SortOrder
    IsForemanHourApproved?: SortOrder
    IsForemanApproval?: SortOrder
    ForemanApprovalGeneralCRMUserId?: SortOrder
    IsComplementRow?: SortOrder
  }

  export type EmployeeHoursSumOrderByAggregateInput = {
    EmployeeId?: SortOrder
    EmployeeNumber?: SortOrder
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    RealHours?: SortOrder
    QtyHour?: SortOrder
    QtyHour125?: SortOrder
    QtyHour150?: SortOrder
    QtyHour175?: SortOrder
    QtyHour200?: SortOrder
    BreakMinutes?: SortOrder
    IsManualInsert?: SortOrder
    IsRowDeleted?: SortOrder
    ActionTypeID?: SortOrder
    DayTypeID?: SortOrder
    IsComplementRow?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EmployeeHoursListRelationFilter = {
    every?: EmployeeHoursWhereInput
    some?: EmployeeHoursWhereInput
    none?: EmployeeHoursWhereInput
  }

  export type EmployeeHoursUsersScalarRelationFilter = {
    is?: EmployeeHoursUsersWhereInput
    isNot?: EmployeeHoursUsersWhereInput
  }

  export type EmployeeHoursContractsScalarRelationFilter = {
    is?: EmployeeHoursContractsWhereInput
    isNot?: EmployeeHoursContractsWhereInput
  }

  export type EmployeeHoursLocalitiesScalarRelationFilter = {
    is?: EmployeeHoursLocalitiesWhereInput
    isNot?: EmployeeHoursLocalitiesWhereInput
  }

  export type EmployeeHoursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeHoursByLocalityCountOrderByAggregateInput = {
    EmployeeHoursByLocalityId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    NotShowEmployeeHours?: SortOrder
    EmployeeHoursLocalityId?: SortOrder
    HourMinStart?: SortOrder
    HourMaxStop?: SortOrder
    RoundTime?: SortOrder
    EmployeeHoursUserId?: SortOrder
    MinimumHours2BreakTime?: SortOrder
    BreakTime?: SortOrder
    AlertForMaxMonthHours?: SortOrder
    EmployeeHoursContractId?: SortOrder
  }

  export type EmployeeHoursByLocalityAvgOrderByAggregateInput = {
    EmployeeId?: SortOrder
    NotShowEmployeeHours?: SortOrder
    MinimumHours2BreakTime?: SortOrder
    BreakTime?: SortOrder
    AlertForMaxMonthHours?: SortOrder
  }

  export type EmployeeHoursByLocalityMaxOrderByAggregateInput = {
    EmployeeHoursByLocalityId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    NotShowEmployeeHours?: SortOrder
    EmployeeHoursLocalityId?: SortOrder
    HourMinStart?: SortOrder
    HourMaxStop?: SortOrder
    RoundTime?: SortOrder
    EmployeeHoursUserId?: SortOrder
    MinimumHours2BreakTime?: SortOrder
    BreakTime?: SortOrder
    AlertForMaxMonthHours?: SortOrder
    EmployeeHoursContractId?: SortOrder
  }

  export type EmployeeHoursByLocalityMinOrderByAggregateInput = {
    EmployeeHoursByLocalityId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    NotShowEmployeeHours?: SortOrder
    EmployeeHoursLocalityId?: SortOrder
    HourMinStart?: SortOrder
    HourMaxStop?: SortOrder
    RoundTime?: SortOrder
    EmployeeHoursUserId?: SortOrder
    MinimumHours2BreakTime?: SortOrder
    BreakTime?: SortOrder
    AlertForMaxMonthHours?: SortOrder
    EmployeeHoursContractId?: SortOrder
  }

  export type EmployeeHoursByLocalitySumOrderByAggregateInput = {
    EmployeeId?: SortOrder
    NotShowEmployeeHours?: SortOrder
    MinimumHours2BreakTime?: SortOrder
    BreakTime?: SortOrder
    AlertForMaxMonthHours?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EmployeeHoursByLocalityTotalsActionTypeListRelationFilter = {
    every?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
    some?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
    none?: EmployeeHoursByLocalityTotalsActionTypeWhereInput
  }

  export type EmployeeHoursByLocalityTotalsActionTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeHoursByLocalityTotalsCountOrderByAggregateInput = {
    EmployeeHoursByLocalityTotalsId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    EmployeeId?: SortOrder
    EmployeeHoursLocalityId?: SortOrder
    QtyHour?: SortOrder
    QtyHour125?: SortOrder
    QtyHour150?: SortOrder
    QtyHour175?: SortOrder
    QtyHour200?: SortOrder
    RealHours?: SortOrder
    BreakMinutes?: SortOrder
    WorkedDays?: SortOrder
    IsCloseSalary?: SortOrder
  }

  export type EmployeeHoursByLocalityTotalsAvgOrderByAggregateInput = {
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    EmployeeId?: SortOrder
    QtyHour?: SortOrder
    QtyHour125?: SortOrder
    QtyHour150?: SortOrder
    QtyHour175?: SortOrder
    QtyHour200?: SortOrder
    RealHours?: SortOrder
    BreakMinutes?: SortOrder
    WorkedDays?: SortOrder
    IsCloseSalary?: SortOrder
  }

  export type EmployeeHoursByLocalityTotalsMaxOrderByAggregateInput = {
    EmployeeHoursByLocalityTotalsId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    EmployeeId?: SortOrder
    EmployeeHoursLocalityId?: SortOrder
    QtyHour?: SortOrder
    QtyHour125?: SortOrder
    QtyHour150?: SortOrder
    QtyHour175?: SortOrder
    QtyHour200?: SortOrder
    RealHours?: SortOrder
    BreakMinutes?: SortOrder
    WorkedDays?: SortOrder
    IsCloseSalary?: SortOrder
  }

  export type EmployeeHoursByLocalityTotalsMinOrderByAggregateInput = {
    EmployeeHoursByLocalityTotalsId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    EmployeeId?: SortOrder
    EmployeeHoursLocalityId?: SortOrder
    QtyHour?: SortOrder
    QtyHour125?: SortOrder
    QtyHour150?: SortOrder
    QtyHour175?: SortOrder
    QtyHour200?: SortOrder
    RealHours?: SortOrder
    BreakMinutes?: SortOrder
    WorkedDays?: SortOrder
    IsCloseSalary?: SortOrder
  }

  export type EmployeeHoursByLocalityTotalsSumOrderByAggregateInput = {
    MonthManaged?: SortOrder
    YearManaged?: SortOrder
    EmployeeId?: SortOrder
    QtyHour?: SortOrder
    QtyHour125?: SortOrder
    QtyHour150?: SortOrder
    QtyHour175?: SortOrder
    QtyHour200?: SortOrder
    RealHours?: SortOrder
    BreakMinutes?: SortOrder
    WorkedDays?: SortOrder
    IsCloseSalary?: SortOrder
  }

  export type Lkup_ActionTypeScalarRelationFilter = {
    is?: Lkup_ActionTypeWhereInput
    isNot?: Lkup_ActionTypeWhereInput
  }

  export type EmployeeHoursByLocalityTotalsScalarRelationFilter = {
    is?: EmployeeHoursByLocalityTotalsWhereInput
    isNot?: EmployeeHoursByLocalityTotalsWhereInput
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCountOrderByAggregateInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: SortOrder
    CreatedAt?: SortOrder
    EmployeeHoursByLocalityTotalsId?: SortOrder
    ActionTypeId?: SortOrder
    TotalActionType?: SortOrder
  }

  export type EmployeeHoursByLocalityTotalsActionTypeAvgOrderByAggregateInput = {
    ActionTypeId?: SortOrder
    TotalActionType?: SortOrder
  }

  export type EmployeeHoursByLocalityTotalsActionTypeMaxOrderByAggregateInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: SortOrder
    CreatedAt?: SortOrder
    EmployeeHoursByLocalityTotalsId?: SortOrder
    ActionTypeId?: SortOrder
    TotalActionType?: SortOrder
  }

  export type EmployeeHoursByLocalityTotalsActionTypeMinOrderByAggregateInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: SortOrder
    CreatedAt?: SortOrder
    EmployeeHoursByLocalityTotalsId?: SortOrder
    ActionTypeId?: SortOrder
    TotalActionType?: SortOrder
  }

  export type EmployeeHoursByLocalityTotalsActionTypeSumOrderByAggregateInput = {
    ActionTypeId?: SortOrder
    TotalActionType?: SortOrder
  }

  export type EmployeeHoursCompaniesSmsAlertCountOrderByAggregateInput = {
    CompaniesSmsAlertId?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    CreatedAt?: SortOrder
    EmployeeID?: SortOrder
    SmsNumber?: SortOrder
    SmsResponse?: SortOrder
    UserSend?: SortOrder
  }

  export type EmployeeHoursCompaniesSmsAlertAvgOrderByAggregateInput = {
    CompaniesSmsAlertId?: SortOrder
    EmployeeID?: SortOrder
  }

  export type EmployeeHoursCompaniesSmsAlertMaxOrderByAggregateInput = {
    CompaniesSmsAlertId?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    CreatedAt?: SortOrder
    EmployeeID?: SortOrder
    SmsNumber?: SortOrder
    SmsResponse?: SortOrder
    UserSend?: SortOrder
  }

  export type EmployeeHoursCompaniesSmsAlertMinOrderByAggregateInput = {
    CompaniesSmsAlertId?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    CreatedAt?: SortOrder
    EmployeeID?: SortOrder
    SmsNumber?: SortOrder
    SmsResponse?: SortOrder
    UserSend?: SortOrder
  }

  export type EmployeeHoursCompaniesSmsAlertSumOrderByAggregateInput = {
    CompaniesSmsAlertId?: SortOrder
    EmployeeID?: SortOrder
  }

  export type EmployeeHoursByLocalityListRelationFilter = {
    every?: EmployeeHoursByLocalityWhereInput
    some?: EmployeeHoursByLocalityWhereInput
    none?: EmployeeHoursByLocalityWhereInput
  }

  export type EmployeeHoursByLocalityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeHoursContractsCountOrderByAggregateInput = {
    EmployeeHoursContractsId?: SortOrder
    CreatedAt?: SortOrder
    Active?: SortOrder
    HebrewName?: SortOrder
    Comments?: SortOrder
    JsonData?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    HoursWeek?: SortOrder
    NumberDayInWeek?: SortOrder
    IsExtraHoursWeekCalc?: SortOrder
    IsNightShiftCalc?: SortOrder
  }

  export type EmployeeHoursContractsAvgOrderByAggregateInput = {
    Active?: SortOrder
    HoursWeek?: SortOrder
    NumberDayInWeek?: SortOrder
    IsExtraHoursWeekCalc?: SortOrder
    IsNightShiftCalc?: SortOrder
  }

  export type EmployeeHoursContractsMaxOrderByAggregateInput = {
    EmployeeHoursContractsId?: SortOrder
    CreatedAt?: SortOrder
    Active?: SortOrder
    HebrewName?: SortOrder
    Comments?: SortOrder
    JsonData?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    HoursWeek?: SortOrder
    NumberDayInWeek?: SortOrder
    IsExtraHoursWeekCalc?: SortOrder
    IsNightShiftCalc?: SortOrder
  }

  export type EmployeeHoursContractsMinOrderByAggregateInput = {
    EmployeeHoursContractsId?: SortOrder
    CreatedAt?: SortOrder
    Active?: SortOrder
    HebrewName?: SortOrder
    Comments?: SortOrder
    JsonData?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    HoursWeek?: SortOrder
    NumberDayInWeek?: SortOrder
    IsExtraHoursWeekCalc?: SortOrder
    IsNightShiftCalc?: SortOrder
  }

  export type EmployeeHoursContractsSumOrderByAggregateInput = {
    Active?: SortOrder
    HoursWeek?: SortOrder
    NumberDayInWeek?: SortOrder
    IsExtraHoursWeekCalc?: SortOrder
    IsNightShiftCalc?: SortOrder
  }

  export type EmployeeHoursForemansConfigCountOrderByAggregateInput = {
    EmployeeHoursForemanConfigId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    ForemanUserGeneralCRM?: SortOrder
    CanEdit?: SortOrder
    NotShowSourceHours?: SortOrder
  }

  export type EmployeeHoursForemansConfigAvgOrderByAggregateInput = {
    CanEdit?: SortOrder
    NotShowSourceHours?: SortOrder
  }

  export type EmployeeHoursForemansConfigMaxOrderByAggregateInput = {
    EmployeeHoursForemanConfigId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    ForemanUserGeneralCRM?: SortOrder
    CanEdit?: SortOrder
    NotShowSourceHours?: SortOrder
  }

  export type EmployeeHoursForemansConfigMinOrderByAggregateInput = {
    EmployeeHoursForemanConfigId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    ForemanUserGeneralCRM?: SortOrder
    CanEdit?: SortOrder
    NotShowSourceHours?: SortOrder
  }

  export type EmployeeHoursForemansConfigSumOrderByAggregateInput = {
    CanEdit?: SortOrder
    NotShowSourceHours?: SortOrder
  }

  export type EmployeeHoursByLocalityTotalsListRelationFilter = {
    every?: EmployeeHoursByLocalityTotalsWhereInput
    some?: EmployeeHoursByLocalityTotalsWhereInput
    none?: EmployeeHoursByLocalityTotalsWhereInput
  }

  export type EmployeeHoursByLocalityTotalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeHoursLocalitiesCountOrderByAggregateInput = {
    EmployeeHoursLocalityId?: SortOrder
    CreatedAt?: SortOrder
    NotShowLocality?: SortOrder
    LocalityName?: SortOrder
    LocalityNameEng?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    Address?: SortOrder
    Gps?: SortOrder
    GpsRadius?: SortOrder
    AddressAccess?: SortOrder
    LocalityIDAccess?: SortOrder
    LocalityCodeAccess?: SortOrder
    CustomerIDAccess?: SortOrder
    CustomerNameAccess?: SortOrder
    ForemanGeneralCRMUserId?: SortOrder
    HourMinStart?: SortOrder
    HourMaxStop?: SortOrder
    RoundTime?: SortOrder
    MinimumHours2BreakTime?: SortOrder
    BreakTime?: SortOrder
    AlertForMaxMonthHours?: SortOrder
    RestrictDayHoursAbove12?: SortOrder
    RestrictWeekExtraHoursAbove16?: SortOrder
    RestrictGpsActive?: SortOrder
  }

  export type EmployeeHoursLocalitiesAvgOrderByAggregateInput = {
    NotShowLocality?: SortOrder
    GpsRadius?: SortOrder
    LocalityIDAccess?: SortOrder
    LocalityCodeAccess?: SortOrder
    CustomerIDAccess?: SortOrder
    MinimumHours2BreakTime?: SortOrder
    BreakTime?: SortOrder
    AlertForMaxMonthHours?: SortOrder
    RestrictDayHoursAbove12?: SortOrder
    RestrictWeekExtraHoursAbove16?: SortOrder
    RestrictGpsActive?: SortOrder
  }

  export type EmployeeHoursLocalitiesMaxOrderByAggregateInput = {
    EmployeeHoursLocalityId?: SortOrder
    CreatedAt?: SortOrder
    NotShowLocality?: SortOrder
    LocalityName?: SortOrder
    LocalityNameEng?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    Address?: SortOrder
    Gps?: SortOrder
    GpsRadius?: SortOrder
    AddressAccess?: SortOrder
    LocalityIDAccess?: SortOrder
    LocalityCodeAccess?: SortOrder
    CustomerIDAccess?: SortOrder
    CustomerNameAccess?: SortOrder
    ForemanGeneralCRMUserId?: SortOrder
    HourMinStart?: SortOrder
    HourMaxStop?: SortOrder
    RoundTime?: SortOrder
    MinimumHours2BreakTime?: SortOrder
    BreakTime?: SortOrder
    AlertForMaxMonthHours?: SortOrder
    RestrictDayHoursAbove12?: SortOrder
    RestrictWeekExtraHoursAbove16?: SortOrder
    RestrictGpsActive?: SortOrder
  }

  export type EmployeeHoursLocalitiesMinOrderByAggregateInput = {
    EmployeeHoursLocalityId?: SortOrder
    CreatedAt?: SortOrder
    NotShowLocality?: SortOrder
    LocalityName?: SortOrder
    LocalityNameEng?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    Address?: SortOrder
    Gps?: SortOrder
    GpsRadius?: SortOrder
    AddressAccess?: SortOrder
    LocalityIDAccess?: SortOrder
    LocalityCodeAccess?: SortOrder
    CustomerIDAccess?: SortOrder
    CustomerNameAccess?: SortOrder
    ForemanGeneralCRMUserId?: SortOrder
    HourMinStart?: SortOrder
    HourMaxStop?: SortOrder
    RoundTime?: SortOrder
    MinimumHours2BreakTime?: SortOrder
    BreakTime?: SortOrder
    AlertForMaxMonthHours?: SortOrder
    RestrictDayHoursAbove12?: SortOrder
    RestrictWeekExtraHoursAbove16?: SortOrder
    RestrictGpsActive?: SortOrder
  }

  export type EmployeeHoursLocalitiesSumOrderByAggregateInput = {
    NotShowLocality?: SortOrder
    GpsRadius?: SortOrder
    LocalityIDAccess?: SortOrder
    LocalityCodeAccess?: SortOrder
    CustomerIDAccess?: SortOrder
    MinimumHours2BreakTime?: SortOrder
    BreakTime?: SortOrder
    AlertForMaxMonthHours?: SortOrder
    RestrictDayHoursAbove12?: SortOrder
    RestrictWeekExtraHoursAbove16?: SortOrder
    RestrictGpsActive?: SortOrder
  }

  export type EmployeeHoursUsersCountOrderByAggregateInput = {
    EmployeeHoursUsersId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    MobileNumber?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IsAdmin?: SortOrder
    LastEntry?: SortOrder
    IsAllowAccess2WebSite?: SortOrder
    PhoneData?: SortOrder
    CookieError?: SortOrder
  }

  export type EmployeeHoursUsersAvgOrderByAggregateInput = {
    EmployeeId?: SortOrder
    IsAdmin?: SortOrder
    IsAllowAccess2WebSite?: SortOrder
  }

  export type EmployeeHoursUsersMaxOrderByAggregateInput = {
    EmployeeHoursUsersId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    MobileNumber?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IsAdmin?: SortOrder
    LastEntry?: SortOrder
    IsAllowAccess2WebSite?: SortOrder
    PhoneData?: SortOrder
    CookieError?: SortOrder
  }

  export type EmployeeHoursUsersMinOrderByAggregateInput = {
    EmployeeHoursUsersId?: SortOrder
    CreatedAt?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    EmployeeId?: SortOrder
    MobileNumber?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IsAdmin?: SortOrder
    LastEntry?: SortOrder
    IsAllowAccess2WebSite?: SortOrder
    PhoneData?: SortOrder
    CookieError?: SortOrder
  }

  export type EmployeeHoursUsersSumOrderByAggregateInput = {
    EmployeeId?: SortOrder
    IsAdmin?: SortOrder
    IsAllowAccess2WebSite?: SortOrder
  }

  export type EmployeesAccessDocumentsTempCountOrderByAggregateInput = {
    EmployeesAccessDocumentTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    EmployeeID?: SortOrder
    DocumemtID?: SortOrder
    Date?: SortOrder
    DocumemtType?: SortOrder
    Comment?: SortOrder
    DocumentName?: SortOrder
  }

  export type EmployeesAccessDocumentsTempMaxOrderByAggregateInput = {
    EmployeesAccessDocumentTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    EmployeeID?: SortOrder
    DocumemtID?: SortOrder
    Date?: SortOrder
    DocumemtType?: SortOrder
    Comment?: SortOrder
    DocumentName?: SortOrder
  }

  export type EmployeesAccessDocumentsTempMinOrderByAggregateInput = {
    EmployeesAccessDocumentTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    EmployeeID?: SortOrder
    DocumemtID?: SortOrder
    Date?: SortOrder
    DocumemtType?: SortOrder
    Comment?: SortOrder
    DocumentName?: SortOrder
  }

  export type EmployeesAccessHouseTempCountOrderByAggregateInput = {
    EmployeesAccessHouseTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    HouseID?: SortOrder
    HouseCode?: SortOrder
    CityName?: SortOrder
    Street?: SortOrder
    HouseNumber?: SortOrder
    ZipCode?: SortOrder
    EmployeesQtyMax?: SortOrder
    ElectricityCounter_Start?: SortOrder
    ElectricityCounter_End?: SortOrder
    GasCounter_Start?: SortOrder
    GasCounter_End?: SortOrder
    WaterCounter_Start?: SortOrder
    WaterCounter_End?: SortOrder
    ElectricityNumber?: SortOrder
    GasNumber?: SortOrder
    WaterNumber?: SortOrder
    HouseField?: SortOrder
    ArnonaNumber?: SortOrder
    EvacuationDate?: SortOrder
    AreaMan?: SortOrder
    GasContainer?: SortOrder
    GasCompanyID?: SortOrder
    SleepingRooms?: SortOrder
    Salon?: SortOrder
    Toilet?: SortOrder
    Baths?: SortOrder
    HouseCommittee?: SortOrder
    HouseCommitteePhone?: SortOrder
    Status?: SortOrder
    Name?: SortOrder
    Street_?: SortOrder
    CityName_?: SortOrder
    ZipCode_?: SortOrder
    Phone_1?: SortOrder
    Phone_2?: SortOrder
    FaxNumber?: SortOrder
    StartDateContract?: SortOrder
    EndDateContract?: SortOrder
    Security?: SortOrder
    SecurityAmount?: SortOrder
    PaymentFrequency?: SortOrder
    Rant?: SortOrder
    Comment?: SortOrder
    IsInsured?: SortOrder
    InsureEndDate?: SortOrder
    IsUpdate?: SortOrder
    LivingArea?: SortOrder
    HouseRelation?: SortOrder
    CableTypeID?: SortOrder
    CableInstallationdate?: SortOrder
    AccountNumber?: SortOrder
    PathNumber?: SortOrder
    AppartmentNum?: SortOrder
    IsBroker?: SortOrder
    BrokerName?: SortOrder
    BrokerPhone?: SortOrder
    ElectricityCode?: SortOrder
    GasNumberCode?: SortOrder
    WaterNumberCode?: SortOrder
    ElectricityComment?: SortOrder
    GasCounteComment?: SortOrder
    WaterCounterComment?: SortOrder
    AgencyFee?: SortOrder
    IdNumber?: SortOrder
    ArrivalInstructions?: SortOrder
    OwnerEmail?: SortOrder
    OwnerBankAcount?: SortOrder
    CustomerID?: SortOrder
    LocalityName?: SortOrder
    Contractor_billing?: SortOrder
    Floor?: SortOrder
    Entrance?: SortOrder
    OwnerBranchCode?: SortOrder
    OwnerBankID?: SortOrder
  }

  export type EmployeesAccessHouseTempMaxOrderByAggregateInput = {
    EmployeesAccessHouseTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    HouseID?: SortOrder
    HouseCode?: SortOrder
    CityName?: SortOrder
    Street?: SortOrder
    HouseNumber?: SortOrder
    ZipCode?: SortOrder
    EmployeesQtyMax?: SortOrder
    ElectricityCounter_Start?: SortOrder
    ElectricityCounter_End?: SortOrder
    GasCounter_Start?: SortOrder
    GasCounter_End?: SortOrder
    WaterCounter_Start?: SortOrder
    WaterCounter_End?: SortOrder
    ElectricityNumber?: SortOrder
    GasNumber?: SortOrder
    WaterNumber?: SortOrder
    HouseField?: SortOrder
    ArnonaNumber?: SortOrder
    EvacuationDate?: SortOrder
    AreaMan?: SortOrder
    GasContainer?: SortOrder
    GasCompanyID?: SortOrder
    SleepingRooms?: SortOrder
    Salon?: SortOrder
    Toilet?: SortOrder
    Baths?: SortOrder
    HouseCommittee?: SortOrder
    HouseCommitteePhone?: SortOrder
    Status?: SortOrder
    Name?: SortOrder
    Street_?: SortOrder
    CityName_?: SortOrder
    ZipCode_?: SortOrder
    Phone_1?: SortOrder
    Phone_2?: SortOrder
    FaxNumber?: SortOrder
    StartDateContract?: SortOrder
    EndDateContract?: SortOrder
    Security?: SortOrder
    SecurityAmount?: SortOrder
    PaymentFrequency?: SortOrder
    Rant?: SortOrder
    Comment?: SortOrder
    IsInsured?: SortOrder
    InsureEndDate?: SortOrder
    IsUpdate?: SortOrder
    LivingArea?: SortOrder
    HouseRelation?: SortOrder
    CableTypeID?: SortOrder
    CableInstallationdate?: SortOrder
    AccountNumber?: SortOrder
    PathNumber?: SortOrder
    AppartmentNum?: SortOrder
    IsBroker?: SortOrder
    BrokerName?: SortOrder
    BrokerPhone?: SortOrder
    ElectricityCode?: SortOrder
    GasNumberCode?: SortOrder
    WaterNumberCode?: SortOrder
    ElectricityComment?: SortOrder
    GasCounteComment?: SortOrder
    WaterCounterComment?: SortOrder
    AgencyFee?: SortOrder
    IdNumber?: SortOrder
    ArrivalInstructions?: SortOrder
    OwnerEmail?: SortOrder
    OwnerBankAcount?: SortOrder
    CustomerID?: SortOrder
    LocalityName?: SortOrder
    Contractor_billing?: SortOrder
    Floor?: SortOrder
    Entrance?: SortOrder
    OwnerBranchCode?: SortOrder
    OwnerBankID?: SortOrder
  }

  export type EmployeesAccessHouseTempMinOrderByAggregateInput = {
    EmployeesAccessHouseTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    HouseID?: SortOrder
    HouseCode?: SortOrder
    CityName?: SortOrder
    Street?: SortOrder
    HouseNumber?: SortOrder
    ZipCode?: SortOrder
    EmployeesQtyMax?: SortOrder
    ElectricityCounter_Start?: SortOrder
    ElectricityCounter_End?: SortOrder
    GasCounter_Start?: SortOrder
    GasCounter_End?: SortOrder
    WaterCounter_Start?: SortOrder
    WaterCounter_End?: SortOrder
    ElectricityNumber?: SortOrder
    GasNumber?: SortOrder
    WaterNumber?: SortOrder
    HouseField?: SortOrder
    ArnonaNumber?: SortOrder
    EvacuationDate?: SortOrder
    AreaMan?: SortOrder
    GasContainer?: SortOrder
    GasCompanyID?: SortOrder
    SleepingRooms?: SortOrder
    Salon?: SortOrder
    Toilet?: SortOrder
    Baths?: SortOrder
    HouseCommittee?: SortOrder
    HouseCommitteePhone?: SortOrder
    Status?: SortOrder
    Name?: SortOrder
    Street_?: SortOrder
    CityName_?: SortOrder
    ZipCode_?: SortOrder
    Phone_1?: SortOrder
    Phone_2?: SortOrder
    FaxNumber?: SortOrder
    StartDateContract?: SortOrder
    EndDateContract?: SortOrder
    Security?: SortOrder
    SecurityAmount?: SortOrder
    PaymentFrequency?: SortOrder
    Rant?: SortOrder
    Comment?: SortOrder
    IsInsured?: SortOrder
    InsureEndDate?: SortOrder
    IsUpdate?: SortOrder
    LivingArea?: SortOrder
    HouseRelation?: SortOrder
    CableTypeID?: SortOrder
    CableInstallationdate?: SortOrder
    AccountNumber?: SortOrder
    PathNumber?: SortOrder
    AppartmentNum?: SortOrder
    IsBroker?: SortOrder
    BrokerName?: SortOrder
    BrokerPhone?: SortOrder
    ElectricityCode?: SortOrder
    GasNumberCode?: SortOrder
    WaterNumberCode?: SortOrder
    ElectricityComment?: SortOrder
    GasCounteComment?: SortOrder
    WaterCounterComment?: SortOrder
    AgencyFee?: SortOrder
    IdNumber?: SortOrder
    ArrivalInstructions?: SortOrder
    OwnerEmail?: SortOrder
    OwnerBankAcount?: SortOrder
    CustomerID?: SortOrder
    LocalityName?: SortOrder
    Contractor_billing?: SortOrder
    Floor?: SortOrder
    Entrance?: SortOrder
    OwnerBranchCode?: SortOrder
    OwnerBankID?: SortOrder
  }

  export type EmployeesAccessLkupDocumentTypeTempCountOrderByAggregateInput = {
    EmployeesAccessLkupDocumentTypeTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    DocumemtType?: SortOrder
  }

  export type EmployeesAccessLkupDocumentTypeTempMaxOrderByAggregateInput = {
    EmployeesAccessLkupDocumentTypeTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    DocumemtType?: SortOrder
  }

  export type EmployeesAccessLkupDocumentTypeTempMinOrderByAggregateInput = {
    EmployeesAccessLkupDocumentTypeTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    DocumemtType?: SortOrder
  }

  export type EmployeesAccessTempCountOrderByAggregateInput = {
    EmployeesAccessTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    AgentID?: SortOrder
    AreaMan?: SortOrder
    AppartmentNum?: SortOrder
    BirthDate?: SortOrder
    CityName?: SortOrder
    CoatReceivingDate?: SortOrder
    CoatSize?: SortOrder
    CountryID?: SortOrder
    CountryName?: SortOrder
    CourseAtatDate?: SortOrder
    CourseAtatExpireDate?: SortOrder
    CustomerName?: SortOrder
    CustomerStatus?: SortOrder
    CustomerID?: SortOrder
    EmployeeFirstName?: SortOrder
    EmployeeID?: SortOrder
    EmployeeLastName?: SortOrder
    EmployeeNumber?: SortOrder
    EndInsuranceDate?: SortOrder
    EntranceDate?: SortOrder
    HealthFund?: SortOrder
    HouseID?: SortOrder
    HouseNumber?: SortOrder
    InsuranceCompany?: SortOrder
    InsuranceNumber?: SortOrder
    InsuredNumber?: SortOrder
    IsCourseAtat?: SortOrder
    Isbriefing?: SortOrder
    LocalityName?: SortOrder
    LocalityCode?: SortOrder
    LocalityID?: SortOrder
    LongshirtReceivingDate?: SortOrder
    LongshirtSize?: SortOrder
    MobilePhone?: SortOrder
    PantsReceivingDate?: SortOrder
    PassportNumber?: SortOrder
    ProfessionName?: SortOrder
    ProfessionSecondName?: SortOrder
    ProfessionThirdName?: SortOrder
    ShoesNumber?: SortOrder
    ShoesReceiveDate?: SortOrder
    SizeOfPantes?: SortOrder
    SizeOfshirt?: SortOrder
    StartDate?: SortOrder
    StatusName?: SortOrder
    Street?: SortOrder
    TshirReceivingDate?: SortOrder
    briefingDate?: SortOrder
    briefingExpireDate?: SortOrder
    startInsuranceDate?: SortOrder
  }

  export type EmployeesAccessTempMaxOrderByAggregateInput = {
    EmployeesAccessTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    AgentID?: SortOrder
    AreaMan?: SortOrder
    AppartmentNum?: SortOrder
    BirthDate?: SortOrder
    CityName?: SortOrder
    CoatReceivingDate?: SortOrder
    CoatSize?: SortOrder
    CountryID?: SortOrder
    CountryName?: SortOrder
    CourseAtatDate?: SortOrder
    CourseAtatExpireDate?: SortOrder
    CustomerName?: SortOrder
    CustomerStatus?: SortOrder
    CustomerID?: SortOrder
    EmployeeFirstName?: SortOrder
    EmployeeID?: SortOrder
    EmployeeLastName?: SortOrder
    EmployeeNumber?: SortOrder
    EndInsuranceDate?: SortOrder
    EntranceDate?: SortOrder
    HealthFund?: SortOrder
    HouseID?: SortOrder
    HouseNumber?: SortOrder
    InsuranceCompany?: SortOrder
    InsuranceNumber?: SortOrder
    InsuredNumber?: SortOrder
    IsCourseAtat?: SortOrder
    Isbriefing?: SortOrder
    LocalityName?: SortOrder
    LocalityCode?: SortOrder
    LocalityID?: SortOrder
    LongshirtReceivingDate?: SortOrder
    LongshirtSize?: SortOrder
    MobilePhone?: SortOrder
    PantsReceivingDate?: SortOrder
    PassportNumber?: SortOrder
    ProfessionName?: SortOrder
    ProfessionSecondName?: SortOrder
    ProfessionThirdName?: SortOrder
    ShoesNumber?: SortOrder
    ShoesReceiveDate?: SortOrder
    SizeOfPantes?: SortOrder
    SizeOfshirt?: SortOrder
    StartDate?: SortOrder
    StatusName?: SortOrder
    Street?: SortOrder
    TshirReceivingDate?: SortOrder
    briefingDate?: SortOrder
    briefingExpireDate?: SortOrder
    startInsuranceDate?: SortOrder
  }

  export type EmployeesAccessTempMinOrderByAggregateInput = {
    EmployeesAccessTempId?: SortOrder
    CompanyGeneralCrmId?: SortOrder
    CreatedAt?: SortOrder
    AgentID?: SortOrder
    AreaMan?: SortOrder
    AppartmentNum?: SortOrder
    BirthDate?: SortOrder
    CityName?: SortOrder
    CoatReceivingDate?: SortOrder
    CoatSize?: SortOrder
    CountryID?: SortOrder
    CountryName?: SortOrder
    CourseAtatDate?: SortOrder
    CourseAtatExpireDate?: SortOrder
    CustomerName?: SortOrder
    CustomerStatus?: SortOrder
    CustomerID?: SortOrder
    EmployeeFirstName?: SortOrder
    EmployeeID?: SortOrder
    EmployeeLastName?: SortOrder
    EmployeeNumber?: SortOrder
    EndInsuranceDate?: SortOrder
    EntranceDate?: SortOrder
    HealthFund?: SortOrder
    HouseID?: SortOrder
    HouseNumber?: SortOrder
    InsuranceCompany?: SortOrder
    InsuranceNumber?: SortOrder
    InsuredNumber?: SortOrder
    IsCourseAtat?: SortOrder
    Isbriefing?: SortOrder
    LocalityName?: SortOrder
    LocalityCode?: SortOrder
    LocalityID?: SortOrder
    LongshirtReceivingDate?: SortOrder
    LongshirtSize?: SortOrder
    MobilePhone?: SortOrder
    PantsReceivingDate?: SortOrder
    PassportNumber?: SortOrder
    ProfessionName?: SortOrder
    ProfessionSecondName?: SortOrder
    ProfessionThirdName?: SortOrder
    ShoesNumber?: SortOrder
    ShoesReceiveDate?: SortOrder
    SizeOfPantes?: SortOrder
    SizeOfshirt?: SortOrder
    StartDate?: SortOrder
    StatusName?: SortOrder
    Street?: SortOrder
    TshirReceivingDate?: SortOrder
    briefingDate?: SortOrder
    briefingExpireDate?: SortOrder
    startInsuranceDate?: SortOrder
  }

  export type ErrorsPhpLogsCountOrderByAggregateInput = {
    ErrorsPhpLogsId?: SortOrder
    CreatedAt?: SortOrder
    tokenData?: SortOrder
    urlController?: SortOrder
    sendData?: SortOrder
    errorMessg?: SortOrder
  }

  export type ErrorsPhpLogsAvgOrderByAggregateInput = {
    ErrorsPhpLogsId?: SortOrder
  }

  export type ErrorsPhpLogsMaxOrderByAggregateInput = {
    ErrorsPhpLogsId?: SortOrder
    CreatedAt?: SortOrder
    tokenData?: SortOrder
    urlController?: SortOrder
    sendData?: SortOrder
    errorMessg?: SortOrder
  }

  export type ErrorsPhpLogsMinOrderByAggregateInput = {
    ErrorsPhpLogsId?: SortOrder
    CreatedAt?: SortOrder
    tokenData?: SortOrder
    urlController?: SortOrder
    sendData?: SortOrder
    errorMessg?: SortOrder
  }

  export type ErrorsPhpLogsSumOrderByAggregateInput = {
    ErrorsPhpLogsId?: SortOrder
  }

  export type Lkup_ActionTypeCountOrderByAggregateInput = {
    ActionTypeID?: SortOrder
    ActionType?: SortOrder
    IsIgnoreHours?: SortOrder
  }

  export type Lkup_ActionTypeAvgOrderByAggregateInput = {
    ActionTypeID?: SortOrder
    IsIgnoreHours?: SortOrder
  }

  export type Lkup_ActionTypeMaxOrderByAggregateInput = {
    ActionTypeID?: SortOrder
    ActionType?: SortOrder
    IsIgnoreHours?: SortOrder
  }

  export type Lkup_ActionTypeMinOrderByAggregateInput = {
    ActionTypeID?: SortOrder
    ActionType?: SortOrder
    IsIgnoreHours?: SortOrder
  }

  export type Lkup_ActionTypeSumOrderByAggregateInput = {
    ActionTypeID?: SortOrder
    IsIgnoreHours?: SortOrder
  }

  export type LogEnterEmployeeCountOrderByAggregateInput = {
    LogEnterEmployee?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    EmployeeID?: SortOrder
    CreatedAt?: SortOrder
    ResultsData?: SortOrder
  }

  export type LogEnterEmployeeAvgOrderByAggregateInput = {
    LogEnterEmployee?: SortOrder
    EmployeeID?: SortOrder
  }

  export type LogEnterEmployeeMaxOrderByAggregateInput = {
    LogEnterEmployee?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    EmployeeID?: SortOrder
    CreatedAt?: SortOrder
    ResultsData?: SortOrder
  }

  export type LogEnterEmployeeMinOrderByAggregateInput = {
    LogEnterEmployee?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    EmployeeID?: SortOrder
    CreatedAt?: SortOrder
    ResultsData?: SortOrder
  }

  export type LogEnterEmployeeSumOrderByAggregateInput = {
    LogEnterEmployee?: SortOrder
    EmployeeID?: SortOrder
  }

  export type LogSearchsCountOrderByAggregateInput = {
    LogSearchsId?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrder
    searchData?: SortOrder
    resultsCount?: SortOrder
  }

  export type LogSearchsAvgOrderByAggregateInput = {
    LogSearchsId?: SortOrder
    resultsCount?: SortOrder
  }

  export type LogSearchsMaxOrderByAggregateInput = {
    LogSearchsId?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrder
    searchData?: SortOrder
    resultsCount?: SortOrder
  }

  export type LogSearchsMinOrderByAggregateInput = {
    LogSearchsId?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrder
    searchData?: SortOrder
    resultsCount?: SortOrder
  }

  export type LogSearchsSumOrderByAggregateInput = {
    LogSearchsId?: SortOrder
    resultsCount?: SortOrder
  }

  export type LogSignUpCountOrderByAggregateInput = {
    LogSignUpId?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrder
  }

  export type LogSignUpAvgOrderByAggregateInput = {
    LogSignUpId?: SortOrder
  }

  export type LogSignUpMaxOrderByAggregateInput = {
    LogSignUpId?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrder
  }

  export type LogSignUpMinOrderByAggregateInput = {
    LogSignUpId?: SortOrder
    UserID?: SortOrder
    CompanyID?: SortOrder
    CreatedAt?: SortOrder
  }

  export type LogSignUpSumOrderByAggregateInput = {
    LogSignUpId?: SortOrder
  }

  export type MessagesEmployeesNullableScalarRelationFilter = {
    is?: MessagesEmployeesWhereInput | null
    isNot?: MessagesEmployeesWhereInput | null
  }

  export type MessagesEmployeesListRelationFilter = {
    every?: MessagesEmployeesWhereInput
    some?: MessagesEmployeesWhereInput
    none?: MessagesEmployeesWhereInput
  }

  export type MessagesStatusScalarRelationFilter = {
    is?: MessagesStatusWhereInput
    isNot?: MessagesStatusWhereInput
  }

  export type MessagesEmployeesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessagesEmployeesCountOrderByAggregateInput = {
    MessageEmployeeId?: SortOrder
    CreatedAt?: SortOrder
    FinalDateForTask?: SortOrder
    ReadedAt?: SortOrder
    DoneAt?: SortOrder
    SendResponseAtStatusDone?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    UserFromIdGeneralCRM?: SortOrder
    UserToIdGeneralCRM?: SortOrder
    IsReplyToMessageId?: SortOrder
    MessageStatusId?: SortOrder
    MessageSubject?: SortOrder
    MessageText?: SortOrder
    LinkEmployees?: SortOrder
    LinkHouses?: SortOrder
  }

  export type MessagesEmployeesAvgOrderByAggregateInput = {
    SendResponseAtStatusDone?: SortOrder
  }

  export type MessagesEmployeesMaxOrderByAggregateInput = {
    MessageEmployeeId?: SortOrder
    CreatedAt?: SortOrder
    FinalDateForTask?: SortOrder
    ReadedAt?: SortOrder
    DoneAt?: SortOrder
    SendResponseAtStatusDone?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    UserFromIdGeneralCRM?: SortOrder
    UserToIdGeneralCRM?: SortOrder
    IsReplyToMessageId?: SortOrder
    MessageStatusId?: SortOrder
    MessageSubject?: SortOrder
    MessageText?: SortOrder
    LinkEmployees?: SortOrder
    LinkHouses?: SortOrder
  }

  export type MessagesEmployeesMinOrderByAggregateInput = {
    MessageEmployeeId?: SortOrder
    CreatedAt?: SortOrder
    FinalDateForTask?: SortOrder
    ReadedAt?: SortOrder
    DoneAt?: SortOrder
    SendResponseAtStatusDone?: SortOrder
    CompanyIdGeneralCRM?: SortOrder
    UserFromIdGeneralCRM?: SortOrder
    UserToIdGeneralCRM?: SortOrder
    IsReplyToMessageId?: SortOrder
    MessageStatusId?: SortOrder
    MessageSubject?: SortOrder
    MessageText?: SortOrder
    LinkEmployees?: SortOrder
    LinkHouses?: SortOrder
  }

  export type MessagesEmployeesSumOrderByAggregateInput = {
    SendResponseAtStatusDone?: SortOrder
  }

  export type MessagesStatusCountOrderByAggregateInput = {
    MessagesStatusId?: SortOrder
    MessagesStatusName?: SortOrder
    CreatedAt?: SortOrder
    Sort?: SortOrder
    Comments?: SortOrder
  }

  export type MessagesStatusAvgOrderByAggregateInput = {
    Sort?: SortOrder
  }

  export type MessagesStatusMaxOrderByAggregateInput = {
    MessagesStatusId?: SortOrder
    MessagesStatusName?: SortOrder
    CreatedAt?: SortOrder
    Sort?: SortOrder
    Comments?: SortOrder
  }

  export type MessagesStatusMinOrderByAggregateInput = {
    MessagesStatusId?: SortOrder
    MessagesStatusName?: SortOrder
    CreatedAt?: SortOrder
    Sort?: SortOrder
    Comments?: SortOrder
  }

  export type MessagesStatusSumOrderByAggregateInput = {
    Sort?: SortOrder
  }

  export type SiteConfigCountOrderByAggregateInput = {
    SiteConfigId?: SortOrder
    PropertyEngName?: SortOrder
    PropertyIntValue?: SortOrder
    PropertyTextValue?: SortOrder
    PropertyHebDescription?: SortOrder
    CreatedAt?: SortOrder
  }

  export type SiteConfigAvgOrderByAggregateInput = {
    SiteConfigId?: SortOrder
    PropertyIntValue?: SortOrder
  }

  export type SiteConfigMaxOrderByAggregateInput = {
    SiteConfigId?: SortOrder
    PropertyEngName?: SortOrder
    PropertyIntValue?: SortOrder
    PropertyTextValue?: SortOrder
    PropertyHebDescription?: SortOrder
    CreatedAt?: SortOrder
  }

  export type SiteConfigMinOrderByAggregateInput = {
    SiteConfigId?: SortOrder
    PropertyEngName?: SortOrder
    PropertyIntValue?: SortOrder
    PropertyTextValue?: SortOrder
    PropertyHebDescription?: SortOrder
    CreatedAt?: SortOrder
  }

  export type SiteConfigSumOrderByAggregateInput = {
    SiteConfigId?: SortOrder
    PropertyIntValue?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type sysdiagramsPrincipal_idNameCompoundUniqueInput = {
    principal_id: number
    name: string
  }

  export type sysdiagramsCountOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsAvgOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type sysdiagramsMaxOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsMinOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsSumOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type UserViewRolesScalarRelationFilter = {
    is?: UserViewRolesWhereInput
    isNot?: UserViewRolesWhereInput
  }

  export type UsersLinkedViewRoleCountOrderByAggregateInput = {
    UsersLinkedViewRoleId?: SortOrder
    CreatedAt?: SortOrder
    CompanyID?: SortOrder
    UserID?: SortOrder
    UserViewRolesId?: SortOrder
  }

  export type UsersLinkedViewRoleMaxOrderByAggregateInput = {
    UsersLinkedViewRoleId?: SortOrder
    CreatedAt?: SortOrder
    CompanyID?: SortOrder
    UserID?: SortOrder
    UserViewRolesId?: SortOrder
  }

  export type UsersLinkedViewRoleMinOrderByAggregateInput = {
    UsersLinkedViewRoleId?: SortOrder
    CreatedAt?: SortOrder
    CompanyID?: SortOrder
    UserID?: SortOrder
    UserViewRolesId?: SortOrder
  }

  export type UsersLinkedViewRoleListRelationFilter = {
    every?: UsersLinkedViewRoleWhereInput
    some?: UsersLinkedViewRoleWhereInput
    none?: UsersLinkedViewRoleWhereInput
  }

  export type UsersLinkedViewRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserViewRolesCountOrderByAggregateInput = {
    UserViewRolesId?: SortOrder
    CreatedAt?: SortOrder
    CompanyID?: SortOrder
    UserViewRoleName?: SortOrder
    NotShowFields?: SortOrder
    MaxSearchResults?: SortOrder
    EditFields?: SortOrder
  }

  export type UserViewRolesAvgOrderByAggregateInput = {
    MaxSearchResults?: SortOrder
  }

  export type UserViewRolesMaxOrderByAggregateInput = {
    UserViewRolesId?: SortOrder
    CreatedAt?: SortOrder
    CompanyID?: SortOrder
    UserViewRoleName?: SortOrder
    NotShowFields?: SortOrder
    MaxSearchResults?: SortOrder
    EditFields?: SortOrder
  }

  export type UserViewRolesMinOrderByAggregateInput = {
    UserViewRolesId?: SortOrder
    CreatedAt?: SortOrder
    CompanyID?: SortOrder
    UserViewRoleName?: SortOrder
    NotShowFields?: SortOrder
    MaxSearchResults?: SortOrder
    EditFields?: SortOrder
  }

  export type UserViewRolesSumOrderByAggregateInput = {
    MaxSearchResults?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Lkup_ActionTypeCreateNestedOneWithoutEmployeeHoursInput = {
    create?: XOR<Lkup_ActionTypeCreateWithoutEmployeeHoursInput, Lkup_ActionTypeUncheckedCreateWithoutEmployeeHoursInput>
    connectOrCreate?: Lkup_ActionTypeCreateOrConnectWithoutEmployeeHoursInput
    connect?: Lkup_ActionTypeWhereUniqueInput
  }

  export type EmployeeHoursByLocalityCreateNestedOneWithoutEmployeeHoursInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursInput>
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursInput
    connect?: EmployeeHoursByLocalityWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type Lkup_ActionTypeUpdateOneWithoutEmployeeHoursNestedInput = {
    create?: XOR<Lkup_ActionTypeCreateWithoutEmployeeHoursInput, Lkup_ActionTypeUncheckedCreateWithoutEmployeeHoursInput>
    connectOrCreate?: Lkup_ActionTypeCreateOrConnectWithoutEmployeeHoursInput
    upsert?: Lkup_ActionTypeUpsertWithoutEmployeeHoursInput
    disconnect?: Lkup_ActionTypeWhereInput | boolean
    delete?: Lkup_ActionTypeWhereInput | boolean
    connect?: Lkup_ActionTypeWhereUniqueInput
    update?: XOR<XOR<Lkup_ActionTypeUpdateToOneWithWhereWithoutEmployeeHoursInput, Lkup_ActionTypeUpdateWithoutEmployeeHoursInput>, Lkup_ActionTypeUncheckedUpdateWithoutEmployeeHoursInput>
  }

  export type EmployeeHoursByLocalityUpdateOneRequiredWithoutEmployeeHoursNestedInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursInput>
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursInput
    upsert?: EmployeeHoursByLocalityUpsertWithoutEmployeeHoursInput
    connect?: EmployeeHoursByLocalityWhereUniqueInput
    update?: XOR<XOR<EmployeeHoursByLocalityUpdateToOneWithWhereWithoutEmployeeHoursInput, EmployeeHoursByLocalityUpdateWithoutEmployeeHoursInput>, EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursInput>
  }

  export type EmployeeHoursCreateNestedManyWithoutEmployeeHoursByLocalityInput = {
    create?: XOR<EmployeeHoursCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUncheckedCreateWithoutEmployeeHoursByLocalityInput> | EmployeeHoursCreateWithoutEmployeeHoursByLocalityInput[] | EmployeeHoursUncheckedCreateWithoutEmployeeHoursByLocalityInput[]
    connectOrCreate?: EmployeeHoursCreateOrConnectWithoutEmployeeHoursByLocalityInput | EmployeeHoursCreateOrConnectWithoutEmployeeHoursByLocalityInput[]
    createMany?: EmployeeHoursCreateManyEmployeeHoursByLocalityInputEnvelope
    connect?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
  }

  export type EmployeeHoursUsersCreateNestedOneWithoutEmployeeHoursByLocalityInput = {
    create?: XOR<EmployeeHoursUsersCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUsersUncheckedCreateWithoutEmployeeHoursByLocalityInput>
    connectOrCreate?: EmployeeHoursUsersCreateOrConnectWithoutEmployeeHoursByLocalityInput
    connect?: EmployeeHoursUsersWhereUniqueInput
  }

  export type EmployeeHoursContractsCreateNestedOneWithoutEmployeeHoursByLocalityInput = {
    create?: XOR<EmployeeHoursContractsCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursContractsUncheckedCreateWithoutEmployeeHoursByLocalityInput>
    connectOrCreate?: EmployeeHoursContractsCreateOrConnectWithoutEmployeeHoursByLocalityInput
    connect?: EmployeeHoursContractsWhereUniqueInput
  }

  export type EmployeeHoursLocalitiesCreateNestedOneWithoutEmployeeHoursByLocalityInput = {
    create?: XOR<EmployeeHoursLocalitiesCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursLocalitiesUncheckedCreateWithoutEmployeeHoursByLocalityInput>
    connectOrCreate?: EmployeeHoursLocalitiesCreateOrConnectWithoutEmployeeHoursByLocalityInput
    connect?: EmployeeHoursLocalitiesWhereUniqueInput
  }

  export type EmployeeHoursUncheckedCreateNestedManyWithoutEmployeeHoursByLocalityInput = {
    create?: XOR<EmployeeHoursCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUncheckedCreateWithoutEmployeeHoursByLocalityInput> | EmployeeHoursCreateWithoutEmployeeHoursByLocalityInput[] | EmployeeHoursUncheckedCreateWithoutEmployeeHoursByLocalityInput[]
    connectOrCreate?: EmployeeHoursCreateOrConnectWithoutEmployeeHoursByLocalityInput | EmployeeHoursCreateOrConnectWithoutEmployeeHoursByLocalityInput[]
    createMany?: EmployeeHoursCreateManyEmployeeHoursByLocalityInputEnvelope
    connect?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeHoursUpdateManyWithoutEmployeeHoursByLocalityNestedInput = {
    create?: XOR<EmployeeHoursCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUncheckedCreateWithoutEmployeeHoursByLocalityInput> | EmployeeHoursCreateWithoutEmployeeHoursByLocalityInput[] | EmployeeHoursUncheckedCreateWithoutEmployeeHoursByLocalityInput[]
    connectOrCreate?: EmployeeHoursCreateOrConnectWithoutEmployeeHoursByLocalityInput | EmployeeHoursCreateOrConnectWithoutEmployeeHoursByLocalityInput[]
    upsert?: EmployeeHoursUpsertWithWhereUniqueWithoutEmployeeHoursByLocalityInput | EmployeeHoursUpsertWithWhereUniqueWithoutEmployeeHoursByLocalityInput[]
    createMany?: EmployeeHoursCreateManyEmployeeHoursByLocalityInputEnvelope
    set?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    disconnect?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    delete?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    connect?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    update?: EmployeeHoursUpdateWithWhereUniqueWithoutEmployeeHoursByLocalityInput | EmployeeHoursUpdateWithWhereUniqueWithoutEmployeeHoursByLocalityInput[]
    updateMany?: EmployeeHoursUpdateManyWithWhereWithoutEmployeeHoursByLocalityInput | EmployeeHoursUpdateManyWithWhereWithoutEmployeeHoursByLocalityInput[]
    deleteMany?: EmployeeHoursScalarWhereInput | EmployeeHoursScalarWhereInput[]
  }

  export type EmployeeHoursUsersUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput = {
    create?: XOR<EmployeeHoursUsersCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUsersUncheckedCreateWithoutEmployeeHoursByLocalityInput>
    connectOrCreate?: EmployeeHoursUsersCreateOrConnectWithoutEmployeeHoursByLocalityInput
    upsert?: EmployeeHoursUsersUpsertWithoutEmployeeHoursByLocalityInput
    connect?: EmployeeHoursUsersWhereUniqueInput
    update?: XOR<XOR<EmployeeHoursUsersUpdateToOneWithWhereWithoutEmployeeHoursByLocalityInput, EmployeeHoursUsersUpdateWithoutEmployeeHoursByLocalityInput>, EmployeeHoursUsersUncheckedUpdateWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursContractsUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput = {
    create?: XOR<EmployeeHoursContractsCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursContractsUncheckedCreateWithoutEmployeeHoursByLocalityInput>
    connectOrCreate?: EmployeeHoursContractsCreateOrConnectWithoutEmployeeHoursByLocalityInput
    upsert?: EmployeeHoursContractsUpsertWithoutEmployeeHoursByLocalityInput
    connect?: EmployeeHoursContractsWhereUniqueInput
    update?: XOR<XOR<EmployeeHoursContractsUpdateToOneWithWhereWithoutEmployeeHoursByLocalityInput, EmployeeHoursContractsUpdateWithoutEmployeeHoursByLocalityInput>, EmployeeHoursContractsUncheckedUpdateWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursLocalitiesUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput = {
    create?: XOR<EmployeeHoursLocalitiesCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursLocalitiesUncheckedCreateWithoutEmployeeHoursByLocalityInput>
    connectOrCreate?: EmployeeHoursLocalitiesCreateOrConnectWithoutEmployeeHoursByLocalityInput
    upsert?: EmployeeHoursLocalitiesUpsertWithoutEmployeeHoursByLocalityInput
    connect?: EmployeeHoursLocalitiesWhereUniqueInput
    update?: XOR<XOR<EmployeeHoursLocalitiesUpdateToOneWithWhereWithoutEmployeeHoursByLocalityInput, EmployeeHoursLocalitiesUpdateWithoutEmployeeHoursByLocalityInput>, EmployeeHoursLocalitiesUncheckedUpdateWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursUncheckedUpdateManyWithoutEmployeeHoursByLocalityNestedInput = {
    create?: XOR<EmployeeHoursCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUncheckedCreateWithoutEmployeeHoursByLocalityInput> | EmployeeHoursCreateWithoutEmployeeHoursByLocalityInput[] | EmployeeHoursUncheckedCreateWithoutEmployeeHoursByLocalityInput[]
    connectOrCreate?: EmployeeHoursCreateOrConnectWithoutEmployeeHoursByLocalityInput | EmployeeHoursCreateOrConnectWithoutEmployeeHoursByLocalityInput[]
    upsert?: EmployeeHoursUpsertWithWhereUniqueWithoutEmployeeHoursByLocalityInput | EmployeeHoursUpsertWithWhereUniqueWithoutEmployeeHoursByLocalityInput[]
    createMany?: EmployeeHoursCreateManyEmployeeHoursByLocalityInputEnvelope
    set?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    disconnect?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    delete?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    connect?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    update?: EmployeeHoursUpdateWithWhereUniqueWithoutEmployeeHoursByLocalityInput | EmployeeHoursUpdateWithWhereUniqueWithoutEmployeeHoursByLocalityInput[]
    updateMany?: EmployeeHoursUpdateManyWithWhereWithoutEmployeeHoursByLocalityInput | EmployeeHoursUpdateManyWithWhereWithoutEmployeeHoursByLocalityInput[]
    deleteMany?: EmployeeHoursScalarWhereInput | EmployeeHoursScalarWhereInput[]
  }

  export type EmployeeHoursLocalitiesCreateNestedOneWithoutEmployeeHoursByLocalityTotalsInput = {
    create?: XOR<EmployeeHoursLocalitiesCreateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursLocalitiesUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput>
    connectOrCreate?: EmployeeHoursLocalitiesCreateOrConnectWithoutEmployeeHoursByLocalityTotalsInput
    connect?: EmployeeHoursLocalitiesWhereUniqueInput
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCreateNestedManyWithoutEmployeeHoursByLocalityTotalsInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput> | EmployeeHoursByLocalityTotalsActionTypeCreateWithoutEmployeeHoursByLocalityTotalsInput[] | EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput[]
    connectOrCreate?: EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutEmployeeHoursByLocalityTotalsInput | EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutEmployeeHoursByLocalityTotalsInput[]
    createMany?: EmployeeHoursByLocalityTotalsActionTypeCreateManyEmployeeHoursByLocalityTotalsInputEnvelope
    connect?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateNestedManyWithoutEmployeeHoursByLocalityTotalsInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput> | EmployeeHoursByLocalityTotalsActionTypeCreateWithoutEmployeeHoursByLocalityTotalsInput[] | EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput[]
    connectOrCreate?: EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutEmployeeHoursByLocalityTotalsInput | EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutEmployeeHoursByLocalityTotalsInput[]
    createMany?: EmployeeHoursByLocalityTotalsActionTypeCreateManyEmployeeHoursByLocalityTotalsInputEnvelope
    connect?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
  }

  export type EmployeeHoursLocalitiesUpdateOneRequiredWithoutEmployeeHoursByLocalityTotalsNestedInput = {
    create?: XOR<EmployeeHoursLocalitiesCreateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursLocalitiesUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput>
    connectOrCreate?: EmployeeHoursLocalitiesCreateOrConnectWithoutEmployeeHoursByLocalityTotalsInput
    upsert?: EmployeeHoursLocalitiesUpsertWithoutEmployeeHoursByLocalityTotalsInput
    connect?: EmployeeHoursLocalitiesWhereUniqueInput
    update?: XOR<XOR<EmployeeHoursLocalitiesUpdateToOneWithWhereWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursLocalitiesUpdateWithoutEmployeeHoursByLocalityTotalsInput>, EmployeeHoursLocalitiesUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsInput>
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithoutEmployeeHoursByLocalityTotalsNestedInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput> | EmployeeHoursByLocalityTotalsActionTypeCreateWithoutEmployeeHoursByLocalityTotalsInput[] | EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput[]
    connectOrCreate?: EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutEmployeeHoursByLocalityTotalsInput | EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutEmployeeHoursByLocalityTotalsInput[]
    upsert?: EmployeeHoursByLocalityTotalsActionTypeUpsertWithWhereUniqueWithoutEmployeeHoursByLocalityTotalsInput | EmployeeHoursByLocalityTotalsActionTypeUpsertWithWhereUniqueWithoutEmployeeHoursByLocalityTotalsInput[]
    createMany?: EmployeeHoursByLocalityTotalsActionTypeCreateManyEmployeeHoursByLocalityTotalsInputEnvelope
    set?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    disconnect?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    delete?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    connect?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    update?: EmployeeHoursByLocalityTotalsActionTypeUpdateWithWhereUniqueWithoutEmployeeHoursByLocalityTotalsInput | EmployeeHoursByLocalityTotalsActionTypeUpdateWithWhereUniqueWithoutEmployeeHoursByLocalityTotalsInput[]
    updateMany?: EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithWhereWithoutEmployeeHoursByLocalityTotalsInput | EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithWhereWithoutEmployeeHoursByLocalityTotalsInput[]
    deleteMany?: EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput | EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput[]
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateManyWithoutEmployeeHoursByLocalityTotalsNestedInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput> | EmployeeHoursByLocalityTotalsActionTypeCreateWithoutEmployeeHoursByLocalityTotalsInput[] | EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput[]
    connectOrCreate?: EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutEmployeeHoursByLocalityTotalsInput | EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutEmployeeHoursByLocalityTotalsInput[]
    upsert?: EmployeeHoursByLocalityTotalsActionTypeUpsertWithWhereUniqueWithoutEmployeeHoursByLocalityTotalsInput | EmployeeHoursByLocalityTotalsActionTypeUpsertWithWhereUniqueWithoutEmployeeHoursByLocalityTotalsInput[]
    createMany?: EmployeeHoursByLocalityTotalsActionTypeCreateManyEmployeeHoursByLocalityTotalsInputEnvelope
    set?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    disconnect?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    delete?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    connect?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    update?: EmployeeHoursByLocalityTotalsActionTypeUpdateWithWhereUniqueWithoutEmployeeHoursByLocalityTotalsInput | EmployeeHoursByLocalityTotalsActionTypeUpdateWithWhereUniqueWithoutEmployeeHoursByLocalityTotalsInput[]
    updateMany?: EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithWhereWithoutEmployeeHoursByLocalityTotalsInput | EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithWhereWithoutEmployeeHoursByLocalityTotalsInput[]
    deleteMany?: EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput | EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput[]
  }

  export type Lkup_ActionTypeCreateNestedOneWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    create?: XOR<Lkup_ActionTypeCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput, Lkup_ActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
    connectOrCreate?: Lkup_ActionTypeCreateOrConnectWithoutEmployeeHoursByLocalityTotalsActionTypeInput
    connect?: Lkup_ActionTypeWhereUniqueInput
  }

  export type EmployeeHoursByLocalityTotalsCreateNestedOneWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput, EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
    connectOrCreate?: EmployeeHoursByLocalityTotalsCreateOrConnectWithoutEmployeeHoursByLocalityTotalsActionTypeInput
    connect?: EmployeeHoursByLocalityTotalsWhereUniqueInput
  }

  export type Lkup_ActionTypeUpdateOneRequiredWithoutEmployeeHoursByLocalityTotalsActionTypeNestedInput = {
    create?: XOR<Lkup_ActionTypeCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput, Lkup_ActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
    connectOrCreate?: Lkup_ActionTypeCreateOrConnectWithoutEmployeeHoursByLocalityTotalsActionTypeInput
    upsert?: Lkup_ActionTypeUpsertWithoutEmployeeHoursByLocalityTotalsActionTypeInput
    connect?: Lkup_ActionTypeWhereUniqueInput
    update?: XOR<XOR<Lkup_ActionTypeUpdateToOneWithWhereWithoutEmployeeHoursByLocalityTotalsActionTypeInput, Lkup_ActionTypeUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>, Lkup_ActionTypeUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
  }

  export type EmployeeHoursByLocalityTotalsUpdateOneRequiredWithoutEmployeeHoursByLocalityTotalsActionTypeNestedInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput, EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
    connectOrCreate?: EmployeeHoursByLocalityTotalsCreateOrConnectWithoutEmployeeHoursByLocalityTotalsActionTypeInput
    upsert?: EmployeeHoursByLocalityTotalsUpsertWithoutEmployeeHoursByLocalityTotalsActionTypeInput
    connect?: EmployeeHoursByLocalityTotalsWhereUniqueInput
    update?: XOR<XOR<EmployeeHoursByLocalityTotalsUpdateToOneWithWhereWithoutEmployeeHoursByLocalityTotalsActionTypeInput, EmployeeHoursByLocalityTotalsUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>, EmployeeHoursByLocalityTotalsUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
  }

  export type EmployeeHoursByLocalityCreateNestedManyWithoutEmployeeHoursContractsInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursContractsInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursContractsInput> | EmployeeHoursByLocalityCreateWithoutEmployeeHoursContractsInput[] | EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursContractsInput[]
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursContractsInput | EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursContractsInput[]
    createMany?: EmployeeHoursByLocalityCreateManyEmployeeHoursContractsInputEnvelope
    connect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
  }

  export type EmployeeHoursByLocalityUncheckedCreateNestedManyWithoutEmployeeHoursContractsInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursContractsInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursContractsInput> | EmployeeHoursByLocalityCreateWithoutEmployeeHoursContractsInput[] | EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursContractsInput[]
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursContractsInput | EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursContractsInput[]
    createMany?: EmployeeHoursByLocalityCreateManyEmployeeHoursContractsInputEnvelope
    connect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
  }

  export type EmployeeHoursByLocalityUpdateManyWithoutEmployeeHoursContractsNestedInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursContractsInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursContractsInput> | EmployeeHoursByLocalityCreateWithoutEmployeeHoursContractsInput[] | EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursContractsInput[]
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursContractsInput | EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursContractsInput[]
    upsert?: EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursContractsInput | EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursContractsInput[]
    createMany?: EmployeeHoursByLocalityCreateManyEmployeeHoursContractsInputEnvelope
    set?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    disconnect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    delete?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    connect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    update?: EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursContractsInput | EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursContractsInput[]
    updateMany?: EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursContractsInput | EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursContractsInput[]
    deleteMany?: EmployeeHoursByLocalityScalarWhereInput | EmployeeHoursByLocalityScalarWhereInput[]
  }

  export type EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursContractsNestedInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursContractsInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursContractsInput> | EmployeeHoursByLocalityCreateWithoutEmployeeHoursContractsInput[] | EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursContractsInput[]
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursContractsInput | EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursContractsInput[]
    upsert?: EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursContractsInput | EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursContractsInput[]
    createMany?: EmployeeHoursByLocalityCreateManyEmployeeHoursContractsInputEnvelope
    set?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    disconnect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    delete?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    connect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    update?: EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursContractsInput | EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursContractsInput[]
    updateMany?: EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursContractsInput | EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursContractsInput[]
    deleteMany?: EmployeeHoursByLocalityScalarWhereInput | EmployeeHoursByLocalityScalarWhereInput[]
  }

  export type EmployeeHoursByLocalityCreateNestedManyWithoutEmployeeHoursLocalitiesInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursLocalitiesInput> | EmployeeHoursByLocalityCreateWithoutEmployeeHoursLocalitiesInput[] | EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursLocalitiesInput[]
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursLocalitiesInput[]
    createMany?: EmployeeHoursByLocalityCreateManyEmployeeHoursLocalitiesInputEnvelope
    connect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
  }

  export type EmployeeHoursByLocalityTotalsCreateNestedManyWithoutEmployeeHoursLocalitiesInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursLocalitiesInput> | EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursLocalitiesInput[] | EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursLocalitiesInput[]
    connectOrCreate?: EmployeeHoursByLocalityTotalsCreateOrConnectWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityTotalsCreateOrConnectWithoutEmployeeHoursLocalitiesInput[]
    createMany?: EmployeeHoursByLocalityTotalsCreateManyEmployeeHoursLocalitiesInputEnvelope
    connect?: EmployeeHoursByLocalityTotalsWhereUniqueInput | EmployeeHoursByLocalityTotalsWhereUniqueInput[]
  }

  export type EmployeeHoursByLocalityUncheckedCreateNestedManyWithoutEmployeeHoursLocalitiesInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursLocalitiesInput> | EmployeeHoursByLocalityCreateWithoutEmployeeHoursLocalitiesInput[] | EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursLocalitiesInput[]
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursLocalitiesInput[]
    createMany?: EmployeeHoursByLocalityCreateManyEmployeeHoursLocalitiesInputEnvelope
    connect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
  }

  export type EmployeeHoursByLocalityTotalsUncheckedCreateNestedManyWithoutEmployeeHoursLocalitiesInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursLocalitiesInput> | EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursLocalitiesInput[] | EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursLocalitiesInput[]
    connectOrCreate?: EmployeeHoursByLocalityTotalsCreateOrConnectWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityTotalsCreateOrConnectWithoutEmployeeHoursLocalitiesInput[]
    createMany?: EmployeeHoursByLocalityTotalsCreateManyEmployeeHoursLocalitiesInputEnvelope
    connect?: EmployeeHoursByLocalityTotalsWhereUniqueInput | EmployeeHoursByLocalityTotalsWhereUniqueInput[]
  }

  export type EmployeeHoursByLocalityUpdateManyWithoutEmployeeHoursLocalitiesNestedInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursLocalitiesInput> | EmployeeHoursByLocalityCreateWithoutEmployeeHoursLocalitiesInput[] | EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursLocalitiesInput[]
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursLocalitiesInput[]
    upsert?: EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursLocalitiesInput[]
    createMany?: EmployeeHoursByLocalityCreateManyEmployeeHoursLocalitiesInputEnvelope
    set?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    disconnect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    delete?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    connect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    update?: EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursLocalitiesInput[]
    updateMany?: EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursLocalitiesInput[]
    deleteMany?: EmployeeHoursByLocalityScalarWhereInput | EmployeeHoursByLocalityScalarWhereInput[]
  }

  export type EmployeeHoursByLocalityTotalsUpdateManyWithoutEmployeeHoursLocalitiesNestedInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursLocalitiesInput> | EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursLocalitiesInput[] | EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursLocalitiesInput[]
    connectOrCreate?: EmployeeHoursByLocalityTotalsCreateOrConnectWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityTotalsCreateOrConnectWithoutEmployeeHoursLocalitiesInput[]
    upsert?: EmployeeHoursByLocalityTotalsUpsertWithWhereUniqueWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityTotalsUpsertWithWhereUniqueWithoutEmployeeHoursLocalitiesInput[]
    createMany?: EmployeeHoursByLocalityTotalsCreateManyEmployeeHoursLocalitiesInputEnvelope
    set?: EmployeeHoursByLocalityTotalsWhereUniqueInput | EmployeeHoursByLocalityTotalsWhereUniqueInput[]
    disconnect?: EmployeeHoursByLocalityTotalsWhereUniqueInput | EmployeeHoursByLocalityTotalsWhereUniqueInput[]
    delete?: EmployeeHoursByLocalityTotalsWhereUniqueInput | EmployeeHoursByLocalityTotalsWhereUniqueInput[]
    connect?: EmployeeHoursByLocalityTotalsWhereUniqueInput | EmployeeHoursByLocalityTotalsWhereUniqueInput[]
    update?: EmployeeHoursByLocalityTotalsUpdateWithWhereUniqueWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityTotalsUpdateWithWhereUniqueWithoutEmployeeHoursLocalitiesInput[]
    updateMany?: EmployeeHoursByLocalityTotalsUpdateManyWithWhereWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityTotalsUpdateManyWithWhereWithoutEmployeeHoursLocalitiesInput[]
    deleteMany?: EmployeeHoursByLocalityTotalsScalarWhereInput | EmployeeHoursByLocalityTotalsScalarWhereInput[]
  }

  export type EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursLocalitiesNestedInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursLocalitiesInput> | EmployeeHoursByLocalityCreateWithoutEmployeeHoursLocalitiesInput[] | EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursLocalitiesInput[]
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursLocalitiesInput[]
    upsert?: EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursLocalitiesInput[]
    createMany?: EmployeeHoursByLocalityCreateManyEmployeeHoursLocalitiesInputEnvelope
    set?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    disconnect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    delete?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    connect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    update?: EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursLocalitiesInput[]
    updateMany?: EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursLocalitiesInput[]
    deleteMany?: EmployeeHoursByLocalityScalarWhereInput | EmployeeHoursByLocalityScalarWhereInput[]
  }

  export type EmployeeHoursByLocalityTotalsUncheckedUpdateManyWithoutEmployeeHoursLocalitiesNestedInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursLocalitiesInput> | EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursLocalitiesInput[] | EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursLocalitiesInput[]
    connectOrCreate?: EmployeeHoursByLocalityTotalsCreateOrConnectWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityTotalsCreateOrConnectWithoutEmployeeHoursLocalitiesInput[]
    upsert?: EmployeeHoursByLocalityTotalsUpsertWithWhereUniqueWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityTotalsUpsertWithWhereUniqueWithoutEmployeeHoursLocalitiesInput[]
    createMany?: EmployeeHoursByLocalityTotalsCreateManyEmployeeHoursLocalitiesInputEnvelope
    set?: EmployeeHoursByLocalityTotalsWhereUniqueInput | EmployeeHoursByLocalityTotalsWhereUniqueInput[]
    disconnect?: EmployeeHoursByLocalityTotalsWhereUniqueInput | EmployeeHoursByLocalityTotalsWhereUniqueInput[]
    delete?: EmployeeHoursByLocalityTotalsWhereUniqueInput | EmployeeHoursByLocalityTotalsWhereUniqueInput[]
    connect?: EmployeeHoursByLocalityTotalsWhereUniqueInput | EmployeeHoursByLocalityTotalsWhereUniqueInput[]
    update?: EmployeeHoursByLocalityTotalsUpdateWithWhereUniqueWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityTotalsUpdateWithWhereUniqueWithoutEmployeeHoursLocalitiesInput[]
    updateMany?: EmployeeHoursByLocalityTotalsUpdateManyWithWhereWithoutEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityTotalsUpdateManyWithWhereWithoutEmployeeHoursLocalitiesInput[]
    deleteMany?: EmployeeHoursByLocalityTotalsScalarWhereInput | EmployeeHoursByLocalityTotalsScalarWhereInput[]
  }

  export type EmployeeHoursByLocalityCreateNestedManyWithoutEmployeeHoursUsersInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursUsersInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursUsersInput> | EmployeeHoursByLocalityCreateWithoutEmployeeHoursUsersInput[] | EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursUsersInput[]
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursUsersInput | EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursUsersInput[]
    createMany?: EmployeeHoursByLocalityCreateManyEmployeeHoursUsersInputEnvelope
    connect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
  }

  export type EmployeeHoursByLocalityUncheckedCreateNestedManyWithoutEmployeeHoursUsersInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursUsersInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursUsersInput> | EmployeeHoursByLocalityCreateWithoutEmployeeHoursUsersInput[] | EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursUsersInput[]
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursUsersInput | EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursUsersInput[]
    createMany?: EmployeeHoursByLocalityCreateManyEmployeeHoursUsersInputEnvelope
    connect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
  }

  export type EmployeeHoursByLocalityUpdateManyWithoutEmployeeHoursUsersNestedInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursUsersInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursUsersInput> | EmployeeHoursByLocalityCreateWithoutEmployeeHoursUsersInput[] | EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursUsersInput[]
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursUsersInput | EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursUsersInput[]
    upsert?: EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursUsersInput | EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursUsersInput[]
    createMany?: EmployeeHoursByLocalityCreateManyEmployeeHoursUsersInputEnvelope
    set?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    disconnect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    delete?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    connect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    update?: EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursUsersInput | EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursUsersInput[]
    updateMany?: EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursUsersInput | EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursUsersInput[]
    deleteMany?: EmployeeHoursByLocalityScalarWhereInput | EmployeeHoursByLocalityScalarWhereInput[]
  }

  export type EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursUsersNestedInput = {
    create?: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursUsersInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursUsersInput> | EmployeeHoursByLocalityCreateWithoutEmployeeHoursUsersInput[] | EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursUsersInput[]
    connectOrCreate?: EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursUsersInput | EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursUsersInput[]
    upsert?: EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursUsersInput | EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursUsersInput[]
    createMany?: EmployeeHoursByLocalityCreateManyEmployeeHoursUsersInputEnvelope
    set?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    disconnect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    delete?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    connect?: EmployeeHoursByLocalityWhereUniqueInput | EmployeeHoursByLocalityWhereUniqueInput[]
    update?: EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursUsersInput | EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursUsersInput[]
    updateMany?: EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursUsersInput | EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursUsersInput[]
    deleteMany?: EmployeeHoursByLocalityScalarWhereInput | EmployeeHoursByLocalityScalarWhereInput[]
  }

  export type EmployeeHoursCreateNestedManyWithoutLkup_ActionTypeInput = {
    create?: XOR<EmployeeHoursCreateWithoutLkup_ActionTypeInput, EmployeeHoursUncheckedCreateWithoutLkup_ActionTypeInput> | EmployeeHoursCreateWithoutLkup_ActionTypeInput[] | EmployeeHoursUncheckedCreateWithoutLkup_ActionTypeInput[]
    connectOrCreate?: EmployeeHoursCreateOrConnectWithoutLkup_ActionTypeInput | EmployeeHoursCreateOrConnectWithoutLkup_ActionTypeInput[]
    createMany?: EmployeeHoursCreateManyLkup_ActionTypeInputEnvelope
    connect?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCreateNestedManyWithoutLkup_ActionTypeInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateWithoutLkup_ActionTypeInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutLkup_ActionTypeInput> | EmployeeHoursByLocalityTotalsActionTypeCreateWithoutLkup_ActionTypeInput[] | EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutLkup_ActionTypeInput[]
    connectOrCreate?: EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutLkup_ActionTypeInput | EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutLkup_ActionTypeInput[]
    createMany?: EmployeeHoursByLocalityTotalsActionTypeCreateManyLkup_ActionTypeInputEnvelope
    connect?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
  }

  export type EmployeeHoursUncheckedCreateNestedManyWithoutLkup_ActionTypeInput = {
    create?: XOR<EmployeeHoursCreateWithoutLkup_ActionTypeInput, EmployeeHoursUncheckedCreateWithoutLkup_ActionTypeInput> | EmployeeHoursCreateWithoutLkup_ActionTypeInput[] | EmployeeHoursUncheckedCreateWithoutLkup_ActionTypeInput[]
    connectOrCreate?: EmployeeHoursCreateOrConnectWithoutLkup_ActionTypeInput | EmployeeHoursCreateOrConnectWithoutLkup_ActionTypeInput[]
    createMany?: EmployeeHoursCreateManyLkup_ActionTypeInputEnvelope
    connect?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateNestedManyWithoutLkup_ActionTypeInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateWithoutLkup_ActionTypeInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutLkup_ActionTypeInput> | EmployeeHoursByLocalityTotalsActionTypeCreateWithoutLkup_ActionTypeInput[] | EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutLkup_ActionTypeInput[]
    connectOrCreate?: EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutLkup_ActionTypeInput | EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutLkup_ActionTypeInput[]
    createMany?: EmployeeHoursByLocalityTotalsActionTypeCreateManyLkup_ActionTypeInputEnvelope
    connect?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
  }

  export type EmployeeHoursUpdateManyWithoutLkup_ActionTypeNestedInput = {
    create?: XOR<EmployeeHoursCreateWithoutLkup_ActionTypeInput, EmployeeHoursUncheckedCreateWithoutLkup_ActionTypeInput> | EmployeeHoursCreateWithoutLkup_ActionTypeInput[] | EmployeeHoursUncheckedCreateWithoutLkup_ActionTypeInput[]
    connectOrCreate?: EmployeeHoursCreateOrConnectWithoutLkup_ActionTypeInput | EmployeeHoursCreateOrConnectWithoutLkup_ActionTypeInput[]
    upsert?: EmployeeHoursUpsertWithWhereUniqueWithoutLkup_ActionTypeInput | EmployeeHoursUpsertWithWhereUniqueWithoutLkup_ActionTypeInput[]
    createMany?: EmployeeHoursCreateManyLkup_ActionTypeInputEnvelope
    set?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    disconnect?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    delete?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    connect?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    update?: EmployeeHoursUpdateWithWhereUniqueWithoutLkup_ActionTypeInput | EmployeeHoursUpdateWithWhereUniqueWithoutLkup_ActionTypeInput[]
    updateMany?: EmployeeHoursUpdateManyWithWhereWithoutLkup_ActionTypeInput | EmployeeHoursUpdateManyWithWhereWithoutLkup_ActionTypeInput[]
    deleteMany?: EmployeeHoursScalarWhereInput | EmployeeHoursScalarWhereInput[]
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithoutLkup_ActionTypeNestedInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateWithoutLkup_ActionTypeInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutLkup_ActionTypeInput> | EmployeeHoursByLocalityTotalsActionTypeCreateWithoutLkup_ActionTypeInput[] | EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutLkup_ActionTypeInput[]
    connectOrCreate?: EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutLkup_ActionTypeInput | EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutLkup_ActionTypeInput[]
    upsert?: EmployeeHoursByLocalityTotalsActionTypeUpsertWithWhereUniqueWithoutLkup_ActionTypeInput | EmployeeHoursByLocalityTotalsActionTypeUpsertWithWhereUniqueWithoutLkup_ActionTypeInput[]
    createMany?: EmployeeHoursByLocalityTotalsActionTypeCreateManyLkup_ActionTypeInputEnvelope
    set?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    disconnect?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    delete?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    connect?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    update?: EmployeeHoursByLocalityTotalsActionTypeUpdateWithWhereUniqueWithoutLkup_ActionTypeInput | EmployeeHoursByLocalityTotalsActionTypeUpdateWithWhereUniqueWithoutLkup_ActionTypeInput[]
    updateMany?: EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithWhereWithoutLkup_ActionTypeInput | EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithWhereWithoutLkup_ActionTypeInput[]
    deleteMany?: EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput | EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput[]
  }

  export type EmployeeHoursUncheckedUpdateManyWithoutLkup_ActionTypeNestedInput = {
    create?: XOR<EmployeeHoursCreateWithoutLkup_ActionTypeInput, EmployeeHoursUncheckedCreateWithoutLkup_ActionTypeInput> | EmployeeHoursCreateWithoutLkup_ActionTypeInput[] | EmployeeHoursUncheckedCreateWithoutLkup_ActionTypeInput[]
    connectOrCreate?: EmployeeHoursCreateOrConnectWithoutLkup_ActionTypeInput | EmployeeHoursCreateOrConnectWithoutLkup_ActionTypeInput[]
    upsert?: EmployeeHoursUpsertWithWhereUniqueWithoutLkup_ActionTypeInput | EmployeeHoursUpsertWithWhereUniqueWithoutLkup_ActionTypeInput[]
    createMany?: EmployeeHoursCreateManyLkup_ActionTypeInputEnvelope
    set?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    disconnect?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    delete?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    connect?: EmployeeHoursWhereUniqueInput | EmployeeHoursWhereUniqueInput[]
    update?: EmployeeHoursUpdateWithWhereUniqueWithoutLkup_ActionTypeInput | EmployeeHoursUpdateWithWhereUniqueWithoutLkup_ActionTypeInput[]
    updateMany?: EmployeeHoursUpdateManyWithWhereWithoutLkup_ActionTypeInput | EmployeeHoursUpdateManyWithWhereWithoutLkup_ActionTypeInput[]
    deleteMany?: EmployeeHoursScalarWhereInput | EmployeeHoursScalarWhereInput[]
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateManyWithoutLkup_ActionTypeNestedInput = {
    create?: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateWithoutLkup_ActionTypeInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutLkup_ActionTypeInput> | EmployeeHoursByLocalityTotalsActionTypeCreateWithoutLkup_ActionTypeInput[] | EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutLkup_ActionTypeInput[]
    connectOrCreate?: EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutLkup_ActionTypeInput | EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutLkup_ActionTypeInput[]
    upsert?: EmployeeHoursByLocalityTotalsActionTypeUpsertWithWhereUniqueWithoutLkup_ActionTypeInput | EmployeeHoursByLocalityTotalsActionTypeUpsertWithWhereUniqueWithoutLkup_ActionTypeInput[]
    createMany?: EmployeeHoursByLocalityTotalsActionTypeCreateManyLkup_ActionTypeInputEnvelope
    set?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    disconnect?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    delete?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    connect?: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput | EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput[]
    update?: EmployeeHoursByLocalityTotalsActionTypeUpdateWithWhereUniqueWithoutLkup_ActionTypeInput | EmployeeHoursByLocalityTotalsActionTypeUpdateWithWhereUniqueWithoutLkup_ActionTypeInput[]
    updateMany?: EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithWhereWithoutLkup_ActionTypeInput | EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithWhereWithoutLkup_ActionTypeInput[]
    deleteMany?: EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput | EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput[]
  }

  export type MessagesEmployeesCreateNestedOneWithoutOther_MessagesEmployeesInput = {
    create?: XOR<MessagesEmployeesCreateWithoutOther_MessagesEmployeesInput, MessagesEmployeesUncheckedCreateWithoutOther_MessagesEmployeesInput>
    connectOrCreate?: MessagesEmployeesCreateOrConnectWithoutOther_MessagesEmployeesInput
    connect?: MessagesEmployeesWhereUniqueInput
  }

  export type MessagesEmployeesCreateNestedManyWithoutMessagesEmployeesInput = {
    create?: XOR<MessagesEmployeesCreateWithoutMessagesEmployeesInput, MessagesEmployeesUncheckedCreateWithoutMessagesEmployeesInput> | MessagesEmployeesCreateWithoutMessagesEmployeesInput[] | MessagesEmployeesUncheckedCreateWithoutMessagesEmployeesInput[]
    connectOrCreate?: MessagesEmployeesCreateOrConnectWithoutMessagesEmployeesInput | MessagesEmployeesCreateOrConnectWithoutMessagesEmployeesInput[]
    createMany?: MessagesEmployeesCreateManyMessagesEmployeesInputEnvelope
    connect?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
  }

  export type MessagesStatusCreateNestedOneWithoutMessagesEmployeesInput = {
    create?: XOR<MessagesStatusCreateWithoutMessagesEmployeesInput, MessagesStatusUncheckedCreateWithoutMessagesEmployeesInput>
    connectOrCreate?: MessagesStatusCreateOrConnectWithoutMessagesEmployeesInput
    connect?: MessagesStatusWhereUniqueInput
  }

  export type MessagesEmployeesUncheckedCreateNestedManyWithoutMessagesEmployeesInput = {
    create?: XOR<MessagesEmployeesCreateWithoutMessagesEmployeesInput, MessagesEmployeesUncheckedCreateWithoutMessagesEmployeesInput> | MessagesEmployeesCreateWithoutMessagesEmployeesInput[] | MessagesEmployeesUncheckedCreateWithoutMessagesEmployeesInput[]
    connectOrCreate?: MessagesEmployeesCreateOrConnectWithoutMessagesEmployeesInput | MessagesEmployeesCreateOrConnectWithoutMessagesEmployeesInput[]
    createMany?: MessagesEmployeesCreateManyMessagesEmployeesInputEnvelope
    connect?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
  }

  export type MessagesEmployeesUpdateOneWithoutOther_MessagesEmployeesNestedInput = {
    create?: XOR<MessagesEmployeesCreateWithoutOther_MessagesEmployeesInput, MessagesEmployeesUncheckedCreateWithoutOther_MessagesEmployeesInput>
    connectOrCreate?: MessagesEmployeesCreateOrConnectWithoutOther_MessagesEmployeesInput
    upsert?: MessagesEmployeesUpsertWithoutOther_MessagesEmployeesInput
    disconnect?: MessagesEmployeesWhereInput | boolean
    delete?: MessagesEmployeesWhereInput | boolean
    connect?: MessagesEmployeesWhereUniqueInput
    update?: XOR<XOR<MessagesEmployeesUpdateToOneWithWhereWithoutOther_MessagesEmployeesInput, MessagesEmployeesUpdateWithoutOther_MessagesEmployeesInput>, MessagesEmployeesUncheckedUpdateWithoutOther_MessagesEmployeesInput>
  }

  export type MessagesEmployeesUpdateManyWithoutMessagesEmployeesNestedInput = {
    create?: XOR<MessagesEmployeesCreateWithoutMessagesEmployeesInput, MessagesEmployeesUncheckedCreateWithoutMessagesEmployeesInput> | MessagesEmployeesCreateWithoutMessagesEmployeesInput[] | MessagesEmployeesUncheckedCreateWithoutMessagesEmployeesInput[]
    connectOrCreate?: MessagesEmployeesCreateOrConnectWithoutMessagesEmployeesInput | MessagesEmployeesCreateOrConnectWithoutMessagesEmployeesInput[]
    upsert?: MessagesEmployeesUpsertWithWhereUniqueWithoutMessagesEmployeesInput | MessagesEmployeesUpsertWithWhereUniqueWithoutMessagesEmployeesInput[]
    createMany?: MessagesEmployeesCreateManyMessagesEmployeesInputEnvelope
    set?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    disconnect?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    delete?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    connect?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    update?: MessagesEmployeesUpdateWithWhereUniqueWithoutMessagesEmployeesInput | MessagesEmployeesUpdateWithWhereUniqueWithoutMessagesEmployeesInput[]
    updateMany?: MessagesEmployeesUpdateManyWithWhereWithoutMessagesEmployeesInput | MessagesEmployeesUpdateManyWithWhereWithoutMessagesEmployeesInput[]
    deleteMany?: MessagesEmployeesScalarWhereInput | MessagesEmployeesScalarWhereInput[]
  }

  export type MessagesStatusUpdateOneRequiredWithoutMessagesEmployeesNestedInput = {
    create?: XOR<MessagesStatusCreateWithoutMessagesEmployeesInput, MessagesStatusUncheckedCreateWithoutMessagesEmployeesInput>
    connectOrCreate?: MessagesStatusCreateOrConnectWithoutMessagesEmployeesInput
    upsert?: MessagesStatusUpsertWithoutMessagesEmployeesInput
    connect?: MessagesStatusWhereUniqueInput
    update?: XOR<XOR<MessagesStatusUpdateToOneWithWhereWithoutMessagesEmployeesInput, MessagesStatusUpdateWithoutMessagesEmployeesInput>, MessagesStatusUncheckedUpdateWithoutMessagesEmployeesInput>
  }

  export type MessagesEmployeesUncheckedUpdateManyWithoutMessagesEmployeesNestedInput = {
    create?: XOR<MessagesEmployeesCreateWithoutMessagesEmployeesInput, MessagesEmployeesUncheckedCreateWithoutMessagesEmployeesInput> | MessagesEmployeesCreateWithoutMessagesEmployeesInput[] | MessagesEmployeesUncheckedCreateWithoutMessagesEmployeesInput[]
    connectOrCreate?: MessagesEmployeesCreateOrConnectWithoutMessagesEmployeesInput | MessagesEmployeesCreateOrConnectWithoutMessagesEmployeesInput[]
    upsert?: MessagesEmployeesUpsertWithWhereUniqueWithoutMessagesEmployeesInput | MessagesEmployeesUpsertWithWhereUniqueWithoutMessagesEmployeesInput[]
    createMany?: MessagesEmployeesCreateManyMessagesEmployeesInputEnvelope
    set?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    disconnect?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    delete?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    connect?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    update?: MessagesEmployeesUpdateWithWhereUniqueWithoutMessagesEmployeesInput | MessagesEmployeesUpdateWithWhereUniqueWithoutMessagesEmployeesInput[]
    updateMany?: MessagesEmployeesUpdateManyWithWhereWithoutMessagesEmployeesInput | MessagesEmployeesUpdateManyWithWhereWithoutMessagesEmployeesInput[]
    deleteMany?: MessagesEmployeesScalarWhereInput | MessagesEmployeesScalarWhereInput[]
  }

  export type MessagesEmployeesCreateNestedManyWithoutMessagesStatusInput = {
    create?: XOR<MessagesEmployeesCreateWithoutMessagesStatusInput, MessagesEmployeesUncheckedCreateWithoutMessagesStatusInput> | MessagesEmployeesCreateWithoutMessagesStatusInput[] | MessagesEmployeesUncheckedCreateWithoutMessagesStatusInput[]
    connectOrCreate?: MessagesEmployeesCreateOrConnectWithoutMessagesStatusInput | MessagesEmployeesCreateOrConnectWithoutMessagesStatusInput[]
    createMany?: MessagesEmployeesCreateManyMessagesStatusInputEnvelope
    connect?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
  }

  export type MessagesEmployeesUncheckedCreateNestedManyWithoutMessagesStatusInput = {
    create?: XOR<MessagesEmployeesCreateWithoutMessagesStatusInput, MessagesEmployeesUncheckedCreateWithoutMessagesStatusInput> | MessagesEmployeesCreateWithoutMessagesStatusInput[] | MessagesEmployeesUncheckedCreateWithoutMessagesStatusInput[]
    connectOrCreate?: MessagesEmployeesCreateOrConnectWithoutMessagesStatusInput | MessagesEmployeesCreateOrConnectWithoutMessagesStatusInput[]
    createMany?: MessagesEmployeesCreateManyMessagesStatusInputEnvelope
    connect?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
  }

  export type MessagesEmployeesUpdateManyWithoutMessagesStatusNestedInput = {
    create?: XOR<MessagesEmployeesCreateWithoutMessagesStatusInput, MessagesEmployeesUncheckedCreateWithoutMessagesStatusInput> | MessagesEmployeesCreateWithoutMessagesStatusInput[] | MessagesEmployeesUncheckedCreateWithoutMessagesStatusInput[]
    connectOrCreate?: MessagesEmployeesCreateOrConnectWithoutMessagesStatusInput | MessagesEmployeesCreateOrConnectWithoutMessagesStatusInput[]
    upsert?: MessagesEmployeesUpsertWithWhereUniqueWithoutMessagesStatusInput | MessagesEmployeesUpsertWithWhereUniqueWithoutMessagesStatusInput[]
    createMany?: MessagesEmployeesCreateManyMessagesStatusInputEnvelope
    set?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    disconnect?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    delete?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    connect?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    update?: MessagesEmployeesUpdateWithWhereUniqueWithoutMessagesStatusInput | MessagesEmployeesUpdateWithWhereUniqueWithoutMessagesStatusInput[]
    updateMany?: MessagesEmployeesUpdateManyWithWhereWithoutMessagesStatusInput | MessagesEmployeesUpdateManyWithWhereWithoutMessagesStatusInput[]
    deleteMany?: MessagesEmployeesScalarWhereInput | MessagesEmployeesScalarWhereInput[]
  }

  export type MessagesEmployeesUncheckedUpdateManyWithoutMessagesStatusNestedInput = {
    create?: XOR<MessagesEmployeesCreateWithoutMessagesStatusInput, MessagesEmployeesUncheckedCreateWithoutMessagesStatusInput> | MessagesEmployeesCreateWithoutMessagesStatusInput[] | MessagesEmployeesUncheckedCreateWithoutMessagesStatusInput[]
    connectOrCreate?: MessagesEmployeesCreateOrConnectWithoutMessagesStatusInput | MessagesEmployeesCreateOrConnectWithoutMessagesStatusInput[]
    upsert?: MessagesEmployeesUpsertWithWhereUniqueWithoutMessagesStatusInput | MessagesEmployeesUpsertWithWhereUniqueWithoutMessagesStatusInput[]
    createMany?: MessagesEmployeesCreateManyMessagesStatusInputEnvelope
    set?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    disconnect?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    delete?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    connect?: MessagesEmployeesWhereUniqueInput | MessagesEmployeesWhereUniqueInput[]
    update?: MessagesEmployeesUpdateWithWhereUniqueWithoutMessagesStatusInput | MessagesEmployeesUpdateWithWhereUniqueWithoutMessagesStatusInput[]
    updateMany?: MessagesEmployeesUpdateManyWithWhereWithoutMessagesStatusInput | MessagesEmployeesUpdateManyWithWhereWithoutMessagesStatusInput[]
    deleteMany?: MessagesEmployeesScalarWhereInput | MessagesEmployeesScalarWhereInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type UserViewRolesCreateNestedOneWithoutUsersLinkedViewRoleInput = {
    create?: XOR<UserViewRolesCreateWithoutUsersLinkedViewRoleInput, UserViewRolesUncheckedCreateWithoutUsersLinkedViewRoleInput>
    connectOrCreate?: UserViewRolesCreateOrConnectWithoutUsersLinkedViewRoleInput
    connect?: UserViewRolesWhereUniqueInput
  }

  export type UserViewRolesUpdateOneRequiredWithoutUsersLinkedViewRoleNestedInput = {
    create?: XOR<UserViewRolesCreateWithoutUsersLinkedViewRoleInput, UserViewRolesUncheckedCreateWithoutUsersLinkedViewRoleInput>
    connectOrCreate?: UserViewRolesCreateOrConnectWithoutUsersLinkedViewRoleInput
    upsert?: UserViewRolesUpsertWithoutUsersLinkedViewRoleInput
    connect?: UserViewRolesWhereUniqueInput
    update?: XOR<XOR<UserViewRolesUpdateToOneWithWhereWithoutUsersLinkedViewRoleInput, UserViewRolesUpdateWithoutUsersLinkedViewRoleInput>, UserViewRolesUncheckedUpdateWithoutUsersLinkedViewRoleInput>
  }

  export type UsersLinkedViewRoleCreateNestedManyWithoutUserViewRolesInput = {
    create?: XOR<UsersLinkedViewRoleCreateWithoutUserViewRolesInput, UsersLinkedViewRoleUncheckedCreateWithoutUserViewRolesInput> | UsersLinkedViewRoleCreateWithoutUserViewRolesInput[] | UsersLinkedViewRoleUncheckedCreateWithoutUserViewRolesInput[]
    connectOrCreate?: UsersLinkedViewRoleCreateOrConnectWithoutUserViewRolesInput | UsersLinkedViewRoleCreateOrConnectWithoutUserViewRolesInput[]
    createMany?: UsersLinkedViewRoleCreateManyUserViewRolesInputEnvelope
    connect?: UsersLinkedViewRoleWhereUniqueInput | UsersLinkedViewRoleWhereUniqueInput[]
  }

  export type UsersLinkedViewRoleUncheckedCreateNestedManyWithoutUserViewRolesInput = {
    create?: XOR<UsersLinkedViewRoleCreateWithoutUserViewRolesInput, UsersLinkedViewRoleUncheckedCreateWithoutUserViewRolesInput> | UsersLinkedViewRoleCreateWithoutUserViewRolesInput[] | UsersLinkedViewRoleUncheckedCreateWithoutUserViewRolesInput[]
    connectOrCreate?: UsersLinkedViewRoleCreateOrConnectWithoutUserViewRolesInput | UsersLinkedViewRoleCreateOrConnectWithoutUserViewRolesInput[]
    createMany?: UsersLinkedViewRoleCreateManyUserViewRolesInputEnvelope
    connect?: UsersLinkedViewRoleWhereUniqueInput | UsersLinkedViewRoleWhereUniqueInput[]
  }

  export type UsersLinkedViewRoleUpdateManyWithoutUserViewRolesNestedInput = {
    create?: XOR<UsersLinkedViewRoleCreateWithoutUserViewRolesInput, UsersLinkedViewRoleUncheckedCreateWithoutUserViewRolesInput> | UsersLinkedViewRoleCreateWithoutUserViewRolesInput[] | UsersLinkedViewRoleUncheckedCreateWithoutUserViewRolesInput[]
    connectOrCreate?: UsersLinkedViewRoleCreateOrConnectWithoutUserViewRolesInput | UsersLinkedViewRoleCreateOrConnectWithoutUserViewRolesInput[]
    upsert?: UsersLinkedViewRoleUpsertWithWhereUniqueWithoutUserViewRolesInput | UsersLinkedViewRoleUpsertWithWhereUniqueWithoutUserViewRolesInput[]
    createMany?: UsersLinkedViewRoleCreateManyUserViewRolesInputEnvelope
    set?: UsersLinkedViewRoleWhereUniqueInput | UsersLinkedViewRoleWhereUniqueInput[]
    disconnect?: UsersLinkedViewRoleWhereUniqueInput | UsersLinkedViewRoleWhereUniqueInput[]
    delete?: UsersLinkedViewRoleWhereUniqueInput | UsersLinkedViewRoleWhereUniqueInput[]
    connect?: UsersLinkedViewRoleWhereUniqueInput | UsersLinkedViewRoleWhereUniqueInput[]
    update?: UsersLinkedViewRoleUpdateWithWhereUniqueWithoutUserViewRolesInput | UsersLinkedViewRoleUpdateWithWhereUniqueWithoutUserViewRolesInput[]
    updateMany?: UsersLinkedViewRoleUpdateManyWithWhereWithoutUserViewRolesInput | UsersLinkedViewRoleUpdateManyWithWhereWithoutUserViewRolesInput[]
    deleteMany?: UsersLinkedViewRoleScalarWhereInput | UsersLinkedViewRoleScalarWhereInput[]
  }

  export type UsersLinkedViewRoleUncheckedUpdateManyWithoutUserViewRolesNestedInput = {
    create?: XOR<UsersLinkedViewRoleCreateWithoutUserViewRolesInput, UsersLinkedViewRoleUncheckedCreateWithoutUserViewRolesInput> | UsersLinkedViewRoleCreateWithoutUserViewRolesInput[] | UsersLinkedViewRoleUncheckedCreateWithoutUserViewRolesInput[]
    connectOrCreate?: UsersLinkedViewRoleCreateOrConnectWithoutUserViewRolesInput | UsersLinkedViewRoleCreateOrConnectWithoutUserViewRolesInput[]
    upsert?: UsersLinkedViewRoleUpsertWithWhereUniqueWithoutUserViewRolesInput | UsersLinkedViewRoleUpsertWithWhereUniqueWithoutUserViewRolesInput[]
    createMany?: UsersLinkedViewRoleCreateManyUserViewRolesInputEnvelope
    set?: UsersLinkedViewRoleWhereUniqueInput | UsersLinkedViewRoleWhereUniqueInput[]
    disconnect?: UsersLinkedViewRoleWhereUniqueInput | UsersLinkedViewRoleWhereUniqueInput[]
    delete?: UsersLinkedViewRoleWhereUniqueInput | UsersLinkedViewRoleWhereUniqueInput[]
    connect?: UsersLinkedViewRoleWhereUniqueInput | UsersLinkedViewRoleWhereUniqueInput[]
    update?: UsersLinkedViewRoleUpdateWithWhereUniqueWithoutUserViewRolesInput | UsersLinkedViewRoleUpdateWithWhereUniqueWithoutUserViewRolesInput[]
    updateMany?: UsersLinkedViewRoleUpdateManyWithWhereWithoutUserViewRolesInput | UsersLinkedViewRoleUpdateManyWithWhereWithoutUserViewRolesInput[]
    deleteMany?: UsersLinkedViewRoleScalarWhereInput | UsersLinkedViewRoleScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type Lkup_ActionTypeCreateWithoutEmployeeHoursInput = {
    ActionType?: string | null
    IsIgnoreHours?: number | null
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeCreateNestedManyWithoutLkup_ActionTypeInput
  }

  export type Lkup_ActionTypeUncheckedCreateWithoutEmployeeHoursInput = {
    ActionTypeID?: number
    ActionType?: string | null
    IsIgnoreHours?: number | null
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateNestedManyWithoutLkup_ActionTypeInput
  }

  export type Lkup_ActionTypeCreateOrConnectWithoutEmployeeHoursInput = {
    where: Lkup_ActionTypeWhereUniqueInput
    create: XOR<Lkup_ActionTypeCreateWithoutEmployeeHoursInput, Lkup_ActionTypeUncheckedCreateWithoutEmployeeHoursInput>
  }

  export type EmployeeHoursByLocalityCreateWithoutEmployeeHoursInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHoursUsers: EmployeeHoursUsersCreateNestedOneWithoutEmployeeHoursByLocalityInput
    EmployeeHoursContracts: EmployeeHoursContractsCreateNestedOneWithoutEmployeeHoursByLocalityInput
    EmployeeHoursLocalities: EmployeeHoursLocalitiesCreateNestedOneWithoutEmployeeHoursByLocalityInput
  }

  export type EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    EmployeeHoursLocalityId: string
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    EmployeeHoursUserId: string
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHoursContractId: string
  }

  export type EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursInput = {
    where: EmployeeHoursByLocalityWhereUniqueInput
    create: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursInput>
  }

  export type Lkup_ActionTypeUpsertWithoutEmployeeHoursInput = {
    update: XOR<Lkup_ActionTypeUpdateWithoutEmployeeHoursInput, Lkup_ActionTypeUncheckedUpdateWithoutEmployeeHoursInput>
    create: XOR<Lkup_ActionTypeCreateWithoutEmployeeHoursInput, Lkup_ActionTypeUncheckedCreateWithoutEmployeeHoursInput>
    where?: Lkup_ActionTypeWhereInput
  }

  export type Lkup_ActionTypeUpdateToOneWithWhereWithoutEmployeeHoursInput = {
    where?: Lkup_ActionTypeWhereInput
    data: XOR<Lkup_ActionTypeUpdateWithoutEmployeeHoursInput, Lkup_ActionTypeUncheckedUpdateWithoutEmployeeHoursInput>
  }

  export type Lkup_ActionTypeUpdateWithoutEmployeeHoursInput = {
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    IsIgnoreHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithoutLkup_ActionTypeNestedInput
  }

  export type Lkup_ActionTypeUncheckedUpdateWithoutEmployeeHoursInput = {
    ActionTypeID?: IntFieldUpdateOperationsInput | number
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    IsIgnoreHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateManyWithoutLkup_ActionTypeNestedInput
  }

  export type EmployeeHoursByLocalityUpsertWithoutEmployeeHoursInput = {
    update: XOR<EmployeeHoursByLocalityUpdateWithoutEmployeeHoursInput, EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursInput>
    create: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursInput>
    where?: EmployeeHoursByLocalityWhereInput
  }

  export type EmployeeHoursByLocalityUpdateToOneWithWhereWithoutEmployeeHoursInput = {
    where?: EmployeeHoursByLocalityWhereInput
    data: XOR<EmployeeHoursByLocalityUpdateWithoutEmployeeHoursInput, EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursInput>
  }

  export type EmployeeHoursByLocalityUpdateWithoutEmployeeHoursInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHoursUsers?: EmployeeHoursUsersUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput
    EmployeeHoursContracts?: EmployeeHoursContractsUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput
    EmployeeHoursLocalities?: EmployeeHoursLocalitiesUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput
  }

  export type EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeHoursUserId?: StringFieldUpdateOperationsInput | string
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHoursContractId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeHoursCreateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    EmployeeNumber: number
    MonthManaged: number
    YearManaged: number
    LeadingDate: Date | string
    HourStart?: Date | string | null
    HourEnd?: Date | string | null
    HourStartSource?: Date | string | null
    HourEndSource?: Date | string | null
    RealHours?: number | null
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    BreakMinutes?: number | null
    GpsStart?: string | null
    GpsEnd?: string | null
    IsManualInsert?: number | null
    ManualInsertUserId?: string | null
    IsRowDeleted?: number | null
    DayTypeID?: number | null
    HolidayName?: string | null
    StartEndTimeSabat?: Date | string | null
    IsForemanHourApproved?: Date | string | null
    IsForemanApproval?: Date | string | null
    ForemanApprovalGeneralCRMUserId?: string | null
    IsComplementRow?: number | null
    Lkup_ActionType?: Lkup_ActionTypeCreateNestedOneWithoutEmployeeHoursInput
  }

  export type EmployeeHoursUncheckedCreateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    EmployeeNumber: number
    MonthManaged: number
    YearManaged: number
    LeadingDate: Date | string
    HourStart?: Date | string | null
    HourEnd?: Date | string | null
    HourStartSource?: Date | string | null
    HourEndSource?: Date | string | null
    RealHours?: number | null
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    BreakMinutes?: number | null
    GpsStart?: string | null
    GpsEnd?: string | null
    IsManualInsert?: number | null
    ManualInsertUserId?: string | null
    IsRowDeleted?: number | null
    ActionTypeID?: number | null
    DayTypeID?: number | null
    HolidayName?: string | null
    StartEndTimeSabat?: Date | string | null
    IsForemanHourApproved?: Date | string | null
    IsForemanApproval?: Date | string | null
    ForemanApprovalGeneralCRMUserId?: string | null
    IsComplementRow?: number | null
  }

  export type EmployeeHoursCreateOrConnectWithoutEmployeeHoursByLocalityInput = {
    where: EmployeeHoursWhereUniqueInput
    create: XOR<EmployeeHoursCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUncheckedCreateWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursCreateManyEmployeeHoursByLocalityInputEnvelope = {
    data: EmployeeHoursCreateManyEmployeeHoursByLocalityInput | EmployeeHoursCreateManyEmployeeHoursByLocalityInput[]
  }

  export type EmployeeHoursUsersCreateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursUsersId: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    MobileNumber?: string | null
    UserName: string
    Password: string
    IsAdmin?: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    PhoneData?: string | null
    CookieError?: Date | string | null
  }

  export type EmployeeHoursUsersUncheckedCreateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursUsersId: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    MobileNumber?: string | null
    UserName: string
    Password: string
    IsAdmin?: number
    LastEntry?: Date | string | null
    IsAllowAccess2WebSite?: number
    PhoneData?: string | null
    CookieError?: Date | string | null
  }

  export type EmployeeHoursUsersCreateOrConnectWithoutEmployeeHoursByLocalityInput = {
    where: EmployeeHoursUsersWhereUniqueInput
    create: XOR<EmployeeHoursUsersCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUsersUncheckedCreateWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursContractsCreateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursContractsId?: string
    CreatedAt?: Date | string | null
    Active: number
    HebrewName: string
    Comments?: string | null
    JsonData: string
    CompanyIdGeneralCRM?: string | null
    HoursWeek: number
    NumberDayInWeek: number
    IsExtraHoursWeekCalc?: number | null
    IsNightShiftCalc?: number | null
  }

  export type EmployeeHoursContractsUncheckedCreateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursContractsId?: string
    CreatedAt?: Date | string | null
    Active: number
    HebrewName: string
    Comments?: string | null
    JsonData: string
    CompanyIdGeneralCRM?: string | null
    HoursWeek: number
    NumberDayInWeek: number
    IsExtraHoursWeekCalc?: number | null
    IsNightShiftCalc?: number | null
  }

  export type EmployeeHoursContractsCreateOrConnectWithoutEmployeeHoursByLocalityInput = {
    where: EmployeeHoursContractsWhereUniqueInput
    create: XOR<EmployeeHoursContractsCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursContractsUncheckedCreateWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursLocalitiesCreateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursLocalityId?: string
    CreatedAt?: Date | string | null
    NotShowLocality?: number | null
    LocalityName: string
    LocalityNameEng?: string | null
    CompanyIdGeneralCRM: string
    Address?: string | null
    Gps?: string | null
    GpsRadius: number
    AddressAccess?: string | null
    LocalityIDAccess: number
    LocalityCodeAccess?: number | null
    CustomerIDAccess?: number | null
    CustomerNameAccess?: string | null
    ForemanGeneralCRMUserId?: string | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number | null
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    RestrictDayHoursAbove12?: number | null
    RestrictWeekExtraHoursAbove16?: number | null
    RestrictGpsActive?: number | null
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsCreateNestedManyWithoutEmployeeHoursLocalitiesInput
  }

  export type EmployeeHoursLocalitiesUncheckedCreateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursLocalityId?: string
    CreatedAt?: Date | string | null
    NotShowLocality?: number | null
    LocalityName: string
    LocalityNameEng?: string | null
    CompanyIdGeneralCRM: string
    Address?: string | null
    Gps?: string | null
    GpsRadius: number
    AddressAccess?: string | null
    LocalityIDAccess: number
    LocalityCodeAccess?: number | null
    CustomerIDAccess?: number | null
    CustomerNameAccess?: string | null
    ForemanGeneralCRMUserId?: string | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number | null
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    RestrictDayHoursAbove12?: number | null
    RestrictWeekExtraHoursAbove16?: number | null
    RestrictGpsActive?: number | null
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsUncheckedCreateNestedManyWithoutEmployeeHoursLocalitiesInput
  }

  export type EmployeeHoursLocalitiesCreateOrConnectWithoutEmployeeHoursByLocalityInput = {
    where: EmployeeHoursLocalitiesWhereUniqueInput
    create: XOR<EmployeeHoursLocalitiesCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursLocalitiesUncheckedCreateWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursUpsertWithWhereUniqueWithoutEmployeeHoursByLocalityInput = {
    where: EmployeeHoursWhereUniqueInput
    update: XOR<EmployeeHoursUpdateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUncheckedUpdateWithoutEmployeeHoursByLocalityInput>
    create: XOR<EmployeeHoursCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUncheckedCreateWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursUpdateWithWhereUniqueWithoutEmployeeHoursByLocalityInput = {
    where: EmployeeHoursWhereUniqueInput
    data: XOR<EmployeeHoursUpdateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUncheckedUpdateWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursUpdateManyWithWhereWithoutEmployeeHoursByLocalityInput = {
    where: EmployeeHoursScalarWhereInput
    data: XOR<EmployeeHoursUpdateManyMutationInput, EmployeeHoursUncheckedUpdateManyWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursScalarWhereInput = {
    AND?: EmployeeHoursScalarWhereInput | EmployeeHoursScalarWhereInput[]
    OR?: EmployeeHoursScalarWhereInput[]
    NOT?: EmployeeHoursScalarWhereInput | EmployeeHoursScalarWhereInput[]
    EmployeeHoursId?: StringFilter<"EmployeeHours"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHours"> | string
    EmployeeId?: IntFilter<"EmployeeHours"> | number
    EmployeeNumber?: IntFilter<"EmployeeHours"> | number
    MonthManaged?: IntFilter<"EmployeeHours"> | number
    YearManaged?: IntFilter<"EmployeeHours"> | number
    LeadingDate?: DateTimeFilter<"EmployeeHours"> | Date | string
    HourStart?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    HourEnd?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    HourStartSource?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    HourEndSource?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    RealHours?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour125?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour150?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour175?: FloatNullableFilter<"EmployeeHours"> | number | null
    QtyHour200?: FloatNullableFilter<"EmployeeHours"> | number | null
    BreakMinutes?: FloatNullableFilter<"EmployeeHours"> | number | null
    GpsStart?: StringNullableFilter<"EmployeeHours"> | string | null
    GpsEnd?: StringNullableFilter<"EmployeeHours"> | string | null
    EmployeeHoursByLocalityId?: StringFilter<"EmployeeHours"> | string
    IsManualInsert?: IntNullableFilter<"EmployeeHours"> | number | null
    ManualInsertUserId?: StringNullableFilter<"EmployeeHours"> | string | null
    IsRowDeleted?: IntNullableFilter<"EmployeeHours"> | number | null
    ActionTypeID?: IntNullableFilter<"EmployeeHours"> | number | null
    DayTypeID?: IntNullableFilter<"EmployeeHours"> | number | null
    HolidayName?: StringNullableFilter<"EmployeeHours"> | string | null
    StartEndTimeSabat?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    IsForemanHourApproved?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    IsForemanApproval?: DateTimeNullableFilter<"EmployeeHours"> | Date | string | null
    ForemanApprovalGeneralCRMUserId?: StringNullableFilter<"EmployeeHours"> | string | null
    IsComplementRow?: IntNullableFilter<"EmployeeHours"> | number | null
  }

  export type EmployeeHoursUsersUpsertWithoutEmployeeHoursByLocalityInput = {
    update: XOR<EmployeeHoursUsersUpdateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUsersUncheckedUpdateWithoutEmployeeHoursByLocalityInput>
    create: XOR<EmployeeHoursUsersCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUsersUncheckedCreateWithoutEmployeeHoursByLocalityInput>
    where?: EmployeeHoursUsersWhereInput
  }

  export type EmployeeHoursUsersUpdateToOneWithWhereWithoutEmployeeHoursByLocalityInput = {
    where?: EmployeeHoursUsersWhereInput
    data: XOR<EmployeeHoursUsersUpdateWithoutEmployeeHoursByLocalityInput, EmployeeHoursUsersUncheckedUpdateWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursUsersUpdateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursUsersId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    PhoneData?: NullableStringFieldUpdateOperationsInput | string | null
    CookieError?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeHoursUsersUncheckedUpdateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursUsersId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    IsAdmin?: IntFieldUpdateOperationsInput | number
    LastEntry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsAllowAccess2WebSite?: IntFieldUpdateOperationsInput | number
    PhoneData?: NullableStringFieldUpdateOperationsInput | string | null
    CookieError?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeHoursContractsUpsertWithoutEmployeeHoursByLocalityInput = {
    update: XOR<EmployeeHoursContractsUpdateWithoutEmployeeHoursByLocalityInput, EmployeeHoursContractsUncheckedUpdateWithoutEmployeeHoursByLocalityInput>
    create: XOR<EmployeeHoursContractsCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursContractsUncheckedCreateWithoutEmployeeHoursByLocalityInput>
    where?: EmployeeHoursContractsWhereInput
  }

  export type EmployeeHoursContractsUpdateToOneWithWhereWithoutEmployeeHoursByLocalityInput = {
    where?: EmployeeHoursContractsWhereInput
    data: XOR<EmployeeHoursContractsUpdateWithoutEmployeeHoursByLocalityInput, EmployeeHoursContractsUncheckedUpdateWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursContractsUpdateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursContractsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: IntFieldUpdateOperationsInput | number
    HebrewName?: StringFieldUpdateOperationsInput | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    JsonData?: StringFieldUpdateOperationsInput | string
    CompanyIdGeneralCRM?: NullableStringFieldUpdateOperationsInput | string | null
    HoursWeek?: FloatFieldUpdateOperationsInput | number
    NumberDayInWeek?: IntFieldUpdateOperationsInput | number
    IsExtraHoursWeekCalc?: NullableIntFieldUpdateOperationsInput | number | null
    IsNightShiftCalc?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursContractsUncheckedUpdateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursContractsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: IntFieldUpdateOperationsInput | number
    HebrewName?: StringFieldUpdateOperationsInput | string
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
    JsonData?: StringFieldUpdateOperationsInput | string
    CompanyIdGeneralCRM?: NullableStringFieldUpdateOperationsInput | string | null
    HoursWeek?: FloatFieldUpdateOperationsInput | number
    NumberDayInWeek?: IntFieldUpdateOperationsInput | number
    IsExtraHoursWeekCalc?: NullableIntFieldUpdateOperationsInput | number | null
    IsNightShiftCalc?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursLocalitiesUpsertWithoutEmployeeHoursByLocalityInput = {
    update: XOR<EmployeeHoursLocalitiesUpdateWithoutEmployeeHoursByLocalityInput, EmployeeHoursLocalitiesUncheckedUpdateWithoutEmployeeHoursByLocalityInput>
    create: XOR<EmployeeHoursLocalitiesCreateWithoutEmployeeHoursByLocalityInput, EmployeeHoursLocalitiesUncheckedCreateWithoutEmployeeHoursByLocalityInput>
    where?: EmployeeHoursLocalitiesWhereInput
  }

  export type EmployeeHoursLocalitiesUpdateToOneWithWhereWithoutEmployeeHoursByLocalityInput = {
    where?: EmployeeHoursLocalitiesWhereInput
    data: XOR<EmployeeHoursLocalitiesUpdateWithoutEmployeeHoursByLocalityInput, EmployeeHoursLocalitiesUncheckedUpdateWithoutEmployeeHoursByLocalityInput>
  }

  export type EmployeeHoursLocalitiesUpdateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NotShowLocality?: NullableIntFieldUpdateOperationsInput | number | null
    LocalityName?: StringFieldUpdateOperationsInput | string
    LocalityNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Gps?: NullableStringFieldUpdateOperationsInput | string | null
    GpsRadius?: IntFieldUpdateOperationsInput | number
    AddressAccess?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityIDAccess?: IntFieldUpdateOperationsInput | number
    LocalityCodeAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerIDAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerNameAccess?: NullableStringFieldUpdateOperationsInput | string | null
    ForemanGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    RestrictDayHoursAbove12?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictWeekExtraHoursAbove16?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictGpsActive?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsUpdateManyWithoutEmployeeHoursLocalitiesNestedInput
  }

  export type EmployeeHoursLocalitiesUncheckedUpdateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NotShowLocality?: NullableIntFieldUpdateOperationsInput | number | null
    LocalityName?: StringFieldUpdateOperationsInput | string
    LocalityNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Gps?: NullableStringFieldUpdateOperationsInput | string | null
    GpsRadius?: IntFieldUpdateOperationsInput | number
    AddressAccess?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityIDAccess?: IntFieldUpdateOperationsInput | number
    LocalityCodeAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerIDAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerNameAccess?: NullableStringFieldUpdateOperationsInput | string | null
    ForemanGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    RestrictDayHoursAbove12?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictWeekExtraHoursAbove16?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictGpsActive?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsUncheckedUpdateManyWithoutEmployeeHoursLocalitiesNestedInput
  }

  export type EmployeeHoursLocalitiesCreateWithoutEmployeeHoursByLocalityTotalsInput = {
    EmployeeHoursLocalityId?: string
    CreatedAt?: Date | string | null
    NotShowLocality?: number | null
    LocalityName: string
    LocalityNameEng?: string | null
    CompanyIdGeneralCRM: string
    Address?: string | null
    Gps?: string | null
    GpsRadius: number
    AddressAccess?: string | null
    LocalityIDAccess: number
    LocalityCodeAccess?: number | null
    CustomerIDAccess?: number | null
    CustomerNameAccess?: string | null
    ForemanGeneralCRMUserId?: string | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number | null
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    RestrictDayHoursAbove12?: number | null
    RestrictWeekExtraHoursAbove16?: number | null
    RestrictGpsActive?: number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityCreateNestedManyWithoutEmployeeHoursLocalitiesInput
  }

  export type EmployeeHoursLocalitiesUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput = {
    EmployeeHoursLocalityId?: string
    CreatedAt?: Date | string | null
    NotShowLocality?: number | null
    LocalityName: string
    LocalityNameEng?: string | null
    CompanyIdGeneralCRM: string
    Address?: string | null
    Gps?: string | null
    GpsRadius: number
    AddressAccess?: string | null
    LocalityIDAccess: number
    LocalityCodeAccess?: number | null
    CustomerIDAccess?: number | null
    CustomerNameAccess?: string | null
    ForemanGeneralCRMUserId?: string | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number | null
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    RestrictDayHoursAbove12?: number | null
    RestrictWeekExtraHoursAbove16?: number | null
    RestrictGpsActive?: number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUncheckedCreateNestedManyWithoutEmployeeHoursLocalitiesInput
  }

  export type EmployeeHoursLocalitiesCreateOrConnectWithoutEmployeeHoursByLocalityTotalsInput = {
    where: EmployeeHoursLocalitiesWhereUniqueInput
    create: XOR<EmployeeHoursLocalitiesCreateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursLocalitiesUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput>
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCreateWithoutEmployeeHoursByLocalityTotalsInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: string
    CreatedAt?: Date | string | null
    TotalActionType: number
    Lkup_ActionType: Lkup_ActionTypeCreateNestedOneWithoutEmployeeHoursByLocalityTotalsActionTypeInput
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: string
    CreatedAt?: Date | string | null
    ActionTypeId: number
    TotalActionType: number
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutEmployeeHoursByLocalityTotalsInput = {
    where: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    create: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput>
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCreateManyEmployeeHoursByLocalityTotalsInputEnvelope = {
    data: EmployeeHoursByLocalityTotalsActionTypeCreateManyEmployeeHoursByLocalityTotalsInput | EmployeeHoursByLocalityTotalsActionTypeCreateManyEmployeeHoursByLocalityTotalsInput[]
  }

  export type EmployeeHoursLocalitiesUpsertWithoutEmployeeHoursByLocalityTotalsInput = {
    update: XOR<EmployeeHoursLocalitiesUpdateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursLocalitiesUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsInput>
    create: XOR<EmployeeHoursLocalitiesCreateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursLocalitiesUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput>
    where?: EmployeeHoursLocalitiesWhereInput
  }

  export type EmployeeHoursLocalitiesUpdateToOneWithWhereWithoutEmployeeHoursByLocalityTotalsInput = {
    where?: EmployeeHoursLocalitiesWhereInput
    data: XOR<EmployeeHoursLocalitiesUpdateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursLocalitiesUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsInput>
  }

  export type EmployeeHoursLocalitiesUpdateWithoutEmployeeHoursByLocalityTotalsInput = {
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NotShowLocality?: NullableIntFieldUpdateOperationsInput | number | null
    LocalityName?: StringFieldUpdateOperationsInput | string
    LocalityNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Gps?: NullableStringFieldUpdateOperationsInput | string | null
    GpsRadius?: IntFieldUpdateOperationsInput | number
    AddressAccess?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityIDAccess?: IntFieldUpdateOperationsInput | number
    LocalityCodeAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerIDAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerNameAccess?: NullableStringFieldUpdateOperationsInput | string | null
    ForemanGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    RestrictDayHoursAbove12?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictWeekExtraHoursAbove16?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictGpsActive?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUpdateManyWithoutEmployeeHoursLocalitiesNestedInput
  }

  export type EmployeeHoursLocalitiesUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsInput = {
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NotShowLocality?: NullableIntFieldUpdateOperationsInput | number | null
    LocalityName?: StringFieldUpdateOperationsInput | string
    LocalityNameEng?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Gps?: NullableStringFieldUpdateOperationsInput | string | null
    GpsRadius?: IntFieldUpdateOperationsInput | number
    AddressAccess?: NullableStringFieldUpdateOperationsInput | string | null
    LocalityIDAccess?: IntFieldUpdateOperationsInput | number
    LocalityCodeAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerIDAccess?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerNameAccess?: NullableStringFieldUpdateOperationsInput | string | null
    ForemanGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    RestrictDayHoursAbove12?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictWeekExtraHoursAbove16?: NullableIntFieldUpdateOperationsInput | number | null
    RestrictGpsActive?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursLocalitiesNestedInput
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUpsertWithWhereUniqueWithoutEmployeeHoursByLocalityTotalsInput = {
    where: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    update: XOR<EmployeeHoursByLocalityTotalsActionTypeUpdateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsInput>
    create: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsInput>
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUpdateWithWhereUniqueWithoutEmployeeHoursByLocalityTotalsInput = {
    where: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    data: XOR<EmployeeHoursByLocalityTotalsActionTypeUpdateWithoutEmployeeHoursByLocalityTotalsInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsInput>
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithWhereWithoutEmployeeHoursByLocalityTotalsInput = {
    where: EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput
    data: XOR<EmployeeHoursByLocalityTotalsActionTypeUpdateManyMutationInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateManyWithoutEmployeeHoursByLocalityTotalsInput>
  }

  export type EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput = {
    AND?: EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput | EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput[]
    OR?: EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput[]
    NOT?: EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput | EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput[]
    EmployeeHoursByLocalityTotalsActionTypeId?: StringFilter<"EmployeeHoursByLocalityTotalsActionType"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursByLocalityTotalsActionType"> | Date | string | null
    EmployeeHoursByLocalityTotalsId?: StringFilter<"EmployeeHoursByLocalityTotalsActionType"> | string
    ActionTypeId?: IntFilter<"EmployeeHoursByLocalityTotalsActionType"> | number
    TotalActionType?: FloatFilter<"EmployeeHoursByLocalityTotalsActionType"> | number
  }

  export type Lkup_ActionTypeCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    ActionType?: string | null
    IsIgnoreHours?: number | null
    EmployeeHours?: EmployeeHoursCreateNestedManyWithoutLkup_ActionTypeInput
  }

  export type Lkup_ActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    ActionTypeID?: number
    ActionType?: string | null
    IsIgnoreHours?: number | null
    EmployeeHours?: EmployeeHoursUncheckedCreateNestedManyWithoutLkup_ActionTypeInput
  }

  export type Lkup_ActionTypeCreateOrConnectWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    where: Lkup_ActionTypeWhereUniqueInput
    create: XOR<Lkup_ActionTypeCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput, Lkup_ActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
  }

  export type EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    EmployeeHoursByLocalityTotalsId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    MonthManaged: number
    YearManaged: number
    EmployeeId: number
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    RealHours?: number | null
    BreakMinutes?: number | null
    WorkedDays?: number | null
    IsCloseSalary?: number
    EmployeeHoursLocalities: EmployeeHoursLocalitiesCreateNestedOneWithoutEmployeeHoursByLocalityTotalsInput
  }

  export type EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    EmployeeHoursByLocalityTotalsId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    MonthManaged: number
    YearManaged: number
    EmployeeId: number
    EmployeeHoursLocalityId: string
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    RealHours?: number | null
    BreakMinutes?: number | null
    WorkedDays?: number | null
    IsCloseSalary?: number
  }

  export type EmployeeHoursByLocalityTotalsCreateOrConnectWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    where: EmployeeHoursByLocalityTotalsWhereUniqueInput
    create: XOR<EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput, EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
  }

  export type Lkup_ActionTypeUpsertWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    update: XOR<Lkup_ActionTypeUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput, Lkup_ActionTypeUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
    create: XOR<Lkup_ActionTypeCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput, Lkup_ActionTypeUncheckedCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
    where?: Lkup_ActionTypeWhereInput
  }

  export type Lkup_ActionTypeUpdateToOneWithWhereWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    where?: Lkup_ActionTypeWhereInput
    data: XOR<Lkup_ActionTypeUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput, Lkup_ActionTypeUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
  }

  export type Lkup_ActionTypeUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    IsIgnoreHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHours?: EmployeeHoursUpdateManyWithoutLkup_ActionTypeNestedInput
  }

  export type Lkup_ActionTypeUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    ActionTypeID?: IntFieldUpdateOperationsInput | number
    ActionType?: NullableStringFieldUpdateOperationsInput | string | null
    IsIgnoreHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHours?: EmployeeHoursUncheckedUpdateManyWithoutLkup_ActionTypeNestedInput
  }

  export type EmployeeHoursByLocalityTotalsUpsertWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    update: XOR<EmployeeHoursByLocalityTotalsUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput, EmployeeHoursByLocalityTotalsUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
    create: XOR<EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput, EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
    where?: EmployeeHoursByLocalityTotalsWhereInput
  }

  export type EmployeeHoursByLocalityTotalsUpdateToOneWithWhereWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    where?: EmployeeHoursByLocalityTotalsWhereInput
    data: XOR<EmployeeHoursByLocalityTotalsUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput, EmployeeHoursByLocalityTotalsUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput>
  }

  export type EmployeeHoursByLocalityTotalsUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    EmployeeId?: IntFieldUpdateOperationsInput | number
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    WorkedDays?: NullableIntFieldUpdateOperationsInput | number | null
    IsCloseSalary?: IntFieldUpdateOperationsInput | number
    EmployeeHoursLocalities?: EmployeeHoursLocalitiesUpdateOneRequiredWithoutEmployeeHoursByLocalityTotalsNestedInput
  }

  export type EmployeeHoursByLocalityTotalsUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsActionTypeInput = {
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    WorkedDays?: NullableIntFieldUpdateOperationsInput | number | null
    IsCloseSalary?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeHoursByLocalityCreateWithoutEmployeeHoursContractsInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHours?: EmployeeHoursCreateNestedManyWithoutEmployeeHoursByLocalityInput
    EmployeeHoursUsers: EmployeeHoursUsersCreateNestedOneWithoutEmployeeHoursByLocalityInput
    EmployeeHoursLocalities: EmployeeHoursLocalitiesCreateNestedOneWithoutEmployeeHoursByLocalityInput
  }

  export type EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursContractsInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    EmployeeHoursLocalityId: string
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    EmployeeHoursUserId: string
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHours?: EmployeeHoursUncheckedCreateNestedManyWithoutEmployeeHoursByLocalityInput
  }

  export type EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursContractsInput = {
    where: EmployeeHoursByLocalityWhereUniqueInput
    create: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursContractsInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursContractsInput>
  }

  export type EmployeeHoursByLocalityCreateManyEmployeeHoursContractsInputEnvelope = {
    data: EmployeeHoursByLocalityCreateManyEmployeeHoursContractsInput | EmployeeHoursByLocalityCreateManyEmployeeHoursContractsInput[]
  }

  export type EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursContractsInput = {
    where: EmployeeHoursByLocalityWhereUniqueInput
    update: XOR<EmployeeHoursByLocalityUpdateWithoutEmployeeHoursContractsInput, EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursContractsInput>
    create: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursContractsInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursContractsInput>
  }

  export type EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursContractsInput = {
    where: EmployeeHoursByLocalityWhereUniqueInput
    data: XOR<EmployeeHoursByLocalityUpdateWithoutEmployeeHoursContractsInput, EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursContractsInput>
  }

  export type EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursContractsInput = {
    where: EmployeeHoursByLocalityScalarWhereInput
    data: XOR<EmployeeHoursByLocalityUpdateManyMutationInput, EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursContractsInput>
  }

  export type EmployeeHoursByLocalityScalarWhereInput = {
    AND?: EmployeeHoursByLocalityScalarWhereInput | EmployeeHoursByLocalityScalarWhereInput[]
    OR?: EmployeeHoursByLocalityScalarWhereInput[]
    NOT?: EmployeeHoursByLocalityScalarWhereInput | EmployeeHoursByLocalityScalarWhereInput[]
    EmployeeHoursByLocalityId?: StringFilter<"EmployeeHoursByLocality"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursByLocality"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursByLocality"> | string
    EmployeeId?: IntFilter<"EmployeeHoursByLocality"> | number
    NotShowEmployeeHours?: IntNullableFilter<"EmployeeHoursByLocality"> | number | null
    EmployeeHoursLocalityId?: StringFilter<"EmployeeHoursByLocality"> | string
    HourMinStart?: DateTimeNullableFilter<"EmployeeHoursByLocality"> | Date | string | null
    HourMaxStop?: DateTimeNullableFilter<"EmployeeHoursByLocality"> | Date | string | null
    RoundTime?: StringNullableFilter<"EmployeeHoursByLocality"> | string | null
    EmployeeHoursUserId?: StringFilter<"EmployeeHoursByLocality"> | string
    MinimumHours2BreakTime?: FloatFilter<"EmployeeHoursByLocality"> | number
    BreakTime?: IntNullableFilter<"EmployeeHoursByLocality"> | number | null
    AlertForMaxMonthHours?: FloatNullableFilter<"EmployeeHoursByLocality"> | number | null
    EmployeeHoursContractId?: StringFilter<"EmployeeHoursByLocality"> | string
  }

  export type EmployeeHoursByLocalityCreateWithoutEmployeeHoursLocalitiesInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHours?: EmployeeHoursCreateNestedManyWithoutEmployeeHoursByLocalityInput
    EmployeeHoursUsers: EmployeeHoursUsersCreateNestedOneWithoutEmployeeHoursByLocalityInput
    EmployeeHoursContracts: EmployeeHoursContractsCreateNestedOneWithoutEmployeeHoursByLocalityInput
  }

  export type EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursLocalitiesInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    EmployeeHoursUserId: string
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHoursContractId: string
    EmployeeHours?: EmployeeHoursUncheckedCreateNestedManyWithoutEmployeeHoursByLocalityInput
  }

  export type EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursLocalitiesInput = {
    where: EmployeeHoursByLocalityWhereUniqueInput
    create: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursLocalitiesInput>
  }

  export type EmployeeHoursByLocalityCreateManyEmployeeHoursLocalitiesInputEnvelope = {
    data: EmployeeHoursByLocalityCreateManyEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityCreateManyEmployeeHoursLocalitiesInput[]
  }

  export type EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursLocalitiesInput = {
    EmployeeHoursByLocalityTotalsId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    MonthManaged: number
    YearManaged: number
    EmployeeId: number
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    RealHours?: number | null
    BreakMinutes?: number | null
    WorkedDays?: number | null
    IsCloseSalary?: number
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeCreateNestedManyWithoutEmployeeHoursByLocalityTotalsInput
  }

  export type EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursLocalitiesInput = {
    EmployeeHoursByLocalityTotalsId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    MonthManaged: number
    YearManaged: number
    EmployeeId: number
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    RealHours?: number | null
    BreakMinutes?: number | null
    WorkedDays?: number | null
    IsCloseSalary?: number
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateNestedManyWithoutEmployeeHoursByLocalityTotalsInput
  }

  export type EmployeeHoursByLocalityTotalsCreateOrConnectWithoutEmployeeHoursLocalitiesInput = {
    where: EmployeeHoursByLocalityTotalsWhereUniqueInput
    create: XOR<EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursLocalitiesInput>
  }

  export type EmployeeHoursByLocalityTotalsCreateManyEmployeeHoursLocalitiesInputEnvelope = {
    data: EmployeeHoursByLocalityTotalsCreateManyEmployeeHoursLocalitiesInput | EmployeeHoursByLocalityTotalsCreateManyEmployeeHoursLocalitiesInput[]
  }

  export type EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursLocalitiesInput = {
    where: EmployeeHoursByLocalityWhereUniqueInput
    update: XOR<EmployeeHoursByLocalityUpdateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursLocalitiesInput>
    create: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursLocalitiesInput>
  }

  export type EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursLocalitiesInput = {
    where: EmployeeHoursByLocalityWhereUniqueInput
    data: XOR<EmployeeHoursByLocalityUpdateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursLocalitiesInput>
  }

  export type EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursLocalitiesInput = {
    where: EmployeeHoursByLocalityScalarWhereInput
    data: XOR<EmployeeHoursByLocalityUpdateManyMutationInput, EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursLocalitiesInput>
  }

  export type EmployeeHoursByLocalityTotalsUpsertWithWhereUniqueWithoutEmployeeHoursLocalitiesInput = {
    where: EmployeeHoursByLocalityTotalsWhereUniqueInput
    update: XOR<EmployeeHoursByLocalityTotalsUpdateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityTotalsUncheckedUpdateWithoutEmployeeHoursLocalitiesInput>
    create: XOR<EmployeeHoursByLocalityTotalsCreateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityTotalsUncheckedCreateWithoutEmployeeHoursLocalitiesInput>
  }

  export type EmployeeHoursByLocalityTotalsUpdateWithWhereUniqueWithoutEmployeeHoursLocalitiesInput = {
    where: EmployeeHoursByLocalityTotalsWhereUniqueInput
    data: XOR<EmployeeHoursByLocalityTotalsUpdateWithoutEmployeeHoursLocalitiesInput, EmployeeHoursByLocalityTotalsUncheckedUpdateWithoutEmployeeHoursLocalitiesInput>
  }

  export type EmployeeHoursByLocalityTotalsUpdateManyWithWhereWithoutEmployeeHoursLocalitiesInput = {
    where: EmployeeHoursByLocalityTotalsScalarWhereInput
    data: XOR<EmployeeHoursByLocalityTotalsUpdateManyMutationInput, EmployeeHoursByLocalityTotalsUncheckedUpdateManyWithoutEmployeeHoursLocalitiesInput>
  }

  export type EmployeeHoursByLocalityTotalsScalarWhereInput = {
    AND?: EmployeeHoursByLocalityTotalsScalarWhereInput | EmployeeHoursByLocalityTotalsScalarWhereInput[]
    OR?: EmployeeHoursByLocalityTotalsScalarWhereInput[]
    NOT?: EmployeeHoursByLocalityTotalsScalarWhereInput | EmployeeHoursByLocalityTotalsScalarWhereInput[]
    EmployeeHoursByLocalityTotalsId?: StringFilter<"EmployeeHoursByLocalityTotals"> | string
    CreatedAt?: DateTimeNullableFilter<"EmployeeHoursByLocalityTotals"> | Date | string | null
    CompanyIdGeneralCRM?: StringFilter<"EmployeeHoursByLocalityTotals"> | string
    MonthManaged?: IntFilter<"EmployeeHoursByLocalityTotals"> | number
    YearManaged?: IntFilter<"EmployeeHoursByLocalityTotals"> | number
    EmployeeId?: IntFilter<"EmployeeHoursByLocalityTotals"> | number
    EmployeeHoursLocalityId?: StringFilter<"EmployeeHoursByLocalityTotals"> | string
    QtyHour?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour125?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour150?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour175?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    QtyHour200?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    RealHours?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    BreakMinutes?: FloatNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    WorkedDays?: IntNullableFilter<"EmployeeHoursByLocalityTotals"> | number | null
    IsCloseSalary?: IntFilter<"EmployeeHoursByLocalityTotals"> | number
  }

  export type EmployeeHoursByLocalityCreateWithoutEmployeeHoursUsersInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHours?: EmployeeHoursCreateNestedManyWithoutEmployeeHoursByLocalityInput
    EmployeeHoursContracts: EmployeeHoursContractsCreateNestedOneWithoutEmployeeHoursByLocalityInput
    EmployeeHoursLocalities: EmployeeHoursLocalitiesCreateNestedOneWithoutEmployeeHoursByLocalityInput
  }

  export type EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursUsersInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    EmployeeHoursLocalityId: string
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHoursContractId: string
    EmployeeHours?: EmployeeHoursUncheckedCreateNestedManyWithoutEmployeeHoursByLocalityInput
  }

  export type EmployeeHoursByLocalityCreateOrConnectWithoutEmployeeHoursUsersInput = {
    where: EmployeeHoursByLocalityWhereUniqueInput
    create: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursUsersInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursUsersInput>
  }

  export type EmployeeHoursByLocalityCreateManyEmployeeHoursUsersInputEnvelope = {
    data: EmployeeHoursByLocalityCreateManyEmployeeHoursUsersInput | EmployeeHoursByLocalityCreateManyEmployeeHoursUsersInput[]
  }

  export type EmployeeHoursByLocalityUpsertWithWhereUniqueWithoutEmployeeHoursUsersInput = {
    where: EmployeeHoursByLocalityWhereUniqueInput
    update: XOR<EmployeeHoursByLocalityUpdateWithoutEmployeeHoursUsersInput, EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursUsersInput>
    create: XOR<EmployeeHoursByLocalityCreateWithoutEmployeeHoursUsersInput, EmployeeHoursByLocalityUncheckedCreateWithoutEmployeeHoursUsersInput>
  }

  export type EmployeeHoursByLocalityUpdateWithWhereUniqueWithoutEmployeeHoursUsersInput = {
    where: EmployeeHoursByLocalityWhereUniqueInput
    data: XOR<EmployeeHoursByLocalityUpdateWithoutEmployeeHoursUsersInput, EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursUsersInput>
  }

  export type EmployeeHoursByLocalityUpdateManyWithWhereWithoutEmployeeHoursUsersInput = {
    where: EmployeeHoursByLocalityScalarWhereInput
    data: XOR<EmployeeHoursByLocalityUpdateManyMutationInput, EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursUsersInput>
  }

  export type EmployeeHoursCreateWithoutLkup_ActionTypeInput = {
    EmployeeHoursId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    EmployeeNumber: number
    MonthManaged: number
    YearManaged: number
    LeadingDate: Date | string
    HourStart?: Date | string | null
    HourEnd?: Date | string | null
    HourStartSource?: Date | string | null
    HourEndSource?: Date | string | null
    RealHours?: number | null
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    BreakMinutes?: number | null
    GpsStart?: string | null
    GpsEnd?: string | null
    IsManualInsert?: number | null
    ManualInsertUserId?: string | null
    IsRowDeleted?: number | null
    DayTypeID?: number | null
    HolidayName?: string | null
    StartEndTimeSabat?: Date | string | null
    IsForemanHourApproved?: Date | string | null
    IsForemanApproval?: Date | string | null
    ForemanApprovalGeneralCRMUserId?: string | null
    IsComplementRow?: number | null
    EmployeeHoursByLocality: EmployeeHoursByLocalityCreateNestedOneWithoutEmployeeHoursInput
  }

  export type EmployeeHoursUncheckedCreateWithoutLkup_ActionTypeInput = {
    EmployeeHoursId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    EmployeeNumber: number
    MonthManaged: number
    YearManaged: number
    LeadingDate: Date | string
    HourStart?: Date | string | null
    HourEnd?: Date | string | null
    HourStartSource?: Date | string | null
    HourEndSource?: Date | string | null
    RealHours?: number | null
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    BreakMinutes?: number | null
    GpsStart?: string | null
    GpsEnd?: string | null
    EmployeeHoursByLocalityId: string
    IsManualInsert?: number | null
    ManualInsertUserId?: string | null
    IsRowDeleted?: number | null
    DayTypeID?: number | null
    HolidayName?: string | null
    StartEndTimeSabat?: Date | string | null
    IsForemanHourApproved?: Date | string | null
    IsForemanApproval?: Date | string | null
    ForemanApprovalGeneralCRMUserId?: string | null
    IsComplementRow?: number | null
  }

  export type EmployeeHoursCreateOrConnectWithoutLkup_ActionTypeInput = {
    where: EmployeeHoursWhereUniqueInput
    create: XOR<EmployeeHoursCreateWithoutLkup_ActionTypeInput, EmployeeHoursUncheckedCreateWithoutLkup_ActionTypeInput>
  }

  export type EmployeeHoursCreateManyLkup_ActionTypeInputEnvelope = {
    data: EmployeeHoursCreateManyLkup_ActionTypeInput | EmployeeHoursCreateManyLkup_ActionTypeInput[]
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCreateWithoutLkup_ActionTypeInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: string
    CreatedAt?: Date | string | null
    TotalActionType: number
    EmployeeHoursByLocalityTotals: EmployeeHoursByLocalityTotalsCreateNestedOneWithoutEmployeeHoursByLocalityTotalsActionTypeInput
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutLkup_ActionTypeInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: string
    CreatedAt?: Date | string | null
    EmployeeHoursByLocalityTotalsId: string
    TotalActionType: number
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCreateOrConnectWithoutLkup_ActionTypeInput = {
    where: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    create: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateWithoutLkup_ActionTypeInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutLkup_ActionTypeInput>
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCreateManyLkup_ActionTypeInputEnvelope = {
    data: EmployeeHoursByLocalityTotalsActionTypeCreateManyLkup_ActionTypeInput | EmployeeHoursByLocalityTotalsActionTypeCreateManyLkup_ActionTypeInput[]
  }

  export type EmployeeHoursUpsertWithWhereUniqueWithoutLkup_ActionTypeInput = {
    where: EmployeeHoursWhereUniqueInput
    update: XOR<EmployeeHoursUpdateWithoutLkup_ActionTypeInput, EmployeeHoursUncheckedUpdateWithoutLkup_ActionTypeInput>
    create: XOR<EmployeeHoursCreateWithoutLkup_ActionTypeInput, EmployeeHoursUncheckedCreateWithoutLkup_ActionTypeInput>
  }

  export type EmployeeHoursUpdateWithWhereUniqueWithoutLkup_ActionTypeInput = {
    where: EmployeeHoursWhereUniqueInput
    data: XOR<EmployeeHoursUpdateWithoutLkup_ActionTypeInput, EmployeeHoursUncheckedUpdateWithoutLkup_ActionTypeInput>
  }

  export type EmployeeHoursUpdateManyWithWhereWithoutLkup_ActionTypeInput = {
    where: EmployeeHoursScalarWhereInput
    data: XOR<EmployeeHoursUpdateManyMutationInput, EmployeeHoursUncheckedUpdateManyWithoutLkup_ActionTypeInput>
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUpsertWithWhereUniqueWithoutLkup_ActionTypeInput = {
    where: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    update: XOR<EmployeeHoursByLocalityTotalsActionTypeUpdateWithoutLkup_ActionTypeInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateWithoutLkup_ActionTypeInput>
    create: XOR<EmployeeHoursByLocalityTotalsActionTypeCreateWithoutLkup_ActionTypeInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedCreateWithoutLkup_ActionTypeInput>
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUpdateWithWhereUniqueWithoutLkup_ActionTypeInput = {
    where: EmployeeHoursByLocalityTotalsActionTypeWhereUniqueInput
    data: XOR<EmployeeHoursByLocalityTotalsActionTypeUpdateWithoutLkup_ActionTypeInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateWithoutLkup_ActionTypeInput>
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithWhereWithoutLkup_ActionTypeInput = {
    where: EmployeeHoursByLocalityTotalsActionTypeScalarWhereInput
    data: XOR<EmployeeHoursByLocalityTotalsActionTypeUpdateManyMutationInput, EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateManyWithoutLkup_ActionTypeInput>
  }

  export type MessagesEmployeesCreateWithoutOther_MessagesEmployeesInput = {
    MessageEmployeeId?: string
    CreatedAt?: Date | string
    FinalDateForTask?: Date | string | null
    ReadedAt?: Date | string | null
    DoneAt?: Date | string | null
    SendResponseAtStatusDone?: number | null
    CompanyIdGeneralCRM: string
    UserFromIdGeneralCRM: string
    UserToIdGeneralCRM: string
    MessageSubject?: string | null
    MessageText?: string | null
    LinkEmployees?: string | null
    LinkHouses?: string | null
    MessagesEmployees?: MessagesEmployeesCreateNestedOneWithoutOther_MessagesEmployeesInput
    MessagesStatus?: MessagesStatusCreateNestedOneWithoutMessagesEmployeesInput
  }

  export type MessagesEmployeesUncheckedCreateWithoutOther_MessagesEmployeesInput = {
    MessageEmployeeId?: string
    CreatedAt?: Date | string
    FinalDateForTask?: Date | string | null
    ReadedAt?: Date | string | null
    DoneAt?: Date | string | null
    SendResponseAtStatusDone?: number | null
    CompanyIdGeneralCRM: string
    UserFromIdGeneralCRM: string
    UserToIdGeneralCRM: string
    IsReplyToMessageId?: string | null
    MessageStatusId?: string
    MessageSubject?: string | null
    MessageText?: string | null
    LinkEmployees?: string | null
    LinkHouses?: string | null
  }

  export type MessagesEmployeesCreateOrConnectWithoutOther_MessagesEmployeesInput = {
    where: MessagesEmployeesWhereUniqueInput
    create: XOR<MessagesEmployeesCreateWithoutOther_MessagesEmployeesInput, MessagesEmployeesUncheckedCreateWithoutOther_MessagesEmployeesInput>
  }

  export type MessagesEmployeesCreateWithoutMessagesEmployeesInput = {
    MessageEmployeeId?: string
    CreatedAt?: Date | string
    FinalDateForTask?: Date | string | null
    ReadedAt?: Date | string | null
    DoneAt?: Date | string | null
    SendResponseAtStatusDone?: number | null
    CompanyIdGeneralCRM: string
    UserFromIdGeneralCRM: string
    UserToIdGeneralCRM: string
    MessageSubject?: string | null
    MessageText?: string | null
    LinkEmployees?: string | null
    LinkHouses?: string | null
    other_MessagesEmployees?: MessagesEmployeesCreateNestedManyWithoutMessagesEmployeesInput
    MessagesStatus?: MessagesStatusCreateNestedOneWithoutMessagesEmployeesInput
  }

  export type MessagesEmployeesUncheckedCreateWithoutMessagesEmployeesInput = {
    MessageEmployeeId?: string
    CreatedAt?: Date | string
    FinalDateForTask?: Date | string | null
    ReadedAt?: Date | string | null
    DoneAt?: Date | string | null
    SendResponseAtStatusDone?: number | null
    CompanyIdGeneralCRM: string
    UserFromIdGeneralCRM: string
    UserToIdGeneralCRM: string
    MessageStatusId?: string
    MessageSubject?: string | null
    MessageText?: string | null
    LinkEmployees?: string | null
    LinkHouses?: string | null
    other_MessagesEmployees?: MessagesEmployeesUncheckedCreateNestedManyWithoutMessagesEmployeesInput
  }

  export type MessagesEmployeesCreateOrConnectWithoutMessagesEmployeesInput = {
    where: MessagesEmployeesWhereUniqueInput
    create: XOR<MessagesEmployeesCreateWithoutMessagesEmployeesInput, MessagesEmployeesUncheckedCreateWithoutMessagesEmployeesInput>
  }

  export type MessagesEmployeesCreateManyMessagesEmployeesInputEnvelope = {
    data: MessagesEmployeesCreateManyMessagesEmployeesInput | MessagesEmployeesCreateManyMessagesEmployeesInput[]
  }

  export type MessagesStatusCreateWithoutMessagesEmployeesInput = {
    MessagesStatusId?: string
    MessagesStatusName: string
    CreatedAt?: Date | string | null
    Sort?: number
    Comments?: string | null
  }

  export type MessagesStatusUncheckedCreateWithoutMessagesEmployeesInput = {
    MessagesStatusId?: string
    MessagesStatusName: string
    CreatedAt?: Date | string | null
    Sort?: number
    Comments?: string | null
  }

  export type MessagesStatusCreateOrConnectWithoutMessagesEmployeesInput = {
    where: MessagesStatusWhereUniqueInput
    create: XOR<MessagesStatusCreateWithoutMessagesEmployeesInput, MessagesStatusUncheckedCreateWithoutMessagesEmployeesInput>
  }

  export type MessagesEmployeesUpsertWithoutOther_MessagesEmployeesInput = {
    update: XOR<MessagesEmployeesUpdateWithoutOther_MessagesEmployeesInput, MessagesEmployeesUncheckedUpdateWithoutOther_MessagesEmployeesInput>
    create: XOR<MessagesEmployeesCreateWithoutOther_MessagesEmployeesInput, MessagesEmployeesUncheckedCreateWithoutOther_MessagesEmployeesInput>
    where?: MessagesEmployeesWhereInput
  }

  export type MessagesEmployeesUpdateToOneWithWhereWithoutOther_MessagesEmployeesInput = {
    where?: MessagesEmployeesWhereInput
    data: XOR<MessagesEmployeesUpdateWithoutOther_MessagesEmployeesInput, MessagesEmployeesUncheckedUpdateWithoutOther_MessagesEmployeesInput>
  }

  export type MessagesEmployeesUpdateWithoutOther_MessagesEmployeesInput = {
    MessageEmployeeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FinalDateForTask?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DoneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SendResponseAtStatusDone?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserFromIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserToIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MessageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    MessageText?: NullableStringFieldUpdateOperationsInput | string | null
    LinkEmployees?: NullableStringFieldUpdateOperationsInput | string | null
    LinkHouses?: NullableStringFieldUpdateOperationsInput | string | null
    MessagesEmployees?: MessagesEmployeesUpdateOneWithoutOther_MessagesEmployeesNestedInput
    MessagesStatus?: MessagesStatusUpdateOneRequiredWithoutMessagesEmployeesNestedInput
  }

  export type MessagesEmployeesUncheckedUpdateWithoutOther_MessagesEmployeesInput = {
    MessageEmployeeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FinalDateForTask?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DoneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SendResponseAtStatusDone?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserFromIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserToIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    IsReplyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    MessageStatusId?: StringFieldUpdateOperationsInput | string
    MessageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    MessageText?: NullableStringFieldUpdateOperationsInput | string | null
    LinkEmployees?: NullableStringFieldUpdateOperationsInput | string | null
    LinkHouses?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessagesEmployeesUpsertWithWhereUniqueWithoutMessagesEmployeesInput = {
    where: MessagesEmployeesWhereUniqueInput
    update: XOR<MessagesEmployeesUpdateWithoutMessagesEmployeesInput, MessagesEmployeesUncheckedUpdateWithoutMessagesEmployeesInput>
    create: XOR<MessagesEmployeesCreateWithoutMessagesEmployeesInput, MessagesEmployeesUncheckedCreateWithoutMessagesEmployeesInput>
  }

  export type MessagesEmployeesUpdateWithWhereUniqueWithoutMessagesEmployeesInput = {
    where: MessagesEmployeesWhereUniqueInput
    data: XOR<MessagesEmployeesUpdateWithoutMessagesEmployeesInput, MessagesEmployeesUncheckedUpdateWithoutMessagesEmployeesInput>
  }

  export type MessagesEmployeesUpdateManyWithWhereWithoutMessagesEmployeesInput = {
    where: MessagesEmployeesScalarWhereInput
    data: XOR<MessagesEmployeesUpdateManyMutationInput, MessagesEmployeesUncheckedUpdateManyWithoutMessagesEmployeesInput>
  }

  export type MessagesEmployeesScalarWhereInput = {
    AND?: MessagesEmployeesScalarWhereInput | MessagesEmployeesScalarWhereInput[]
    OR?: MessagesEmployeesScalarWhereInput[]
    NOT?: MessagesEmployeesScalarWhereInput | MessagesEmployeesScalarWhereInput[]
    MessageEmployeeId?: StringFilter<"MessagesEmployees"> | string
    CreatedAt?: DateTimeFilter<"MessagesEmployees"> | Date | string
    FinalDateForTask?: DateTimeNullableFilter<"MessagesEmployees"> | Date | string | null
    ReadedAt?: DateTimeNullableFilter<"MessagesEmployees"> | Date | string | null
    DoneAt?: DateTimeNullableFilter<"MessagesEmployees"> | Date | string | null
    SendResponseAtStatusDone?: IntNullableFilter<"MessagesEmployees"> | number | null
    CompanyIdGeneralCRM?: StringFilter<"MessagesEmployees"> | string
    UserFromIdGeneralCRM?: StringFilter<"MessagesEmployees"> | string
    UserToIdGeneralCRM?: StringFilter<"MessagesEmployees"> | string
    IsReplyToMessageId?: StringNullableFilter<"MessagesEmployees"> | string | null
    MessageStatusId?: StringFilter<"MessagesEmployees"> | string
    MessageSubject?: StringNullableFilter<"MessagesEmployees"> | string | null
    MessageText?: StringNullableFilter<"MessagesEmployees"> | string | null
    LinkEmployees?: StringNullableFilter<"MessagesEmployees"> | string | null
    LinkHouses?: StringNullableFilter<"MessagesEmployees"> | string | null
  }

  export type MessagesStatusUpsertWithoutMessagesEmployeesInput = {
    update: XOR<MessagesStatusUpdateWithoutMessagesEmployeesInput, MessagesStatusUncheckedUpdateWithoutMessagesEmployeesInput>
    create: XOR<MessagesStatusCreateWithoutMessagesEmployeesInput, MessagesStatusUncheckedCreateWithoutMessagesEmployeesInput>
    where?: MessagesStatusWhereInput
  }

  export type MessagesStatusUpdateToOneWithWhereWithoutMessagesEmployeesInput = {
    where?: MessagesStatusWhereInput
    data: XOR<MessagesStatusUpdateWithoutMessagesEmployeesInput, MessagesStatusUncheckedUpdateWithoutMessagesEmployeesInput>
  }

  export type MessagesStatusUpdateWithoutMessagesEmployeesInput = {
    MessagesStatusId?: StringFieldUpdateOperationsInput | string
    MessagesStatusName?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Sort?: IntFieldUpdateOperationsInput | number
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessagesStatusUncheckedUpdateWithoutMessagesEmployeesInput = {
    MessagesStatusId?: StringFieldUpdateOperationsInput | string
    MessagesStatusName?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Sort?: IntFieldUpdateOperationsInput | number
    Comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessagesEmployeesCreateWithoutMessagesStatusInput = {
    MessageEmployeeId?: string
    CreatedAt?: Date | string
    FinalDateForTask?: Date | string | null
    ReadedAt?: Date | string | null
    DoneAt?: Date | string | null
    SendResponseAtStatusDone?: number | null
    CompanyIdGeneralCRM: string
    UserFromIdGeneralCRM: string
    UserToIdGeneralCRM: string
    MessageSubject?: string | null
    MessageText?: string | null
    LinkEmployees?: string | null
    LinkHouses?: string | null
    MessagesEmployees?: MessagesEmployeesCreateNestedOneWithoutOther_MessagesEmployeesInput
    other_MessagesEmployees?: MessagesEmployeesCreateNestedManyWithoutMessagesEmployeesInput
  }

  export type MessagesEmployeesUncheckedCreateWithoutMessagesStatusInput = {
    MessageEmployeeId?: string
    CreatedAt?: Date | string
    FinalDateForTask?: Date | string | null
    ReadedAt?: Date | string | null
    DoneAt?: Date | string | null
    SendResponseAtStatusDone?: number | null
    CompanyIdGeneralCRM: string
    UserFromIdGeneralCRM: string
    UserToIdGeneralCRM: string
    IsReplyToMessageId?: string | null
    MessageSubject?: string | null
    MessageText?: string | null
    LinkEmployees?: string | null
    LinkHouses?: string | null
    other_MessagesEmployees?: MessagesEmployeesUncheckedCreateNestedManyWithoutMessagesEmployeesInput
  }

  export type MessagesEmployeesCreateOrConnectWithoutMessagesStatusInput = {
    where: MessagesEmployeesWhereUniqueInput
    create: XOR<MessagesEmployeesCreateWithoutMessagesStatusInput, MessagesEmployeesUncheckedCreateWithoutMessagesStatusInput>
  }

  export type MessagesEmployeesCreateManyMessagesStatusInputEnvelope = {
    data: MessagesEmployeesCreateManyMessagesStatusInput | MessagesEmployeesCreateManyMessagesStatusInput[]
  }

  export type MessagesEmployeesUpsertWithWhereUniqueWithoutMessagesStatusInput = {
    where: MessagesEmployeesWhereUniqueInput
    update: XOR<MessagesEmployeesUpdateWithoutMessagesStatusInput, MessagesEmployeesUncheckedUpdateWithoutMessagesStatusInput>
    create: XOR<MessagesEmployeesCreateWithoutMessagesStatusInput, MessagesEmployeesUncheckedCreateWithoutMessagesStatusInput>
  }

  export type MessagesEmployeesUpdateWithWhereUniqueWithoutMessagesStatusInput = {
    where: MessagesEmployeesWhereUniqueInput
    data: XOR<MessagesEmployeesUpdateWithoutMessagesStatusInput, MessagesEmployeesUncheckedUpdateWithoutMessagesStatusInput>
  }

  export type MessagesEmployeesUpdateManyWithWhereWithoutMessagesStatusInput = {
    where: MessagesEmployeesScalarWhereInput
    data: XOR<MessagesEmployeesUpdateManyMutationInput, MessagesEmployeesUncheckedUpdateManyWithoutMessagesStatusInput>
  }

  export type UserViewRolesCreateWithoutUsersLinkedViewRoleInput = {
    UserViewRolesId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserViewRoleName: string
    NotShowFields?: string | null
    MaxSearchResults?: number | null
    EditFields?: string | null
  }

  export type UserViewRolesUncheckedCreateWithoutUsersLinkedViewRoleInput = {
    UserViewRolesId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserViewRoleName: string
    NotShowFields?: string | null
    MaxSearchResults?: number | null
    EditFields?: string | null
  }

  export type UserViewRolesCreateOrConnectWithoutUsersLinkedViewRoleInput = {
    where: UserViewRolesWhereUniqueInput
    create: XOR<UserViewRolesCreateWithoutUsersLinkedViewRoleInput, UserViewRolesUncheckedCreateWithoutUsersLinkedViewRoleInput>
  }

  export type UserViewRolesUpsertWithoutUsersLinkedViewRoleInput = {
    update: XOR<UserViewRolesUpdateWithoutUsersLinkedViewRoleInput, UserViewRolesUncheckedUpdateWithoutUsersLinkedViewRoleInput>
    create: XOR<UserViewRolesCreateWithoutUsersLinkedViewRoleInput, UserViewRolesUncheckedCreateWithoutUsersLinkedViewRoleInput>
    where?: UserViewRolesWhereInput
  }

  export type UserViewRolesUpdateToOneWithWhereWithoutUsersLinkedViewRoleInput = {
    where?: UserViewRolesWhereInput
    data: XOR<UserViewRolesUpdateWithoutUsersLinkedViewRoleInput, UserViewRolesUncheckedUpdateWithoutUsersLinkedViewRoleInput>
  }

  export type UserViewRolesUpdateWithoutUsersLinkedViewRoleInput = {
    UserViewRolesId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserViewRoleName?: StringFieldUpdateOperationsInput | string
    NotShowFields?: NullableStringFieldUpdateOperationsInput | string | null
    MaxSearchResults?: NullableIntFieldUpdateOperationsInput | number | null
    EditFields?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserViewRolesUncheckedUpdateWithoutUsersLinkedViewRoleInput = {
    UserViewRolesId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserViewRoleName?: StringFieldUpdateOperationsInput | string
    NotShowFields?: NullableStringFieldUpdateOperationsInput | string | null
    MaxSearchResults?: NullableIntFieldUpdateOperationsInput | number | null
    EditFields?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersLinkedViewRoleCreateWithoutUserViewRolesInput = {
    UsersLinkedViewRoleId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserID: string
  }

  export type UsersLinkedViewRoleUncheckedCreateWithoutUserViewRolesInput = {
    UsersLinkedViewRoleId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserID: string
  }

  export type UsersLinkedViewRoleCreateOrConnectWithoutUserViewRolesInput = {
    where: UsersLinkedViewRoleWhereUniqueInput
    create: XOR<UsersLinkedViewRoleCreateWithoutUserViewRolesInput, UsersLinkedViewRoleUncheckedCreateWithoutUserViewRolesInput>
  }

  export type UsersLinkedViewRoleCreateManyUserViewRolesInputEnvelope = {
    data: UsersLinkedViewRoleCreateManyUserViewRolesInput | UsersLinkedViewRoleCreateManyUserViewRolesInput[]
  }

  export type UsersLinkedViewRoleUpsertWithWhereUniqueWithoutUserViewRolesInput = {
    where: UsersLinkedViewRoleWhereUniqueInput
    update: XOR<UsersLinkedViewRoleUpdateWithoutUserViewRolesInput, UsersLinkedViewRoleUncheckedUpdateWithoutUserViewRolesInput>
    create: XOR<UsersLinkedViewRoleCreateWithoutUserViewRolesInput, UsersLinkedViewRoleUncheckedCreateWithoutUserViewRolesInput>
  }

  export type UsersLinkedViewRoleUpdateWithWhereUniqueWithoutUserViewRolesInput = {
    where: UsersLinkedViewRoleWhereUniqueInput
    data: XOR<UsersLinkedViewRoleUpdateWithoutUserViewRolesInput, UsersLinkedViewRoleUncheckedUpdateWithoutUserViewRolesInput>
  }

  export type UsersLinkedViewRoleUpdateManyWithWhereWithoutUserViewRolesInput = {
    where: UsersLinkedViewRoleScalarWhereInput
    data: XOR<UsersLinkedViewRoleUpdateManyMutationInput, UsersLinkedViewRoleUncheckedUpdateManyWithoutUserViewRolesInput>
  }

  export type UsersLinkedViewRoleScalarWhereInput = {
    AND?: UsersLinkedViewRoleScalarWhereInput | UsersLinkedViewRoleScalarWhereInput[]
    OR?: UsersLinkedViewRoleScalarWhereInput[]
    NOT?: UsersLinkedViewRoleScalarWhereInput | UsersLinkedViewRoleScalarWhereInput[]
    UsersLinkedViewRoleId?: StringFilter<"UsersLinkedViewRole"> | string
    CreatedAt?: DateTimeNullableFilter<"UsersLinkedViewRole"> | Date | string | null
    CompanyID?: StringFilter<"UsersLinkedViewRole"> | string
    UserID?: StringFilter<"UsersLinkedViewRole"> | string
    UserViewRolesId?: StringFilter<"UsersLinkedViewRole"> | string
  }

  export type EmployeeHoursCreateManyEmployeeHoursByLocalityInput = {
    EmployeeHoursId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    EmployeeNumber: number
    MonthManaged: number
    YearManaged: number
    LeadingDate: Date | string
    HourStart?: Date | string | null
    HourEnd?: Date | string | null
    HourStartSource?: Date | string | null
    HourEndSource?: Date | string | null
    RealHours?: number | null
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    BreakMinutes?: number | null
    GpsStart?: string | null
    GpsEnd?: string | null
    IsManualInsert?: number | null
    ManualInsertUserId?: string | null
    IsRowDeleted?: number | null
    ActionTypeID?: number | null
    DayTypeID?: number | null
    HolidayName?: string | null
    StartEndTimeSabat?: Date | string | null
    IsForemanHourApproved?: Date | string | null
    IsForemanApproval?: Date | string | null
    ForemanApprovalGeneralCRMUserId?: string | null
    IsComplementRow?: number | null
  }

  export type EmployeeHoursUpdateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeNumber?: IntFieldUpdateOperationsInput | number
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    LeadingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    HourStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourStartSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEndSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    GpsStart?: NullableStringFieldUpdateOperationsInput | string | null
    GpsEnd?: NullableStringFieldUpdateOperationsInput | string | null
    IsManualInsert?: NullableIntFieldUpdateOperationsInput | number | null
    ManualInsertUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsRowDeleted?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanHourApproved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanApproval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ForemanApprovalGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsComplementRow?: NullableIntFieldUpdateOperationsInput | number | null
    Lkup_ActionType?: Lkup_ActionTypeUpdateOneWithoutEmployeeHoursNestedInput
  }

  export type EmployeeHoursUncheckedUpdateWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeNumber?: IntFieldUpdateOperationsInput | number
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    LeadingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    HourStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourStartSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEndSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    GpsStart?: NullableStringFieldUpdateOperationsInput | string | null
    GpsEnd?: NullableStringFieldUpdateOperationsInput | string | null
    IsManualInsert?: NullableIntFieldUpdateOperationsInput | number | null
    ManualInsertUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsRowDeleted?: NullableIntFieldUpdateOperationsInput | number | null
    ActionTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanHourApproved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanApproval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ForemanApprovalGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsComplementRow?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursUncheckedUpdateManyWithoutEmployeeHoursByLocalityInput = {
    EmployeeHoursId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeNumber?: IntFieldUpdateOperationsInput | number
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    LeadingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    HourStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourStartSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEndSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    GpsStart?: NullableStringFieldUpdateOperationsInput | string | null
    GpsEnd?: NullableStringFieldUpdateOperationsInput | string | null
    IsManualInsert?: NullableIntFieldUpdateOperationsInput | number | null
    ManualInsertUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsRowDeleted?: NullableIntFieldUpdateOperationsInput | number | null
    ActionTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanHourApproved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanApproval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ForemanApprovalGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsComplementRow?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCreateManyEmployeeHoursByLocalityTotalsInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: string
    CreatedAt?: Date | string | null
    ActionTypeId: number
    TotalActionType: number
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUpdateWithoutEmployeeHoursByLocalityTotalsInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalActionType?: FloatFieldUpdateOperationsInput | number
    Lkup_ActionType?: Lkup_ActionTypeUpdateOneRequiredWithoutEmployeeHoursByLocalityTotalsActionTypeNestedInput
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateWithoutEmployeeHoursByLocalityTotalsInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ActionTypeId?: IntFieldUpdateOperationsInput | number
    TotalActionType?: FloatFieldUpdateOperationsInput | number
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateManyWithoutEmployeeHoursByLocalityTotalsInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ActionTypeId?: IntFieldUpdateOperationsInput | number
    TotalActionType?: FloatFieldUpdateOperationsInput | number
  }

  export type EmployeeHoursByLocalityCreateManyEmployeeHoursContractsInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    EmployeeHoursLocalityId: string
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    EmployeeHoursUserId: string
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
  }

  export type EmployeeHoursByLocalityUpdateWithoutEmployeeHoursContractsInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHours?: EmployeeHoursUpdateManyWithoutEmployeeHoursByLocalityNestedInput
    EmployeeHoursUsers?: EmployeeHoursUsersUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput
    EmployeeHoursLocalities?: EmployeeHoursLocalitiesUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput
  }

  export type EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursContractsInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeHoursUserId?: StringFieldUpdateOperationsInput | string
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHours?: EmployeeHoursUncheckedUpdateManyWithoutEmployeeHoursByLocalityNestedInput
  }

  export type EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursContractsInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeHoursUserId?: StringFieldUpdateOperationsInput | string
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursByLocalityCreateManyEmployeeHoursLocalitiesInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    EmployeeHoursUserId: string
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHoursContractId: string
  }

  export type EmployeeHoursByLocalityTotalsCreateManyEmployeeHoursLocalitiesInput = {
    EmployeeHoursByLocalityTotalsId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    MonthManaged: number
    YearManaged: number
    EmployeeId: number
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    RealHours?: number | null
    BreakMinutes?: number | null
    WorkedDays?: number | null
    IsCloseSalary?: number
  }

  export type EmployeeHoursByLocalityUpdateWithoutEmployeeHoursLocalitiesInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHours?: EmployeeHoursUpdateManyWithoutEmployeeHoursByLocalityNestedInput
    EmployeeHoursUsers?: EmployeeHoursUsersUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput
    EmployeeHoursContracts?: EmployeeHoursContractsUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput
  }

  export type EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursLocalitiesInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeHoursUserId?: StringFieldUpdateOperationsInput | string
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHoursContractId?: StringFieldUpdateOperationsInput | string
    EmployeeHours?: EmployeeHoursUncheckedUpdateManyWithoutEmployeeHoursByLocalityNestedInput
  }

  export type EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursLocalitiesInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeHoursUserId?: StringFieldUpdateOperationsInput | string
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHoursContractId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeHoursByLocalityTotalsUpdateWithoutEmployeeHoursLocalitiesInput = {
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    EmployeeId?: IntFieldUpdateOperationsInput | number
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    WorkedDays?: NullableIntFieldUpdateOperationsInput | number | null
    IsCloseSalary?: IntFieldUpdateOperationsInput | number
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeUpdateManyWithoutEmployeeHoursByLocalityTotalsNestedInput
  }

  export type EmployeeHoursByLocalityTotalsUncheckedUpdateWithoutEmployeeHoursLocalitiesInput = {
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    EmployeeId?: IntFieldUpdateOperationsInput | number
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    WorkedDays?: NullableIntFieldUpdateOperationsInput | number | null
    IsCloseSalary?: IntFieldUpdateOperationsInput | number
    EmployeeHoursByLocalityTotalsActionType?: EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateManyWithoutEmployeeHoursByLocalityTotalsNestedInput
  }

  export type EmployeeHoursByLocalityTotalsUncheckedUpdateManyWithoutEmployeeHoursLocalitiesInput = {
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    EmployeeId?: IntFieldUpdateOperationsInput | number
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    WorkedDays?: NullableIntFieldUpdateOperationsInput | number | null
    IsCloseSalary?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeHoursByLocalityCreateManyEmployeeHoursUsersInput = {
    EmployeeHoursByLocalityId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    NotShowEmployeeHours?: number | null
    EmployeeHoursLocalityId: string
    HourMinStart?: Date | string | null
    HourMaxStop?: Date | string | null
    RoundTime?: string | null
    MinimumHours2BreakTime?: number
    BreakTime?: number | null
    AlertForMaxMonthHours?: number | null
    EmployeeHoursContractId: string
  }

  export type EmployeeHoursByLocalityUpdateWithoutEmployeeHoursUsersInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHours?: EmployeeHoursUpdateManyWithoutEmployeeHoursByLocalityNestedInput
    EmployeeHoursContracts?: EmployeeHoursContractsUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput
    EmployeeHoursLocalities?: EmployeeHoursLocalitiesUpdateOneRequiredWithoutEmployeeHoursByLocalityNestedInput
  }

  export type EmployeeHoursByLocalityUncheckedUpdateWithoutEmployeeHoursUsersInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHoursContractId?: StringFieldUpdateOperationsInput | string
    EmployeeHours?: EmployeeHoursUncheckedUpdateManyWithoutEmployeeHoursByLocalityNestedInput
  }

  export type EmployeeHoursByLocalityUncheckedUpdateManyWithoutEmployeeHoursUsersInput = {
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    NotShowEmployeeHours?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursLocalityId?: StringFieldUpdateOperationsInput | string
    HourMinStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourMaxStop?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RoundTime?: NullableStringFieldUpdateOperationsInput | string | null
    MinimumHours2BreakTime?: FloatFieldUpdateOperationsInput | number
    BreakTime?: NullableIntFieldUpdateOperationsInput | number | null
    AlertForMaxMonthHours?: NullableFloatFieldUpdateOperationsInput | number | null
    EmployeeHoursContractId?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeHoursCreateManyLkup_ActionTypeInput = {
    EmployeeHoursId?: string
    CreatedAt?: Date | string | null
    CompanyIdGeneralCRM: string
    EmployeeId: number
    EmployeeNumber: number
    MonthManaged: number
    YearManaged: number
    LeadingDate: Date | string
    HourStart?: Date | string | null
    HourEnd?: Date | string | null
    HourStartSource?: Date | string | null
    HourEndSource?: Date | string | null
    RealHours?: number | null
    QtyHour?: number | null
    QtyHour125?: number | null
    QtyHour150?: number | null
    QtyHour175?: number | null
    QtyHour200?: number | null
    BreakMinutes?: number | null
    GpsStart?: string | null
    GpsEnd?: string | null
    EmployeeHoursByLocalityId: string
    IsManualInsert?: number | null
    ManualInsertUserId?: string | null
    IsRowDeleted?: number | null
    DayTypeID?: number | null
    HolidayName?: string | null
    StartEndTimeSabat?: Date | string | null
    IsForemanHourApproved?: Date | string | null
    IsForemanApproval?: Date | string | null
    ForemanApprovalGeneralCRMUserId?: string | null
    IsComplementRow?: number | null
  }

  export type EmployeeHoursByLocalityTotalsActionTypeCreateManyLkup_ActionTypeInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: string
    CreatedAt?: Date | string | null
    EmployeeHoursByLocalityTotalsId: string
    TotalActionType: number
  }

  export type EmployeeHoursUpdateWithoutLkup_ActionTypeInput = {
    EmployeeHoursId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeNumber?: IntFieldUpdateOperationsInput | number
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    LeadingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    HourStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourStartSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEndSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    GpsStart?: NullableStringFieldUpdateOperationsInput | string | null
    GpsEnd?: NullableStringFieldUpdateOperationsInput | string | null
    IsManualInsert?: NullableIntFieldUpdateOperationsInput | number | null
    ManualInsertUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsRowDeleted?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanHourApproved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanApproval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ForemanApprovalGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsComplementRow?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeHoursByLocality?: EmployeeHoursByLocalityUpdateOneRequiredWithoutEmployeeHoursNestedInput
  }

  export type EmployeeHoursUncheckedUpdateWithoutLkup_ActionTypeInput = {
    EmployeeHoursId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeNumber?: IntFieldUpdateOperationsInput | number
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    LeadingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    HourStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourStartSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEndSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    GpsStart?: NullableStringFieldUpdateOperationsInput | string | null
    GpsEnd?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    IsManualInsert?: NullableIntFieldUpdateOperationsInput | number | null
    ManualInsertUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsRowDeleted?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanHourApproved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanApproval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ForemanApprovalGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsComplementRow?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursUncheckedUpdateManyWithoutLkup_ActionTypeInput = {
    EmployeeHoursId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    EmployeeId?: IntFieldUpdateOperationsInput | number
    EmployeeNumber?: IntFieldUpdateOperationsInput | number
    MonthManaged?: IntFieldUpdateOperationsInput | number
    YearManaged?: IntFieldUpdateOperationsInput | number
    LeadingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    HourStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourStartSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HourEndSource?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RealHours?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour125?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour150?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour175?: NullableFloatFieldUpdateOperationsInput | number | null
    QtyHour200?: NullableFloatFieldUpdateOperationsInput | number | null
    BreakMinutes?: NullableFloatFieldUpdateOperationsInput | number | null
    GpsStart?: NullableStringFieldUpdateOperationsInput | string | null
    GpsEnd?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeHoursByLocalityId?: StringFieldUpdateOperationsInput | string
    IsManualInsert?: NullableIntFieldUpdateOperationsInput | number | null
    ManualInsertUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsRowDeleted?: NullableIntFieldUpdateOperationsInput | number | null
    DayTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    HolidayName?: NullableStringFieldUpdateOperationsInput | string | null
    StartEndTimeSabat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanHourApproved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsForemanApproval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ForemanApprovalGeneralCRMUserId?: NullableStringFieldUpdateOperationsInput | string | null
    IsComplementRow?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUpdateWithoutLkup_ActionTypeInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalActionType?: FloatFieldUpdateOperationsInput | number
    EmployeeHoursByLocalityTotals?: EmployeeHoursByLocalityTotalsUpdateOneRequiredWithoutEmployeeHoursByLocalityTotalsActionTypeNestedInput
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateWithoutLkup_ActionTypeInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    TotalActionType?: FloatFieldUpdateOperationsInput | number
  }

  export type EmployeeHoursByLocalityTotalsActionTypeUncheckedUpdateManyWithoutLkup_ActionTypeInput = {
    EmployeeHoursByLocalityTotalsActionTypeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmployeeHoursByLocalityTotalsId?: StringFieldUpdateOperationsInput | string
    TotalActionType?: FloatFieldUpdateOperationsInput | number
  }

  export type MessagesEmployeesCreateManyMessagesEmployeesInput = {
    MessageEmployeeId?: string
    CreatedAt?: Date | string
    FinalDateForTask?: Date | string | null
    ReadedAt?: Date | string | null
    DoneAt?: Date | string | null
    SendResponseAtStatusDone?: number | null
    CompanyIdGeneralCRM: string
    UserFromIdGeneralCRM: string
    UserToIdGeneralCRM: string
    MessageStatusId?: string
    MessageSubject?: string | null
    MessageText?: string | null
    LinkEmployees?: string | null
    LinkHouses?: string | null
  }

  export type MessagesEmployeesUpdateWithoutMessagesEmployeesInput = {
    MessageEmployeeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FinalDateForTask?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DoneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SendResponseAtStatusDone?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserFromIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserToIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MessageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    MessageText?: NullableStringFieldUpdateOperationsInput | string | null
    LinkEmployees?: NullableStringFieldUpdateOperationsInput | string | null
    LinkHouses?: NullableStringFieldUpdateOperationsInput | string | null
    other_MessagesEmployees?: MessagesEmployeesUpdateManyWithoutMessagesEmployeesNestedInput
    MessagesStatus?: MessagesStatusUpdateOneRequiredWithoutMessagesEmployeesNestedInput
  }

  export type MessagesEmployeesUncheckedUpdateWithoutMessagesEmployeesInput = {
    MessageEmployeeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FinalDateForTask?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DoneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SendResponseAtStatusDone?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserFromIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserToIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MessageStatusId?: StringFieldUpdateOperationsInput | string
    MessageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    MessageText?: NullableStringFieldUpdateOperationsInput | string | null
    LinkEmployees?: NullableStringFieldUpdateOperationsInput | string | null
    LinkHouses?: NullableStringFieldUpdateOperationsInput | string | null
    other_MessagesEmployees?: MessagesEmployeesUncheckedUpdateManyWithoutMessagesEmployeesNestedInput
  }

  export type MessagesEmployeesUncheckedUpdateManyWithoutMessagesEmployeesInput = {
    MessageEmployeeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FinalDateForTask?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DoneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SendResponseAtStatusDone?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserFromIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserToIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MessageStatusId?: StringFieldUpdateOperationsInput | string
    MessageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    MessageText?: NullableStringFieldUpdateOperationsInput | string | null
    LinkEmployees?: NullableStringFieldUpdateOperationsInput | string | null
    LinkHouses?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessagesEmployeesCreateManyMessagesStatusInput = {
    MessageEmployeeId?: string
    CreatedAt?: Date | string
    FinalDateForTask?: Date | string | null
    ReadedAt?: Date | string | null
    DoneAt?: Date | string | null
    SendResponseAtStatusDone?: number | null
    CompanyIdGeneralCRM: string
    UserFromIdGeneralCRM: string
    UserToIdGeneralCRM: string
    IsReplyToMessageId?: string | null
    MessageSubject?: string | null
    MessageText?: string | null
    LinkEmployees?: string | null
    LinkHouses?: string | null
  }

  export type MessagesEmployeesUpdateWithoutMessagesStatusInput = {
    MessageEmployeeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FinalDateForTask?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DoneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SendResponseAtStatusDone?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserFromIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserToIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    MessageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    MessageText?: NullableStringFieldUpdateOperationsInput | string | null
    LinkEmployees?: NullableStringFieldUpdateOperationsInput | string | null
    LinkHouses?: NullableStringFieldUpdateOperationsInput | string | null
    MessagesEmployees?: MessagesEmployeesUpdateOneWithoutOther_MessagesEmployeesNestedInput
    other_MessagesEmployees?: MessagesEmployeesUpdateManyWithoutMessagesEmployeesNestedInput
  }

  export type MessagesEmployeesUncheckedUpdateWithoutMessagesStatusInput = {
    MessageEmployeeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FinalDateForTask?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DoneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SendResponseAtStatusDone?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserFromIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserToIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    IsReplyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    MessageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    MessageText?: NullableStringFieldUpdateOperationsInput | string | null
    LinkEmployees?: NullableStringFieldUpdateOperationsInput | string | null
    LinkHouses?: NullableStringFieldUpdateOperationsInput | string | null
    other_MessagesEmployees?: MessagesEmployeesUncheckedUpdateManyWithoutMessagesEmployeesNestedInput
  }

  export type MessagesEmployeesUncheckedUpdateManyWithoutMessagesStatusInput = {
    MessageEmployeeId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FinalDateForTask?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ReadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DoneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SendResponseAtStatusDone?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserFromIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    UserToIdGeneralCRM?: StringFieldUpdateOperationsInput | string
    IsReplyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    MessageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    MessageText?: NullableStringFieldUpdateOperationsInput | string | null
    LinkEmployees?: NullableStringFieldUpdateOperationsInput | string | null
    LinkHouses?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersLinkedViewRoleCreateManyUserViewRolesInput = {
    UsersLinkedViewRoleId?: string
    CreatedAt?: Date | string | null
    CompanyID: string
    UserID: string
  }

  export type UsersLinkedViewRoleUpdateWithoutUserViewRolesInput = {
    UsersLinkedViewRoleId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserID?: StringFieldUpdateOperationsInput | string
  }

  export type UsersLinkedViewRoleUncheckedUpdateWithoutUserViewRolesInput = {
    UsersLinkedViewRoleId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserID?: StringFieldUpdateOperationsInput | string
  }

  export type UsersLinkedViewRoleUncheckedUpdateManyWithoutUserViewRolesInput = {
    UsersLinkedViewRoleId?: StringFieldUpdateOperationsInput | string
    CreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompanyID?: StringFieldUpdateOperationsInput | string
    UserID?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}